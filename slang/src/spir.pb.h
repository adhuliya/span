// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spir.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_spir_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_spir_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spir_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spir_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spir_2eproto;
namespace spir {
class BitDataType;
struct BitDataTypeDefaultTypeInternal;
extern BitDataTypeDefaultTypeInternal _BitDataType_default_instance_;
class BitEntity;
struct BitEntityDefaultTypeInternal;
extern BitEntityDefaultTypeInternal _BitEntity_default_instance_;
class BitEntityInfo;
struct BitEntityInfoDefaultTypeInternal;
extern BitEntityInfoDefaultTypeInternal _BitEntityInfo_default_instance_;
class BitExpr;
struct BitExprDefaultTypeInternal;
extern BitExprDefaultTypeInternal _BitExpr_default_instance_;
class BitFunc;
struct BitFuncDefaultTypeInternal;
extern BitFuncDefaultTypeInternal _BitFunc_default_instance_;
class BitInsn;
struct BitInsnDefaultTypeInternal;
extern BitInsnDefaultTypeInternal _BitInsn_default_instance_;
class BitSrcLoc;
struct BitSrcLocDefaultTypeInternal;
extern BitSrcLocDefaultTypeInternal _BitSrcLoc_default_instance_;
class BitTU;
struct BitTUDefaultTypeInternal;
extern BitTUDefaultTypeInternal _BitTU_default_instance_;
class BitTU_EntityInfoEntry_DoNotUse;
struct BitTU_EntityInfoEntry_DoNotUseDefaultTypeInternal;
extern BitTU_EntityInfoEntry_DoNotUseDefaultTypeInternal _BitTU_EntityInfoEntry_DoNotUse_default_instance_;
class BitTU_NamesToIdsEntry_DoNotUse;
struct BitTU_NamesToIdsEntry_DoNotUseDefaultTypeInternal;
extern BitTU_NamesToIdsEntry_DoNotUseDefaultTypeInternal _BitTU_NamesToIdsEntry_DoNotUse_default_instance_;
}  // namespace spir
PROTOBUF_NAMESPACE_OPEN
template<> ::spir::BitDataType* Arena::CreateMaybeMessage<::spir::BitDataType>(Arena*);
template<> ::spir::BitEntity* Arena::CreateMaybeMessage<::spir::BitEntity>(Arena*);
template<> ::spir::BitEntityInfo* Arena::CreateMaybeMessage<::spir::BitEntityInfo>(Arena*);
template<> ::spir::BitExpr* Arena::CreateMaybeMessage<::spir::BitExpr>(Arena*);
template<> ::spir::BitFunc* Arena::CreateMaybeMessage<::spir::BitFunc>(Arena*);
template<> ::spir::BitInsn* Arena::CreateMaybeMessage<::spir::BitInsn>(Arena*);
template<> ::spir::BitSrcLoc* Arena::CreateMaybeMessage<::spir::BitSrcLoc>(Arena*);
template<> ::spir::BitTU* Arena::CreateMaybeMessage<::spir::BitTU>(Arena*);
template<> ::spir::BitTU_EntityInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::spir::BitTU_EntityInfoEntry_DoNotUse>(Arena*);
template<> ::spir::BitTU_NamesToIdsEntry_DoNotUse* Arena::CreateMaybeMessage<::spir::BitTU_NamesToIdsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace spir {

enum K_EK : int {
  ENIL = 0,
  EVAR_GLBL = 1,
  EVAR_LOCL = 2,
  EVAR_LOCL_ARG = 3,
  EVAR_LOCL_STATIC = 4,
  EVAR_LOCL_TMP = 5,
  EVAR_LOCL_SSA = 6,
  EVAR_LOCL_PSEUDO = 7,
  ELIT_NUM = 8,
  ELIT_NUM_IMM = 9,
  ELIT_STR = 10,
  EDATA_TYPE = 11,
  EFUNC = 12,
  EFUNC_VARGS = 13,
  ELABEL = 14,
  EOTHER = 15,
  ERECORD_FIELD = 16,
  EINSN = 17,
  EBB = 18,
  ECFG = 19,
  ESCOPE = 20,
  ETU = 21,
  K_EK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_EK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_EK_IsValid(int value);
constexpr K_EK K_EK_MIN = ENIL;
constexpr K_EK K_EK_MAX = ETU;
constexpr int K_EK_ARRAYSIZE = K_EK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_EK_descriptor();
template<typename T>
inline const std::string& K_EK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_EK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_EK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_EK_descriptor(), enum_t_value);
}
inline bool K_EK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_EK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_EK>(
    K_EK_descriptor(), name, value);
}
enum K_IK : int {
  INIL = 0,
  INOP = 1,
  IBARRIER = 2,
  IASGN_SIMPLE = 3,
  IASGN_RHS_OP = 4,
  IASGN_LHS_OP = 5,
  IASGN_CALL = 6,
  IASGN_PHI = 7,
  ICALL = 8,
  IGOTO = 9,
  ICOND = 10,
  ILABEL = 11,
  IRETURN = 12,
  K_IK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_IK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_IK_IsValid(int value);
constexpr K_IK K_IK_MIN = INIL;
constexpr K_IK K_IK_MAX = IRETURN;
constexpr int K_IK_ARRAYSIZE = K_IK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_IK_descriptor();
template<typename T>
inline const std::string& K_IK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_IK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_IK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_IK_descriptor(), enum_t_value);
}
inline bool K_IK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_IK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_IK>(
    K_IK_descriptor(), name, value);
}
enum K_XK : int {
  XNIL = 0,
  XVAL = 1,
  XADD = 2,
  XSUB = 3,
  XMUL = 4,
  XDIV = 5,
  XMOD = 6,
  XAND = 7,
  XOR = 8,
  XXOR = 9,
  XSHL = 10,
  XSHR = 11,
  XSHRA = 12,
  XEQ = 13,
  XNE = 14,
  XLT = 15,
  XGE = 16,
  XARRAY_INDEX = 17,
  XMEMBER_ACCESS = 18,
  XMEMBER_PTR_ACCESS = 19,
  XMEMBER_PTR_ADDROF = 20,
  XCALL = 21,
  XCALL_0 = 22,
  XCAST = 23,
  XBIT_NOT = 24,
  XNEGATE = 25,
  XNOT = 26,
  XDEREF = 27,
  XADDROF = 28,
  XSIZEOF = 29,
  XALIGNOF = 30,
  XOTHER = 31,
  K_XK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_XK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_XK_IsValid(int value);
constexpr K_XK K_XK_MIN = XNIL;
constexpr K_XK K_XK_MAX = XOTHER;
constexpr int K_XK_ARRAYSIZE = K_XK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_XK_descriptor();
template<typename T>
inline const std::string& K_XK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_XK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_XK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_XK_descriptor(), enum_t_value);
}
inline bool K_XK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_XK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_XK>(
    K_XK_descriptor(), name, value);
}
enum K_VK : int {
  TNIL = 0,
  TVOID = 0,
  TCHAR = 1,
  TINT8 = 2,
  TINT16 = 3,
  TINT32 = 4,
  TINT64 = 5,
  TUINT8 = 6,
  TUCHAR = 6,
  TUINT16 = 7,
  TUINT32 = 8,
  TUINT64 = 9,
  TCHAR16 = 7,
  TWCHAR = 8,
  TCHAR32 = 8,
  TN_BITS = 10,
  TN_UBITS = 11,
  TBOOL = 12,
  TFLOAT16 = 13,
  TFLOAT32 = 14,
  TFLOAT = 14,
  TFLOAT64 = 15,
  TDOUBLE = 15,
  TFLOAT80 = 16,
  TLONG_DOUBLE = 16,
  TPTR_TO_VOID = 17,
  TPTR_TO_PTR = 18,
  TPTR_TO_ARR = 19,
  TPTR_TO_CHAR = 20,
  TPTR_TO_INT = 21,
  TPTR_TO_FLOAT = 22,
  TPTR_TO_RECORD = 23,
  TPTR_TO_FUNC = 24,
  TARR_FIXED = 25,
  TARR_VARIABLE = 26,
  TARR_PARTIAL = 27,
  TUNION = 28,
  TSTRUCT = 29,
  TCLASS = 30,
  TOTHER = 31,
  K_VK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_VK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_VK_IsValid(int value);
constexpr K_VK K_VK_MIN = TNIL;
constexpr K_VK K_VK_MAX = TOTHER;
constexpr int K_VK_ARRAYSIZE = K_VK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_VK_descriptor();
template<typename T>
inline const std::string& K_VK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_VK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_VK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_VK_descriptor(), enum_t_value);
}
inline bool K_VK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_VK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_VK>(
    K_VK_descriptor(), name, value);
}
enum K_QK : int {
  QNIL = 0,
  QCONST = 1,
  QCONST_DEST = 2,
  QLOCL_STATIC = 4,
  QGLBL_STATIC = 8,
  QVOLATILE = 16,
  QWEAK = 32,
  QTHREAD_LOCAL = 64,
  QNO_INIT = 128,
  QEXTERNAL = 256,
  QNO_DEF = 512,
  QRESTRICT = 1024,
  QINLINE = 2048,
  QATOMIC = 4096,
  QREGISTER = 8192,
  QRECORD_MEMBER = 16384,
  QOTHER = 32768,
  K_QK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_QK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_QK_IsValid(int value);
constexpr K_QK K_QK_MIN = QNIL;
constexpr K_QK K_QK_MAX = QOTHER;
constexpr int K_QK_ARRAYSIZE = K_QK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_QK_descriptor();
template<typename T>
inline const std::string& K_QK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_QK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_QK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_QK_descriptor(), enum_t_value);
}
inline bool K_QK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_QK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_QK>(
    K_QK_descriptor(), name, value);
}
// ===================================================================

class BitSrcLoc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitSrcLoc) */ {
 public:
  inline BitSrcLoc() : BitSrcLoc(nullptr) {}
  ~BitSrcLoc() override;
  explicit PROTOBUF_CONSTEXPR BitSrcLoc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitSrcLoc(const BitSrcLoc& from);
  BitSrcLoc(BitSrcLoc&& from) noexcept
    : BitSrcLoc() {
    *this = ::std::move(from);
  }

  inline BitSrcLoc& operator=(const BitSrcLoc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitSrcLoc& operator=(BitSrcLoc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitSrcLoc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitSrcLoc* internal_default_instance() {
    return reinterpret_cast<const BitSrcLoc*>(
               &_BitSrcLoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BitSrcLoc& a, BitSrcLoc& b) {
    a.Swap(&b);
  }
  inline void Swap(BitSrcLoc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitSrcLoc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitSrcLoc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitSrcLoc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitSrcLoc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitSrcLoc& from) {
    BitSrcLoc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitSrcLoc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitSrcLoc";
  }
  protected:
  explicit BitSrcLoc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // uint32 line = 1;
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // uint32 col = 2;
  void clear_col();
  uint32_t col() const;
  void set_col(uint32_t value);
  private:
  uint32_t _internal_col() const;
  void _internal_set_col(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitSrcLoc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t line_;
    uint32_t col_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitDataType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitDataType) */ {
 public:
  inline BitDataType() : BitDataType(nullptr) {}
  ~BitDataType() override;
  explicit PROTOBUF_CONSTEXPR BitDataType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitDataType(const BitDataType& from);
  BitDataType(BitDataType&& from) noexcept
    : BitDataType() {
    *this = ::std::move(from);
  }

  inline BitDataType& operator=(const BitDataType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitDataType& operator=(BitDataType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitDataType& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitDataType* internal_default_instance() {
    return reinterpret_cast<const BitDataType*>(
               &_BitDataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BitDataType& a, BitDataType& b) {
    a.Swap(&b);
  }
  inline void Swap(BitDataType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitDataType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitDataType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitDataType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitDataType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitDataType& from) {
    BitDataType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitDataType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitDataType";
  }
  protected:
  explicit BitDataType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFopIdsFieldNumber = 10,
    kFopTypesFieldNumber = 11,
    kAttributesFieldNumber = 4,
    kTypeNameFieldNumber = 8,
    kSubTypeFieldNumber = 7,
    kLocFieldNumber = 13,
    kTypeIdFieldNumber = 2,
    kVkindFieldNumber = 1,
    kQtypeFieldNumber = 3,
    kLenFieldNumber = 5,
    kAlignFieldNumber = 6,
    kAnonymousFieldNumber = 9,
    kVariadicFieldNumber = 12,
  };
  // repeated uint64 fopIds = 10;
  int fopids_size() const;
  private:
  int _internal_fopids_size() const;
  public:
  void clear_fopids();
  private:
  uint64_t _internal_fopids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_fopids() const;
  void _internal_add_fopids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_fopids();
  public:
  uint64_t fopids(int index) const;
  void set_fopids(int index, uint64_t value);
  void add_fopids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      fopids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_fopids();

  // repeated .spir.BitDataType fopTypes = 11;
  int foptypes_size() const;
  private:
  int _internal_foptypes_size() const;
  public:
  void clear_foptypes();
  ::spir::BitDataType* mutable_foptypes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitDataType >*
      mutable_foptypes();
  private:
  const ::spir::BitDataType& _internal_foptypes(int index) const;
  ::spir::BitDataType* _internal_add_foptypes();
  public:
  const ::spir::BitDataType& foptypes(int index) const;
  ::spir::BitDataType* add_foptypes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitDataType >&
      foptypes() const;

  // optional string attributes = 4;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const std::string& attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributes();
  PROTOBUF_NODISCARD std::string* release_attributes();
  void set_allocated_attributes(std::string* attributes);
  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
  std::string* _internal_mutable_attributes();
  public:

  // optional string typeName = 8;
  bool has_typename_() const;
  private:
  bool _internal_has_typename_() const;
  public:
  void clear_typename_();
  const std::string& typename_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_typename_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_typename_();
  PROTOBUF_NODISCARD std::string* release_typename_();
  void set_allocated_typename_(std::string* typename_);
  private:
  const std::string& _internal_typename_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_typename_(const std::string& value);
  std::string* _internal_mutable_typename_();
  public:

  // optional .spir.BitDataType subType = 7;
  bool has_subtype() const;
  private:
  bool _internal_has_subtype() const;
  public:
  void clear_subtype();
  const ::spir::BitDataType& subtype() const;
  PROTOBUF_NODISCARD ::spir::BitDataType* release_subtype();
  ::spir::BitDataType* mutable_subtype();
  void set_allocated_subtype(::spir::BitDataType* subtype);
  private:
  const ::spir::BitDataType& _internal_subtype() const;
  ::spir::BitDataType* _internal_mutable_subtype();
  public:
  void unsafe_arena_set_allocated_subtype(
      ::spir::BitDataType* subtype);
  ::spir::BitDataType* unsafe_arena_release_subtype();

  // optional .spir.BitSrcLoc loc = 13;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // optional uint64 typeId = 2;
  bool has_typeid_() const;
  private:
  bool _internal_has_typeid_() const;
  public:
  void clear_typeid_();
  uint64_t typeid_() const;
  void set_typeid_(uint64_t value);
  private:
  uint64_t _internal_typeid_() const;
  void _internal_set_typeid_(uint64_t value);
  public:

  // .spir.K_VK vkind = 1;
  void clear_vkind();
  ::spir::K_VK vkind() const;
  void set_vkind(::spir::K_VK value);
  private:
  ::spir::K_VK _internal_vkind() const;
  void _internal_set_vkind(::spir::K_VK value);
  public:

  // optional uint32 qtype = 3;
  bool has_qtype() const;
  private:
  bool _internal_has_qtype() const;
  public:
  void clear_qtype();
  uint32_t qtype() const;
  void set_qtype(uint32_t value);
  private:
  uint32_t _internal_qtype() const;
  void _internal_set_qtype(uint32_t value);
  public:

  // optional uint32 len = 5;
  bool has_len() const;
  private:
  bool _internal_has_len() const;
  public:
  void clear_len();
  uint32_t len() const;
  void set_len(uint32_t value);
  private:
  uint32_t _internal_len() const;
  void _internal_set_len(uint32_t value);
  public:

  // optional uint32 align = 6;
  bool has_align() const;
  private:
  bool _internal_has_align() const;
  public:
  void clear_align();
  uint32_t align() const;
  void set_align(uint32_t value);
  private:
  uint32_t _internal_align() const;
  void _internal_set_align(uint32_t value);
  public:

  // optional bool anonymous = 9;
  bool has_anonymous() const;
  private:
  bool _internal_has_anonymous() const;
  public:
  void clear_anonymous();
  bool anonymous() const;
  void set_anonymous(bool value);
  private:
  bool _internal_anonymous() const;
  void _internal_set_anonymous(bool value);
  public:

  // optional bool variadic = 12;
  bool has_variadic() const;
  private:
  bool _internal_has_variadic() const;
  public:
  void clear_variadic();
  bool variadic() const;
  void set_variadic(bool value);
  private:
  bool _internal_variadic() const;
  void _internal_set_variadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitDataType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > fopids_;
    mutable std::atomic<int> _fopids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitDataType > foptypes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr typename__;
    ::spir::BitDataType* subtype_;
    ::spir::BitSrcLoc* loc_;
    uint64_t typeid__;
    int vkind_;
    uint32_t qtype_;
    uint32_t len_;
    uint32_t align_;
    bool anonymous_;
    bool variadic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitEntityInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitEntityInfo) */ {
 public:
  inline BitEntityInfo() : BitEntityInfo(nullptr) {}
  ~BitEntityInfo() override;
  explicit PROTOBUF_CONSTEXPR BitEntityInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitEntityInfo(const BitEntityInfo& from);
  BitEntityInfo(BitEntityInfo&& from) noexcept
    : BitEntityInfo() {
    *this = ::std::move(from);
  }

  inline BitEntityInfo& operator=(const BitEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitEntityInfo& operator=(BitEntityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitEntityInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitEntityInfo* internal_default_instance() {
    return reinterpret_cast<const BitEntityInfo*>(
               &_BitEntityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BitEntityInfo& a, BitEntityInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BitEntityInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitEntityInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitEntityInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitEntityInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitEntityInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitEntityInfo& from) {
    BitEntityInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitEntityInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitEntityInfo";
  }
  protected:
  explicit BitEntityInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrValFieldNumber = 7,
    kDtFieldNumber = 4,
    kLocFieldNumber = 8,
    kEidFieldNumber = 1,
    kParentIdFieldNumber = 3,
    kLowValFieldNumber = 5,
    kHighValFieldNumber = 6,
    kEkindFieldNumber = 2,
  };
  // optional string strVal = 7;
  bool has_strval() const;
  private:
  bool _internal_has_strval() const;
  public:
  void clear_strval();
  const std::string& strval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strval();
  PROTOBUF_NODISCARD std::string* release_strval();
  void set_allocated_strval(std::string* strval);
  private:
  const std::string& _internal_strval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strval(const std::string& value);
  std::string* _internal_mutable_strval();
  public:

  // optional .spir.BitDataType dt = 4;
  bool has_dt() const;
  private:
  bool _internal_has_dt() const;
  public:
  void clear_dt();
  const ::spir::BitDataType& dt() const;
  PROTOBUF_NODISCARD ::spir::BitDataType* release_dt();
  ::spir::BitDataType* mutable_dt();
  void set_allocated_dt(::spir::BitDataType* dt);
  private:
  const ::spir::BitDataType& _internal_dt() const;
  ::spir::BitDataType* _internal_mutable_dt();
  public:
  void unsafe_arena_set_allocated_dt(
      ::spir::BitDataType* dt);
  ::spir::BitDataType* unsafe_arena_release_dt();

  // optional .spir.BitSrcLoc loc = 8;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // uint64 eid = 1;
  void clear_eid();
  uint64_t eid() const;
  void set_eid(uint64_t value);
  private:
  uint64_t _internal_eid() const;
  void _internal_set_eid(uint64_t value);
  public:

  // optional uint64 parentId = 3;
  bool has_parentid() const;
  private:
  bool _internal_has_parentid() const;
  public:
  void clear_parentid();
  uint64_t parentid() const;
  void set_parentid(uint64_t value);
  private:
  uint64_t _internal_parentid() const;
  void _internal_set_parentid(uint64_t value);
  public:

  // optional uint64 lowVal = 5;
  bool has_lowval() const;
  private:
  bool _internal_has_lowval() const;
  public:
  void clear_lowval();
  uint64_t lowval() const;
  void set_lowval(uint64_t value);
  private:
  uint64_t _internal_lowval() const;
  void _internal_set_lowval(uint64_t value);
  public:

  // optional uint64 highVal = 6;
  bool has_highval() const;
  private:
  bool _internal_has_highval() const;
  public:
  void clear_highval();
  uint64_t highval() const;
  void set_highval(uint64_t value);
  private:
  uint64_t _internal_highval() const;
  void _internal_set_highval(uint64_t value);
  public:

  // .spir.K_EK ekind = 2;
  void clear_ekind();
  ::spir::K_EK ekind() const;
  void set_ekind(::spir::K_EK value);
  private:
  ::spir::K_EK _internal_ekind() const;
  void _internal_set_ekind(::spir::K_EK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitEntityInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strval_;
    ::spir::BitDataType* dt_;
    ::spir::BitSrcLoc* loc_;
    uint64_t eid_;
    uint64_t parentid_;
    uint64_t lowval_;
    uint64_t highval_;
    int ekind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitEntity) */ {
 public:
  inline BitEntity() : BitEntity(nullptr) {}
  ~BitEntity() override;
  explicit PROTOBUF_CONSTEXPR BitEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitEntity(const BitEntity& from);
  BitEntity(BitEntity&& from) noexcept
    : BitEntity() {
    *this = ::std::move(from);
  }

  inline BitEntity& operator=(const BitEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitEntity& operator=(BitEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitEntity* internal_default_instance() {
    return reinterpret_cast<const BitEntity*>(
               &_BitEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BitEntity& a, BitEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(BitEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitEntity& from) {
    BitEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitEntity";
  }
  protected:
  explicit BitEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocFieldNumber = 2,
    kEidFieldNumber = 1,
  };
  // optional .spir.BitSrcLoc loc = 2;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // uint64 eid = 1;
  void clear_eid();
  uint64_t eid() const;
  void set_eid(uint64_t value);
  private:
  uint64_t _internal_eid() const;
  void _internal_set_eid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::spir::BitSrcLoc* loc_;
    uint64_t eid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitExpr) */ {
 public:
  inline BitExpr() : BitExpr(nullptr) {}
  ~BitExpr() override;
  explicit PROTOBUF_CONSTEXPR BitExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitExpr(const BitExpr& from);
  BitExpr(BitExpr&& from) noexcept
    : BitExpr() {
    *this = ::std::move(from);
  }

  inline BitExpr& operator=(const BitExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitExpr& operator=(BitExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitExpr* internal_default_instance() {
    return reinterpret_cast<const BitExpr*>(
               &_BitExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BitExpr& a, BitExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BitExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitExpr& from) {
    BitExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitExpr";
  }
  protected:
  explicit BitExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOprsFieldNumber = 4,
    kOpr1FieldNumber = 2,
    kOpr2FieldNumber = 3,
    kLocFieldNumber = 5,
    kKindFieldNumber = 1,
  };
  // repeated .spir.BitEntity oprs = 4;
  int oprs_size() const;
  private:
  int _internal_oprs_size() const;
  public:
  void clear_oprs();
  ::spir::BitEntity* mutable_oprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >*
      mutable_oprs();
  private:
  const ::spir::BitEntity& _internal_oprs(int index) const;
  ::spir::BitEntity* _internal_add_oprs();
  public:
  const ::spir::BitEntity& oprs(int index) const;
  ::spir::BitEntity* add_oprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >&
      oprs() const;

  // optional .spir.BitEntity opr1 = 2;
  bool has_opr1() const;
  private:
  bool _internal_has_opr1() const;
  public:
  void clear_opr1();
  const ::spir::BitEntity& opr1() const;
  PROTOBUF_NODISCARD ::spir::BitEntity* release_opr1();
  ::spir::BitEntity* mutable_opr1();
  void set_allocated_opr1(::spir::BitEntity* opr1);
  private:
  const ::spir::BitEntity& _internal_opr1() const;
  ::spir::BitEntity* _internal_mutable_opr1();
  public:
  void unsafe_arena_set_allocated_opr1(
      ::spir::BitEntity* opr1);
  ::spir::BitEntity* unsafe_arena_release_opr1();

  // optional .spir.BitEntity opr2 = 3;
  bool has_opr2() const;
  private:
  bool _internal_has_opr2() const;
  public:
  void clear_opr2();
  const ::spir::BitEntity& opr2() const;
  PROTOBUF_NODISCARD ::spir::BitEntity* release_opr2();
  ::spir::BitEntity* mutable_opr2();
  void set_allocated_opr2(::spir::BitEntity* opr2);
  private:
  const ::spir::BitEntity& _internal_opr2() const;
  ::spir::BitEntity* _internal_mutable_opr2();
  public:
  void unsafe_arena_set_allocated_opr2(
      ::spir::BitEntity* opr2);
  ::spir::BitEntity* unsafe_arena_release_opr2();

  // optional .spir.BitSrcLoc loc = 5;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // .spir.K_XK kind = 1;
  void clear_kind();
  ::spir::K_XK kind() const;
  void set_kind(::spir::K_XK value);
  private:
  ::spir::K_XK _internal_kind() const;
  void _internal_set_kind(::spir::K_XK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity > oprs_;
    ::spir::BitEntity* opr1_;
    ::spir::BitEntity* opr2_;
    ::spir::BitSrcLoc* loc_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitInsn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitInsn) */ {
 public:
  inline BitInsn() : BitInsn(nullptr) {}
  ~BitInsn() override;
  explicit PROTOBUF_CONSTEXPR BitInsn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitInsn(const BitInsn& from);
  BitInsn(BitInsn&& from) noexcept
    : BitInsn() {
    *this = ::std::move(from);
  }

  inline BitInsn& operator=(const BitInsn& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitInsn& operator=(BitInsn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitInsn& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitInsn* internal_default_instance() {
    return reinterpret_cast<const BitInsn*>(
               &_BitInsn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BitInsn& a, BitInsn& b) {
    a.Swap(&b);
  }
  inline void Swap(BitInsn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitInsn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitInsn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitInsn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitInsn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitInsn& from) {
    BitInsn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitInsn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitInsn";
  }
  protected:
  explicit BitInsn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpr1FieldNumber = 2,
    kExpr2FieldNumber = 3,
    kLocFieldNumber = 4,
    kKindFieldNumber = 1,
  };
  // optional .spir.BitExpr expr1 = 2;
  bool has_expr1() const;
  private:
  bool _internal_has_expr1() const;
  public:
  void clear_expr1();
  const ::spir::BitExpr& expr1() const;
  PROTOBUF_NODISCARD ::spir::BitExpr* release_expr1();
  ::spir::BitExpr* mutable_expr1();
  void set_allocated_expr1(::spir::BitExpr* expr1);
  private:
  const ::spir::BitExpr& _internal_expr1() const;
  ::spir::BitExpr* _internal_mutable_expr1();
  public:
  void unsafe_arena_set_allocated_expr1(
      ::spir::BitExpr* expr1);
  ::spir::BitExpr* unsafe_arena_release_expr1();

  // optional .spir.BitExpr expr2 = 3;
  bool has_expr2() const;
  private:
  bool _internal_has_expr2() const;
  public:
  void clear_expr2();
  const ::spir::BitExpr& expr2() const;
  PROTOBUF_NODISCARD ::spir::BitExpr* release_expr2();
  ::spir::BitExpr* mutable_expr2();
  void set_allocated_expr2(::spir::BitExpr* expr2);
  private:
  const ::spir::BitExpr& _internal_expr2() const;
  ::spir::BitExpr* _internal_mutable_expr2();
  public:
  void unsafe_arena_set_allocated_expr2(
      ::spir::BitExpr* expr2);
  ::spir::BitExpr* unsafe_arena_release_expr2();

  // optional .spir.BitSrcLoc loc = 4;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // .spir.K_IK kind = 1;
  void clear_kind();
  ::spir::K_IK kind() const;
  void set_kind(::spir::K_IK value);
  private:
  ::spir::K_IK _internal_kind() const;
  void _internal_set_kind(::spir::K_IK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitInsn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::spir::BitExpr* expr1_;
    ::spir::BitExpr* expr2_;
    ::spir::BitSrcLoc* loc_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitFunc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitFunc) */ {
 public:
  inline BitFunc() : BitFunc(nullptr) {}
  ~BitFunc() override;
  explicit PROTOBUF_CONSTEXPR BitFunc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitFunc(const BitFunc& from);
  BitFunc(BitFunc&& from) noexcept
    : BitFunc() {
    *this = ::std::move(from);
  }

  inline BitFunc& operator=(const BitFunc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitFunc& operator=(BitFunc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitFunc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitFunc* internal_default_instance() {
    return reinterpret_cast<const BitFunc*>(
               &_BitFunc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BitFunc& a, BitFunc& b) {
    a.Swap(&b);
  }
  inline void Swap(BitFunc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitFunc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitFunc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitFunc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitFunc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitFunc& from) {
    BitFunc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitFunc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitFunc";
  }
  protected:
  explicit BitFunc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsnsFieldNumber = 5,
    kLocalsFieldNumber = 6,
    kFnameFieldNumber = 2,
    kCallingConventionFieldNumber = 4,
    kFidFieldNumber = 1,
    kIsVariadicFieldNumber = 3,
  };
  // repeated .spir.BitInsn insns = 5;
  int insns_size() const;
  private:
  int _internal_insns_size() const;
  public:
  void clear_insns();
  ::spir::BitInsn* mutable_insns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >*
      mutable_insns();
  private:
  const ::spir::BitInsn& _internal_insns(int index) const;
  ::spir::BitInsn* _internal_add_insns();
  public:
  const ::spir::BitInsn& insns(int index) const;
  ::spir::BitInsn* add_insns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >&
      insns() const;

  // repeated uint64 locals = 6;
  int locals_size() const;
  private:
  int _internal_locals_size() const;
  public:
  void clear_locals();
  private:
  uint64_t _internal_locals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_locals() const;
  void _internal_add_locals(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_locals();
  public:
  uint64_t locals(int index) const;
  void set_locals(int index, uint64_t value);
  void add_locals(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      locals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_locals();

  // string fname = 2;
  void clear_fname();
  const std::string& fname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fname();
  PROTOBUF_NODISCARD std::string* release_fname();
  void set_allocated_fname(std::string* fname);
  private:
  const std::string& _internal_fname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fname(const std::string& value);
  std::string* _internal_mutable_fname();
  public:

  // optional string calling_convention = 4;
  bool has_calling_convention() const;
  private:
  bool _internal_has_calling_convention() const;
  public:
  void clear_calling_convention();
  const std::string& calling_convention() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_calling_convention(ArgT0&& arg0, ArgT... args);
  std::string* mutable_calling_convention();
  PROTOBUF_NODISCARD std::string* release_calling_convention();
  void set_allocated_calling_convention(std::string* calling_convention);
  private:
  const std::string& _internal_calling_convention() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_calling_convention(const std::string& value);
  std::string* _internal_mutable_calling_convention();
  public:

  // uint64 fid = 1;
  void clear_fid();
  uint64_t fid() const;
  void set_fid(uint64_t value);
  private:
  uint64_t _internal_fid() const;
  void _internal_set_fid(uint64_t value);
  public:

  // bool is_variadic = 3;
  void clear_is_variadic();
  bool is_variadic() const;
  void set_is_variadic(bool value);
  private:
  bool _internal_is_variadic() const;
  void _internal_set_is_variadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitFunc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn > insns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > locals_;
    mutable std::atomic<int> _locals_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr calling_convention_;
    uint64_t fid_;
    bool is_variadic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitTU_NamesToIdsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_NamesToIdsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_NamesToIdsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  BitTU_NamesToIdsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BitTU_NamesToIdsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BitTU_NamesToIdsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BitTU_NamesToIdsEntry_DoNotUse& other);
  static const BitTU_NamesToIdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BitTU_NamesToIdsEntry_DoNotUse*>(&_BitTU_NamesToIdsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spir.BitTU.NamesToIdsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spir_2eproto;
};

// -------------------------------------------------------------------

class BitTU_EntityInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntityInfoEntry_DoNotUse, 
    uint64_t, ::spir::BitEntityInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntityInfoEntry_DoNotUse, 
    uint64_t, ::spir::BitEntityInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BitTU_EntityInfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BitTU_EntityInfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BitTU_EntityInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BitTU_EntityInfoEntry_DoNotUse& other);
  static const BitTU_EntityInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BitTU_EntityInfoEntry_DoNotUse*>(&_BitTU_EntityInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spir_2eproto;
};

// -------------------------------------------------------------------

class BitTU final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitTU) */ {
 public:
  inline BitTU() : BitTU(nullptr) {}
  ~BitTU() override;
  explicit PROTOBUF_CONSTEXPR BitTU(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitTU(const BitTU& from);
  BitTU(BitTU&& from) noexcept
    : BitTU() {
    *this = ::std::move(from);
  }

  inline BitTU& operator=(const BitTU& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitTU& operator=(BitTU&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitTU& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitTU* internal_default_instance() {
    return reinterpret_cast<const BitTU*>(
               &_BitTU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BitTU& a, BitTU& b) {
    a.Swap(&b);
  }
  inline void Swap(BitTU* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitTU* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitTU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitTU>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitTU& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitTU& from) {
    BitTU::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitTU* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitTU";
  }
  protected:
  explicit BitTU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNamesToIdsFieldNumber = 4,
    kEntityInfoFieldNumber = 5,
    kFunctionsFieldNumber = 6,
    kTuNameFieldNumber = 1,
    kAbsPathFieldNumber = 2,
    kOriginFieldNumber = 3,
  };
  // map<string, uint64> namesToIds = 4;
  int namestoids_size() const;
  private:
  int _internal_namestoids_size() const;
  public:
  void clear_namestoids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      _internal_namestoids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      _internal_mutable_namestoids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      namestoids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      mutable_namestoids();

  // map<uint64, .spir.BitEntityInfo> entityInfo = 5;
  int entityinfo_size() const;
  private:
  int _internal_entityinfo_size() const;
  public:
  void clear_entityinfo();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >&
      _internal_entityinfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >*
      _internal_mutable_entityinfo();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >&
      entityinfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >*
      mutable_entityinfo();

  // repeated .spir.BitFunc functions = 6;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  ::spir::BitFunc* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >*
      mutable_functions();
  private:
  const ::spir::BitFunc& _internal_functions(int index) const;
  ::spir::BitFunc* _internal_add_functions();
  public:
  const ::spir::BitFunc& functions(int index) const;
  ::spir::BitFunc* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >&
      functions() const;

  // string tuName = 1;
  void clear_tuname();
  const std::string& tuname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tuname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tuname();
  PROTOBUF_NODISCARD std::string* release_tuname();
  void set_allocated_tuname(std::string* tuname);
  private:
  const std::string& _internal_tuname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tuname(const std::string& value);
  std::string* _internal_mutable_tuname();
  public:

  // optional string absPath = 2;
  bool has_abspath() const;
  private:
  bool _internal_has_abspath() const;
  public:
  void clear_abspath();
  const std::string& abspath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abspath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abspath();
  PROTOBUF_NODISCARD std::string* release_abspath();
  void set_allocated_abspath(std::string* abspath);
  private:
  const std::string& _internal_abspath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abspath(const std::string& value);
  std::string* _internal_mutable_abspath();
  public:

  // optional string origin = 3;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const std::string& origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin();
  PROTOBUF_NODISCARD std::string* release_origin();
  void set_allocated_origin(std::string* origin);
  private:
  const std::string& _internal_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
  std::string* _internal_mutable_origin();
  public:

  // @@protoc_insertion_point(class_scope:spir.BitTU)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BitTU_NamesToIdsEntry_DoNotUse,
        std::string, uint64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> namestoids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BitTU_EntityInfoEntry_DoNotUse,
        uint64_t, ::spir::BitEntityInfo,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> entityinfo_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc > functions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tuname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abspath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BitSrcLoc

// uint32 line = 1;
inline void BitSrcLoc::clear_line() {
  _impl_.line_ = 0u;
}
inline uint32_t BitSrcLoc::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t BitSrcLoc::line() const {
  // @@protoc_insertion_point(field_get:spir.BitSrcLoc.line)
  return _internal_line();
}
inline void BitSrcLoc::_internal_set_line(uint32_t value) {
  
  _impl_.line_ = value;
}
inline void BitSrcLoc::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:spir.BitSrcLoc.line)
}

// uint32 col = 2;
inline void BitSrcLoc::clear_col() {
  _impl_.col_ = 0u;
}
inline uint32_t BitSrcLoc::_internal_col() const {
  return _impl_.col_;
}
inline uint32_t BitSrcLoc::col() const {
  // @@protoc_insertion_point(field_get:spir.BitSrcLoc.col)
  return _internal_col();
}
inline void BitSrcLoc::_internal_set_col(uint32_t value) {
  
  _impl_.col_ = value;
}
inline void BitSrcLoc::set_col(uint32_t value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:spir.BitSrcLoc.col)
}

// -------------------------------------------------------------------

// BitDataType

// .spir.K_VK vkind = 1;
inline void BitDataType::clear_vkind() {
  _impl_.vkind_ = 0;
}
inline ::spir::K_VK BitDataType::_internal_vkind() const {
  return static_cast< ::spir::K_VK >(_impl_.vkind_);
}
inline ::spir::K_VK BitDataType::vkind() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.vkind)
  return _internal_vkind();
}
inline void BitDataType::_internal_set_vkind(::spir::K_VK value) {
  
  _impl_.vkind_ = value;
}
inline void BitDataType::set_vkind(::spir::K_VK value) {
  _internal_set_vkind(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.vkind)
}

// optional uint64 typeId = 2;
inline bool BitDataType::_internal_has_typeid_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BitDataType::has_typeid_() const {
  return _internal_has_typeid_();
}
inline void BitDataType::clear_typeid_() {
  _impl_.typeid__ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t BitDataType::_internal_typeid_() const {
  return _impl_.typeid__;
}
inline uint64_t BitDataType::typeid_() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.typeId)
  return _internal_typeid_();
}
inline void BitDataType::_internal_set_typeid_(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.typeid__ = value;
}
inline void BitDataType::set_typeid_(uint64_t value) {
  _internal_set_typeid_(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.typeId)
}

// optional uint32 qtype = 3;
inline bool BitDataType::_internal_has_qtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BitDataType::has_qtype() const {
  return _internal_has_qtype();
}
inline void BitDataType::clear_qtype() {
  _impl_.qtype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t BitDataType::_internal_qtype() const {
  return _impl_.qtype_;
}
inline uint32_t BitDataType::qtype() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.qtype)
  return _internal_qtype();
}
inline void BitDataType::_internal_set_qtype(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.qtype_ = value;
}
inline void BitDataType::set_qtype(uint32_t value) {
  _internal_set_qtype(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.qtype)
}

// optional string attributes = 4;
inline bool BitDataType::_internal_has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitDataType::has_attributes() const {
  return _internal_has_attributes();
}
inline void BitDataType::clear_attributes() {
  _impl_.attributes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitDataType::attributes() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.attributes)
  return _internal_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitDataType::set_attributes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attributes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitDataType.attributes)
}
inline std::string* BitDataType::mutable_attributes() {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:spir.BitDataType.attributes)
  return _s;
}
inline const std::string& BitDataType::_internal_attributes() const {
  return _impl_.attributes_.Get();
}
inline void BitDataType::_internal_set_attributes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attributes_.Set(value, GetArenaForAllocation());
}
inline std::string* BitDataType::_internal_mutable_attributes() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attributes_.Mutable(GetArenaForAllocation());
}
inline std::string* BitDataType::release_attributes() {
  // @@protoc_insertion_point(field_release:spir.BitDataType.attributes)
  if (!_internal_has_attributes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attributes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributes_.IsDefault()) {
    _impl_.attributes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitDataType::set_allocated_attributes(std::string* attributes) {
  if (attributes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attributes_.SetAllocated(attributes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributes_.IsDefault()) {
    _impl_.attributes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitDataType.attributes)
}

// optional uint32 len = 5;
inline bool BitDataType::_internal_has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BitDataType::has_len() const {
  return _internal_has_len();
}
inline void BitDataType::clear_len() {
  _impl_.len_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t BitDataType::_internal_len() const {
  return _impl_.len_;
}
inline uint32_t BitDataType::len() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.len)
  return _internal_len();
}
inline void BitDataType::_internal_set_len(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.len_ = value;
}
inline void BitDataType::set_len(uint32_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.len)
}

// optional uint32 align = 6;
inline bool BitDataType::_internal_has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BitDataType::has_align() const {
  return _internal_has_align();
}
inline void BitDataType::clear_align() {
  _impl_.align_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t BitDataType::_internal_align() const {
  return _impl_.align_;
}
inline uint32_t BitDataType::align() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.align)
  return _internal_align();
}
inline void BitDataType::_internal_set_align(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.align_ = value;
}
inline void BitDataType::set_align(uint32_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.align)
}

// optional .spir.BitDataType subType = 7;
inline bool BitDataType::_internal_has_subtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subtype_ != nullptr);
  return value;
}
inline bool BitDataType::has_subtype() const {
  return _internal_has_subtype();
}
inline void BitDataType::clear_subtype() {
  if (_impl_.subtype_ != nullptr) _impl_.subtype_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::spir::BitDataType& BitDataType::_internal_subtype() const {
  const ::spir::BitDataType* p = _impl_.subtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitDataType&>(
      ::spir::_BitDataType_default_instance_);
}
inline const ::spir::BitDataType& BitDataType::subtype() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.subType)
  return _internal_subtype();
}
inline void BitDataType::unsafe_arena_set_allocated_subtype(
    ::spir::BitDataType* subtype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtype_);
  }
  _impl_.subtype_ = subtype;
  if (subtype) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitDataType.subType)
}
inline ::spir::BitDataType* BitDataType::release_subtype() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitDataType* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitDataType* BitDataType::unsafe_arena_release_subtype() {
  // @@protoc_insertion_point(field_release:spir.BitDataType.subType)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitDataType* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
  return temp;
}
inline ::spir::BitDataType* BitDataType::_internal_mutable_subtype() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.subtype_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitDataType>(GetArenaForAllocation());
    _impl_.subtype_ = p;
  }
  return _impl_.subtype_;
}
inline ::spir::BitDataType* BitDataType::mutable_subtype() {
  ::spir::BitDataType* _msg = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:spir.BitDataType.subType)
  return _msg;
}
inline void BitDataType::set_allocated_subtype(::spir::BitDataType* subtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subtype_;
  }
  if (subtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtype);
    if (message_arena != submessage_arena) {
      subtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtype, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.subtype_ = subtype;
  // @@protoc_insertion_point(field_set_allocated:spir.BitDataType.subType)
}

// optional string typeName = 8;
inline bool BitDataType::_internal_has_typename_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BitDataType::has_typename_() const {
  return _internal_has_typename_();
}
inline void BitDataType::clear_typename_() {
  _impl_.typename__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BitDataType::typename_() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.typeName)
  return _internal_typename_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitDataType::set_typename_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.typename__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitDataType.typeName)
}
inline std::string* BitDataType::mutable_typename_() {
  std::string* _s = _internal_mutable_typename_();
  // @@protoc_insertion_point(field_mutable:spir.BitDataType.typeName)
  return _s;
}
inline const std::string& BitDataType::_internal_typename_() const {
  return _impl_.typename__.Get();
}
inline void BitDataType::_internal_set_typename_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.typename__.Set(value, GetArenaForAllocation());
}
inline std::string* BitDataType::_internal_mutable_typename_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.typename__.Mutable(GetArenaForAllocation());
}
inline std::string* BitDataType::release_typename_() {
  // @@protoc_insertion_point(field_release:spir.BitDataType.typeName)
  if (!_internal_has_typename_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.typename__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.typename__.IsDefault()) {
    _impl_.typename__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitDataType::set_allocated_typename_(std::string* typename_) {
  if (typename_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.typename__.SetAllocated(typename_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.typename__.IsDefault()) {
    _impl_.typename__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitDataType.typeName)
}

// optional bool anonymous = 9;
inline bool BitDataType::_internal_has_anonymous() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BitDataType::has_anonymous() const {
  return _internal_has_anonymous();
}
inline void BitDataType::clear_anonymous() {
  _impl_.anonymous_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool BitDataType::_internal_anonymous() const {
  return _impl_.anonymous_;
}
inline bool BitDataType::anonymous() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.anonymous)
  return _internal_anonymous();
}
inline void BitDataType::_internal_set_anonymous(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.anonymous_ = value;
}
inline void BitDataType::set_anonymous(bool value) {
  _internal_set_anonymous(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.anonymous)
}

// repeated uint64 fopIds = 10;
inline int BitDataType::_internal_fopids_size() const {
  return _impl_.fopids_.size();
}
inline int BitDataType::fopids_size() const {
  return _internal_fopids_size();
}
inline void BitDataType::clear_fopids() {
  _impl_.fopids_.Clear();
}
inline uint64_t BitDataType::_internal_fopids(int index) const {
  return _impl_.fopids_.Get(index);
}
inline uint64_t BitDataType::fopids(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.fopIds)
  return _internal_fopids(index);
}
inline void BitDataType::set_fopids(int index, uint64_t value) {
  _impl_.fopids_.Set(index, value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.fopIds)
}
inline void BitDataType::_internal_add_fopids(uint64_t value) {
  _impl_.fopids_.Add(value);
}
inline void BitDataType::add_fopids(uint64_t value) {
  _internal_add_fopids(value);
  // @@protoc_insertion_point(field_add:spir.BitDataType.fopIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitDataType::_internal_fopids() const {
  return _impl_.fopids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitDataType::fopids() const {
  // @@protoc_insertion_point(field_list:spir.BitDataType.fopIds)
  return _internal_fopids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitDataType::_internal_mutable_fopids() {
  return &_impl_.fopids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitDataType::mutable_fopids() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitDataType.fopIds)
  return _internal_mutable_fopids();
}

// repeated .spir.BitDataType fopTypes = 11;
inline int BitDataType::_internal_foptypes_size() const {
  return _impl_.foptypes_.size();
}
inline int BitDataType::foptypes_size() const {
  return _internal_foptypes_size();
}
inline void BitDataType::clear_foptypes() {
  _impl_.foptypes_.Clear();
}
inline ::spir::BitDataType* BitDataType::mutable_foptypes(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitDataType.fopTypes)
  return _impl_.foptypes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitDataType >*
BitDataType::mutable_foptypes() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitDataType.fopTypes)
  return &_impl_.foptypes_;
}
inline const ::spir::BitDataType& BitDataType::_internal_foptypes(int index) const {
  return _impl_.foptypes_.Get(index);
}
inline const ::spir::BitDataType& BitDataType::foptypes(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.fopTypes)
  return _internal_foptypes(index);
}
inline ::spir::BitDataType* BitDataType::_internal_add_foptypes() {
  return _impl_.foptypes_.Add();
}
inline ::spir::BitDataType* BitDataType::add_foptypes() {
  ::spir::BitDataType* _add = _internal_add_foptypes();
  // @@protoc_insertion_point(field_add:spir.BitDataType.fopTypes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitDataType >&
BitDataType::foptypes() const {
  // @@protoc_insertion_point(field_list:spir.BitDataType.fopTypes)
  return _impl_.foptypes_;
}

// optional bool variadic = 12;
inline bool BitDataType::_internal_has_variadic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BitDataType::has_variadic() const {
  return _internal_has_variadic();
}
inline void BitDataType::clear_variadic() {
  _impl_.variadic_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool BitDataType::_internal_variadic() const {
  return _impl_.variadic_;
}
inline bool BitDataType::variadic() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.variadic)
  return _internal_variadic();
}
inline void BitDataType::_internal_set_variadic(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.variadic_ = value;
}
inline void BitDataType::set_variadic(bool value) {
  _internal_set_variadic(value);
  // @@protoc_insertion_point(field_set:spir.BitDataType.variadic)
}

// optional .spir.BitSrcLoc loc = 13;
inline bool BitDataType::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitDataType::has_loc() const {
  return _internal_has_loc();
}
inline void BitDataType::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::spir::BitSrcLoc& BitDataType::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitDataType::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitDataType.loc)
  return _internal_loc();
}
inline void BitDataType::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitDataType.loc)
}
inline ::spir::BitSrcLoc* BitDataType::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitDataType::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitDataType.loc)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitDataType::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitDataType::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitDataType.loc)
  return _msg;
}
inline void BitDataType::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitDataType.loc)
}

// -------------------------------------------------------------------

// BitEntityInfo

// uint64 eid = 1;
inline void BitEntityInfo::clear_eid() {
  _impl_.eid_ = uint64_t{0u};
}
inline uint64_t BitEntityInfo::_internal_eid() const {
  return _impl_.eid_;
}
inline uint64_t BitEntityInfo::eid() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.eid)
  return _internal_eid();
}
inline void BitEntityInfo::_internal_set_eid(uint64_t value) {
  
  _impl_.eid_ = value;
}
inline void BitEntityInfo::set_eid(uint64_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.eid)
}

// .spir.K_EK ekind = 2;
inline void BitEntityInfo::clear_ekind() {
  _impl_.ekind_ = 0;
}
inline ::spir::K_EK BitEntityInfo::_internal_ekind() const {
  return static_cast< ::spir::K_EK >(_impl_.ekind_);
}
inline ::spir::K_EK BitEntityInfo::ekind() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.ekind)
  return _internal_ekind();
}
inline void BitEntityInfo::_internal_set_ekind(::spir::K_EK value) {
  
  _impl_.ekind_ = value;
}
inline void BitEntityInfo::set_ekind(::spir::K_EK value) {
  _internal_set_ekind(value);
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.ekind)
}

// optional uint64 parentId = 3;
inline bool BitEntityInfo::_internal_has_parentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BitEntityInfo::has_parentid() const {
  return _internal_has_parentid();
}
inline void BitEntityInfo::clear_parentid() {
  _impl_.parentid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t BitEntityInfo::_internal_parentid() const {
  return _impl_.parentid_;
}
inline uint64_t BitEntityInfo::parentid() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.parentId)
  return _internal_parentid();
}
inline void BitEntityInfo::_internal_set_parentid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parentid_ = value;
}
inline void BitEntityInfo::set_parentid(uint64_t value) {
  _internal_set_parentid(value);
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.parentId)
}

// optional .spir.BitDataType dt = 4;
inline bool BitEntityInfo::_internal_has_dt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dt_ != nullptr);
  return value;
}
inline bool BitEntityInfo::has_dt() const {
  return _internal_has_dt();
}
inline void BitEntityInfo::clear_dt() {
  if (_impl_.dt_ != nullptr) _impl_.dt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitDataType& BitEntityInfo::_internal_dt() const {
  const ::spir::BitDataType* p = _impl_.dt_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitDataType&>(
      ::spir::_BitDataType_default_instance_);
}
inline const ::spir::BitDataType& BitEntityInfo::dt() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.dt)
  return _internal_dt();
}
inline void BitEntityInfo::unsafe_arena_set_allocated_dt(
    ::spir::BitDataType* dt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dt_);
  }
  _impl_.dt_ = dt;
  if (dt) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitEntityInfo.dt)
}
inline ::spir::BitDataType* BitEntityInfo::release_dt() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitDataType* temp = _impl_.dt_;
  _impl_.dt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitDataType* BitEntityInfo::unsafe_arena_release_dt() {
  // @@protoc_insertion_point(field_release:spir.BitEntityInfo.dt)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitDataType* temp = _impl_.dt_;
  _impl_.dt_ = nullptr;
  return temp;
}
inline ::spir::BitDataType* BitEntityInfo::_internal_mutable_dt() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dt_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitDataType>(GetArenaForAllocation());
    _impl_.dt_ = p;
  }
  return _impl_.dt_;
}
inline ::spir::BitDataType* BitEntityInfo::mutable_dt() {
  ::spir::BitDataType* _msg = _internal_mutable_dt();
  // @@protoc_insertion_point(field_mutable:spir.BitEntityInfo.dt)
  return _msg;
}
inline void BitEntityInfo::set_allocated_dt(::spir::BitDataType* dt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dt_;
  }
  if (dt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dt);
    if (message_arena != submessage_arena) {
      dt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dt, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dt_ = dt;
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntityInfo.dt)
}

// optional uint64 lowVal = 5;
inline bool BitEntityInfo::_internal_has_lowval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BitEntityInfo::has_lowval() const {
  return _internal_has_lowval();
}
inline void BitEntityInfo::clear_lowval() {
  _impl_.lowval_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t BitEntityInfo::_internal_lowval() const {
  return _impl_.lowval_;
}
inline uint64_t BitEntityInfo::lowval() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.lowVal)
  return _internal_lowval();
}
inline void BitEntityInfo::_internal_set_lowval(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.lowval_ = value;
}
inline void BitEntityInfo::set_lowval(uint64_t value) {
  _internal_set_lowval(value);
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.lowVal)
}

// optional uint64 highVal = 6;
inline bool BitEntityInfo::_internal_has_highval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BitEntityInfo::has_highval() const {
  return _internal_has_highval();
}
inline void BitEntityInfo::clear_highval() {
  _impl_.highval_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t BitEntityInfo::_internal_highval() const {
  return _impl_.highval_;
}
inline uint64_t BitEntityInfo::highval() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.highVal)
  return _internal_highval();
}
inline void BitEntityInfo::_internal_set_highval(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.highval_ = value;
}
inline void BitEntityInfo::set_highval(uint64_t value) {
  _internal_set_highval(value);
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.highVal)
}

// optional string strVal = 7;
inline bool BitEntityInfo::_internal_has_strval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitEntityInfo::has_strval() const {
  return _internal_has_strval();
}
inline void BitEntityInfo::clear_strval() {
  _impl_.strval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitEntityInfo::strval() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.strVal)
  return _internal_strval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitEntityInfo::set_strval(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.strval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitEntityInfo.strVal)
}
inline std::string* BitEntityInfo::mutable_strval() {
  std::string* _s = _internal_mutable_strval();
  // @@protoc_insertion_point(field_mutable:spir.BitEntityInfo.strVal)
  return _s;
}
inline const std::string& BitEntityInfo::_internal_strval() const {
  return _impl_.strval_.Get();
}
inline void BitEntityInfo::_internal_set_strval(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.strval_.Set(value, GetArenaForAllocation());
}
inline std::string* BitEntityInfo::_internal_mutable_strval() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.strval_.Mutable(GetArenaForAllocation());
}
inline std::string* BitEntityInfo::release_strval() {
  // @@protoc_insertion_point(field_release:spir.BitEntityInfo.strVal)
  if (!_internal_has_strval()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.strval_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strval_.IsDefault()) {
    _impl_.strval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitEntityInfo::set_allocated_strval(std::string* strval) {
  if (strval != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.strval_.SetAllocated(strval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strval_.IsDefault()) {
    _impl_.strval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntityInfo.strVal)
}

// optional .spir.BitSrcLoc loc = 8;
inline bool BitEntityInfo::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitEntityInfo::has_loc() const {
  return _internal_has_loc();
}
inline void BitEntityInfo::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::spir::BitSrcLoc& BitEntityInfo::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitEntityInfo::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitEntityInfo.loc)
  return _internal_loc();
}
inline void BitEntityInfo::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitEntityInfo.loc)
}
inline ::spir::BitSrcLoc* BitEntityInfo::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitEntityInfo::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitEntityInfo.loc)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitEntityInfo::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitEntityInfo::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitEntityInfo.loc)
  return _msg;
}
inline void BitEntityInfo::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntityInfo.loc)
}

// -------------------------------------------------------------------

// BitEntity

// uint64 eid = 1;
inline void BitEntity::clear_eid() {
  _impl_.eid_ = uint64_t{0u};
}
inline uint64_t BitEntity::_internal_eid() const {
  return _impl_.eid_;
}
inline uint64_t BitEntity::eid() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.eid)
  return _internal_eid();
}
inline void BitEntity::_internal_set_eid(uint64_t value) {
  
  _impl_.eid_ = value;
}
inline void BitEntity::set_eid(uint64_t value) {
  _internal_set_eid(value);
  // @@protoc_insertion_point(field_set:spir.BitEntity.eid)
}

// optional .spir.BitSrcLoc loc = 2;
inline bool BitEntity::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitEntity::has_loc() const {
  return _internal_has_loc();
}
inline void BitEntity::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spir::BitSrcLoc& BitEntity::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitEntity::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.loc)
  return _internal_loc();
}
inline void BitEntity::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitEntity.loc)
}
inline ::spir::BitSrcLoc* BitEntity::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitEntity::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitEntity.loc)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitEntity::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitEntity::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitEntity.loc)
  return _msg;
}
inline void BitEntity::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntity.loc)
}

// -------------------------------------------------------------------

// BitExpr

// .spir.K_XK kind = 1;
inline void BitExpr::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_XK BitExpr::_internal_kind() const {
  return static_cast< ::spir::K_XK >(_impl_.kind_);
}
inline ::spir::K_XK BitExpr::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.kind)
  return _internal_kind();
}
inline void BitExpr::_internal_set_kind(::spir::K_XK value) {
  
  _impl_.kind_ = value;
}
inline void BitExpr::set_kind(::spir::K_XK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitExpr.kind)
}

// optional .spir.BitEntity opr1 = 2;
inline bool BitExpr::_internal_has_opr1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opr1_ != nullptr);
  return value;
}
inline bool BitExpr::has_opr1() const {
  return _internal_has_opr1();
}
inline void BitExpr::clear_opr1() {
  if (_impl_.opr1_ != nullptr) _impl_.opr1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spir::BitEntity& BitExpr::_internal_opr1() const {
  const ::spir::BitEntity* p = _impl_.opr1_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitEntity&>(
      ::spir::_BitEntity_default_instance_);
}
inline const ::spir::BitEntity& BitExpr::opr1() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.opr1)
  return _internal_opr1();
}
inline void BitExpr::unsafe_arena_set_allocated_opr1(
    ::spir::BitEntity* opr1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opr1_);
  }
  _impl_.opr1_ = opr1;
  if (opr1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.opr1)
}
inline ::spir::BitEntity* BitExpr::release_opr1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitEntity* temp = _impl_.opr1_;
  _impl_.opr1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitEntity* BitExpr::unsafe_arena_release_opr1() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.opr1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitEntity* temp = _impl_.opr1_;
  _impl_.opr1_ = nullptr;
  return temp;
}
inline ::spir::BitEntity* BitExpr::_internal_mutable_opr1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.opr1_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitEntity>(GetArenaForAllocation());
    _impl_.opr1_ = p;
  }
  return _impl_.opr1_;
}
inline ::spir::BitEntity* BitExpr::mutable_opr1() {
  ::spir::BitEntity* _msg = _internal_mutable_opr1();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.opr1)
  return _msg;
}
inline void BitExpr::set_allocated_opr1(::spir::BitEntity* opr1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opr1_;
  }
  if (opr1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opr1);
    if (message_arena != submessage_arena) {
      opr1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opr1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.opr1_ = opr1;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.opr1)
}

// optional .spir.BitEntity opr2 = 3;
inline bool BitExpr::_internal_has_opr2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opr2_ != nullptr);
  return value;
}
inline bool BitExpr::has_opr2() const {
  return _internal_has_opr2();
}
inline void BitExpr::clear_opr2() {
  if (_impl_.opr2_ != nullptr) _impl_.opr2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitEntity& BitExpr::_internal_opr2() const {
  const ::spir::BitEntity* p = _impl_.opr2_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitEntity&>(
      ::spir::_BitEntity_default_instance_);
}
inline const ::spir::BitEntity& BitExpr::opr2() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.opr2)
  return _internal_opr2();
}
inline void BitExpr::unsafe_arena_set_allocated_opr2(
    ::spir::BitEntity* opr2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opr2_);
  }
  _impl_.opr2_ = opr2;
  if (opr2) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.opr2)
}
inline ::spir::BitEntity* BitExpr::release_opr2() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitEntity* temp = _impl_.opr2_;
  _impl_.opr2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitEntity* BitExpr::unsafe_arena_release_opr2() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.opr2)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitEntity* temp = _impl_.opr2_;
  _impl_.opr2_ = nullptr;
  return temp;
}
inline ::spir::BitEntity* BitExpr::_internal_mutable_opr2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.opr2_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitEntity>(GetArenaForAllocation());
    _impl_.opr2_ = p;
  }
  return _impl_.opr2_;
}
inline ::spir::BitEntity* BitExpr::mutable_opr2() {
  ::spir::BitEntity* _msg = _internal_mutable_opr2();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.opr2)
  return _msg;
}
inline void BitExpr::set_allocated_opr2(::spir::BitEntity* opr2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opr2_;
  }
  if (opr2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opr2);
    if (message_arena != submessage_arena) {
      opr2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opr2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.opr2_ = opr2;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.opr2)
}

// repeated .spir.BitEntity oprs = 4;
inline int BitExpr::_internal_oprs_size() const {
  return _impl_.oprs_.size();
}
inline int BitExpr::oprs_size() const {
  return _internal_oprs_size();
}
inline void BitExpr::clear_oprs() {
  _impl_.oprs_.Clear();
}
inline ::spir::BitEntity* BitExpr::mutable_oprs(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.oprs)
  return _impl_.oprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >*
BitExpr::mutable_oprs() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitExpr.oprs)
  return &_impl_.oprs_;
}
inline const ::spir::BitEntity& BitExpr::_internal_oprs(int index) const {
  return _impl_.oprs_.Get(index);
}
inline const ::spir::BitEntity& BitExpr::oprs(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.oprs)
  return _internal_oprs(index);
}
inline ::spir::BitEntity* BitExpr::_internal_add_oprs() {
  return _impl_.oprs_.Add();
}
inline ::spir::BitEntity* BitExpr::add_oprs() {
  ::spir::BitEntity* _add = _internal_add_oprs();
  // @@protoc_insertion_point(field_add:spir.BitExpr.oprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >&
BitExpr::oprs() const {
  // @@protoc_insertion_point(field_list:spir.BitExpr.oprs)
  return _impl_.oprs_;
}

// optional .spir.BitSrcLoc loc = 5;
inline bool BitExpr::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitExpr::has_loc() const {
  return _internal_has_loc();
}
inline void BitExpr::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::spir::BitSrcLoc& BitExpr::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitExpr::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.loc)
  return _internal_loc();
}
inline void BitExpr::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.loc)
}
inline ::spir::BitSrcLoc* BitExpr::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitExpr::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.loc)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitExpr::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitExpr::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.loc)
  return _msg;
}
inline void BitExpr::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.loc)
}

// -------------------------------------------------------------------

// BitInsn

// .spir.K_IK kind = 1;
inline void BitInsn::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_IK BitInsn::_internal_kind() const {
  return static_cast< ::spir::K_IK >(_impl_.kind_);
}
inline ::spir::K_IK BitInsn::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.kind)
  return _internal_kind();
}
inline void BitInsn::_internal_set_kind(::spir::K_IK value) {
  
  _impl_.kind_ = value;
}
inline void BitInsn::set_kind(::spir::K_IK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitInsn.kind)
}

// optional .spir.BitExpr expr1 = 2;
inline bool BitInsn::_internal_has_expr1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expr1_ != nullptr);
  return value;
}
inline bool BitInsn::has_expr1() const {
  return _internal_has_expr1();
}
inline void BitInsn::clear_expr1() {
  if (_impl_.expr1_ != nullptr) _impl_.expr1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spir::BitExpr& BitInsn::_internal_expr1() const {
  const ::spir::BitExpr* p = _impl_.expr1_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitExpr&>(
      ::spir::_BitExpr_default_instance_);
}
inline const ::spir::BitExpr& BitInsn::expr1() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.expr1)
  return _internal_expr1();
}
inline void BitInsn::unsafe_arena_set_allocated_expr1(
    ::spir::BitExpr* expr1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expr1_);
  }
  _impl_.expr1_ = expr1;
  if (expr1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitInsn.expr1)
}
inline ::spir::BitExpr* BitInsn::release_expr1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitExpr* temp = _impl_.expr1_;
  _impl_.expr1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitExpr* BitInsn::unsafe_arena_release_expr1() {
  // @@protoc_insertion_point(field_release:spir.BitInsn.expr1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitExpr* temp = _impl_.expr1_;
  _impl_.expr1_ = nullptr;
  return temp;
}
inline ::spir::BitExpr* BitInsn::_internal_mutable_expr1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.expr1_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitExpr>(GetArenaForAllocation());
    _impl_.expr1_ = p;
  }
  return _impl_.expr1_;
}
inline ::spir::BitExpr* BitInsn::mutable_expr1() {
  ::spir::BitExpr* _msg = _internal_mutable_expr1();
  // @@protoc_insertion_point(field_mutable:spir.BitInsn.expr1)
  return _msg;
}
inline void BitInsn::set_allocated_expr1(::spir::BitExpr* expr1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expr1_;
  }
  if (expr1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expr1);
    if (message_arena != submessage_arena) {
      expr1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.expr1_ = expr1;
  // @@protoc_insertion_point(field_set_allocated:spir.BitInsn.expr1)
}

// optional .spir.BitExpr expr2 = 3;
inline bool BitInsn::_internal_has_expr2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expr2_ != nullptr);
  return value;
}
inline bool BitInsn::has_expr2() const {
  return _internal_has_expr2();
}
inline void BitInsn::clear_expr2() {
  if (_impl_.expr2_ != nullptr) _impl_.expr2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitExpr& BitInsn::_internal_expr2() const {
  const ::spir::BitExpr* p = _impl_.expr2_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitExpr&>(
      ::spir::_BitExpr_default_instance_);
}
inline const ::spir::BitExpr& BitInsn::expr2() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.expr2)
  return _internal_expr2();
}
inline void BitInsn::unsafe_arena_set_allocated_expr2(
    ::spir::BitExpr* expr2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expr2_);
  }
  _impl_.expr2_ = expr2;
  if (expr2) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitInsn.expr2)
}
inline ::spir::BitExpr* BitInsn::release_expr2() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitExpr* temp = _impl_.expr2_;
  _impl_.expr2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitExpr* BitInsn::unsafe_arena_release_expr2() {
  // @@protoc_insertion_point(field_release:spir.BitInsn.expr2)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitExpr* temp = _impl_.expr2_;
  _impl_.expr2_ = nullptr;
  return temp;
}
inline ::spir::BitExpr* BitInsn::_internal_mutable_expr2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expr2_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitExpr>(GetArenaForAllocation());
    _impl_.expr2_ = p;
  }
  return _impl_.expr2_;
}
inline ::spir::BitExpr* BitInsn::mutable_expr2() {
  ::spir::BitExpr* _msg = _internal_mutable_expr2();
  // @@protoc_insertion_point(field_mutable:spir.BitInsn.expr2)
  return _msg;
}
inline void BitInsn::set_allocated_expr2(::spir::BitExpr* expr2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expr2_;
  }
  if (expr2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expr2);
    if (message_arena != submessage_arena) {
      expr2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.expr2_ = expr2;
  // @@protoc_insertion_point(field_set_allocated:spir.BitInsn.expr2)
}

// optional .spir.BitSrcLoc loc = 4;
inline bool BitInsn::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitInsn::has_loc() const {
  return _internal_has_loc();
}
inline void BitInsn::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::spir::BitSrcLoc& BitInsn::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitInsn::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.loc)
  return _internal_loc();
}
inline void BitInsn::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitInsn.loc)
}
inline ::spir::BitSrcLoc* BitInsn::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitInsn::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitInsn.loc)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitInsn::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitInsn::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitInsn.loc)
  return _msg;
}
inline void BitInsn::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitInsn.loc)
}

// -------------------------------------------------------------------

// BitFunc

// uint64 fid = 1;
inline void BitFunc::clear_fid() {
  _impl_.fid_ = uint64_t{0u};
}
inline uint64_t BitFunc::_internal_fid() const {
  return _impl_.fid_;
}
inline uint64_t BitFunc::fid() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.fid)
  return _internal_fid();
}
inline void BitFunc::_internal_set_fid(uint64_t value) {
  
  _impl_.fid_ = value;
}
inline void BitFunc::set_fid(uint64_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:spir.BitFunc.fid)
}

// string fname = 2;
inline void BitFunc::clear_fname() {
  _impl_.fname_.ClearToEmpty();
}
inline const std::string& BitFunc::fname() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.fname)
  return _internal_fname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitFunc::set_fname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitFunc.fname)
}
inline std::string* BitFunc::mutable_fname() {
  std::string* _s = _internal_mutable_fname();
  // @@protoc_insertion_point(field_mutable:spir.BitFunc.fname)
  return _s;
}
inline const std::string& BitFunc::_internal_fname() const {
  return _impl_.fname_.Get();
}
inline void BitFunc::_internal_set_fname(const std::string& value) {
  
  _impl_.fname_.Set(value, GetArenaForAllocation());
}
inline std::string* BitFunc::_internal_mutable_fname() {
  
  return _impl_.fname_.Mutable(GetArenaForAllocation());
}
inline std::string* BitFunc::release_fname() {
  // @@protoc_insertion_point(field_release:spir.BitFunc.fname)
  return _impl_.fname_.Release();
}
inline void BitFunc::set_allocated_fname(std::string* fname) {
  if (fname != nullptr) {
    
  } else {
    
  }
  _impl_.fname_.SetAllocated(fname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fname_.IsDefault()) {
    _impl_.fname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitFunc.fname)
}

// bool is_variadic = 3;
inline void BitFunc::clear_is_variadic() {
  _impl_.is_variadic_ = false;
}
inline bool BitFunc::_internal_is_variadic() const {
  return _impl_.is_variadic_;
}
inline bool BitFunc::is_variadic() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.is_variadic)
  return _internal_is_variadic();
}
inline void BitFunc::_internal_set_is_variadic(bool value) {
  
  _impl_.is_variadic_ = value;
}
inline void BitFunc::set_is_variadic(bool value) {
  _internal_set_is_variadic(value);
  // @@protoc_insertion_point(field_set:spir.BitFunc.is_variadic)
}

// optional string calling_convention = 4;
inline bool BitFunc::_internal_has_calling_convention() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitFunc::has_calling_convention() const {
  return _internal_has_calling_convention();
}
inline void BitFunc::clear_calling_convention() {
  _impl_.calling_convention_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitFunc::calling_convention() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.calling_convention)
  return _internal_calling_convention();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitFunc::set_calling_convention(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.calling_convention_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitFunc.calling_convention)
}
inline std::string* BitFunc::mutable_calling_convention() {
  std::string* _s = _internal_mutable_calling_convention();
  // @@protoc_insertion_point(field_mutable:spir.BitFunc.calling_convention)
  return _s;
}
inline const std::string& BitFunc::_internal_calling_convention() const {
  return _impl_.calling_convention_.Get();
}
inline void BitFunc::_internal_set_calling_convention(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.calling_convention_.Set(value, GetArenaForAllocation());
}
inline std::string* BitFunc::_internal_mutable_calling_convention() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.calling_convention_.Mutable(GetArenaForAllocation());
}
inline std::string* BitFunc::release_calling_convention() {
  // @@protoc_insertion_point(field_release:spir.BitFunc.calling_convention)
  if (!_internal_has_calling_convention()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.calling_convention_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.calling_convention_.IsDefault()) {
    _impl_.calling_convention_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitFunc::set_allocated_calling_convention(std::string* calling_convention) {
  if (calling_convention != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.calling_convention_.SetAllocated(calling_convention, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.calling_convention_.IsDefault()) {
    _impl_.calling_convention_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitFunc.calling_convention)
}

// repeated .spir.BitInsn insns = 5;
inline int BitFunc::_internal_insns_size() const {
  return _impl_.insns_.size();
}
inline int BitFunc::insns_size() const {
  return _internal_insns_size();
}
inline void BitFunc::clear_insns() {
  _impl_.insns_.Clear();
}
inline ::spir::BitInsn* BitFunc::mutable_insns(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitFunc.insns)
  return _impl_.insns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >*
BitFunc::mutable_insns() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitFunc.insns)
  return &_impl_.insns_;
}
inline const ::spir::BitInsn& BitFunc::_internal_insns(int index) const {
  return _impl_.insns_.Get(index);
}
inline const ::spir::BitInsn& BitFunc::insns(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.insns)
  return _internal_insns(index);
}
inline ::spir::BitInsn* BitFunc::_internal_add_insns() {
  return _impl_.insns_.Add();
}
inline ::spir::BitInsn* BitFunc::add_insns() {
  ::spir::BitInsn* _add = _internal_add_insns();
  // @@protoc_insertion_point(field_add:spir.BitFunc.insns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >&
BitFunc::insns() const {
  // @@protoc_insertion_point(field_list:spir.BitFunc.insns)
  return _impl_.insns_;
}

// repeated uint64 locals = 6;
inline int BitFunc::_internal_locals_size() const {
  return _impl_.locals_.size();
}
inline int BitFunc::locals_size() const {
  return _internal_locals_size();
}
inline void BitFunc::clear_locals() {
  _impl_.locals_.Clear();
}
inline uint64_t BitFunc::_internal_locals(int index) const {
  return _impl_.locals_.Get(index);
}
inline uint64_t BitFunc::locals(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.locals)
  return _internal_locals(index);
}
inline void BitFunc::set_locals(int index, uint64_t value) {
  _impl_.locals_.Set(index, value);
  // @@protoc_insertion_point(field_set:spir.BitFunc.locals)
}
inline void BitFunc::_internal_add_locals(uint64_t value) {
  _impl_.locals_.Add(value);
}
inline void BitFunc::add_locals(uint64_t value) {
  _internal_add_locals(value);
  // @@protoc_insertion_point(field_add:spir.BitFunc.locals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitFunc::_internal_locals() const {
  return _impl_.locals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitFunc::locals() const {
  // @@protoc_insertion_point(field_list:spir.BitFunc.locals)
  return _internal_locals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitFunc::_internal_mutable_locals() {
  return &_impl_.locals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitFunc::mutable_locals() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitFunc.locals)
  return _internal_mutable_locals();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BitTU

// string tuName = 1;
inline void BitTU::clear_tuname() {
  _impl_.tuname_.ClearToEmpty();
}
inline const std::string& BitTU::tuname() const {
  // @@protoc_insertion_point(field_get:spir.BitTU.tuName)
  return _internal_tuname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitTU::set_tuname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tuname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitTU.tuName)
}
inline std::string* BitTU::mutable_tuname() {
  std::string* _s = _internal_mutable_tuname();
  // @@protoc_insertion_point(field_mutable:spir.BitTU.tuName)
  return _s;
}
inline const std::string& BitTU::_internal_tuname() const {
  return _impl_.tuname_.Get();
}
inline void BitTU::_internal_set_tuname(const std::string& value) {
  
  _impl_.tuname_.Set(value, GetArenaForAllocation());
}
inline std::string* BitTU::_internal_mutable_tuname() {
  
  return _impl_.tuname_.Mutable(GetArenaForAllocation());
}
inline std::string* BitTU::release_tuname() {
  // @@protoc_insertion_point(field_release:spir.BitTU.tuName)
  return _impl_.tuname_.Release();
}
inline void BitTU::set_allocated_tuname(std::string* tuname) {
  if (tuname != nullptr) {
    
  } else {
    
  }
  _impl_.tuname_.SetAllocated(tuname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tuname_.IsDefault()) {
    _impl_.tuname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitTU.tuName)
}

// optional string absPath = 2;
inline bool BitTU::_internal_has_abspath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitTU::has_abspath() const {
  return _internal_has_abspath();
}
inline void BitTU::clear_abspath() {
  _impl_.abspath_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitTU::abspath() const {
  // @@protoc_insertion_point(field_get:spir.BitTU.absPath)
  return _internal_abspath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitTU::set_abspath(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.abspath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitTU.absPath)
}
inline std::string* BitTU::mutable_abspath() {
  std::string* _s = _internal_mutable_abspath();
  // @@protoc_insertion_point(field_mutable:spir.BitTU.absPath)
  return _s;
}
inline const std::string& BitTU::_internal_abspath() const {
  return _impl_.abspath_.Get();
}
inline void BitTU::_internal_set_abspath(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.abspath_.Set(value, GetArenaForAllocation());
}
inline std::string* BitTU::_internal_mutable_abspath() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.abspath_.Mutable(GetArenaForAllocation());
}
inline std::string* BitTU::release_abspath() {
  // @@protoc_insertion_point(field_release:spir.BitTU.absPath)
  if (!_internal_has_abspath()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.abspath_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abspath_.IsDefault()) {
    _impl_.abspath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitTU::set_allocated_abspath(std::string* abspath) {
  if (abspath != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.abspath_.SetAllocated(abspath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abspath_.IsDefault()) {
    _impl_.abspath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitTU.absPath)
}

// optional string origin = 3;
inline bool BitTU::_internal_has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BitTU::has_origin() const {
  return _internal_has_origin();
}
inline void BitTU::clear_origin() {
  _impl_.origin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BitTU::origin() const {
  // @@protoc_insertion_point(field_get:spir.BitTU.origin)
  return _internal_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitTU::set_origin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.origin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitTU.origin)
}
inline std::string* BitTU::mutable_origin() {
  std::string* _s = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:spir.BitTU.origin)
  return _s;
}
inline const std::string& BitTU::_internal_origin() const {
  return _impl_.origin_.Get();
}
inline void BitTU::_internal_set_origin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.origin_.Set(value, GetArenaForAllocation());
}
inline std::string* BitTU::_internal_mutable_origin() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.origin_.Mutable(GetArenaForAllocation());
}
inline std::string* BitTU::release_origin() {
  // @@protoc_insertion_point(field_release:spir.BitTU.origin)
  if (!_internal_has_origin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.origin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.origin_.IsDefault()) {
    _impl_.origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitTU::set_allocated_origin(std::string* origin) {
  if (origin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.origin_.SetAllocated(origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.origin_.IsDefault()) {
    _impl_.origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitTU.origin)
}

// map<string, uint64> namesToIds = 4;
inline int BitTU::_internal_namestoids_size() const {
  return _impl_.namestoids_.size();
}
inline int BitTU::namestoids_size() const {
  return _internal_namestoids_size();
}
inline void BitTU::clear_namestoids() {
  _impl_.namestoids_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
BitTU::_internal_namestoids() const {
  return _impl_.namestoids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
BitTU::namestoids() const {
  // @@protoc_insertion_point(field_map:spir.BitTU.namesToIds)
  return _internal_namestoids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
BitTU::_internal_mutable_namestoids() {
  return _impl_.namestoids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
BitTU::mutable_namestoids() {
  // @@protoc_insertion_point(field_mutable_map:spir.BitTU.namesToIds)
  return _internal_mutable_namestoids();
}

// map<uint64, .spir.BitEntityInfo> entityInfo = 5;
inline int BitTU::_internal_entityinfo_size() const {
  return _impl_.entityinfo_.size();
}
inline int BitTU::entityinfo_size() const {
  return _internal_entityinfo_size();
}
inline void BitTU::clear_entityinfo() {
  _impl_.entityinfo_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >&
BitTU::_internal_entityinfo() const {
  return _impl_.entityinfo_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >&
BitTU::entityinfo() const {
  // @@protoc_insertion_point(field_map:spir.BitTU.entityInfo)
  return _internal_entityinfo();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >*
BitTU::_internal_mutable_entityinfo() {
  return _impl_.entityinfo_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitEntityInfo >*
BitTU::mutable_entityinfo() {
  // @@protoc_insertion_point(field_mutable_map:spir.BitTU.entityInfo)
  return _internal_mutable_entityinfo();
}

// repeated .spir.BitFunc functions = 6;
inline int BitTU::_internal_functions_size() const {
  return _impl_.functions_.size();
}
inline int BitTU::functions_size() const {
  return _internal_functions_size();
}
inline void BitTU::clear_functions() {
  _impl_.functions_.Clear();
}
inline ::spir::BitFunc* BitTU::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitTU.functions)
  return _impl_.functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >*
BitTU::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitTU.functions)
  return &_impl_.functions_;
}
inline const ::spir::BitFunc& BitTU::_internal_functions(int index) const {
  return _impl_.functions_.Get(index);
}
inline const ::spir::BitFunc& BitTU::functions(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitTU.functions)
  return _internal_functions(index);
}
inline ::spir::BitFunc* BitTU::_internal_add_functions() {
  return _impl_.functions_.Add();
}
inline ::spir::BitFunc* BitTU::add_functions() {
  ::spir::BitFunc* _add = _internal_add_functions();
  // @@protoc_insertion_point(field_add:spir.BitTU.functions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >&
BitTU::functions() const {
  // @@protoc_insertion_point(field_list:spir.BitTU.functions)
  return _impl_.functions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::spir::K_EK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_EK>() {
  return ::spir::K_EK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_IK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_IK>() {
  return ::spir::K_IK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_XK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_XK>() {
  return ::spir::K_XK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_VK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_VK>() {
  return ::spir::K_VK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_QK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_QK>() {
  return ::spir::K_QK_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spir_2eproto

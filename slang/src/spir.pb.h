// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spir.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_spir_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_spir_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spir_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spir_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spir_2eproto;
namespace spir {
class BitEntity;
struct BitEntityDefaultTypeInternal;
extern BitEntityDefaultTypeInternal _BitEntity_default_instance_;
class BitExpr;
struct BitExprDefaultTypeInternal;
extern BitExprDefaultTypeInternal _BitExpr_default_instance_;
class BitFunc;
struct BitFuncDefaultTypeInternal;
extern BitFuncDefaultTypeInternal _BitFunc_default_instance_;
class BitInsn;
struct BitInsnDefaultTypeInternal;
extern BitInsnDefaultTypeInternal _BitInsn_default_instance_;
class BitSrcLoc;
struct BitSrcLocDefaultTypeInternal;
extern BitSrcLocDefaultTypeInternal _BitSrcLoc_default_instance_;
class BitTU;
struct BitTUDefaultTypeInternal;
extern BitTUDefaultTypeInternal _BitTU_default_instance_;
class BitTU_EntitiesEntry_DoNotUse;
struct BitTU_EntitiesEntry_DoNotUseDefaultTypeInternal;
extern BitTU_EntitiesEntry_DoNotUseDefaultTypeInternal _BitTU_EntitiesEntry_DoNotUse_default_instance_;
class BitTU_EntityTypesEntry_DoNotUse;
struct BitTU_EntityTypesEntry_DoNotUseDefaultTypeInternal;
extern BitTU_EntityTypesEntry_DoNotUseDefaultTypeInternal _BitTU_EntityTypesEntry_DoNotUse_default_instance_;
class BitValueType;
struct BitValueTypeDefaultTypeInternal;
extern BitValueTypeDefaultTypeInternal _BitValueType_default_instance_;
}  // namespace spir
PROTOBUF_NAMESPACE_OPEN
template<> ::spir::BitEntity* Arena::CreateMaybeMessage<::spir::BitEntity>(Arena*);
template<> ::spir::BitExpr* Arena::CreateMaybeMessage<::spir::BitExpr>(Arena*);
template<> ::spir::BitFunc* Arena::CreateMaybeMessage<::spir::BitFunc>(Arena*);
template<> ::spir::BitInsn* Arena::CreateMaybeMessage<::spir::BitInsn>(Arena*);
template<> ::spir::BitSrcLoc* Arena::CreateMaybeMessage<::spir::BitSrcLoc>(Arena*);
template<> ::spir::BitTU* Arena::CreateMaybeMessage<::spir::BitTU>(Arena*);
template<> ::spir::BitTU_EntitiesEntry_DoNotUse* Arena::CreateMaybeMessage<::spir::BitTU_EntitiesEntry_DoNotUse>(Arena*);
template<> ::spir::BitTU_EntityTypesEntry_DoNotUse* Arena::CreateMaybeMessage<::spir::BitTU_EntityTypesEntry_DoNotUse>(Arena*);
template<> ::spir::BitValueType* Arena::CreateMaybeMessage<::spir::BitValueType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace spir {

enum K_EK : int {
  NONE = 0,
  VAR = 1,
  VAR_GLOBAL = 2,
  VAR_TMP = 3,
  VAR_SSA = 4,
  VAR_PSEUDO = 5,
  LIT_NUM = 6,
  LIT_NUM_IMM = 7,
  LIT_STR = 8,
  VALUE_TYPE = 9,
  FUNC = 10,
  FUNC_VAR_ARGS = 11,
  CLASS = 12,
  LABEL = 13,
  ENT1 = 14,
  ENT2 = 15,
  INSN = 16,
  BB = 17,
  CFG = 18,
  SCOPE = 19,
  TU = 20,
  K_EK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_EK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_EK_IsValid(int value);
constexpr K_EK K_EK_MIN = NONE;
constexpr K_EK K_EK_MAX = TU;
constexpr int K_EK_ARRAYSIZE = K_EK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_EK_descriptor();
template<typename T>
inline const std::string& K_EK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_EK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_EK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_EK_descriptor(), enum_t_value);
}
inline bool K_EK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_EK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_EK>(
    K_EK_descriptor(), name, value);
}
enum K_IK : int {
  INOP = 0,
  IBARRIER = 1,
  IASGN_SIMPLE = 2,
  IASGN_BOP = 3,
  IASGN_UOP = 4,
  IASGN_RHS_DEREF = 5,
  IASGN_LHS_DEREF = 6,
  IASGN_RHS_ARRAY = 7,
  IASGN_LHS_ARRAY = 8,
  IASGN_CALL = 9,
  IASGN_PHI = 10,
  ICALL = 11,
  IGOTO = 12,
  ICOND = 13,
  ILABEL = 14,
  IRETURN = 15,
  K_IK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_IK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_IK_IsValid(int value);
constexpr K_IK K_IK_MIN = INOP;
constexpr K_IK K_IK_MAX = IRETURN;
constexpr int K_IK_ARRAYSIZE = K_IK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_IK_descriptor();
template<typename T>
inline const std::string& K_IK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_IK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_IK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_IK_descriptor(), enum_t_value);
}
inline bool K_IK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_IK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_IK>(
    K_IK_descriptor(), name, value);
}
enum K_XK : int {
  NIL = 0,
  VAL = 1,
  ADD = 2,
  SUB = 3,
  MUL = 4,
  DIV = 5,
  MOD = 6,
  AND = 7,
  OR = 8,
  XOR = 9,
  SHL = 10,
  SHR = 11,
  SHRL = 12,
  BIT_NOT = 13,
  NEGATE = 14,
  NOT = 15,
  DEREF = 16,
  ADDROF = 17,
  SIZEOF = 18,
  ALIGNOF = 19,
  ARRAY_SUBSCRIPT = 20,
  MEMBER_ACCESS = 21,
  MEMBER_PTR_ACCESS = 22,
  CALL = 23,
  CALL_0 = 24,
  CAST = 25,
  EQ = 26,
  NE = 27,
  LT = 28,
  LE = 29,
  K_XK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_XK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_XK_IsValid(int value);
constexpr K_XK K_XK_MIN = NIL;
constexpr K_XK K_XK_MAX = LE;
constexpr int K_XK_ARRAYSIZE = K_XK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_XK_descriptor();
template<typename T>
inline const std::string& K_XK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_XK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_XK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_XK_descriptor(), enum_t_value);
}
inline bool K_XK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_XK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_XK>(
    K_XK_descriptor(), name, value);
}
enum K_VK : int {
  VOID = 0,
  CHAR = 1,
  INT8 = 2,
  INT16 = 3,
  INT32 = 4,
  INT64 = 5,
  UINT8 = 6,
  UCHAR = 6,
  UINT16 = 7,
  UINT32 = 8,
  UINT64 = 9,
  N_BITS = 10,
  N_UBITS = 11,
  BOOL = 12,
  FLOAT16 = 13,
  FLOAT32 = 14,
  FLOAT = 14,
  FLOAT64 = 15,
  DOUBLE = 15,
  PTR_TO_VOID = 16,
  PTR_TO_PTR = 17,
  PTR_TO_ARR = 18,
  PTR_TO_CHAR = 19,
  PTR_TO_INT = 20,
  PTR_TO_FLOAT = 21,
  PTR_TO_RECORD = 22,
  PTR_TO_FUNC = 23,
  ARR = 24,
  UNION = 25,
  STRUCT = 26,
  K_VK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_VK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_VK_IsValid(int value);
constexpr K_VK K_VK_MIN = VOID;
constexpr K_VK K_VK_MAX = STRUCT;
constexpr int K_VK_ARRAYSIZE = K_VK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_VK_descriptor();
template<typename T>
inline const std::string& K_VK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_VK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_VK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_VK_descriptor(), enum_t_value);
}
inline bool K_VK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_VK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_VK>(
    K_VK_descriptor(), name, value);
}
enum K_QK : int {
  QNONE = 0,
  QCONST = 1,
  QCONST_DEST = 2,
  QFUNC_STATIC = 4,
  QGLOBAL_STATIC = 8,
  QVOLATILE = 16,
  QWEAK = 32,
  QTHREAD_LOCAL = 64,
  QNO_INIT = 128,
  QEXTERNAL = 256,
  QNO_DEF = 256,
  K_QK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  K_QK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool K_QK_IsValid(int value);
constexpr K_QK K_QK_MIN = QNONE;
constexpr K_QK K_QK_MAX = QEXTERNAL;
constexpr int K_QK_ARRAYSIZE = K_QK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K_QK_descriptor();
template<typename T>
inline const std::string& K_QK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, K_QK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function K_QK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    K_QK_descriptor(), enum_t_value);
}
inline bool K_QK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K_QK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K_QK>(
    K_QK_descriptor(), name, value);
}
// ===================================================================

class BitSrcLoc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitSrcLoc) */ {
 public:
  inline BitSrcLoc() : BitSrcLoc(nullptr) {}
  ~BitSrcLoc() override;
  explicit PROTOBUF_CONSTEXPR BitSrcLoc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitSrcLoc(const BitSrcLoc& from);
  BitSrcLoc(BitSrcLoc&& from) noexcept
    : BitSrcLoc() {
    *this = ::std::move(from);
  }

  inline BitSrcLoc& operator=(const BitSrcLoc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitSrcLoc& operator=(BitSrcLoc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitSrcLoc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitSrcLoc* internal_default_instance() {
    return reinterpret_cast<const BitSrcLoc*>(
               &_BitSrcLoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BitSrcLoc& a, BitSrcLoc& b) {
    a.Swap(&b);
  }
  inline void Swap(BitSrcLoc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitSrcLoc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitSrcLoc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitSrcLoc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitSrcLoc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitSrcLoc& from) {
    BitSrcLoc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitSrcLoc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitSrcLoc";
  }
  protected:
  explicit BitSrcLoc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // uint32 line = 1;
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // uint32 col = 2;
  void clear_col();
  uint32_t col() const;
  void set_col(uint32_t value);
  private:
  uint32_t _internal_col() const;
  void _internal_set_col(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitSrcLoc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t line_;
    uint32_t col_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitTU_EntitiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntitiesEntry_DoNotUse, 
    std::string, ::spir::BitEntity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntitiesEntry_DoNotUse, 
    std::string, ::spir::BitEntity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BitTU_EntitiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BitTU_EntitiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BitTU_EntitiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BitTU_EntitiesEntry_DoNotUse& other);
  static const BitTU_EntitiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BitTU_EntitiesEntry_DoNotUse*>(&_BitTU_EntitiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spir.BitTU.EntitiesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spir_2eproto;
};

// -------------------------------------------------------------------

class BitTU_EntityTypesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntityTypesEntry_DoNotUse, 
    uint64_t, ::spir::BitValueType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BitTU_EntityTypesEntry_DoNotUse, 
    uint64_t, ::spir::BitValueType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BitTU_EntityTypesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BitTU_EntityTypesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BitTU_EntityTypesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BitTU_EntityTypesEntry_DoNotUse& other);
  static const BitTU_EntityTypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BitTU_EntityTypesEntry_DoNotUse*>(&_BitTU_EntityTypesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spir_2eproto;
};

// -------------------------------------------------------------------

class BitTU final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitTU) */ {
 public:
  inline BitTU() : BitTU(nullptr) {}
  ~BitTU() override;
  explicit PROTOBUF_CONSTEXPR BitTU(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitTU(const BitTU& from);
  BitTU(BitTU&& from) noexcept
    : BitTU() {
    *this = ::std::move(from);
  }

  inline BitTU& operator=(const BitTU& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitTU& operator=(BitTU&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitTU& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitTU* internal_default_instance() {
    return reinterpret_cast<const BitTU*>(
               &_BitTU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BitTU& a, BitTU& b) {
    a.Swap(&b);
  }
  inline void Swap(BitTU* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitTU* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitTU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitTU>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitTU& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitTU& from) {
    BitTU::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitTU* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitTU";
  }
  protected:
  explicit BitTU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 2,
    kEntityTypesFieldNumber = 3,
    kFunctionsFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // map<string, .spir.BitEntity> entities = 2;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >&
      _internal_entities() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >*
      _internal_mutable_entities();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >&
      entities() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >*
      mutable_entities();

  // map<uint64, .spir.BitValueType> entityTypes = 3;
  int entitytypes_size() const;
  private:
  int _internal_entitytypes_size() const;
  public:
  void clear_entitytypes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >&
      _internal_entitytypes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >*
      _internal_mutable_entitytypes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >&
      entitytypes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >*
      mutable_entitytypes();

  // repeated .spir.BitFunc functions = 4;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  ::spir::BitFunc* mutable_functions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >*
      mutable_functions();
  private:
  const ::spir::BitFunc& _internal_functions(int index) const;
  ::spir::BitFunc* _internal_add_functions();
  public:
  const ::spir::BitFunc& functions(int index) const;
  ::spir::BitFunc* add_functions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >&
      functions() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:spir.BitTU)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BitTU_EntitiesEntry_DoNotUse,
        std::string, ::spir::BitEntity,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> entities_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BitTU_EntityTypesEntry_DoNotUse,
        uint64_t, ::spir::BitValueType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> entitytypes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc > functions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitFunc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitFunc) */ {
 public:
  inline BitFunc() : BitFunc(nullptr) {}
  ~BitFunc() override;
  explicit PROTOBUF_CONSTEXPR BitFunc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitFunc(const BitFunc& from);
  BitFunc(BitFunc&& from) noexcept
    : BitFunc() {
    *this = ::std::move(from);
  }

  inline BitFunc& operator=(const BitFunc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitFunc& operator=(BitFunc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitFunc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitFunc* internal_default_instance() {
    return reinterpret_cast<const BitFunc*>(
               &_BitFunc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BitFunc& a, BitFunc& b) {
    a.Swap(&b);
  }
  inline void Swap(BitFunc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitFunc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitFunc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitFunc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitFunc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitFunc& from) {
    BitFunc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitFunc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitFunc";
  }
  protected:
  explicit BitFunc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsnsFieldNumber = 3,
    kLocalsFieldNumber = 4,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated .spir.BitInsn insns = 3;
  int insns_size() const;
  private:
  int _internal_insns_size() const;
  public:
  void clear_insns();
  ::spir::BitInsn* mutable_insns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >*
      mutable_insns();
  private:
  const ::spir::BitInsn& _internal_insns(int index) const;
  ::spir::BitInsn* _internal_add_insns();
  public:
  const ::spir::BitInsn& insns(int index) const;
  ::spir::BitInsn* add_insns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >&
      insns() const;

  // repeated uint64 locals = 4;
  int locals_size() const;
  private:
  int _internal_locals_size() const;
  public:
  void clear_locals();
  private:
  uint64_t _internal_locals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_locals() const;
  void _internal_add_locals(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_locals();
  public:
  uint64_t locals(int index) const;
  void set_locals(int index, uint64_t value);
  void add_locals(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      locals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_locals();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitFunc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn > insns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > locals_;
    mutable std::atomic<int> _locals_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitValueType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitValueType) */ {
 public:
  inline BitValueType() : BitValueType(nullptr) {}
  ~BitValueType() override;
  explicit PROTOBUF_CONSTEXPR BitValueType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitValueType(const BitValueType& from);
  BitValueType(BitValueType&& from) noexcept
    : BitValueType() {
    *this = ::std::move(from);
  }

  inline BitValueType& operator=(const BitValueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitValueType& operator=(BitValueType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitValueType& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitValueType* internal_default_instance() {
    return reinterpret_cast<const BitValueType*>(
               &_BitValueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BitValueType& a, BitValueType& b) {
    a.Swap(&b);
  }
  inline void Swap(BitValueType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitValueType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitValueType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitValueType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitValueType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitValueType& from) {
    BitValueType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitValueType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitValueType";
  }
  protected:
  explicit BitValueType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 7,
    kTypesFieldNumber = 8,
    kValTypeNameFieldNumber = 6,
    kSubTypeFieldNumber = 5,
    kKindFieldNumber = 1,
    kQtypeFieldNumber = 2,
    kSizeFieldNumber = 3,
    kAlignFieldNumber = 4,
  };
  // repeated string names = 7;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // repeated .spir.BitValueType types = 8;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::spir::BitValueType* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitValueType >*
      mutable_types();
  private:
  const ::spir::BitValueType& _internal_types(int index) const;
  ::spir::BitValueType* _internal_add_types();
  public:
  const ::spir::BitValueType& types(int index) const;
  ::spir::BitValueType* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitValueType >&
      types() const;

  // optional string valTypeName = 6;
  bool has_valtypename() const;
  private:
  bool _internal_has_valtypename() const;
  public:
  void clear_valtypename();
  const std::string& valtypename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valtypename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valtypename();
  PROTOBUF_NODISCARD std::string* release_valtypename();
  void set_allocated_valtypename(std::string* valtypename);
  private:
  const std::string& _internal_valtypename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valtypename(const std::string& value);
  std::string* _internal_mutable_valtypename();
  public:

  // optional .spir.BitValueType subType = 5;
  bool has_subtype() const;
  private:
  bool _internal_has_subtype() const;
  public:
  void clear_subtype();
  const ::spir::BitValueType& subtype() const;
  PROTOBUF_NODISCARD ::spir::BitValueType* release_subtype();
  ::spir::BitValueType* mutable_subtype();
  void set_allocated_subtype(::spir::BitValueType* subtype);
  private:
  const ::spir::BitValueType& _internal_subtype() const;
  ::spir::BitValueType* _internal_mutable_subtype();
  public:
  void unsafe_arena_set_allocated_subtype(
      ::spir::BitValueType* subtype);
  ::spir::BitValueType* unsafe_arena_release_subtype();

  // .spir.K_VK kind = 1;
  void clear_kind();
  ::spir::K_VK kind() const;
  void set_kind(::spir::K_VK value);
  private:
  ::spir::K_VK _internal_kind() const;
  void _internal_set_kind(::spir::K_VK value);
  public:

  // optional .spir.K_QK qtype = 2;
  bool has_qtype() const;
  private:
  bool _internal_has_qtype() const;
  public:
  void clear_qtype();
  ::spir::K_QK qtype() const;
  void set_qtype(::spir::K_QK value);
  private:
  ::spir::K_QK _internal_qtype() const;
  void _internal_set_qtype(::spir::K_QK value);
  public:

  // optional uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional uint32 align = 4;
  bool has_align() const;
  private:
  bool _internal_has_align() const;
  public:
  void clear_align();
  uint32_t align() const;
  void set_align(uint32_t value);
  private:
  uint32_t _internal_align() const;
  void _internal_set_align(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitValueType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitValueType > types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valtypename_;
    ::spir::BitValueType* subtype_;
    int kind_;
    int qtype_;
    uint32_t size_;
    uint32_t align_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitEntity) */ {
 public:
  inline BitEntity() : BitEntity(nullptr) {}
  ~BitEntity() override;
  explicit PROTOBUF_CONSTEXPR BitEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitEntity(const BitEntity& from);
  BitEntity(BitEntity&& from) noexcept
    : BitEntity() {
    *this = ::std::move(from);
  }

  inline BitEntity& operator=(const BitEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitEntity& operator=(BitEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitEntity* internal_default_instance() {
    return reinterpret_cast<const BitEntity*>(
               &_BitEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BitEntity& a, BitEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(BitEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitEntity& from) {
    BitEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitEntity";
  }
  protected:
  explicit BitEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrFieldNumber = 4,
    kLocFieldNumber = 5,
    kIdFieldNumber = 2,
    kNumFieldNumber = 3,
    kKindFieldNumber = 1,
  };
  // optional string str = 4;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // optional .spir.BitSrcLoc loc = 5;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional uint64 num = 3;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  uint64_t num() const;
  void set_num(uint64_t value);
  private:
  uint64_t _internal_num() const;
  void _internal_set_num(uint64_t value);
  public:

  // .spir.K_EK kind = 1;
  void clear_kind();
  ::spir::K_EK kind() const;
  void set_kind(::spir::K_EK value);
  private:
  ::spir::K_EK _internal_kind() const;
  void _internal_set_kind(::spir::K_EK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
    ::spir::BitSrcLoc* loc_;
    uint64_t id_;
    uint64_t num_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitExpr) */ {
 public:
  inline BitExpr() : BitExpr(nullptr) {}
  ~BitExpr() override;
  explicit PROTOBUF_CONSTEXPR BitExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitExpr(const BitExpr& from);
  BitExpr(BitExpr&& from) noexcept
    : BitExpr() {
    *this = ::std::move(from);
  }

  inline BitExpr& operator=(const BitExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitExpr& operator=(BitExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitExpr* internal_default_instance() {
    return reinterpret_cast<const BitExpr*>(
               &_BitExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BitExpr& a, BitExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BitExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitExpr& from) {
    BitExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitExpr";
  }
  protected:
  explicit BitExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExprsFieldNumber = 4,
    kOpr1FieldNumber = 2,
    kOpr2FieldNumber = 3,
    kLocFieldNumber = 5,
    kKindFieldNumber = 1,
  };
  // repeated .spir.BitEntity exprs = 4;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;
  public:
  void clear_exprs();
  ::spir::BitEntity* mutable_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >*
      mutable_exprs();
  private:
  const ::spir::BitEntity& _internal_exprs(int index) const;
  ::spir::BitEntity* _internal_add_exprs();
  public:
  const ::spir::BitEntity& exprs(int index) const;
  ::spir::BitEntity* add_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >&
      exprs() const;

  // optional .spir.BitEntity opr1 = 2;
  bool has_opr1() const;
  private:
  bool _internal_has_opr1() const;
  public:
  void clear_opr1();
  const ::spir::BitEntity& opr1() const;
  PROTOBUF_NODISCARD ::spir::BitEntity* release_opr1();
  ::spir::BitEntity* mutable_opr1();
  void set_allocated_opr1(::spir::BitEntity* opr1);
  private:
  const ::spir::BitEntity& _internal_opr1() const;
  ::spir::BitEntity* _internal_mutable_opr1();
  public:
  void unsafe_arena_set_allocated_opr1(
      ::spir::BitEntity* opr1);
  ::spir::BitEntity* unsafe_arena_release_opr1();

  // optional .spir.BitEntity opr2 = 3;
  bool has_opr2() const;
  private:
  bool _internal_has_opr2() const;
  public:
  void clear_opr2();
  const ::spir::BitEntity& opr2() const;
  PROTOBUF_NODISCARD ::spir::BitEntity* release_opr2();
  ::spir::BitEntity* mutable_opr2();
  void set_allocated_opr2(::spir::BitEntity* opr2);
  private:
  const ::spir::BitEntity& _internal_opr2() const;
  ::spir::BitEntity* _internal_mutable_opr2();
  public:
  void unsafe_arena_set_allocated_opr2(
      ::spir::BitEntity* opr2);
  ::spir::BitEntity* unsafe_arena_release_opr2();

  // optional .spir.BitSrcLoc loc = 5;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::spir::BitSrcLoc& loc() const;
  PROTOBUF_NODISCARD ::spir::BitSrcLoc* release_loc();
  ::spir::BitSrcLoc* mutable_loc();
  void set_allocated_loc(::spir::BitSrcLoc* loc);
  private:
  const ::spir::BitSrcLoc& _internal_loc() const;
  ::spir::BitSrcLoc* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::spir::BitSrcLoc* loc);
  ::spir::BitSrcLoc* unsafe_arena_release_loc();

  // .spir.K_XK kind = 1;
  void clear_kind();
  ::spir::K_XK kind() const;
  void set_kind(::spir::K_XK value);
  private:
  ::spir::K_XK _internal_kind() const;
  void _internal_set_kind(::spir::K_XK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity > exprs_;
    ::spir::BitEntity* opr1_;
    ::spir::BitEntity* opr2_;
    ::spir::BitSrcLoc* loc_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// -------------------------------------------------------------------

class BitInsn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spir.BitInsn) */ {
 public:
  inline BitInsn() : BitInsn(nullptr) {}
  ~BitInsn() override;
  explicit PROTOBUF_CONSTEXPR BitInsn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitInsn(const BitInsn& from);
  BitInsn(BitInsn&& from) noexcept
    : BitInsn() {
    *this = ::std::move(from);
  }

  inline BitInsn& operator=(const BitInsn& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitInsn& operator=(BitInsn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitInsn& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitInsn* internal_default_instance() {
    return reinterpret_cast<const BitInsn*>(
               &_BitInsn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BitInsn& a, BitInsn& b) {
    a.Swap(&b);
  }
  inline void Swap(BitInsn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitInsn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitInsn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitInsn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitInsn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitInsn& from) {
    BitInsn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitInsn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spir.BitInsn";
  }
  protected:
  explicit BitInsn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRhsFieldNumber = 2,
    kLhsFieldNumber = 3,
    kKindFieldNumber = 1,
  };
  // optional .spir.BitExpr rhs = 2;
  bool has_rhs() const;
  private:
  bool _internal_has_rhs() const;
  public:
  void clear_rhs();
  const ::spir::BitExpr& rhs() const;
  PROTOBUF_NODISCARD ::spir::BitExpr* release_rhs();
  ::spir::BitExpr* mutable_rhs();
  void set_allocated_rhs(::spir::BitExpr* rhs);
  private:
  const ::spir::BitExpr& _internal_rhs() const;
  ::spir::BitExpr* _internal_mutable_rhs();
  public:
  void unsafe_arena_set_allocated_rhs(
      ::spir::BitExpr* rhs);
  ::spir::BitExpr* unsafe_arena_release_rhs();

  // optional .spir.BitExpr lhs = 3;
  bool has_lhs() const;
  private:
  bool _internal_has_lhs() const;
  public:
  void clear_lhs();
  const ::spir::BitExpr& lhs() const;
  PROTOBUF_NODISCARD ::spir::BitExpr* release_lhs();
  ::spir::BitExpr* mutable_lhs();
  void set_allocated_lhs(::spir::BitExpr* lhs);
  private:
  const ::spir::BitExpr& _internal_lhs() const;
  ::spir::BitExpr* _internal_mutable_lhs();
  public:
  void unsafe_arena_set_allocated_lhs(
      ::spir::BitExpr* lhs);
  ::spir::BitExpr* unsafe_arena_release_lhs();

  // .spir.K_IK kind = 1;
  void clear_kind();
  ::spir::K_IK kind() const;
  void set_kind(::spir::K_IK value);
  private:
  ::spir::K_IK _internal_kind() const;
  void _internal_set_kind(::spir::K_IK value);
  public:

  // @@protoc_insertion_point(class_scope:spir.BitInsn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::spir::BitExpr* rhs_;
    ::spir::BitExpr* lhs_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spir_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BitSrcLoc

// uint32 line = 1;
inline void BitSrcLoc::clear_line() {
  _impl_.line_ = 0u;
}
inline uint32_t BitSrcLoc::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t BitSrcLoc::line() const {
  // @@protoc_insertion_point(field_get:spir.BitSrcLoc.line)
  return _internal_line();
}
inline void BitSrcLoc::_internal_set_line(uint32_t value) {
  
  _impl_.line_ = value;
}
inline void BitSrcLoc::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:spir.BitSrcLoc.line)
}

// uint32 col = 2;
inline void BitSrcLoc::clear_col() {
  _impl_.col_ = 0u;
}
inline uint32_t BitSrcLoc::_internal_col() const {
  return _impl_.col_;
}
inline uint32_t BitSrcLoc::col() const {
  // @@protoc_insertion_point(field_get:spir.BitSrcLoc.col)
  return _internal_col();
}
inline void BitSrcLoc::_internal_set_col(uint32_t value) {
  
  _impl_.col_ = value;
}
inline void BitSrcLoc::set_col(uint32_t value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:spir.BitSrcLoc.col)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BitTU

// string name = 1;
inline void BitTU::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BitTU::name() const {
  // @@protoc_insertion_point(field_get:spir.BitTU.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitTU::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitTU.name)
}
inline std::string* BitTU::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spir.BitTU.name)
  return _s;
}
inline const std::string& BitTU::_internal_name() const {
  return _impl_.name_.Get();
}
inline void BitTU::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BitTU::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* BitTU::release_name() {
  // @@protoc_insertion_point(field_release:spir.BitTU.name)
  return _impl_.name_.Release();
}
inline void BitTU::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitTU.name)
}

// map<string, .spir.BitEntity> entities = 2;
inline int BitTU::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int BitTU::entities_size() const {
  return _internal_entities_size();
}
inline void BitTU::clear_entities() {
  _impl_.entities_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >&
BitTU::_internal_entities() const {
  return _impl_.entities_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >&
BitTU::entities() const {
  // @@protoc_insertion_point(field_map:spir.BitTU.entities)
  return _internal_entities();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >*
BitTU::_internal_mutable_entities() {
  return _impl_.entities_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spir::BitEntity >*
BitTU::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_map:spir.BitTU.entities)
  return _internal_mutable_entities();
}

// map<uint64, .spir.BitValueType> entityTypes = 3;
inline int BitTU::_internal_entitytypes_size() const {
  return _impl_.entitytypes_.size();
}
inline int BitTU::entitytypes_size() const {
  return _internal_entitytypes_size();
}
inline void BitTU::clear_entitytypes() {
  _impl_.entitytypes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >&
BitTU::_internal_entitytypes() const {
  return _impl_.entitytypes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >&
BitTU::entitytypes() const {
  // @@protoc_insertion_point(field_map:spir.BitTU.entityTypes)
  return _internal_entitytypes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >*
BitTU::_internal_mutable_entitytypes() {
  return _impl_.entitytypes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::spir::BitValueType >*
BitTU::mutable_entitytypes() {
  // @@protoc_insertion_point(field_mutable_map:spir.BitTU.entityTypes)
  return _internal_mutable_entitytypes();
}

// repeated .spir.BitFunc functions = 4;
inline int BitTU::_internal_functions_size() const {
  return _impl_.functions_.size();
}
inline int BitTU::functions_size() const {
  return _internal_functions_size();
}
inline void BitTU::clear_functions() {
  _impl_.functions_.Clear();
}
inline ::spir::BitFunc* BitTU::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitTU.functions)
  return _impl_.functions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >*
BitTU::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitTU.functions)
  return &_impl_.functions_;
}
inline const ::spir::BitFunc& BitTU::_internal_functions(int index) const {
  return _impl_.functions_.Get(index);
}
inline const ::spir::BitFunc& BitTU::functions(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitTU.functions)
  return _internal_functions(index);
}
inline ::spir::BitFunc* BitTU::_internal_add_functions() {
  return _impl_.functions_.Add();
}
inline ::spir::BitFunc* BitTU::add_functions() {
  ::spir::BitFunc* _add = _internal_add_functions();
  // @@protoc_insertion_point(field_add:spir.BitTU.functions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitFunc >&
BitTU::functions() const {
  // @@protoc_insertion_point(field_list:spir.BitTU.functions)
  return _impl_.functions_;
}

// -------------------------------------------------------------------

// BitFunc

// string name = 1;
inline void BitFunc::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BitFunc::name() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitFunc::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitFunc.name)
}
inline std::string* BitFunc::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spir.BitFunc.name)
  return _s;
}
inline const std::string& BitFunc::_internal_name() const {
  return _impl_.name_.Get();
}
inline void BitFunc::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BitFunc::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* BitFunc::release_name() {
  // @@protoc_insertion_point(field_release:spir.BitFunc.name)
  return _impl_.name_.Release();
}
inline void BitFunc::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitFunc.name)
}

// uint64 id = 2;
inline void BitFunc::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t BitFunc::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t BitFunc::id() const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.id)
  return _internal_id();
}
inline void BitFunc::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void BitFunc::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:spir.BitFunc.id)
}

// repeated .spir.BitInsn insns = 3;
inline int BitFunc::_internal_insns_size() const {
  return _impl_.insns_.size();
}
inline int BitFunc::insns_size() const {
  return _internal_insns_size();
}
inline void BitFunc::clear_insns() {
  _impl_.insns_.Clear();
}
inline ::spir::BitInsn* BitFunc::mutable_insns(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitFunc.insns)
  return _impl_.insns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >*
BitFunc::mutable_insns() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitFunc.insns)
  return &_impl_.insns_;
}
inline const ::spir::BitInsn& BitFunc::_internal_insns(int index) const {
  return _impl_.insns_.Get(index);
}
inline const ::spir::BitInsn& BitFunc::insns(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.insns)
  return _internal_insns(index);
}
inline ::spir::BitInsn* BitFunc::_internal_add_insns() {
  return _impl_.insns_.Add();
}
inline ::spir::BitInsn* BitFunc::add_insns() {
  ::spir::BitInsn* _add = _internal_add_insns();
  // @@protoc_insertion_point(field_add:spir.BitFunc.insns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitInsn >&
BitFunc::insns() const {
  // @@protoc_insertion_point(field_list:spir.BitFunc.insns)
  return _impl_.insns_;
}

// repeated uint64 locals = 4;
inline int BitFunc::_internal_locals_size() const {
  return _impl_.locals_.size();
}
inline int BitFunc::locals_size() const {
  return _internal_locals_size();
}
inline void BitFunc::clear_locals() {
  _impl_.locals_.Clear();
}
inline uint64_t BitFunc::_internal_locals(int index) const {
  return _impl_.locals_.Get(index);
}
inline uint64_t BitFunc::locals(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitFunc.locals)
  return _internal_locals(index);
}
inline void BitFunc::set_locals(int index, uint64_t value) {
  _impl_.locals_.Set(index, value);
  // @@protoc_insertion_point(field_set:spir.BitFunc.locals)
}
inline void BitFunc::_internal_add_locals(uint64_t value) {
  _impl_.locals_.Add(value);
}
inline void BitFunc::add_locals(uint64_t value) {
  _internal_add_locals(value);
  // @@protoc_insertion_point(field_add:spir.BitFunc.locals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitFunc::_internal_locals() const {
  return _impl_.locals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BitFunc::locals() const {
  // @@protoc_insertion_point(field_list:spir.BitFunc.locals)
  return _internal_locals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitFunc::_internal_mutable_locals() {
  return &_impl_.locals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BitFunc::mutable_locals() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitFunc.locals)
  return _internal_mutable_locals();
}

// -------------------------------------------------------------------

// BitValueType

// .spir.K_VK kind = 1;
inline void BitValueType::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_VK BitValueType::_internal_kind() const {
  return static_cast< ::spir::K_VK >(_impl_.kind_);
}
inline ::spir::K_VK BitValueType::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.kind)
  return _internal_kind();
}
inline void BitValueType::_internal_set_kind(::spir::K_VK value) {
  
  _impl_.kind_ = value;
}
inline void BitValueType::set_kind(::spir::K_VK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitValueType.kind)
}

// optional .spir.K_QK qtype = 2;
inline bool BitValueType::_internal_has_qtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BitValueType::has_qtype() const {
  return _internal_has_qtype();
}
inline void BitValueType::clear_qtype() {
  _impl_.qtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::spir::K_QK BitValueType::_internal_qtype() const {
  return static_cast< ::spir::K_QK >(_impl_.qtype_);
}
inline ::spir::K_QK BitValueType::qtype() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.qtype)
  return _internal_qtype();
}
inline void BitValueType::_internal_set_qtype(::spir::K_QK value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.qtype_ = value;
}
inline void BitValueType::set_qtype(::spir::K_QK value) {
  _internal_set_qtype(value);
  // @@protoc_insertion_point(field_set:spir.BitValueType.qtype)
}

// optional uint32 size = 3;
inline bool BitValueType::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BitValueType::has_size() const {
  return _internal_has_size();
}
inline void BitValueType::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t BitValueType::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t BitValueType::size() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.size)
  return _internal_size();
}
inline void BitValueType::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void BitValueType::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:spir.BitValueType.size)
}

// optional uint32 align = 4;
inline bool BitValueType::_internal_has_align() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BitValueType::has_align() const {
  return _internal_has_align();
}
inline void BitValueType::clear_align() {
  _impl_.align_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t BitValueType::_internal_align() const {
  return _impl_.align_;
}
inline uint32_t BitValueType::align() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.align)
  return _internal_align();
}
inline void BitValueType::_internal_set_align(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.align_ = value;
}
inline void BitValueType::set_align(uint32_t value) {
  _internal_set_align(value);
  // @@protoc_insertion_point(field_set:spir.BitValueType.align)
}

// optional .spir.BitValueType subType = 5;
inline bool BitValueType::_internal_has_subtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subtype_ != nullptr);
  return value;
}
inline bool BitValueType::has_subtype() const {
  return _internal_has_subtype();
}
inline void BitValueType::clear_subtype() {
  if (_impl_.subtype_ != nullptr) _impl_.subtype_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitValueType& BitValueType::_internal_subtype() const {
  const ::spir::BitValueType* p = _impl_.subtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitValueType&>(
      ::spir::_BitValueType_default_instance_);
}
inline const ::spir::BitValueType& BitValueType::subtype() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.subType)
  return _internal_subtype();
}
inline void BitValueType::unsafe_arena_set_allocated_subtype(
    ::spir::BitValueType* subtype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtype_);
  }
  _impl_.subtype_ = subtype;
  if (subtype) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitValueType.subType)
}
inline ::spir::BitValueType* BitValueType::release_subtype() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitValueType* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitValueType* BitValueType::unsafe_arena_release_subtype() {
  // @@protoc_insertion_point(field_release:spir.BitValueType.subType)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitValueType* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
  return temp;
}
inline ::spir::BitValueType* BitValueType::_internal_mutable_subtype() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.subtype_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitValueType>(GetArenaForAllocation());
    _impl_.subtype_ = p;
  }
  return _impl_.subtype_;
}
inline ::spir::BitValueType* BitValueType::mutable_subtype() {
  ::spir::BitValueType* _msg = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:spir.BitValueType.subType)
  return _msg;
}
inline void BitValueType::set_allocated_subtype(::spir::BitValueType* subtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subtype_;
  }
  if (subtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtype);
    if (message_arena != submessage_arena) {
      subtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtype, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subtype_ = subtype;
  // @@protoc_insertion_point(field_set_allocated:spir.BitValueType.subType)
}

// optional string valTypeName = 6;
inline bool BitValueType::_internal_has_valtypename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitValueType::has_valtypename() const {
  return _internal_has_valtypename();
}
inline void BitValueType::clear_valtypename() {
  _impl_.valtypename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitValueType::valtypename() const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.valTypeName)
  return _internal_valtypename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitValueType::set_valtypename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.valtypename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitValueType.valTypeName)
}
inline std::string* BitValueType::mutable_valtypename() {
  std::string* _s = _internal_mutable_valtypename();
  // @@protoc_insertion_point(field_mutable:spir.BitValueType.valTypeName)
  return _s;
}
inline const std::string& BitValueType::_internal_valtypename() const {
  return _impl_.valtypename_.Get();
}
inline void BitValueType::_internal_set_valtypename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valtypename_.Set(value, GetArenaForAllocation());
}
inline std::string* BitValueType::_internal_mutable_valtypename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.valtypename_.Mutable(GetArenaForAllocation());
}
inline std::string* BitValueType::release_valtypename() {
  // @@protoc_insertion_point(field_release:spir.BitValueType.valTypeName)
  if (!_internal_has_valtypename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.valtypename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valtypename_.IsDefault()) {
    _impl_.valtypename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitValueType::set_allocated_valtypename(std::string* valtypename) {
  if (valtypename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.valtypename_.SetAllocated(valtypename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valtypename_.IsDefault()) {
    _impl_.valtypename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitValueType.valTypeName)
}

// repeated string names = 7;
inline int BitValueType::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int BitValueType::names_size() const {
  return _internal_names_size();
}
inline void BitValueType::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* BitValueType::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:spir.BitValueType.names)
  return _s;
}
inline const std::string& BitValueType::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& BitValueType::names(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.names)
  return _internal_names(index);
}
inline std::string* BitValueType::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitValueType.names)
  return _impl_.names_.Mutable(index);
}
inline void BitValueType::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spir.BitValueType.names)
}
inline void BitValueType::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spir.BitValueType.names)
}
inline void BitValueType::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spir.BitValueType.names)
}
inline void BitValueType::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spir.BitValueType.names)
}
inline std::string* BitValueType::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void BitValueType::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spir.BitValueType.names)
}
inline void BitValueType::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spir.BitValueType.names)
}
inline void BitValueType::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spir.BitValueType.names)
}
inline void BitValueType::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spir.BitValueType.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BitValueType::names() const {
  // @@protoc_insertion_point(field_list:spir.BitValueType.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BitValueType::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitValueType.names)
  return &_impl_.names_;
}

// repeated .spir.BitValueType types = 8;
inline int BitValueType::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int BitValueType::types_size() const {
  return _internal_types_size();
}
inline void BitValueType::clear_types() {
  _impl_.types_.Clear();
}
inline ::spir::BitValueType* BitValueType::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitValueType.types)
  return _impl_.types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitValueType >*
BitValueType::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitValueType.types)
  return &_impl_.types_;
}
inline const ::spir::BitValueType& BitValueType::_internal_types(int index) const {
  return _impl_.types_.Get(index);
}
inline const ::spir::BitValueType& BitValueType::types(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitValueType.types)
  return _internal_types(index);
}
inline ::spir::BitValueType* BitValueType::_internal_add_types() {
  return _impl_.types_.Add();
}
inline ::spir::BitValueType* BitValueType::add_types() {
  ::spir::BitValueType* _add = _internal_add_types();
  // @@protoc_insertion_point(field_add:spir.BitValueType.types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitValueType >&
BitValueType::types() const {
  // @@protoc_insertion_point(field_list:spir.BitValueType.types)
  return _impl_.types_;
}

// -------------------------------------------------------------------

// BitEntity

// .spir.K_EK kind = 1;
inline void BitEntity::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_EK BitEntity::_internal_kind() const {
  return static_cast< ::spir::K_EK >(_impl_.kind_);
}
inline ::spir::K_EK BitEntity::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.kind)
  return _internal_kind();
}
inline void BitEntity::_internal_set_kind(::spir::K_EK value) {
  
  _impl_.kind_ = value;
}
inline void BitEntity::set_kind(::spir::K_EK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitEntity.kind)
}

// uint64 id = 2;
inline void BitEntity::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t BitEntity::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t BitEntity::id() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.id)
  return _internal_id();
}
inline void BitEntity::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void BitEntity::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:spir.BitEntity.id)
}

// optional uint64 num = 3;
inline bool BitEntity::_internal_has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BitEntity::has_num() const {
  return _internal_has_num();
}
inline void BitEntity::clear_num() {
  _impl_.num_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t BitEntity::_internal_num() const {
  return _impl_.num_;
}
inline uint64_t BitEntity::num() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.num)
  return _internal_num();
}
inline void BitEntity::_internal_set_num(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_ = value;
}
inline void BitEntity::set_num(uint64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:spir.BitEntity.num)
}

// optional string str = 4;
inline bool BitEntity::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BitEntity::has_str() const {
  return _internal_has_str();
}
inline void BitEntity::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitEntity::str() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitEntity::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spir.BitEntity.str)
}
inline std::string* BitEntity::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:spir.BitEntity.str)
  return _s;
}
inline const std::string& BitEntity::_internal_str() const {
  return _impl_.str_.Get();
}
inline void BitEntity::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* BitEntity::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* BitEntity::release_str() {
  // @@protoc_insertion_point(field_release:spir.BitEntity.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BitEntity::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntity.str)
}

// optional .spir.BitSrcLoc loc = 5;
inline bool BitEntity::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitEntity::has_loc() const {
  return _internal_has_loc();
}
inline void BitEntity::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitSrcLoc& BitEntity::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitEntity::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitEntity.loc)
  return _internal_loc();
}
inline void BitEntity::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitEntity.loc)
}
inline ::spir::BitSrcLoc* BitEntity::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitEntity::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitEntity.loc)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitEntity::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitEntity::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitEntity.loc)
  return _msg;
}
inline void BitEntity::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitEntity.loc)
}

// -------------------------------------------------------------------

// BitExpr

// .spir.K_XK kind = 1;
inline void BitExpr::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_XK BitExpr::_internal_kind() const {
  return static_cast< ::spir::K_XK >(_impl_.kind_);
}
inline ::spir::K_XK BitExpr::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.kind)
  return _internal_kind();
}
inline void BitExpr::_internal_set_kind(::spir::K_XK value) {
  
  _impl_.kind_ = value;
}
inline void BitExpr::set_kind(::spir::K_XK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitExpr.kind)
}

// optional .spir.BitEntity opr1 = 2;
inline bool BitExpr::_internal_has_opr1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opr1_ != nullptr);
  return value;
}
inline bool BitExpr::has_opr1() const {
  return _internal_has_opr1();
}
inline void BitExpr::clear_opr1() {
  if (_impl_.opr1_ != nullptr) _impl_.opr1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spir::BitEntity& BitExpr::_internal_opr1() const {
  const ::spir::BitEntity* p = _impl_.opr1_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitEntity&>(
      ::spir::_BitEntity_default_instance_);
}
inline const ::spir::BitEntity& BitExpr::opr1() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.opr1)
  return _internal_opr1();
}
inline void BitExpr::unsafe_arena_set_allocated_opr1(
    ::spir::BitEntity* opr1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opr1_);
  }
  _impl_.opr1_ = opr1;
  if (opr1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.opr1)
}
inline ::spir::BitEntity* BitExpr::release_opr1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitEntity* temp = _impl_.opr1_;
  _impl_.opr1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitEntity* BitExpr::unsafe_arena_release_opr1() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.opr1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitEntity* temp = _impl_.opr1_;
  _impl_.opr1_ = nullptr;
  return temp;
}
inline ::spir::BitEntity* BitExpr::_internal_mutable_opr1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.opr1_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitEntity>(GetArenaForAllocation());
    _impl_.opr1_ = p;
  }
  return _impl_.opr1_;
}
inline ::spir::BitEntity* BitExpr::mutable_opr1() {
  ::spir::BitEntity* _msg = _internal_mutable_opr1();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.opr1)
  return _msg;
}
inline void BitExpr::set_allocated_opr1(::spir::BitEntity* opr1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opr1_;
  }
  if (opr1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opr1);
    if (message_arena != submessage_arena) {
      opr1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opr1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.opr1_ = opr1;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.opr1)
}

// optional .spir.BitEntity opr2 = 3;
inline bool BitExpr::_internal_has_opr2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opr2_ != nullptr);
  return value;
}
inline bool BitExpr::has_opr2() const {
  return _internal_has_opr2();
}
inline void BitExpr::clear_opr2() {
  if (_impl_.opr2_ != nullptr) _impl_.opr2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitEntity& BitExpr::_internal_opr2() const {
  const ::spir::BitEntity* p = _impl_.opr2_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitEntity&>(
      ::spir::_BitEntity_default_instance_);
}
inline const ::spir::BitEntity& BitExpr::opr2() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.opr2)
  return _internal_opr2();
}
inline void BitExpr::unsafe_arena_set_allocated_opr2(
    ::spir::BitEntity* opr2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opr2_);
  }
  _impl_.opr2_ = opr2;
  if (opr2) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.opr2)
}
inline ::spir::BitEntity* BitExpr::release_opr2() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitEntity* temp = _impl_.opr2_;
  _impl_.opr2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitEntity* BitExpr::unsafe_arena_release_opr2() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.opr2)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitEntity* temp = _impl_.opr2_;
  _impl_.opr2_ = nullptr;
  return temp;
}
inline ::spir::BitEntity* BitExpr::_internal_mutable_opr2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.opr2_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitEntity>(GetArenaForAllocation());
    _impl_.opr2_ = p;
  }
  return _impl_.opr2_;
}
inline ::spir::BitEntity* BitExpr::mutable_opr2() {
  ::spir::BitEntity* _msg = _internal_mutable_opr2();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.opr2)
  return _msg;
}
inline void BitExpr::set_allocated_opr2(::spir::BitEntity* opr2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opr2_;
  }
  if (opr2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opr2);
    if (message_arena != submessage_arena) {
      opr2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opr2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.opr2_ = opr2;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.opr2)
}

// repeated .spir.BitEntity exprs = 4;
inline int BitExpr::_internal_exprs_size() const {
  return _impl_.exprs_.size();
}
inline int BitExpr::exprs_size() const {
  return _internal_exprs_size();
}
inline void BitExpr::clear_exprs() {
  _impl_.exprs_.Clear();
}
inline ::spir::BitEntity* BitExpr::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.exprs)
  return _impl_.exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >*
BitExpr::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:spir.BitExpr.exprs)
  return &_impl_.exprs_;
}
inline const ::spir::BitEntity& BitExpr::_internal_exprs(int index) const {
  return _impl_.exprs_.Get(index);
}
inline const ::spir::BitEntity& BitExpr::exprs(int index) const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.exprs)
  return _internal_exprs(index);
}
inline ::spir::BitEntity* BitExpr::_internal_add_exprs() {
  return _impl_.exprs_.Add();
}
inline ::spir::BitEntity* BitExpr::add_exprs() {
  ::spir::BitEntity* _add = _internal_add_exprs();
  // @@protoc_insertion_point(field_add:spir.BitExpr.exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spir::BitEntity >&
BitExpr::exprs() const {
  // @@protoc_insertion_point(field_list:spir.BitExpr.exprs)
  return _impl_.exprs_;
}

// optional .spir.BitSrcLoc loc = 5;
inline bool BitExpr::_internal_has_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.loc_ != nullptr);
  return value;
}
inline bool BitExpr::has_loc() const {
  return _internal_has_loc();
}
inline void BitExpr::clear_loc() {
  if (_impl_.loc_ != nullptr) _impl_.loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::spir::BitSrcLoc& BitExpr::_internal_loc() const {
  const ::spir::BitSrcLoc* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitSrcLoc&>(
      ::spir::_BitSrcLoc_default_instance_);
}
inline const ::spir::BitSrcLoc& BitExpr::loc() const {
  // @@protoc_insertion_point(field_get:spir.BitExpr.loc)
  return _internal_loc();
}
inline void BitExpr::unsafe_arena_set_allocated_loc(
    ::spir::BitSrcLoc* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitExpr.loc)
}
inline ::spir::BitSrcLoc* BitExpr::release_loc() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitSrcLoc* BitExpr::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:spir.BitExpr.loc)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::spir::BitSrcLoc* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::spir::BitSrcLoc* BitExpr::_internal_mutable_loc() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitSrcLoc>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::spir::BitSrcLoc* BitExpr::mutable_loc() {
  ::spir::BitSrcLoc* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:spir.BitExpr.loc)
  return _msg;
}
inline void BitExpr::set_allocated_loc(::spir::BitSrcLoc* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:spir.BitExpr.loc)
}

// -------------------------------------------------------------------

// BitInsn

// .spir.K_IK kind = 1;
inline void BitInsn::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::spir::K_IK BitInsn::_internal_kind() const {
  return static_cast< ::spir::K_IK >(_impl_.kind_);
}
inline ::spir::K_IK BitInsn::kind() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.kind)
  return _internal_kind();
}
inline void BitInsn::_internal_set_kind(::spir::K_IK value) {
  
  _impl_.kind_ = value;
}
inline void BitInsn::set_kind(::spir::K_IK value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:spir.BitInsn.kind)
}

// optional .spir.BitExpr rhs = 2;
inline bool BitInsn::_internal_has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline bool BitInsn::has_rhs() const {
  return _internal_has_rhs();
}
inline void BitInsn::clear_rhs() {
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::spir::BitExpr& BitInsn::_internal_rhs() const {
  const ::spir::BitExpr* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitExpr&>(
      ::spir::_BitExpr_default_instance_);
}
inline const ::spir::BitExpr& BitInsn::rhs() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.rhs)
  return _internal_rhs();
}
inline void BitInsn::unsafe_arena_set_allocated_rhs(
    ::spir::BitExpr* rhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = rhs;
  if (rhs) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitInsn.rhs)
}
inline ::spir::BitExpr* BitInsn::release_rhs() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitExpr* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitExpr* BitInsn::unsafe_arena_release_rhs() {
  // @@protoc_insertion_point(field_release:spir.BitInsn.rhs)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::spir::BitExpr* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::spir::BitExpr* BitInsn::_internal_mutable_rhs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitExpr>(GetArenaForAllocation());
    _impl_.rhs_ = p;
  }
  return _impl_.rhs_;
}
inline ::spir::BitExpr* BitInsn::mutable_rhs() {
  ::spir::BitExpr* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:spir.BitInsn.rhs)
  return _msg;
}
inline void BitInsn::set_allocated_rhs(::spir::BitExpr* rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rhs_;
  }
  if (rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rhs);
    if (message_arena != submessage_arena) {
      rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rhs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rhs_ = rhs;
  // @@protoc_insertion_point(field_set_allocated:spir.BitInsn.rhs)
}

// optional .spir.BitExpr lhs = 3;
inline bool BitInsn::_internal_has_lhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_ != nullptr);
  return value;
}
inline bool BitInsn::has_lhs() const {
  return _internal_has_lhs();
}
inline void BitInsn::clear_lhs() {
  if (_impl_.lhs_ != nullptr) _impl_.lhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::spir::BitExpr& BitInsn::_internal_lhs() const {
  const ::spir::BitExpr* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::spir::BitExpr&>(
      ::spir::_BitExpr_default_instance_);
}
inline const ::spir::BitExpr& BitInsn::lhs() const {
  // @@protoc_insertion_point(field_get:spir.BitInsn.lhs)
  return _internal_lhs();
}
inline void BitInsn::unsafe_arena_set_allocated_lhs(
    ::spir::BitExpr* lhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = lhs;
  if (lhs) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spir.BitInsn.lhs)
}
inline ::spir::BitExpr* BitInsn::release_lhs() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitExpr* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spir::BitExpr* BitInsn::unsafe_arena_release_lhs() {
  // @@protoc_insertion_point(field_release:spir.BitInsn.lhs)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::spir::BitExpr* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::spir::BitExpr* BitInsn::_internal_mutable_lhs() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::spir::BitExpr>(GetArenaForAllocation());
    _impl_.lhs_ = p;
  }
  return _impl_.lhs_;
}
inline ::spir::BitExpr* BitInsn::mutable_lhs() {
  ::spir::BitExpr* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:spir.BitInsn.lhs)
  return _msg;
}
inline void BitInsn::set_allocated_lhs(::spir::BitExpr* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lhs);
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:spir.BitInsn.lhs)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::spir::K_EK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_EK>() {
  return ::spir::K_EK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_IK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_IK>() {
  return ::spir::K_IK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_XK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_XK>() {
  return ::spir::K_XK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_VK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_VK>() {
  return ::spir::K_VK_descriptor();
}
template <> struct is_proto_enum< ::spir::K_QK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spir::K_QK>() {
  return ::spir::K_QK_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spir_2eproto

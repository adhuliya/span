// Version = 0.0.1
// Note of caution: *The sequence of enum values may be significant.*

// To compile this proto file, run from project root:
// protoc --go_out=. --go_opt=paths=source_relative span/pkg/spir/spir.proto
// protoc --cpp_out=slang/src --proto_path=span/pkg/spir span/pkg/spir/spir.proto
// or run the Makefile target "gen-proto" from project root.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: span/pkg/spir/spir.proto

package spir

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
type K_EK int32

const (
	// Entity kinds which can be in an expression (4 bit values)
	K_EK_ENIL             K_EK = 0  // No entity.
	K_EK_EVAR_GLBL        K_EK = 1  // A global variable.
	K_EK_EVAR_LOCL        K_EK = 2  // Local variables in a function body.
	K_EK_EVAR_LOCL_ARG    K_EK = 3  // A function argument variable.
	K_EK_EVAR_LOCL_STATIC K_EK = 4  // Static local variables in a function body.
	K_EK_EVAR_LOCL_TMP    K_EK = 5  // Temporary varibles created when creating SPAN IR.
	K_EK_EVAR_LOCL_SSA    K_EK = 6  // An SSA variable; assigned only once.
	K_EK_EVAR_LOCL_PSEUDO K_EK = 7  // To give special names to, for e.g., memory allocations.
	K_EK_ELIT_NUM         K_EK = 8  // A numeric literal.
	K_EK_ELIT_NUM_IMM     K_EK = 9  // A numeric literal with immediate value.
	K_EK_ELIT_STR         K_EK = 10 // A string literal.
	K_EK_EDATA_TYPE       K_EK = 11 // A data type, like int, function sig, record, class etc.
	K_EK_EFUNC            K_EK = 12 // A function with/without definition.
	K_EK_EFUNC_VARGS      K_EK = 13 // A function with varargs, e.g. printf().
	K_EK_ELABEL           K_EK = 14 // A label in an if-then-else statement.
	K_EK_EOTHER           K_EK = 15 // Other entity kind - used in case ID space is exhausted.
	// Entity kinds which cannot be in an expression (5 bit values)
	K_EK_ERECORD_FIELD K_EK = 16 // A field in a record
	K_EK_EINSN         K_EK = 17 // An instruction.
	K_EK_EBB           K_EK = 18 // A basic block.
	K_EK_ECFG          K_EK = 19 // A control flow graph.
	K_EK_ESCOPE        K_EK = 20 // A scope, e.g. a block scope.
	K_EK_ETU           K_EK = 21 // A translation unit (TU).
)

// Enum value maps for K_EK.
var (
	K_EK_name = map[int32]string{
		0:  "ENIL",
		1:  "EVAR_GLBL",
		2:  "EVAR_LOCL",
		3:  "EVAR_LOCL_ARG",
		4:  "EVAR_LOCL_STATIC",
		5:  "EVAR_LOCL_TMP",
		6:  "EVAR_LOCL_SSA",
		7:  "EVAR_LOCL_PSEUDO",
		8:  "ELIT_NUM",
		9:  "ELIT_NUM_IMM",
		10: "ELIT_STR",
		11: "EDATA_TYPE",
		12: "EFUNC",
		13: "EFUNC_VARGS",
		14: "ELABEL",
		15: "EOTHER",
		16: "ERECORD_FIELD",
		17: "EINSN",
		18: "EBB",
		19: "ECFG",
		20: "ESCOPE",
		21: "ETU",
	}
	K_EK_value = map[string]int32{
		"ENIL":             0,
		"EVAR_GLBL":        1,
		"EVAR_LOCL":        2,
		"EVAR_LOCL_ARG":    3,
		"EVAR_LOCL_STATIC": 4,
		"EVAR_LOCL_TMP":    5,
		"EVAR_LOCL_SSA":    6,
		"EVAR_LOCL_PSEUDO": 7,
		"ELIT_NUM":         8,
		"ELIT_NUM_IMM":     9,
		"ELIT_STR":         10,
		"EDATA_TYPE":       11,
		"EFUNC":            12,
		"EFUNC_VARGS":      13,
		"ELABEL":           14,
		"EOTHER":           15,
		"ERECORD_FIELD":    16,
		"EINSN":            17,
		"EBB":              18,
		"ECFG":             19,
		"ESCOPE":           20,
		"ETU":              21,
	}
)

func (x K_EK) Enum() *K_EK {
	p := new(K_EK)
	*p = x
	return p
}

func (x K_EK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_EK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[0].Descriptor()
}

func (K_EK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[0]
}

func (x K_EK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_EK.Descriptor instead.
func (K_EK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

// Instruction kinds.
// All values must fit in 5 bits.
type K_IK int32

const (
	K_IK_INIL         K_IK = 0  // No instruction
	K_IK_INOP         K_IK = 1  // No-operation - Connects two program points
	K_IK_IBARRIER     K_IK = 2  // Disconnects two program points (no information flow)
	K_IK_IASGN_SIMPLE K_IK = 3  // Simple assignment (no operator)
	K_IK_IASGN_RHS_OP K_IK = 4  // RHS operator assignment
	K_IK_IASGN_LHS_OP K_IK = 5  // LHS operator assignment
	K_IK_IASGN_CALL   K_IK = 6  // Call assignment
	K_IK_IASGN_PHI    K_IK = 7  // Phi assignment.
	K_IK_ICALL        K_IK = 8  // Call instruction
	K_IK_IGOTO        K_IK = 9  // Goto instruction
	K_IK_ICOND        K_IK = 10 // IF-THEN-ELSE instruction
	K_IK_ILABEL       K_IK = 11 // Label instruction (names a location in the code)
	K_IK_IRETURN      K_IK = 12 // Return instruction
)

// Enum value maps for K_IK.
var (
	K_IK_name = map[int32]string{
		0:  "INIL",
		1:  "INOP",
		2:  "IBARRIER",
		3:  "IASGN_SIMPLE",
		4:  "IASGN_RHS_OP",
		5:  "IASGN_LHS_OP",
		6:  "IASGN_CALL",
		7:  "IASGN_PHI",
		8:  "ICALL",
		9:  "IGOTO",
		10: "ICOND",
		11: "ILABEL",
		12: "IRETURN",
	}
	K_IK_value = map[string]int32{
		"INIL":         0,
		"INOP":         1,
		"IBARRIER":     2,
		"IASGN_SIMPLE": 3,
		"IASGN_RHS_OP": 4,
		"IASGN_LHS_OP": 5,
		"IASGN_CALL":   6,
		"IASGN_PHI":    7,
		"ICALL":        8,
		"IGOTO":        9,
		"ICOND":        10,
		"ILABEL":       11,
		"IRETURN":      12,
	}
)

func (x K_IK) Enum() *K_IK {
	p := new(K_IK)
	*p = x
	return p
}

func (x K_IK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_IK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[1].Descriptor()
}

func (K_IK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[1]
}

func (x K_IK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_IK.Descriptor instead.
func (K_IK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

// Expression kinds.
// All values must fit in 5 bits.
type K_XK int32

const (
	// Expression kinds that can be used in expressions
	K_XK_XNIL               K_XK = 0  // No expression
	K_XK_XVAL               K_XK = 1  // A unit expression, i.e. a constant, variable or function
	K_XK_XADD               K_XK = 2  // A binary addition expression
	K_XK_XSUB               K_XK = 3  // A binary subtraction expression
	K_XK_XMUL               K_XK = 4  // A binary multiplication expression
	K_XK_XDIV               K_XK = 5  // A binary division expression
	K_XK_XMOD               K_XK = 6  // A binary modulo expression
	K_XK_XAND               K_XK = 7  // A binary bit AND expression
	K_XK_XOR                K_XK = 8  // A binary bit OR expression
	K_XK_XXOR               K_XK = 9  // A binary bit XOR expression
	K_XK_XSHL               K_XK = 10 // A binary shift left expression
	K_XK_XSHR               K_XK = 11 // A binary shift right expression (logical)
	K_XK_XSHRA              K_XK = 12 // A binary shift right expression (arithmetic)
	K_XK_XEQ                K_XK = 13 // Equality comparison (binary expr).
	K_XK_XNE                K_XK = 14 // Inequality comparison (binary expr).
	K_XK_XLT                K_XK = 15 // Less than comparison (binary expr).
	K_XK_XGE                K_XK = 16 // Greater than or equal to comparison (binary expr).
	K_XK_XARRAY_INDEX       K_XK = 17 // An array index expression (binary expr)
	K_XK_XMEMBER_ACCESS     K_XK = 18 // A member access expression (binary expr)
	K_XK_XMEMBER_PTR_ACCESS K_XK = 19 // A member pointer access expression (binary expr)
	K_XK_XMEMBER_PTR_ADDROF K_XK = 20 // A member pointer address expression (unary expr)
	K_XK_XCALL              K_XK = 21 // A function call expression (all arguments may be stored separately)
	K_XK_XCALL_0            K_XK = 22 // A call with zero arguments
	K_XK_XCAST              K_XK = 23 // A cast expression
	K_XK_XBIT_NOT           K_XK = 24 // A unary bitwise NOT expression
	K_XK_XNEGATE            K_XK = 25 // A unary minus expression
	K_XK_XNOT               K_XK = 26 // A unary logical NOT expression
	K_XK_XDEREF             K_XK = 27 // A dereference expression (unary expr)
	K_XK_XADDROF            K_XK = 28 // An address expression (unary expr)
	K_XK_XSIZEOF            K_XK = 29 // A sizeof expression
	K_XK_XALIGNOF           K_XK = 30 // An alignof expression
	K_XK_XOTHER             K_XK = 31 // Other expression.
)

// Enum value maps for K_XK.
var (
	K_XK_name = map[int32]string{
		0:  "XNIL",
		1:  "XVAL",
		2:  "XADD",
		3:  "XSUB",
		4:  "XMUL",
		5:  "XDIV",
		6:  "XMOD",
		7:  "XAND",
		8:  "XOR",
		9:  "XXOR",
		10: "XSHL",
		11: "XSHR",
		12: "XSHRA",
		13: "XEQ",
		14: "XNE",
		15: "XLT",
		16: "XGE",
		17: "XARRAY_INDEX",
		18: "XMEMBER_ACCESS",
		19: "XMEMBER_PTR_ACCESS",
		20: "XMEMBER_PTR_ADDROF",
		21: "XCALL",
		22: "XCALL_0",
		23: "XCAST",
		24: "XBIT_NOT",
		25: "XNEGATE",
		26: "XNOT",
		27: "XDEREF",
		28: "XADDROF",
		29: "XSIZEOF",
		30: "XALIGNOF",
		31: "XOTHER",
	}
	K_XK_value = map[string]int32{
		"XNIL":               0,
		"XVAL":               1,
		"XADD":               2,
		"XSUB":               3,
		"XMUL":               4,
		"XDIV":               5,
		"XMOD":               6,
		"XAND":               7,
		"XOR":                8,
		"XXOR":               9,
		"XSHL":               10,
		"XSHR":               11,
		"XSHRA":              12,
		"XEQ":                13,
		"XNE":                14,
		"XLT":                15,
		"XGE":                16,
		"XARRAY_INDEX":       17,
		"XMEMBER_ACCESS":     18,
		"XMEMBER_PTR_ACCESS": 19,
		"XMEMBER_PTR_ADDROF": 20,
		"XCALL":              21,
		"XCALL_0":            22,
		"XCAST":              23,
		"XBIT_NOT":           24,
		"XNEGATE":            25,
		"XNOT":               26,
		"XDEREF":             27,
		"XADDROF":            28,
		"XSIZEOF":            29,
		"XALIGNOF":           30,
		"XOTHER":             31,
	}
)

func (x K_XK) Enum() *K_XK {
	p := new(K_XK)
	*p = x
	return p
}

func (x K_XK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_XK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[2].Descriptor()
}

func (K_XK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[2]
}

func (x K_XK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_XK.Descriptor instead.
func (K_XK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

// Value kinds, i.e. the data types.
// All values must fit in 5 bits.
type K_VK int32

const (
	K_VK_TNIL           K_VK = 0
	K_VK_TVOID          K_VK = 0 // TNIL (no type)
	K_VK_TCHAR          K_VK = 1
	K_VK_TINT8          K_VK = 2
	K_VK_TINT16         K_VK = 3
	K_VK_TINT32         K_VK = 4
	K_VK_TINT64         K_VK = 5
	K_VK_TUINT8         K_VK = 6
	K_VK_TUCHAR         K_VK = 6 // UINT8
	K_VK_TUINT16        K_VK = 7
	K_VK_TUINT32        K_VK = 8
	K_VK_TUINT64        K_VK = 9
	K_VK_TCHAR16        K_VK = 7  // UINT16
	K_VK_TWCHAR         K_VK = 8  // UINT32
	K_VK_TCHAR32        K_VK = 8  // UINT32
	K_VK_TN_BITS        K_VK = 10 // N signed bits
	K_VK_TN_UBITS       K_VK = 11 // N unsigned bits
	K_VK_TBOOL          K_VK = 12
	K_VK_TFLOAT16       K_VK = 13
	K_VK_TFLOAT32       K_VK = 14
	K_VK_TFLOAT         K_VK = 14 // FLOAT32
	K_VK_TFLOAT64       K_VK = 15
	K_VK_TDOUBLE        K_VK = 15 // FLOAT64
	K_VK_TFLOAT80       K_VK = 16 // 80-bit extended precision floating point
	K_VK_TLONG_DOUBLE   K_VK = 16 // FLOAT80
	K_VK_TPTR_TO_VOID   K_VK = 17 // An unclassified pointer
	K_VK_TPTR_TO_PTR    K_VK = 18
	K_VK_TPTR_TO_ARR    K_VK = 19 // A pointer to an array type
	K_VK_TPTR_TO_CHAR   K_VK = 20 // A pointer to char type -- it identifies a C string
	K_VK_TPTR_TO_INT    K_VK = 21 // A pointer to any of the integer types
	K_VK_TPTR_TO_FLOAT  K_VK = 22 // A pointer to a float type
	K_VK_TPTR_TO_RECORD K_VK = 23 // A pointer to a struct or a union
	K_VK_TPTR_TO_FUNC   K_VK = 24 // A pointer to a function type
	K_VK_TARR_FIXED     K_VK = 25 // An array with a fixed size known at compile time (e.g. "int x[10]")
	K_VK_TARR_VARIABLE  K_VK = 26 // An array with a variable size determined at runtime
	K_VK_TARR_PARTIAL   K_VK = 27 // An array with partially known size, e.g. "char[][32] x"
	// Three record types: union, struct, class
	K_VK_TUNION  K_VK = 28 // An unclassified union (a record)
	K_VK_TSTRUCT K_VK = 29 // An unclassified struct (a record)
	K_VK_TCLASS  K_VK = 30 // A C++ class (for future use)
	K_VK_TOTHER  K_VK = 31 // Other value type
)

// Enum value maps for K_VK.
var (
	K_VK_name = map[int32]string{
		0: "TNIL",
		// Duplicate value: 0: "TVOID",
		1: "TCHAR",
		2: "TINT8",
		3: "TINT16",
		4: "TINT32",
		5: "TINT64",
		6: "TUINT8",
		// Duplicate value: 6: "TUCHAR",
		7: "TUINT16",
		8: "TUINT32",
		9: "TUINT64",
		// Duplicate value: 7: "TCHAR16",
		// Duplicate value: 8: "TWCHAR",
		// Duplicate value: 8: "TCHAR32",
		10: "TN_BITS",
		11: "TN_UBITS",
		12: "TBOOL",
		13: "TFLOAT16",
		14: "TFLOAT32",
		// Duplicate value: 14: "TFLOAT",
		15: "TFLOAT64",
		// Duplicate value: 15: "TDOUBLE",
		16: "TFLOAT80",
		// Duplicate value: 16: "TLONG_DOUBLE",
		17: "TPTR_TO_VOID",
		18: "TPTR_TO_PTR",
		19: "TPTR_TO_ARR",
		20: "TPTR_TO_CHAR",
		21: "TPTR_TO_INT",
		22: "TPTR_TO_FLOAT",
		23: "TPTR_TO_RECORD",
		24: "TPTR_TO_FUNC",
		25: "TARR_FIXED",
		26: "TARR_VARIABLE",
		27: "TARR_PARTIAL",
		28: "TUNION",
		29: "TSTRUCT",
		30: "TCLASS",
		31: "TOTHER",
	}
	K_VK_value = map[string]int32{
		"TNIL":           0,
		"TVOID":          0,
		"TCHAR":          1,
		"TINT8":          2,
		"TINT16":         3,
		"TINT32":         4,
		"TINT64":         5,
		"TUINT8":         6,
		"TUCHAR":         6,
		"TUINT16":        7,
		"TUINT32":        8,
		"TUINT64":        9,
		"TCHAR16":        7,
		"TWCHAR":         8,
		"TCHAR32":        8,
		"TN_BITS":        10,
		"TN_UBITS":       11,
		"TBOOL":          12,
		"TFLOAT16":       13,
		"TFLOAT32":       14,
		"TFLOAT":         14,
		"TFLOAT64":       15,
		"TDOUBLE":        15,
		"TFLOAT80":       16,
		"TLONG_DOUBLE":   16,
		"TPTR_TO_VOID":   17,
		"TPTR_TO_PTR":    18,
		"TPTR_TO_ARR":    19,
		"TPTR_TO_CHAR":   20,
		"TPTR_TO_INT":    21,
		"TPTR_TO_FLOAT":  22,
		"TPTR_TO_RECORD": 23,
		"TPTR_TO_FUNC":   24,
		"TARR_FIXED":     25,
		"TARR_VARIABLE":  26,
		"TARR_PARTIAL":   27,
		"TUNION":         28,
		"TSTRUCT":        29,
		"TCLASS":         30,
		"TOTHER":         31,
	}
)

func (x K_VK) Enum() *K_VK {
	p := new(K_VK)
	*p = x
	return p
}

func (x K_VK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_VK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[3].Descriptor()
}

func (K_VK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[3]
}

func (x K_VK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_VK.Descriptor instead.
func (K_VK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

// All values must fit in 16 bits.
type K_QK int32

const (
	K_QK_QNIL           K_QK = 0     // No qualifiers
	K_QK_QCONST         K_QK = 1     // Constant: e.g. "const int x = 10"
	K_QK_QCONST_DEST    K_QK = 2     // Constant pointee: e.g. "const int* x = &y"
	K_QK_QLOCL_STATIC   K_QK = 4     // A static variable in a function body.
	K_QK_QGLBL_STATIC   K_QK = 8     // A static global function, variable or type.
	K_QK_QVOLATILE      K_QK = 16    // A volatile variable
	K_QK_QWEAK          K_QK = 32    // A weak variable
	K_QK_QTHREAD_LOCAL  K_QK = 64    // A thread local variable
	K_QK_QNO_INIT       K_QK = 128   // A variable with no initializer
	K_QK_QEXTERNAL      K_QK = 256   // An external variable
	K_QK_QNO_DEF        K_QK = 512   // An entity with no definition (e.g. a function, class etc.)
	K_QK_QRESTRICT      K_QK = 1024  // Restrict qualifier for pointers (e.g. "restrict int* x")
	K_QK_QINLINE        K_QK = 2048  // Inline function qualifier (e.g. "inline int f()")
	K_QK_QATOMIC        K_QK = 4096  // Atomic type qualifier (C11) (e.g. "atomic<int> x")
	K_QK_QREGISTER      K_QK = 8192  // Register storage class (e.g. "register int x")
	K_QK_QRECORD_MEMBER K_QK = 16384 // A member in a union, struct or a class.
	K_QK_QOTHER         K_QK = 32768 // Other qualifier (e.g. "noalias int* x")
)

// Enum value maps for K_QK.
var (
	K_QK_name = map[int32]string{
		0:     "QNIL",
		1:     "QCONST",
		2:     "QCONST_DEST",
		4:     "QLOCL_STATIC",
		8:     "QGLBL_STATIC",
		16:    "QVOLATILE",
		32:    "QWEAK",
		64:    "QTHREAD_LOCAL",
		128:   "QNO_INIT",
		256:   "QEXTERNAL",
		512:   "QNO_DEF",
		1024:  "QRESTRICT",
		2048:  "QINLINE",
		4096:  "QATOMIC",
		8192:  "QREGISTER",
		16384: "QRECORD_MEMBER",
		32768: "QOTHER",
	}
	K_QK_value = map[string]int32{
		"QNIL":           0,
		"QCONST":         1,
		"QCONST_DEST":    2,
		"QLOCL_STATIC":   4,
		"QGLBL_STATIC":   8,
		"QVOLATILE":      16,
		"QWEAK":          32,
		"QTHREAD_LOCAL":  64,
		"QNO_INIT":       128,
		"QEXTERNAL":      256,
		"QNO_DEF":        512,
		"QRESTRICT":      1024,
		"QINLINE":        2048,
		"QATOMIC":        4096,
		"QREGISTER":      8192,
		"QRECORD_MEMBER": 16384,
		"QOTHER":         32768,
	}
)

func (x K_QK) Enum() *K_QK {
	p := new(K_QK)
	*p = x
	return p
}

func (x K_QK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_QK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[4].Descriptor()
}

func (K_QK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[4]
}

func (x K_QK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_QK.Descriptor instead.
func (K_QK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

// The location of an entity.
type BitSrcLoc struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Line          uint32                 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Col           uint32                 `protobuf:"varint,2,opt,name=col,proto3" json:"col,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitSrcLoc) Reset() {
	*x = BitSrcLoc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitSrcLoc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitSrcLoc) ProtoMessage() {}

func (x *BitSrcLoc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitSrcLoc.ProtoReflect.Descriptor instead.
func (*BitSrcLoc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

func (x *BitSrcLoc) GetLine() uint32 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *BitSrcLoc) GetCol() uint32 {
	if x != nil {
		return x.Col
	}
	return 0
}

// The type of an entity.
// It is a recursive data type, capable of representing all types in C.
type BitDataType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Vkind K_VK                   `protobuf:"varint,1,opt,name=vkind,proto3,enum=spir.K_VK" json:"vkind,omitempty"`
	// The id to the type present in BitTU.entityInfo map.
	TypeId *uint64 `protobuf:"varint,2,opt,name=typeId,proto3,oneof" json:"typeId,omitempty"` // also an entity id
	Qtype  *uint32 `protobuf:"varint,3,opt,name=qtype,proto3,oneof" json:"qtype,omitempty"`   // Bitwise OR of one or more K_QK values
	// Colon separated attributes of the type (e.g. "packed:aligned(8)", etc.)
	// These are extra attributes not present in qtype
	Attributes *string `protobuf:"bytes,4,opt,name=attributes,proto3,oneof" json:"attributes,omitempty"`
	// The logical length of the type (e.g. length of an array)
	// Or number of bits in the type (for bit fields and built-in types)
	Len   *uint32 `protobuf:"varint,5,opt,name=len,proto3,oneof" json:"len,omitempty"`
	Align *uint32 `protobuf:"varint,6,opt,name=align,proto3,oneof" json:"align,omitempty"` // Number of bytes to align to
	// Used for,
	//  1. Pointee of a pointer.
	//  2. Element of an array.
	//  3. Return type of a function.
	SubType *BitDataType `protobuf:"bytes,7,opt,name=subType,proto3,oneof" json:"subType,omitempty"`
	// Used to name the record or other special types
	TypeName  *string `protobuf:"bytes,8,opt,name=typeName,proto3,oneof" json:"typeName,omitempty"`
	Anonymous *bool   `protobuf:"varint,9,opt,name=anonymous,proto3,oneof" json:"anonymous,omitempty"`
	// Used for record fields and function parameters
	// length of fopIds and fopTypes sequences must be the same
	// Use hyphen '-' for anonymous fields and parameters (fop)
	FopIds        []uint64       `protobuf:"varint,10,rep,packed,name=fopIds,proto3" json:"fopIds,omitempty"`
	FopTypes      []*BitDataType `protobuf:"bytes,11,rep,name=fopTypes,proto3" json:"fopTypes,omitempty"`
	Variadic      *bool          `protobuf:"varint,12,opt,name=variadic,proto3,oneof" json:"variadic,omitempty"` // Whether the function is variadic
	Loc           *BitSrcLoc     `protobuf:"bytes,13,opt,name=loc,proto3,oneof" json:"loc,omitempty"`            // location of the type definition
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitDataType) Reset() {
	*x = BitDataType{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitDataType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitDataType) ProtoMessage() {}

func (x *BitDataType) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitDataType.ProtoReflect.Descriptor instead.
func (*BitDataType) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

func (x *BitDataType) GetVkind() K_VK {
	if x != nil {
		return x.Vkind
	}
	return K_VK_TNIL
}

func (x *BitDataType) GetTypeId() uint64 {
	if x != nil && x.TypeId != nil {
		return *x.TypeId
	}
	return 0
}

func (x *BitDataType) GetQtype() uint32 {
	if x != nil && x.Qtype != nil {
		return *x.Qtype
	}
	return 0
}

func (x *BitDataType) GetAttributes() string {
	if x != nil && x.Attributes != nil {
		return *x.Attributes
	}
	return ""
}

func (x *BitDataType) GetLen() uint32 {
	if x != nil && x.Len != nil {
		return *x.Len
	}
	return 0
}

func (x *BitDataType) GetAlign() uint32 {
	if x != nil && x.Align != nil {
		return *x.Align
	}
	return 0
}

func (x *BitDataType) GetSubType() *BitDataType {
	if x != nil {
		return x.SubType
	}
	return nil
}

func (x *BitDataType) GetTypeName() string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	return ""
}

func (x *BitDataType) GetAnonymous() bool {
	if x != nil && x.Anonymous != nil {
		return *x.Anonymous
	}
	return false
}

func (x *BitDataType) GetFopIds() []uint64 {
	if x != nil {
		return x.FopIds
	}
	return nil
}

func (x *BitDataType) GetFopTypes() []*BitDataType {
	if x != nil {
		return x.FopTypes
	}
	return nil
}

func (x *BitDataType) GetVariadic() bool {
	if x != nil && x.Variadic != nil {
		return *x.Variadic
	}
	return false
}

func (x *BitDataType) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

type BitEntityInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Eid   uint64                 `protobuf:"varint,1,opt,name=eid,proto3" json:"eid,omitempty"` // Entity id
	Ekind K_EK                   `protobuf:"varint,2,opt,name=ekind,proto3,enum=spir.K_EK" json:"ekind,omitempty"`
	// Id of the parent if this entity is a record field or a function parameter
	ParentId *uint64      `protobuf:"varint,3,opt,name=parentId,proto3,oneof" json:"parentId,omitempty"`
	Dt       *BitDataType `protobuf:"bytes,4,opt,name=dt,proto3,oneof" json:"dt,omitempty"`
	// Store value if entity is a constant value.
	LowVal        *uint64    `protobuf:"varint,5,opt,name=lowVal,proto3,oneof" json:"lowVal,omitempty"`   // for a numeric literal (int, float, etc.)
	HighVal       *uint64    `protobuf:"varint,6,opt,name=highVal,proto3,oneof" json:"highVal,omitempty"` // Used for more than 64 bit numeric literal
	StrVal        *string    `protobuf:"bytes,7,opt,name=strVal,proto3,oneof" json:"strVal,omitempty"`    // for a string literal or entity name
	Loc           *BitSrcLoc `protobuf:"bytes,8,opt,name=loc,proto3,oneof" json:"loc,omitempty"`          // location of the entity in the source file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitEntityInfo) Reset() {
	*x = BitEntityInfo{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitEntityInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitEntityInfo) ProtoMessage() {}

func (x *BitEntityInfo) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitEntityInfo.ProtoReflect.Descriptor instead.
func (*BitEntityInfo) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

func (x *BitEntityInfo) GetEid() uint64 {
	if x != nil {
		return x.Eid
	}
	return 0
}

func (x *BitEntityInfo) GetEkind() K_EK {
	if x != nil {
		return x.Ekind
	}
	return K_EK_ENIL
}

func (x *BitEntityInfo) GetParentId() uint64 {
	if x != nil && x.ParentId != nil {
		return *x.ParentId
	}
	return 0
}

func (x *BitEntityInfo) GetDt() *BitDataType {
	if x != nil {
		return x.Dt
	}
	return nil
}

func (x *BitEntityInfo) GetLowVal() uint64 {
	if x != nil && x.LowVal != nil {
		return *x.LowVal
	}
	return 0
}

func (x *BitEntityInfo) GetHighVal() uint64 {
	if x != nil && x.HighVal != nil {
		return *x.HighVal
	}
	return 0
}

func (x *BitEntityInfo) GetStrVal() string {
	if x != nil && x.StrVal != nil {
		return *x.StrVal
	}
	return ""
}

func (x *BitEntityInfo) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// A single entity like a variable, constant etc.
type BitEntity struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Eid           uint64                 `protobuf:"varint,1,opt,name=eid,proto3" json:"eid,omitempty"`      // Entity id
	Loc           *BitSrcLoc             `protobuf:"bytes,2,opt,name=loc,proto3,oneof" json:"loc,omitempty"` // location of the entity's use in the source file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitEntity) Reset() {
	*x = BitEntity{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitEntity) ProtoMessage() {}

func (x *BitEntity) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitEntity.ProtoReflect.Descriptor instead.
func (*BitEntity) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

func (x *BitEntity) GetEid() uint64 {
	if x != nil {
		return x.Eid
	}
	return 0
}

func (x *BitEntity) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// A unary, binary, and call expressions.
type BitExpr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_XK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_XK" json:"kind,omitempty"`
	Opr1  *BitEntity             `protobuf:"bytes,2,opt,name=opr1,proto3,oneof" json:"opr1,omitempty"`
	Opr2  *BitEntity             `protobuf:"bytes,3,opt,name=opr2,proto3,oneof" json:"opr2,omitempty"`
	// More expressions, e.g. call arguments, array subscript, etc.
	Oprs          []*BitEntity `protobuf:"bytes,4,rep,name=oprs,proto3" json:"oprs,omitempty"`
	Loc           *BitSrcLoc   `protobuf:"bytes,5,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitExpr) Reset() {
	*x = BitExpr{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitExpr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitExpr) ProtoMessage() {}

func (x *BitExpr) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitExpr.ProtoReflect.Descriptor instead.
func (*BitExpr) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

func (x *BitExpr) GetKind() K_XK {
	if x != nil {
		return x.Kind
	}
	return K_XK_XNIL
}

func (x *BitExpr) GetOpr1() *BitEntity {
	if x != nil {
		return x.Opr1
	}
	return nil
}

func (x *BitExpr) GetOpr2() *BitEntity {
	if x != nil {
		return x.Opr2
	}
	return nil
}

func (x *BitExpr) GetOprs() []*BitEntity {
	if x != nil {
		return x.Oprs
	}
	return nil
}

func (x *BitExpr) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// All kinds of instructions.
// Either expr1 or expr2 or both may be missing depending on the instruction type.
type BitInsn struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kind          K_IK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_IK" json:"kind,omitempty"`
	Expr1         *BitExpr               `protobuf:"bytes,2,opt,name=expr1,proto3,oneof" json:"expr1,omitempty"`
	Expr2         *BitExpr               `protobuf:"bytes,3,opt,name=expr2,proto3,oneof" json:"expr2,omitempty"`
	Loc           *BitSrcLoc             `protobuf:"bytes,4,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitInsn) Reset() {
	*x = BitInsn{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitInsn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitInsn) ProtoMessage() {}

func (x *BitInsn) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitInsn.ProtoReflect.Descriptor instead.
func (*BitInsn) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{5}
}

func (x *BitInsn) GetKind() K_IK {
	if x != nil {
		return x.Kind
	}
	return K_IK_INIL
}

func (x *BitInsn) GetExpr1() *BitExpr {
	if x != nil {
		return x.Expr1
	}
	return nil
}

func (x *BitInsn) GetExpr2() *BitExpr {
	if x != nil {
		return x.Expr2
	}
	return nil
}

func (x *BitInsn) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//
//	void 00_glbl_init()
type BitFunc struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Fid        uint64                 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`                                 // Function id (also an entity id)
	Fname      string                 `protobuf:"bytes,2,opt,name=fname,proto3" json:"fname,omitempty"`                              // Function name
	IsVariadic bool                   `protobuf:"varint,3,opt,name=is_variadic,json=isVariadic,proto3" json:"is_variadic,omitempty"` // Whether the function is variadic
	// Calling convention of the function,
	//
	//	e.g. "cdecl", "stdcall", "fastcall", "thiscall", "vectorcall"
	CallingConvention *string    `protobuf:"bytes,4,opt,name=calling_convention,json=callingConvention,proto3,oneof" json:"calling_convention,omitempty"`
	Insns             []*BitInsn `protobuf:"bytes,5,rep,name=insns,proto3" json:"insns,omitempty"`           // Instructions in the function
	Locals            []uint64   `protobuf:"varint,6,rep,packed,name=locals,proto3" json:"locals,omitempty"` // 64 bit EntityId of locals
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BitFunc) Reset() {
	*x = BitFunc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitFunc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitFunc) ProtoMessage() {}

func (x *BitFunc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitFunc.ProtoReflect.Descriptor instead.
func (*BitFunc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{6}
}

func (x *BitFunc) GetFid() uint64 {
	if x != nil {
		return x.Fid
	}
	return 0
}

func (x *BitFunc) GetFname() string {
	if x != nil {
		return x.Fname
	}
	return ""
}

func (x *BitFunc) GetIsVariadic() bool {
	if x != nil {
		return x.IsVariadic
	}
	return false
}

func (x *BitFunc) GetCallingConvention() string {
	if x != nil && x.CallingConvention != nil {
		return *x.CallingConvention
	}
	return ""
}

func (x *BitFunc) GetInsns() []*BitInsn {
	if x != nil {
		return x.Insns
	}
	return nil
}

func (x *BitFunc) GetLocals() []uint64 {
	if x != nil {
		return x.Locals
	}
	return nil
}

// The Translation Unit.
// It contains all the entities in a TU. E.g. functions, variables, etc.
type BitTU struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	TuName  string                 `protobuf:"bytes,1,opt,name=tuName,proto3" json:"tuName,omitempty"`         // Translation unit name
	AbsPath *string                `protobuf:"bytes,2,opt,name=absPath,proto3,oneof" json:"absPath,omitempty"` // Absolute path to source file
	Origin  *string                `protobuf:"bytes,3,opt,name=origin,proto3,oneof" json:"origin,omitempty"`   // Origin, e.g. "Clang AST"
	// Information about the entities
	NamesToIds map[string]uint64         `protobuf:"bytes,4,rep,name=namesToIds,proto3" json:"namesToIds,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"` // name to entity id mapping
	EntityInfo map[uint64]*BitEntityInfo `protobuf:"bytes,5,rep,name=entityInfo,proto3" json:"entityInfo,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Type information of entities
	// Functions with definition
	Functions     []*BitFunc `protobuf:"bytes,6,rep,name=functions,proto3" json:"functions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitTU) Reset() {
	*x = BitTU{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitTU) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitTU) ProtoMessage() {}

func (x *BitTU) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitTU.ProtoReflect.Descriptor instead.
func (*BitTU) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{7}
}

func (x *BitTU) GetTuName() string {
	if x != nil {
		return x.TuName
	}
	return ""
}

func (x *BitTU) GetAbsPath() string {
	if x != nil && x.AbsPath != nil {
		return *x.AbsPath
	}
	return ""
}

func (x *BitTU) GetOrigin() string {
	if x != nil && x.Origin != nil {
		return *x.Origin
	}
	return ""
}

func (x *BitTU) GetNamesToIds() map[string]uint64 {
	if x != nil {
		return x.NamesToIds
	}
	return nil
}

func (x *BitTU) GetEntityInfo() map[uint64]*BitEntityInfo {
	if x != nil {
		return x.EntityInfo
	}
	return nil
}

func (x *BitTU) GetFunctions() []*BitFunc {
	if x != nil {
		return x.Functions
	}
	return nil
}

var File_span_pkg_spir_spir_proto protoreflect.FileDescriptor

const file_span_pkg_spir_spir_proto_rawDesc = "" +
	"\n" +
	"\x18span/pkg/spir/spir.proto\x12\x04spir\"1\n" +
	"\tBitSrcLoc\x12\x12\n" +
	"\x04line\x18\x01 \x01(\rR\x04line\x12\x10\n" +
	"\x03col\x18\x02 \x01(\rR\x03col\"\xb6\x04\n" +
	"\vBitDataType\x12 \n" +
	"\x05vkind\x18\x01 \x01(\x0e2\n" +
	".spir.K_VKR\x05vkind\x12\x1b\n" +
	"\x06typeId\x18\x02 \x01(\x04H\x00R\x06typeId\x88\x01\x01\x12\x19\n" +
	"\x05qtype\x18\x03 \x01(\rH\x01R\x05qtype\x88\x01\x01\x12#\n" +
	"\n" +
	"attributes\x18\x04 \x01(\tH\x02R\n" +
	"attributes\x88\x01\x01\x12\x15\n" +
	"\x03len\x18\x05 \x01(\rH\x03R\x03len\x88\x01\x01\x12\x19\n" +
	"\x05align\x18\x06 \x01(\rH\x04R\x05align\x88\x01\x01\x120\n" +
	"\asubType\x18\a \x01(\v2\x11.spir.BitDataTypeH\x05R\asubType\x88\x01\x01\x12\x1f\n" +
	"\btypeName\x18\b \x01(\tH\x06R\btypeName\x88\x01\x01\x12!\n" +
	"\tanonymous\x18\t \x01(\bH\aR\tanonymous\x88\x01\x01\x12\x16\n" +
	"\x06fopIds\x18\n" +
	" \x03(\x04R\x06fopIds\x12-\n" +
	"\bfopTypes\x18\v \x03(\v2\x11.spir.BitDataTypeR\bfopTypes\x12\x1f\n" +
	"\bvariadic\x18\f \x01(\bH\bR\bvariadic\x88\x01\x01\x12&\n" +
	"\x03loc\x18\r \x01(\v2\x0f.spir.BitSrcLocH\tR\x03loc\x88\x01\x01B\t\n" +
	"\a_typeIdB\b\n" +
	"\x06_qtypeB\r\n" +
	"\v_attributesB\x06\n" +
	"\x04_lenB\b\n" +
	"\x06_alignB\n" +
	"\n" +
	"\b_subTypeB\v\n" +
	"\t_typeNameB\f\n" +
	"\n" +
	"_anonymousB\v\n" +
	"\t_variadicB\x06\n" +
	"\x04_loc\"\xcb\x02\n" +
	"\rBitEntityInfo\x12\x10\n" +
	"\x03eid\x18\x01 \x01(\x04R\x03eid\x12 \n" +
	"\x05ekind\x18\x02 \x01(\x0e2\n" +
	".spir.K_EKR\x05ekind\x12\x1f\n" +
	"\bparentId\x18\x03 \x01(\x04H\x00R\bparentId\x88\x01\x01\x12&\n" +
	"\x02dt\x18\x04 \x01(\v2\x11.spir.BitDataTypeH\x01R\x02dt\x88\x01\x01\x12\x1b\n" +
	"\x06lowVal\x18\x05 \x01(\x04H\x02R\x06lowVal\x88\x01\x01\x12\x1d\n" +
	"\ahighVal\x18\x06 \x01(\x04H\x03R\ahighVal\x88\x01\x01\x12\x1b\n" +
	"\x06strVal\x18\a \x01(\tH\x04R\x06strVal\x88\x01\x01\x12&\n" +
	"\x03loc\x18\b \x01(\v2\x0f.spir.BitSrcLocH\x05R\x03loc\x88\x01\x01B\v\n" +
	"\t_parentIdB\x05\n" +
	"\x03_dtB\t\n" +
	"\a_lowValB\n" +
	"\n" +
	"\b_highValB\t\n" +
	"\a_strValB\x06\n" +
	"\x04_loc\"M\n" +
	"\tBitEntity\x12\x10\n" +
	"\x03eid\x18\x01 \x01(\x04R\x03eid\x12&\n" +
	"\x03loc\x18\x02 \x01(\v2\x0f.spir.BitSrcLocH\x00R\x03loc\x88\x01\x01B\x06\n" +
	"\x04_loc\"\xe4\x01\n" +
	"\aBitExpr\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_XKR\x04kind\x12(\n" +
	"\x04opr1\x18\x02 \x01(\v2\x0f.spir.BitEntityH\x00R\x04opr1\x88\x01\x01\x12(\n" +
	"\x04opr2\x18\x03 \x01(\v2\x0f.spir.BitEntityH\x01R\x04opr2\x88\x01\x01\x12#\n" +
	"\x04oprs\x18\x04 \x03(\v2\x0f.spir.BitEntityR\x04oprs\x12&\n" +
	"\x03loc\x18\x05 \x01(\v2\x0f.spir.BitSrcLocH\x02R\x03loc\x88\x01\x01B\a\n" +
	"\x05_opr1B\a\n" +
	"\x05_opr2B\x06\n" +
	"\x04_loc\"\xc1\x01\n" +
	"\aBitInsn\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_IKR\x04kind\x12(\n" +
	"\x05expr1\x18\x02 \x01(\v2\r.spir.BitExprH\x00R\x05expr1\x88\x01\x01\x12(\n" +
	"\x05expr2\x18\x03 \x01(\v2\r.spir.BitExprH\x01R\x05expr2\x88\x01\x01\x12&\n" +
	"\x03loc\x18\x04 \x01(\v2\x0f.spir.BitSrcLocH\x02R\x03loc\x88\x01\x01B\b\n" +
	"\x06_expr1B\b\n" +
	"\x06_expr2B\x06\n" +
	"\x04_loc\"\xda\x01\n" +
	"\aBitFunc\x12\x10\n" +
	"\x03fid\x18\x01 \x01(\x04R\x03fid\x12\x14\n" +
	"\x05fname\x18\x02 \x01(\tR\x05fname\x12\x1f\n" +
	"\vis_variadic\x18\x03 \x01(\bR\n" +
	"isVariadic\x122\n" +
	"\x12calling_convention\x18\x04 \x01(\tH\x00R\x11callingConvention\x88\x01\x01\x12#\n" +
	"\x05insns\x18\x05 \x03(\v2\r.spir.BitInsnR\x05insns\x12\x16\n" +
	"\x06locals\x18\x06 \x03(\x04R\x06localsB\x15\n" +
	"\x13_calling_convention\"\xac\x03\n" +
	"\x05BitTU\x12\x16\n" +
	"\x06tuName\x18\x01 \x01(\tR\x06tuName\x12\x1d\n" +
	"\aabsPath\x18\x02 \x01(\tH\x00R\aabsPath\x88\x01\x01\x12\x1b\n" +
	"\x06origin\x18\x03 \x01(\tH\x01R\x06origin\x88\x01\x01\x12;\n" +
	"\n" +
	"namesToIds\x18\x04 \x03(\v2\x1b.spir.BitTU.NamesToIdsEntryR\n" +
	"namesToIds\x12;\n" +
	"\n" +
	"entityInfo\x18\x05 \x03(\v2\x1b.spir.BitTU.EntityInfoEntryR\n" +
	"entityInfo\x12+\n" +
	"\tfunctions\x18\x06 \x03(\v2\r.spir.BitFuncR\tfunctions\x1a=\n" +
	"\x0fNamesToIdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x04R\x05value:\x028\x01\x1aR\n" +
	"\x0fEntityInfoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.spir.BitEntityInfoR\x05value:\x028\x01B\n" +
	"\n" +
	"\b_absPathB\t\n" +
	"\a_origin*\xcb\x02\n" +
	"\x04K_EK\x12\b\n" +
	"\x04ENIL\x10\x00\x12\r\n" +
	"\tEVAR_GLBL\x10\x01\x12\r\n" +
	"\tEVAR_LOCL\x10\x02\x12\x11\n" +
	"\rEVAR_LOCL_ARG\x10\x03\x12\x14\n" +
	"\x10EVAR_LOCL_STATIC\x10\x04\x12\x11\n" +
	"\rEVAR_LOCL_TMP\x10\x05\x12\x11\n" +
	"\rEVAR_LOCL_SSA\x10\x06\x12\x14\n" +
	"\x10EVAR_LOCL_PSEUDO\x10\a\x12\f\n" +
	"\bELIT_NUM\x10\b\x12\x10\n" +
	"\fELIT_NUM_IMM\x10\t\x12\f\n" +
	"\bELIT_STR\x10\n" +
	"\x12\x0e\n" +
	"\n" +
	"EDATA_TYPE\x10\v\x12\t\n" +
	"\x05EFUNC\x10\f\x12\x0f\n" +
	"\vEFUNC_VARGS\x10\r\x12\n" +
	"\n" +
	"\x06ELABEL\x10\x0e\x12\n" +
	"\n" +
	"\x06EOTHER\x10\x0f\x12\x11\n" +
	"\rERECORD_FIELD\x10\x10\x12\t\n" +
	"\x05EINSN\x10\x11\x12\a\n" +
	"\x03EBB\x10\x12\x12\b\n" +
	"\x04ECFG\x10\x13\x12\n" +
	"\n" +
	"\x06ESCOPE\x10\x14\x12\a\n" +
	"\x03ETU\x10\x15*\xb7\x01\n" +
	"\x04K_IK\x12\b\n" +
	"\x04INIL\x10\x00\x12\b\n" +
	"\x04INOP\x10\x01\x12\f\n" +
	"\bIBARRIER\x10\x02\x12\x10\n" +
	"\fIASGN_SIMPLE\x10\x03\x12\x10\n" +
	"\fIASGN_RHS_OP\x10\x04\x12\x10\n" +
	"\fIASGN_LHS_OP\x10\x05\x12\x0e\n" +
	"\n" +
	"IASGN_CALL\x10\x06\x12\r\n" +
	"\tIASGN_PHI\x10\a\x12\t\n" +
	"\x05ICALL\x10\b\x12\t\n" +
	"\x05IGOTO\x10\t\x12\t\n" +
	"\x05ICOND\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06ILABEL\x10\v\x12\v\n" +
	"\aIRETURN\x10\f*\x8a\x03\n" +
	"\x04K_XK\x12\b\n" +
	"\x04XNIL\x10\x00\x12\b\n" +
	"\x04XVAL\x10\x01\x12\b\n" +
	"\x04XADD\x10\x02\x12\b\n" +
	"\x04XSUB\x10\x03\x12\b\n" +
	"\x04XMUL\x10\x04\x12\b\n" +
	"\x04XDIV\x10\x05\x12\b\n" +
	"\x04XMOD\x10\x06\x12\b\n" +
	"\x04XAND\x10\a\x12\a\n" +
	"\x03XOR\x10\b\x12\b\n" +
	"\x04XXOR\x10\t\x12\b\n" +
	"\x04XSHL\x10\n" +
	"\x12\b\n" +
	"\x04XSHR\x10\v\x12\t\n" +
	"\x05XSHRA\x10\f\x12\a\n" +
	"\x03XEQ\x10\r\x12\a\n" +
	"\x03XNE\x10\x0e\x12\a\n" +
	"\x03XLT\x10\x0f\x12\a\n" +
	"\x03XGE\x10\x10\x12\x10\n" +
	"\fXARRAY_INDEX\x10\x11\x12\x12\n" +
	"\x0eXMEMBER_ACCESS\x10\x12\x12\x16\n" +
	"\x12XMEMBER_PTR_ACCESS\x10\x13\x12\x16\n" +
	"\x12XMEMBER_PTR_ADDROF\x10\x14\x12\t\n" +
	"\x05XCALL\x10\x15\x12\v\n" +
	"\aXCALL_0\x10\x16\x12\t\n" +
	"\x05XCAST\x10\x17\x12\f\n" +
	"\bXBIT_NOT\x10\x18\x12\v\n" +
	"\aXNEGATE\x10\x19\x12\b\n" +
	"\x04XNOT\x10\x1a\x12\n" +
	"\n" +
	"\x06XDEREF\x10\x1b\x12\v\n" +
	"\aXADDROF\x10\x1c\x12\v\n" +
	"\aXSIZEOF\x10\x1d\x12\f\n" +
	"\bXALIGNOF\x10\x1e\x12\n" +
	"\n" +
	"\x06XOTHER\x10\x1f*\xbd\x04\n" +
	"\x04K_VK\x12\b\n" +
	"\x04TNIL\x10\x00\x12\t\n" +
	"\x05TVOID\x10\x00\x12\t\n" +
	"\x05TCHAR\x10\x01\x12\t\n" +
	"\x05TINT8\x10\x02\x12\n" +
	"\n" +
	"\x06TINT16\x10\x03\x12\n" +
	"\n" +
	"\x06TINT32\x10\x04\x12\n" +
	"\n" +
	"\x06TINT64\x10\x05\x12\n" +
	"\n" +
	"\x06TUINT8\x10\x06\x12\n" +
	"\n" +
	"\x06TUCHAR\x10\x06\x12\v\n" +
	"\aTUINT16\x10\a\x12\v\n" +
	"\aTUINT32\x10\b\x12\v\n" +
	"\aTUINT64\x10\t\x12\v\n" +
	"\aTCHAR16\x10\a\x12\n" +
	"\n" +
	"\x06TWCHAR\x10\b\x12\v\n" +
	"\aTCHAR32\x10\b\x12\v\n" +
	"\aTN_BITS\x10\n" +
	"\x12\f\n" +
	"\bTN_UBITS\x10\v\x12\t\n" +
	"\x05TBOOL\x10\f\x12\f\n" +
	"\bTFLOAT16\x10\r\x12\f\n" +
	"\bTFLOAT32\x10\x0e\x12\n" +
	"\n" +
	"\x06TFLOAT\x10\x0e\x12\f\n" +
	"\bTFLOAT64\x10\x0f\x12\v\n" +
	"\aTDOUBLE\x10\x0f\x12\f\n" +
	"\bTFLOAT80\x10\x10\x12\x10\n" +
	"\fTLONG_DOUBLE\x10\x10\x12\x10\n" +
	"\fTPTR_TO_VOID\x10\x11\x12\x0f\n" +
	"\vTPTR_TO_PTR\x10\x12\x12\x0f\n" +
	"\vTPTR_TO_ARR\x10\x13\x12\x10\n" +
	"\fTPTR_TO_CHAR\x10\x14\x12\x0f\n" +
	"\vTPTR_TO_INT\x10\x15\x12\x11\n" +
	"\rTPTR_TO_FLOAT\x10\x16\x12\x12\n" +
	"\x0eTPTR_TO_RECORD\x10\x17\x12\x10\n" +
	"\fTPTR_TO_FUNC\x10\x18\x12\x0e\n" +
	"\n" +
	"TARR_FIXED\x10\x19\x12\x11\n" +
	"\rTARR_VARIABLE\x10\x1a\x12\x10\n" +
	"\fTARR_PARTIAL\x10\x1b\x12\n" +
	"\n" +
	"\x06TUNION\x10\x1c\x12\v\n" +
	"\aTSTRUCT\x10\x1d\x12\n" +
	"\n" +
	"\x06TCLASS\x10\x1e\x12\n" +
	"\n" +
	"\x06TOTHER\x10\x1f\x1a\x02\x10\x01*\x8b\x02\n" +
	"\x04K_QK\x12\b\n" +
	"\x04QNIL\x10\x00\x12\n" +
	"\n" +
	"\x06QCONST\x10\x01\x12\x0f\n" +
	"\vQCONST_DEST\x10\x02\x12\x10\n" +
	"\fQLOCL_STATIC\x10\x04\x12\x10\n" +
	"\fQGLBL_STATIC\x10\b\x12\r\n" +
	"\tQVOLATILE\x10\x10\x12\t\n" +
	"\x05QWEAK\x10 \x12\x11\n" +
	"\rQTHREAD_LOCAL\x10@\x12\r\n" +
	"\bQNO_INIT\x10\x80\x01\x12\x0e\n" +
	"\tQEXTERNAL\x10\x80\x02\x12\f\n" +
	"\aQNO_DEF\x10\x80\x04\x12\x0e\n" +
	"\tQRESTRICT\x10\x80\b\x12\f\n" +
	"\aQINLINE\x10\x80\x10\x12\f\n" +
	"\aQATOMIC\x10\x80 \x12\x0e\n" +
	"\tQREGISTER\x10\x80@\x12\x14\n" +
	"\x0eQRECORD_MEMBER\x10\x80\x80\x01\x12\f\n" +
	"\x06QOTHER\x10\x80\x80\x02B\bZ\x06./spirb\x06proto3"

var (
	file_span_pkg_spir_spir_proto_rawDescOnce sync.Once
	file_span_pkg_spir_spir_proto_rawDescData []byte
)

func file_span_pkg_spir_spir_proto_rawDescGZIP() []byte {
	file_span_pkg_spir_spir_proto_rawDescOnce.Do(func() {
		file_span_pkg_spir_spir_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)))
	})
	return file_span_pkg_spir_spir_proto_rawDescData
}

var file_span_pkg_spir_spir_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_span_pkg_spir_spir_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_span_pkg_spir_spir_proto_goTypes = []any{
	(K_EK)(0),             // 0: spir.K_EK
	(K_IK)(0),             // 1: spir.K_IK
	(K_XK)(0),             // 2: spir.K_XK
	(K_VK)(0),             // 3: spir.K_VK
	(K_QK)(0),             // 4: spir.K_QK
	(*BitSrcLoc)(nil),     // 5: spir.BitSrcLoc
	(*BitDataType)(nil),   // 6: spir.BitDataType
	(*BitEntityInfo)(nil), // 7: spir.BitEntityInfo
	(*BitEntity)(nil),     // 8: spir.BitEntity
	(*BitExpr)(nil),       // 9: spir.BitExpr
	(*BitInsn)(nil),       // 10: spir.BitInsn
	(*BitFunc)(nil),       // 11: spir.BitFunc
	(*BitTU)(nil),         // 12: spir.BitTU
	nil,                   // 13: spir.BitTU.NamesToIdsEntry
	nil,                   // 14: spir.BitTU.EntityInfoEntry
}
var file_span_pkg_spir_spir_proto_depIdxs = []int32{
	3,  // 0: spir.BitDataType.vkind:type_name -> spir.K_VK
	6,  // 1: spir.BitDataType.subType:type_name -> spir.BitDataType
	6,  // 2: spir.BitDataType.fopTypes:type_name -> spir.BitDataType
	5,  // 3: spir.BitDataType.loc:type_name -> spir.BitSrcLoc
	0,  // 4: spir.BitEntityInfo.ekind:type_name -> spir.K_EK
	6,  // 5: spir.BitEntityInfo.dt:type_name -> spir.BitDataType
	5,  // 6: spir.BitEntityInfo.loc:type_name -> spir.BitSrcLoc
	5,  // 7: spir.BitEntity.loc:type_name -> spir.BitSrcLoc
	2,  // 8: spir.BitExpr.kind:type_name -> spir.K_XK
	8,  // 9: spir.BitExpr.opr1:type_name -> spir.BitEntity
	8,  // 10: spir.BitExpr.opr2:type_name -> spir.BitEntity
	8,  // 11: spir.BitExpr.oprs:type_name -> spir.BitEntity
	5,  // 12: spir.BitExpr.loc:type_name -> spir.BitSrcLoc
	1,  // 13: spir.BitInsn.kind:type_name -> spir.K_IK
	9,  // 14: spir.BitInsn.expr1:type_name -> spir.BitExpr
	9,  // 15: spir.BitInsn.expr2:type_name -> spir.BitExpr
	5,  // 16: spir.BitInsn.loc:type_name -> spir.BitSrcLoc
	10, // 17: spir.BitFunc.insns:type_name -> spir.BitInsn
	13, // 18: spir.BitTU.namesToIds:type_name -> spir.BitTU.NamesToIdsEntry
	14, // 19: spir.BitTU.entityInfo:type_name -> spir.BitTU.EntityInfoEntry
	11, // 20: spir.BitTU.functions:type_name -> spir.BitFunc
	7,  // 21: spir.BitTU.EntityInfoEntry.value:type_name -> spir.BitEntityInfo
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_span_pkg_spir_spir_proto_init() }
func file_span_pkg_spir_spir_proto_init() {
	if File_span_pkg_spir_spir_proto != nil {
		return
	}
	file_span_pkg_spir_spir_proto_msgTypes[1].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[2].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[3].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[4].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[5].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[6].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[7].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_span_pkg_spir_spir_proto_goTypes,
		DependencyIndexes: file_span_pkg_spir_spir_proto_depIdxs,
		EnumInfos:         file_span_pkg_spir_spir_proto_enumTypes,
		MessageInfos:      file_span_pkg_spir_spir_proto_msgTypes,
	}.Build()
	File_span_pkg_spir_spir_proto = out.File
	file_span_pkg_spir_spir_proto_goTypes = nil
	file_span_pkg_spir_spir_proto_depIdxs = nil
}

// Version = 0.0.1
// Note of caution: *The sequence of enum values may be significant.*

// To compile this proto file, run from project root:
// protoc --go_out=. --go_opt=paths=source_relative span/pkg/spir/spir.proto
// protoc --cpp_out=slang/src --proto_path=span/pkg/spir span/pkg/spir/spir.proto
// or run the Makefile target "proto" from project root.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: span/pkg/spir/spir.proto

package spir

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
type K_EK int32

const (
	// Entity kinds which can be in an expression (4 bit values)
	K_EK_NONE            K_EK = 0  // No entity
	K_EK_VAR             K_EK = 1  // An uncategorized variable.
	K_EK_VAR_GLBL        K_EK = 2  // A global variable, function etc.
	K_EK_VAR_STATIC_LOCL K_EK = 3  // To give special names to, for e.g., memory allocations.
	K_EK_VAR_LOCL        K_EK = 4  // Local variables in a function scope
	K_EK_VAR_TMP         K_EK = 5  // Temporary varibles created when creating SPAN IR.
	K_EK_VAR_SSA         K_EK = 6  // An SSA variable; assigned only once.
	K_EK_VAR_PSEUDO      K_EK = 7  // To give special names to, for e.g., memory allocations.
	K_EK_LIT_NUM         K_EK = 8  // A numeric literal.
	K_EK_LIT_NUM_IMM     K_EK = 9  // A numeric litreal with immediate value.
	K_EK_LIT_STR         K_EK = 10 // A string literal.
	K_EK_DATA_TYPE       K_EK = 11 // A data type, like int, float, function sig, record, class etc.
	K_EK_FUNC            K_EK = 12 // A function with/without definition.
	K_EK_FUNC_VARGS      K_EK = 13 // A function with var args like printf().
	K_EK_LABEL           K_EK = 14 // In if-then-else statements.
	K_EK_OTHER           K_EK = 15 // Other entity kind - for future use.
	// Entity kinds which cannot be in an expression (5 bit values)
	K_EK_INSN  K_EK = 16
	K_EK_BB    K_EK = 17
	K_EK_CFG   K_EK = 18
	K_EK_SCOPE K_EK = 19
	K_EK_TU    K_EK = 20
)

// Enum value maps for K_EK.
var (
	K_EK_name = map[int32]string{
		0:  "NONE",
		1:  "VAR",
		2:  "VAR_GLBL",
		3:  "VAR_STATIC_LOCL",
		4:  "VAR_LOCL",
		5:  "VAR_TMP",
		6:  "VAR_SSA",
		7:  "VAR_PSEUDO",
		8:  "LIT_NUM",
		9:  "LIT_NUM_IMM",
		10: "LIT_STR",
		11: "DATA_TYPE",
		12: "FUNC",
		13: "FUNC_VARGS",
		14: "LABEL",
		15: "OTHER",
		16: "INSN",
		17: "BB",
		18: "CFG",
		19: "SCOPE",
		20: "TU",
	}
	K_EK_value = map[string]int32{
		"NONE":            0,
		"VAR":             1,
		"VAR_GLBL":        2,
		"VAR_STATIC_LOCL": 3,
		"VAR_LOCL":        4,
		"VAR_TMP":         5,
		"VAR_SSA":         6,
		"VAR_PSEUDO":      7,
		"LIT_NUM":         8,
		"LIT_NUM_IMM":     9,
		"LIT_STR":         10,
		"DATA_TYPE":       11,
		"FUNC":            12,
		"FUNC_VARGS":      13,
		"LABEL":           14,
		"OTHER":           15,
		"INSN":            16,
		"BB":              17,
		"CFG":             18,
		"SCOPE":           19,
		"TU":              20,
	}
)

func (x K_EK) Enum() *K_EK {
	p := new(K_EK)
	*p = x
	return p
}

func (x K_EK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_EK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[0].Descriptor()
}

func (K_EK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[0]
}

func (x K_EK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_EK.Descriptor instead.
func (K_EK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

// Instruction kinds.
// All values must fit in 5 bits.
type K_IK int32

const (
	K_IK_INOP         K_IK = 0  // No-operation - Connects two program points
	K_IK_IBARRIER     K_IK = 1  // Disconnects two program points (no information flow)
	K_IK_IASGN_SIMPLE K_IK = 2  // Simple assignment (no operator)
	K_IK_IASGN_RHS_OP K_IK = 3  // RHS operator assignment
	K_IK_IASGN_LHS_OP K_IK = 4  // LHS operator assignment
	K_IK_IASGN_CALL   K_IK = 5  // Call assignment
	K_IK_IASGN_PHI    K_IK = 6  // Phi assignment.
	K_IK_ICALL        K_IK = 7  // Call instruction
	K_IK_IGOTO        K_IK = 8  // Goto instruction
	K_IK_ICOND        K_IK = 9  // IF-THEN-ELSE instruction
	K_IK_ILABEL       K_IK = 10 // Label instruction
	K_IK_IRETURN      K_IK = 11 // Return instruction
)

// Enum value maps for K_IK.
var (
	K_IK_name = map[int32]string{
		0:  "INOP",
		1:  "IBARRIER",
		2:  "IASGN_SIMPLE",
		3:  "IASGN_RHS_OP",
		4:  "IASGN_LHS_OP",
		5:  "IASGN_CALL",
		6:  "IASGN_PHI",
		7:  "ICALL",
		8:  "IGOTO",
		9:  "ICOND",
		10: "ILABEL",
		11: "IRETURN",
	}
	K_IK_value = map[string]int32{
		"INOP":         0,
		"IBARRIER":     1,
		"IASGN_SIMPLE": 2,
		"IASGN_RHS_OP": 3,
		"IASGN_LHS_OP": 4,
		"IASGN_CALL":   5,
		"IASGN_PHI":    6,
		"ICALL":        7,
		"IGOTO":        8,
		"ICOND":        9,
		"ILABEL":       10,
		"IRETURN":      11,
	}
)

func (x K_IK) Enum() *K_IK {
	p := new(K_IK)
	*p = x
	return p
}

func (x K_IK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_IK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[1].Descriptor()
}

func (K_IK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[1]
}

func (x K_IK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_IK.Descriptor instead.
func (K_IK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

// Expression kinds.
// All values must fit in 5 bits.
type K_XK int32

const (
	// Expression kinds that can be used in expressions
	K_XK_NIL               K_XK = 0  // Shows that there is no expression present
	K_XK_VAL               K_XK = 1  // A single value type: a constant, variable or function
	K_XK_ADD               K_XK = 2  // A binary addition expression
	K_XK_SUB               K_XK = 3  // A binary subtraction expression
	K_XK_MUL               K_XK = 4  // A binary multiplication expression
	K_XK_DIV               K_XK = 5  // A binary division expression
	K_XK_MOD               K_XK = 6  // A binary modulo expression
	K_XK_AND               K_XK = 7  // A binary AND expression
	K_XK_OR                K_XK = 8  // A binary OR expression
	K_XK_XOR               K_XK = 9  // A binary XOR expression
	K_XK_SHL               K_XK = 10 // A binary shift left expression
	K_XK_SHR               K_XK = 11 // A binary shift right expression
	K_XK_SHRL              K_XK = 12 // A binary shift right logical expression
	K_XK_EQ                K_XK = 13 // Equality comparison (binary expr).
	K_XK_NE                K_XK = 14 // Inequality comparison (binary expr).
	K_XK_LT                K_XK = 15 // Less than comparison (binary expr).
	K_XK_GE                K_XK = 16 // Greater than or equal to comparison (binary expr).
	K_XK_ARRAY_INDEX       K_XK = 17 // An array index expression (binary expr)
	K_XK_MEMBER_ACCESS     K_XK = 18 // A member access expression (binary expr)
	K_XK_MEMBER_PTR_ACCESS K_XK = 19 // A member pointer access expression (binary expr)
	K_XK_MEMBER_PTR_ADDROF K_XK = 20 // A member pointer address expression (unary expr)
	K_XK_CALL              K_XK = 21 // A function call expression (all arguments may be stored separately)
	K_XK_CALL_0            K_XK = 22 // A call with zero arguments
	K_XK_CAST              K_XK = 23 // A cast expression
	K_XK_BIT_NOT           K_XK = 24 // A unary bitwise NOT expression
	K_XK_NEGATE            K_XK = 25 // A unary minus expression
	K_XK_NOT               K_XK = 26 // A unary logical NOT expression
	K_XK_DEREF             K_XK = 27 // A dereference expression (unary expr)
	K_XK_ADDROF            K_XK = 28 // An address expression (unary expr)
	K_XK_SIZEOF            K_XK = 29 // A sizeof expression
	K_XK_ALIGNOF           K_XK = 30 // An alignof expression
	K_XK_OTHER_EXPR        K_XK = 31 // Other expression.
)

// Enum value maps for K_XK.
var (
	K_XK_name = map[int32]string{
		0:  "NIL",
		1:  "VAL",
		2:  "ADD",
		3:  "SUB",
		4:  "MUL",
		5:  "DIV",
		6:  "MOD",
		7:  "AND",
		8:  "OR",
		9:  "XOR",
		10: "SHL",
		11: "SHR",
		12: "SHRL",
		13: "EQ",
		14: "NE",
		15: "LT",
		16: "GE",
		17: "ARRAY_INDEX",
		18: "MEMBER_ACCESS",
		19: "MEMBER_PTR_ACCESS",
		20: "MEMBER_PTR_ADDROF",
		21: "CALL",
		22: "CALL_0",
		23: "CAST",
		24: "BIT_NOT",
		25: "NEGATE",
		26: "NOT",
		27: "DEREF",
		28: "ADDROF",
		29: "SIZEOF",
		30: "ALIGNOF",
		31: "OTHER_EXPR",
	}
	K_XK_value = map[string]int32{
		"NIL":               0,
		"VAL":               1,
		"ADD":               2,
		"SUB":               3,
		"MUL":               4,
		"DIV":               5,
		"MOD":               6,
		"AND":               7,
		"OR":                8,
		"XOR":               9,
		"SHL":               10,
		"SHR":               11,
		"SHRL":              12,
		"EQ":                13,
		"NE":                14,
		"LT":                15,
		"GE":                16,
		"ARRAY_INDEX":       17,
		"MEMBER_ACCESS":     18,
		"MEMBER_PTR_ACCESS": 19,
		"MEMBER_PTR_ADDROF": 20,
		"CALL":              21,
		"CALL_0":            22,
		"CAST":              23,
		"BIT_NOT":           24,
		"NEGATE":            25,
		"NOT":               26,
		"DEREF":             27,
		"ADDROF":            28,
		"SIZEOF":            29,
		"ALIGNOF":           30,
		"OTHER_EXPR":        31,
	}
)

func (x K_XK) Enum() *K_XK {
	p := new(K_XK)
	*p = x
	return p
}

func (x K_XK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_XK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[2].Descriptor()
}

func (K_XK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[2]
}

func (x K_XK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_XK.Descriptor instead.
func (K_XK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

// Value kinds, i.e. the data types.
// All values must fit in 5 bits.
type K_VK int32

const (
	K_VK_VOID          K_VK = 0
	K_VK_CHAR          K_VK = 1
	K_VK_INT8          K_VK = 2
	K_VK_INT16         K_VK = 3
	K_VK_INT32         K_VK = 4
	K_VK_INT64         K_VK = 5
	K_VK_UINT8         K_VK = 6
	K_VK_UCHAR         K_VK = 6 // UINT8
	K_VK_UINT16        K_VK = 7
	K_VK_UINT32        K_VK = 8
	K_VK_UINT64        K_VK = 9
	K_VK_CHAR16        K_VK = 7 // UINT16
	K_VK_WCHAR         K_VK = 8 // UINT32
	K_VK_CHAR32        K_VK = 8 // UINT32
	K_VK_N_BITS        K_VK = 10
	K_VK_N_UBITS       K_VK = 11
	K_VK_BOOL          K_VK = 12
	K_VK_FLOAT16       K_VK = 13
	K_VK_FLOAT32       K_VK = 14
	K_VK_FLOAT         K_VK = 14 // FLOAT32
	K_VK_FLOAT64       K_VK = 15
	K_VK_DOUBLE        K_VK = 15 // FLOAT64
	K_VK_LONG_DOUBLE   K_VK = 16 // 80-bit extended precision floating point
	K_VK_PTR           K_VK = 17 // An unclassified pointer
	K_VK_PTR_TO_VOID   K_VK = 18
	K_VK_PTR_TO_PTR    K_VK = 19
	K_VK_PTR_TO_ARR    K_VK = 20 // A pointer to an array type
	K_VK_PTR_TO_CHAR   K_VK = 21 // A pointer to any of the char types (possible overlap with INT)
	K_VK_PTR_TO_INT    K_VK = 22 // A pointer to any of the integer types
	K_VK_PTR_TO_FLOAT  K_VK = 23 // A pointer to any of the float types
	K_VK_PTR_TO_RECORD K_VK = 24 // A pointer to a struct or a union
	K_VK_PTR_TO_FUNC   K_VK = 25 // A pointer to a function type
	K_VK_ARR_FIXED     K_VK = 26 // An array with a fixed size known at compile time (e.g. "int x[10]")
	K_VK_ARR_VARIABLE  K_VK = 27 // An array with a variable size determined at runtime
	K_VK_ARR_PARTIAL   K_VK = 28 // An array with partially known size, e.g. "char[][32] x"
	K_VK_UNION         K_VK = 29 // An unclassified union (a record)
	K_VK_STRUCT        K_VK = 30 // An unclassified struct (a record)
	K_VK_OTHER_TYPE    K_VK = 31 // Other value type
)

// Enum value maps for K_VK.
var (
	K_VK_name = map[int32]string{
		0: "VOID",
		1: "CHAR",
		2: "INT8",
		3: "INT16",
		4: "INT32",
		5: "INT64",
		6: "UINT8",
		// Duplicate value: 6: "UCHAR",
		7: "UINT16",
		8: "UINT32",
		9: "UINT64",
		// Duplicate value: 7: "CHAR16",
		// Duplicate value: 8: "WCHAR",
		// Duplicate value: 8: "CHAR32",
		10: "N_BITS",
		11: "N_UBITS",
		12: "BOOL",
		13: "FLOAT16",
		14: "FLOAT32",
		// Duplicate value: 14: "FLOAT",
		15: "FLOAT64",
		// Duplicate value: 15: "DOUBLE",
		16: "LONG_DOUBLE",
		17: "PTR",
		18: "PTR_TO_VOID",
		19: "PTR_TO_PTR",
		20: "PTR_TO_ARR",
		21: "PTR_TO_CHAR",
		22: "PTR_TO_INT",
		23: "PTR_TO_FLOAT",
		24: "PTR_TO_RECORD",
		25: "PTR_TO_FUNC",
		26: "ARR_FIXED",
		27: "ARR_VARIABLE",
		28: "ARR_PARTIAL",
		29: "UNION",
		30: "STRUCT",
		31: "OTHER_TYPE",
	}
	K_VK_value = map[string]int32{
		"VOID":          0,
		"CHAR":          1,
		"INT8":          2,
		"INT16":         3,
		"INT32":         4,
		"INT64":         5,
		"UINT8":         6,
		"UCHAR":         6,
		"UINT16":        7,
		"UINT32":        8,
		"UINT64":        9,
		"CHAR16":        7,
		"WCHAR":         8,
		"CHAR32":        8,
		"N_BITS":        10,
		"N_UBITS":       11,
		"BOOL":          12,
		"FLOAT16":       13,
		"FLOAT32":       14,
		"FLOAT":         14,
		"FLOAT64":       15,
		"DOUBLE":        15,
		"LONG_DOUBLE":   16,
		"PTR":           17,
		"PTR_TO_VOID":   18,
		"PTR_TO_PTR":    19,
		"PTR_TO_ARR":    20,
		"PTR_TO_CHAR":   21,
		"PTR_TO_INT":    22,
		"PTR_TO_FLOAT":  23,
		"PTR_TO_RECORD": 24,
		"PTR_TO_FUNC":   25,
		"ARR_FIXED":     26,
		"ARR_VARIABLE":  27,
		"ARR_PARTIAL":   28,
		"UNION":         29,
		"STRUCT":        30,
		"OTHER_TYPE":    31,
	}
)

func (x K_VK) Enum() *K_VK {
	p := new(K_VK)
	*p = x
	return p
}

func (x K_VK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_VK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[3].Descriptor()
}

func (K_VK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[3]
}

func (x K_VK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_VK.Descriptor instead.
func (K_VK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

// All values must fit in 16 bits.
type K_QK int32

const (
	K_QK_QNONE         K_QK = 0     // No qualifiers
	K_QK_QCONST        K_QK = 1     // Constant: e.g. "const int x = 10"
	K_QK_QCONST_DEST   K_QK = 2     // Constant pointee: e.g. "const int* x = &y"
	K_QK_QFUNC_STATIC  K_QK = 4     // A static function
	K_QK_QGLBL_STATIC  K_QK = 8     // A static global variable
	K_QK_QVOLATILE     K_QK = 16    // A volatile variable
	K_QK_QWEAK         K_QK = 32    // A weak variable
	K_QK_QTHREAD_LOCAL K_QK = 64    // A thread local variable
	K_QK_QNO_INIT      K_QK = 128   // A variable with no initializer
	K_QK_QEXTERNAL     K_QK = 256   // An external variable
	K_QK_QNO_DEF       K_QK = 512   // An entity with no definition (e.g. a function, class etc.)
	K_QK_QRESTRICT     K_QK = 1024  // Restrict qualifier for pointers (e.g. "restrict int* x")
	K_QK_QINLINE       K_QK = 2048  // Inline function qualifier (e.g. "inline int f()")
	K_QK_QATOMIC       K_QK = 4096  // Atomic type qualifier (C11) (e.g. "atomic<int> x")
	K_QK_QREGISTER     K_QK = 8192  // Register storage class (e.g. "register int x")
	K_QK_QOTHER        K_QK = 16384 // Other qualifier (e.g. "noalias int* x")
)

// Enum value maps for K_QK.
var (
	K_QK_name = map[int32]string{
		0:     "QNONE",
		1:     "QCONST",
		2:     "QCONST_DEST",
		4:     "QFUNC_STATIC",
		8:     "QGLBL_STATIC",
		16:    "QVOLATILE",
		32:    "QWEAK",
		64:    "QTHREAD_LOCAL",
		128:   "QNO_INIT",
		256:   "QEXTERNAL",
		512:   "QNO_DEF",
		1024:  "QRESTRICT",
		2048:  "QINLINE",
		4096:  "QATOMIC",
		8192:  "QREGISTER",
		16384: "QOTHER",
	}
	K_QK_value = map[string]int32{
		"QNONE":         0,
		"QCONST":        1,
		"QCONST_DEST":   2,
		"QFUNC_STATIC":  4,
		"QGLBL_STATIC":  8,
		"QVOLATILE":     16,
		"QWEAK":         32,
		"QTHREAD_LOCAL": 64,
		"QNO_INIT":      128,
		"QEXTERNAL":     256,
		"QNO_DEF":       512,
		"QRESTRICT":     1024,
		"QINLINE":       2048,
		"QATOMIC":       4096,
		"QREGISTER":     8192,
		"QOTHER":        16384,
	}
)

func (x K_QK) Enum() *K_QK {
	p := new(K_QK)
	*p = x
	return p
}

func (x K_QK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_QK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[4].Descriptor()
}

func (K_QK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[4]
}

func (x K_QK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_QK.Descriptor instead.
func (K_QK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

// The location of an entity.
type BitSrcLoc struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Line          uint32                 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Col           uint32                 `protobuf:"varint,2,opt,name=col,proto3" json:"col,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitSrcLoc) Reset() {
	*x = BitSrcLoc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitSrcLoc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitSrcLoc) ProtoMessage() {}

func (x *BitSrcLoc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitSrcLoc.ProtoReflect.Descriptor instead.
func (*BitSrcLoc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

func (x *BitSrcLoc) GetLine() uint32 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *BitSrcLoc) GetCol() uint32 {
	if x != nil {
		return x.Col
	}
	return 0
}

// The type of an entity.
// It is a recursive data type, capable of representing all types in C.
type BitDataType struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Kind   K_VK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_VK" json:"kind,omitempty"`
	TypeId *uint64                `protobuf:"varint,2,opt,name=typeId,proto3,oneof" json:"typeId,omitempty"` // The id to the type present in BitTU.entityInfo map.
	Qtype  *uint32                `protobuf:"varint,3,opt,name=qtype,proto3,oneof" json:"qtype,omitempty"`   // Bitwise OR of one or more K_QK values
	// Colon separated attributes of the type (e.g. "packed:aligned(8)", etc.)
	// These are extra attributes not present in qtype
	Attributes *string `protobuf:"bytes,4,opt,name=attributes,proto3,oneof" json:"attributes,omitempty"`
	// The logical length of the type (e.g. length of an array)
	// Or number of bits in the type (for bit fields and built-in types)
	Len   *uint32 `protobuf:"varint,5,opt,name=len,proto3,oneof" json:"len,omitempty"`
	Align *uint32 `protobuf:"varint,6,opt,name=align,proto3,oneof" json:"align,omitempty"` // Number of bytes to align to
	// Used for,
	//  1. Pointee of a pointer.
	//  2. Element of an array.
	//  3. Return type of a function.
	SubType *BitDataType `protobuf:"bytes,7,opt,name=subType,proto3,oneof" json:"subType,omitempty"`
	// Used to name the record or other special types
	TypeName  *string `protobuf:"bytes,8,opt,name=typeName,proto3,oneof" json:"typeName,omitempty"`
	Anonymous *bool   `protobuf:"varint,9,opt,name=anonymous,proto3,oneof" json:"anonymous,omitempty"`
	// Used for record and function types
	// length of names and types sequences must be the same
	Names         []string       `protobuf:"bytes,10,rep,name=names,proto3" json:"names,omitempty"` // A hyphen '-' for anonymous fields.
	Types         []*BitDataType `protobuf:"bytes,11,rep,name=types,proto3" json:"types,omitempty"`
	Variadic      *bool          `protobuf:"varint,12,opt,name=variadic,proto3,oneof" json:"variadic,omitempty"` // Whether the function is variadic
	Loc           *BitSrcLoc     `protobuf:"bytes,13,opt,name=loc,proto3,oneof" json:"loc,omitempty"`            // location of the record type in the source file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitDataType) Reset() {
	*x = BitDataType{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitDataType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitDataType) ProtoMessage() {}

func (x *BitDataType) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitDataType.ProtoReflect.Descriptor instead.
func (*BitDataType) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

func (x *BitDataType) GetKind() K_VK {
	if x != nil {
		return x.Kind
	}
	return K_VK_VOID
}

func (x *BitDataType) GetTypeId() uint64 {
	if x != nil && x.TypeId != nil {
		return *x.TypeId
	}
	return 0
}

func (x *BitDataType) GetQtype() uint32 {
	if x != nil && x.Qtype != nil {
		return *x.Qtype
	}
	return 0
}

func (x *BitDataType) GetAttributes() string {
	if x != nil && x.Attributes != nil {
		return *x.Attributes
	}
	return ""
}

func (x *BitDataType) GetLen() uint32 {
	if x != nil && x.Len != nil {
		return *x.Len
	}
	return 0
}

func (x *BitDataType) GetAlign() uint32 {
	if x != nil && x.Align != nil {
		return *x.Align
	}
	return 0
}

func (x *BitDataType) GetSubType() *BitDataType {
	if x != nil {
		return x.SubType
	}
	return nil
}

func (x *BitDataType) GetTypeName() string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	return ""
}

func (x *BitDataType) GetAnonymous() bool {
	if x != nil && x.Anonymous != nil {
		return *x.Anonymous
	}
	return false
}

func (x *BitDataType) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

func (x *BitDataType) GetTypes() []*BitDataType {
	if x != nil {
		return x.Types
	}
	return nil
}

func (x *BitDataType) GetVariadic() bool {
	if x != nil && x.Variadic != nil {
		return *x.Variadic
	}
	return false
}

func (x *BitDataType) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

type BitEntityInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_EK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_EK" json:"kind,omitempty"`
	Id    uint64                 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"` // Entity id
	Dt    *BitDataType           `protobuf:"bytes,3,opt,name=dt,proto3,oneof" json:"dt,omitempty"`
	// Store value if entity is a constant value.
	NumVal        *uint64    `protobuf:"varint,4,opt,name=numVal,proto3,oneof" json:"numVal,omitempty"` // for a numeric literal (int, float, etc.)
	StrVal        *string    `protobuf:"bytes,5,opt,name=strVal,proto3,oneof" json:"strVal,omitempty"`  // for a string literal or entity name
	Loc           *BitSrcLoc `protobuf:"bytes,6,opt,name=loc,proto3,oneof" json:"loc,omitempty"`        // location of the entity in the source file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitEntityInfo) Reset() {
	*x = BitEntityInfo{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitEntityInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitEntityInfo) ProtoMessage() {}

func (x *BitEntityInfo) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitEntityInfo.ProtoReflect.Descriptor instead.
func (*BitEntityInfo) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

func (x *BitEntityInfo) GetKind() K_EK {
	if x != nil {
		return x.Kind
	}
	return K_EK_NONE
}

func (x *BitEntityInfo) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BitEntityInfo) GetDt() *BitDataType {
	if x != nil {
		return x.Dt
	}
	return nil
}

func (x *BitEntityInfo) GetNumVal() uint64 {
	if x != nil && x.NumVal != nil {
		return *x.NumVal
	}
	return 0
}

func (x *BitEntityInfo) GetStrVal() string {
	if x != nil && x.StrVal != nil {
		return *x.StrVal
	}
	return ""
}

func (x *BitEntityInfo) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// A single entity like a variable, constant etc.
type BitEntity struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` // Entity id
	Loc           *BitSrcLoc             `protobuf:"bytes,2,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitEntity) Reset() {
	*x = BitEntity{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitEntity) ProtoMessage() {}

func (x *BitEntity) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitEntity.ProtoReflect.Descriptor instead.
func (*BitEntity) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

func (x *BitEntity) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BitEntity) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

// A unary, binary, and call expressions.
type BitExpr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_XK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_XK" json:"kind,omitempty"`
	Opr1  *BitEntity             `protobuf:"bytes,2,opt,name=opr1,proto3,oneof" json:"opr1,omitempty"`
	Opr2  *BitEntity             `protobuf:"bytes,3,opt,name=opr2,proto3,oneof" json:"opr2,omitempty"`
	Loc   *BitSrcLoc             `protobuf:"bytes,4,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	// More expressions, e.g. call arguments, array subscript, etc.
	Exprs         []*BitEntity `protobuf:"bytes,5,rep,name=exprs,proto3" json:"exprs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitExpr) Reset() {
	*x = BitExpr{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitExpr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitExpr) ProtoMessage() {}

func (x *BitExpr) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitExpr.ProtoReflect.Descriptor instead.
func (*BitExpr) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

func (x *BitExpr) GetKind() K_XK {
	if x != nil {
		return x.Kind
	}
	return K_XK_NIL
}

func (x *BitExpr) GetOpr1() *BitEntity {
	if x != nil {
		return x.Opr1
	}
	return nil
}

func (x *BitExpr) GetOpr2() *BitEntity {
	if x != nil {
		return x.Opr2
	}
	return nil
}

func (x *BitExpr) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

func (x *BitExpr) GetExprs() []*BitEntity {
	if x != nil {
		return x.Exprs
	}
	return nil
}

// All kinds of instructions.
// Either expr1 or expr2 or both may be missing depending on the instruction type.
type BitInsn struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kind          K_IK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_IK" json:"kind,omitempty"`
	Expr1         *BitExpr               `protobuf:"bytes,2,opt,name=expr1,proto3,oneof" json:"expr1,omitempty"`
	Expr2         *BitExpr               `protobuf:"bytes,3,opt,name=expr2,proto3,oneof" json:"expr2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitInsn) Reset() {
	*x = BitInsn{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitInsn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitInsn) ProtoMessage() {}

func (x *BitInsn) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitInsn.ProtoReflect.Descriptor instead.
func (*BitInsn) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{5}
}

func (x *BitInsn) GetKind() K_IK {
	if x != nil {
		return x.Kind
	}
	return K_IK_INOP
}

func (x *BitInsn) GetExpr1() *BitExpr {
	if x != nil {
		return x.Expr1
	}
	return nil
}

func (x *BitInsn) GetExpr2() *BitExpr {
	if x != nil {
		return x.Expr2
	}
	return nil
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//
//	void 00_inits()
type BitFunc struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Id                uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`                                   // The type info is placed in BitTU.entityInfo map.
	IsVariadic        bool                   `protobuf:"varint,2,opt,name=is_variadic,json=isVariadic,proto3" json:"is_variadic,omitempty"` // Whether the function is variadic
	Name              string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	CallingConvention *string                `protobuf:"bytes,4,opt,name=calling_convention,json=callingConvention,proto3,oneof" json:"calling_convention,omitempty"` // e.g. "cdecl", "stdcall", "fastcall", "thiscall", "vectorcall"
	Insns             []*BitInsn             `protobuf:"bytes,5,rep,name=insns,proto3" json:"insns,omitempty"`                                                        // Instructions in the function
	Locals            []uint64               `protobuf:"varint,6,rep,packed,name=locals,proto3" json:"locals,omitempty"`                                              // 64 bit EntityId of locals
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BitFunc) Reset() {
	*x = BitFunc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitFunc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitFunc) ProtoMessage() {}

func (x *BitFunc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitFunc.ProtoReflect.Descriptor instead.
func (*BitFunc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{6}
}

func (x *BitFunc) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BitFunc) GetIsVariadic() bool {
	if x != nil {
		return x.IsVariadic
	}
	return false
}

func (x *BitFunc) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BitFunc) GetCallingConvention() string {
	if x != nil && x.CallingConvention != nil {
		return *x.CallingConvention
	}
	return ""
}

func (x *BitFunc) GetInsns() []*BitInsn {
	if x != nil {
		return x.Insns
	}
	return nil
}

func (x *BitFunc) GetLocals() []uint64 {
	if x != nil {
		return x.Locals
	}
	return nil
}

// The Translation Unit.
// It contains all the entities in a TU. E.g. functions, variables, etc.
type BitTU struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Name          string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Directory     *string                   `protobuf:"bytes,2,opt,name=directory,proto3,oneof" json:"directory,omitempty"`                                                                   // Path to the source file TU was generated from
	Origin        *string                   `protobuf:"bytes,3,opt,name=origin,proto3,oneof" json:"origin,omitempty"`                                                                         // Origin of the TU, e.g. "Clang AST"
	Entities      map[string]*BitEntity     `protobuf:"bytes,4,rep,name=entities,proto3" json:"entities,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // name to entity id mapping
	EntityInfo    map[uint64]*BitEntityInfo `protobuf:"bytes,5,rep,name=entityInfo,proto3" json:"entityInfo,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Functions     []*BitFunc                `protobuf:"bytes,6,rep,name=functions,proto3" json:"functions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitTU) Reset() {
	*x = BitTU{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitTU) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitTU) ProtoMessage() {}

func (x *BitTU) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitTU.ProtoReflect.Descriptor instead.
func (*BitTU) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{7}
}

func (x *BitTU) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BitTU) GetDirectory() string {
	if x != nil && x.Directory != nil {
		return *x.Directory
	}
	return ""
}

func (x *BitTU) GetOrigin() string {
	if x != nil && x.Origin != nil {
		return *x.Origin
	}
	return ""
}

func (x *BitTU) GetEntities() map[string]*BitEntity {
	if x != nil {
		return x.Entities
	}
	return nil
}

func (x *BitTU) GetEntityInfo() map[uint64]*BitEntityInfo {
	if x != nil {
		return x.EntityInfo
	}
	return nil
}

func (x *BitTU) GetFunctions() []*BitFunc {
	if x != nil {
		return x.Functions
	}
	return nil
}

var File_span_pkg_spir_spir_proto protoreflect.FileDescriptor

const file_span_pkg_spir_spir_proto_rawDesc = "" +
	"\n" +
	"\x18span/pkg/spir/spir.proto\x12\x04spir\"1\n" +
	"\tBitSrcLoc\x12\x12\n" +
	"\x04line\x18\x01 \x01(\rR\x04line\x12\x10\n" +
	"\x03col\x18\x02 \x01(\rR\x03col\"\xac\x04\n" +
	"\vBitDataType\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_VKR\x04kind\x12\x1b\n" +
	"\x06typeId\x18\x02 \x01(\x04H\x00R\x06typeId\x88\x01\x01\x12\x19\n" +
	"\x05qtype\x18\x03 \x01(\rH\x01R\x05qtype\x88\x01\x01\x12#\n" +
	"\n" +
	"attributes\x18\x04 \x01(\tH\x02R\n" +
	"attributes\x88\x01\x01\x12\x15\n" +
	"\x03len\x18\x05 \x01(\rH\x03R\x03len\x88\x01\x01\x12\x19\n" +
	"\x05align\x18\x06 \x01(\rH\x04R\x05align\x88\x01\x01\x120\n" +
	"\asubType\x18\a \x01(\v2\x11.spir.BitDataTypeH\x05R\asubType\x88\x01\x01\x12\x1f\n" +
	"\btypeName\x18\b \x01(\tH\x06R\btypeName\x88\x01\x01\x12!\n" +
	"\tanonymous\x18\t \x01(\bH\aR\tanonymous\x88\x01\x01\x12\x14\n" +
	"\x05names\x18\n" +
	" \x03(\tR\x05names\x12'\n" +
	"\x05types\x18\v \x03(\v2\x11.spir.BitDataTypeR\x05types\x12\x1f\n" +
	"\bvariadic\x18\f \x01(\bH\bR\bvariadic\x88\x01\x01\x12&\n" +
	"\x03loc\x18\r \x01(\v2\x0f.spir.BitSrcLocH\tR\x03loc\x88\x01\x01B\t\n" +
	"\a_typeIdB\b\n" +
	"\x06_qtypeB\r\n" +
	"\v_attributesB\x06\n" +
	"\x04_lenB\b\n" +
	"\x06_alignB\n" +
	"\n" +
	"\b_subTypeB\v\n" +
	"\t_typeNameB\f\n" +
	"\n" +
	"_anonymousB\v\n" +
	"\t_variadicB\x06\n" +
	"\x04_loc\"\xee\x01\n" +
	"\rBitEntityInfo\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_EKR\x04kind\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\x04R\x02id\x12&\n" +
	"\x02dt\x18\x03 \x01(\v2\x11.spir.BitDataTypeH\x00R\x02dt\x88\x01\x01\x12\x1b\n" +
	"\x06numVal\x18\x04 \x01(\x04H\x01R\x06numVal\x88\x01\x01\x12\x1b\n" +
	"\x06strVal\x18\x05 \x01(\tH\x02R\x06strVal\x88\x01\x01\x12&\n" +
	"\x03loc\x18\x06 \x01(\v2\x0f.spir.BitSrcLocH\x03R\x03loc\x88\x01\x01B\x05\n" +
	"\x03_dtB\t\n" +
	"\a_numValB\t\n" +
	"\a_strValB\x06\n" +
	"\x04_loc\"K\n" +
	"\tBitEntity\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12&\n" +
	"\x03loc\x18\x02 \x01(\v2\x0f.spir.BitSrcLocH\x00R\x03loc\x88\x01\x01B\x06\n" +
	"\x04_loc\"\xe6\x01\n" +
	"\aBitExpr\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_XKR\x04kind\x12(\n" +
	"\x04opr1\x18\x02 \x01(\v2\x0f.spir.BitEntityH\x00R\x04opr1\x88\x01\x01\x12(\n" +
	"\x04opr2\x18\x03 \x01(\v2\x0f.spir.BitEntityH\x01R\x04opr2\x88\x01\x01\x12&\n" +
	"\x03loc\x18\x04 \x01(\v2\x0f.spir.BitSrcLocH\x02R\x03loc\x88\x01\x01\x12%\n" +
	"\x05exprs\x18\x05 \x03(\v2\x0f.spir.BitEntityR\x05exprsB\a\n" +
	"\x05_opr1B\a\n" +
	"\x05_opr2B\x06\n" +
	"\x04_loc\"\x91\x01\n" +
	"\aBitInsn\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_IKR\x04kind\x12(\n" +
	"\x05expr1\x18\x02 \x01(\v2\r.spir.BitExprH\x00R\x05expr1\x88\x01\x01\x12(\n" +
	"\x05expr2\x18\x03 \x01(\v2\r.spir.BitExprH\x01R\x05expr2\x88\x01\x01B\b\n" +
	"\x06_expr1B\b\n" +
	"\x06_expr2\"\xd6\x01\n" +
	"\aBitFunc\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x1f\n" +
	"\vis_variadic\x18\x02 \x01(\bR\n" +
	"isVariadic\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x122\n" +
	"\x12calling_convention\x18\x04 \x01(\tH\x00R\x11callingConvention\x88\x01\x01\x12#\n" +
	"\x05insns\x18\x05 \x03(\v2\r.spir.BitInsnR\x05insns\x12\x16\n" +
	"\x06locals\x18\x06 \x03(\x04R\x06localsB\x15\n" +
	"\x13_calling_convention\"\xb7\x03\n" +
	"\x05BitTU\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\tdirectory\x18\x02 \x01(\tH\x00R\tdirectory\x88\x01\x01\x12\x1b\n" +
	"\x06origin\x18\x03 \x01(\tH\x01R\x06origin\x88\x01\x01\x125\n" +
	"\bentities\x18\x04 \x03(\v2\x19.spir.BitTU.EntitiesEntryR\bentities\x12;\n" +
	"\n" +
	"entityInfo\x18\x05 \x03(\v2\x1b.spir.BitTU.EntityInfoEntryR\n" +
	"entityInfo\x12+\n" +
	"\tfunctions\x18\x06 \x03(\v2\r.spir.BitFuncR\tfunctions\x1aL\n" +
	"\rEntitiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12%\n" +
	"\x05value\x18\x02 \x01(\v2\x0f.spir.BitEntityR\x05value:\x028\x01\x1aR\n" +
	"\x0fEntityInfoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.spir.BitEntityInfoR\x05value:\x028\x01B\f\n" +
	"\n" +
	"_directoryB\t\n" +
	"\a_origin*\x8c\x02\n" +
	"\x04K_EK\x12\b\n" +
	"\x04NONE\x10\x00\x12\a\n" +
	"\x03VAR\x10\x01\x12\f\n" +
	"\bVAR_GLBL\x10\x02\x12\x13\n" +
	"\x0fVAR_STATIC_LOCL\x10\x03\x12\f\n" +
	"\bVAR_LOCL\x10\x04\x12\v\n" +
	"\aVAR_TMP\x10\x05\x12\v\n" +
	"\aVAR_SSA\x10\x06\x12\x0e\n" +
	"\n" +
	"VAR_PSEUDO\x10\a\x12\v\n" +
	"\aLIT_NUM\x10\b\x12\x0f\n" +
	"\vLIT_NUM_IMM\x10\t\x12\v\n" +
	"\aLIT_STR\x10\n" +
	"\x12\r\n" +
	"\tDATA_TYPE\x10\v\x12\b\n" +
	"\x04FUNC\x10\f\x12\x0e\n" +
	"\n" +
	"FUNC_VARGS\x10\r\x12\t\n" +
	"\x05LABEL\x10\x0e\x12\t\n" +
	"\x05OTHER\x10\x0f\x12\b\n" +
	"\x04INSN\x10\x10\x12\x06\n" +
	"\x02BB\x10\x11\x12\a\n" +
	"\x03CFG\x10\x12\x12\t\n" +
	"\x05SCOPE\x10\x13\x12\x06\n" +
	"\x02TU\x10\x14*\xad\x01\n" +
	"\x04K_IK\x12\b\n" +
	"\x04INOP\x10\x00\x12\f\n" +
	"\bIBARRIER\x10\x01\x12\x10\n" +
	"\fIASGN_SIMPLE\x10\x02\x12\x10\n" +
	"\fIASGN_RHS_OP\x10\x03\x12\x10\n" +
	"\fIASGN_LHS_OP\x10\x04\x12\x0e\n" +
	"\n" +
	"IASGN_CALL\x10\x05\x12\r\n" +
	"\tIASGN_PHI\x10\x06\x12\t\n" +
	"\x05ICALL\x10\a\x12\t\n" +
	"\x05IGOTO\x10\b\x12\t\n" +
	"\x05ICOND\x10\t\x12\n" +
	"\n" +
	"\x06ILABEL\x10\n" +
	"\x12\v\n" +
	"\aIRETURN\x10\v*\xef\x02\n" +
	"\x04K_XK\x12\a\n" +
	"\x03NIL\x10\x00\x12\a\n" +
	"\x03VAL\x10\x01\x12\a\n" +
	"\x03ADD\x10\x02\x12\a\n" +
	"\x03SUB\x10\x03\x12\a\n" +
	"\x03MUL\x10\x04\x12\a\n" +
	"\x03DIV\x10\x05\x12\a\n" +
	"\x03MOD\x10\x06\x12\a\n" +
	"\x03AND\x10\a\x12\x06\n" +
	"\x02OR\x10\b\x12\a\n" +
	"\x03XOR\x10\t\x12\a\n" +
	"\x03SHL\x10\n" +
	"\x12\a\n" +
	"\x03SHR\x10\v\x12\b\n" +
	"\x04SHRL\x10\f\x12\x06\n" +
	"\x02EQ\x10\r\x12\x06\n" +
	"\x02NE\x10\x0e\x12\x06\n" +
	"\x02LT\x10\x0f\x12\x06\n" +
	"\x02GE\x10\x10\x12\x0f\n" +
	"\vARRAY_INDEX\x10\x11\x12\x11\n" +
	"\rMEMBER_ACCESS\x10\x12\x12\x15\n" +
	"\x11MEMBER_PTR_ACCESS\x10\x13\x12\x15\n" +
	"\x11MEMBER_PTR_ADDROF\x10\x14\x12\b\n" +
	"\x04CALL\x10\x15\x12\n" +
	"\n" +
	"\x06CALL_0\x10\x16\x12\b\n" +
	"\x04CAST\x10\x17\x12\v\n" +
	"\aBIT_NOT\x10\x18\x12\n" +
	"\n" +
	"\x06NEGATE\x10\x19\x12\a\n" +
	"\x03NOT\x10\x1a\x12\t\n" +
	"\x05DEREF\x10\x1b\x12\n" +
	"\n" +
	"\x06ADDROF\x10\x1c\x12\n" +
	"\n" +
	"\x06SIZEOF\x10\x1d\x12\v\n" +
	"\aALIGNOF\x10\x1e\x12\x0e\n" +
	"\n" +
	"OTHER_EXPR\x10\x1f*\x82\x04\n" +
	"\x04K_VK\x12\b\n" +
	"\x04VOID\x10\x00\x12\b\n" +
	"\x04CHAR\x10\x01\x12\b\n" +
	"\x04INT8\x10\x02\x12\t\n" +
	"\x05INT16\x10\x03\x12\t\n" +
	"\x05INT32\x10\x04\x12\t\n" +
	"\x05INT64\x10\x05\x12\t\n" +
	"\x05UINT8\x10\x06\x12\t\n" +
	"\x05UCHAR\x10\x06\x12\n" +
	"\n" +
	"\x06UINT16\x10\a\x12\n" +
	"\n" +
	"\x06UINT32\x10\b\x12\n" +
	"\n" +
	"\x06UINT64\x10\t\x12\n" +
	"\n" +
	"\x06CHAR16\x10\a\x12\t\n" +
	"\x05WCHAR\x10\b\x12\n" +
	"\n" +
	"\x06CHAR32\x10\b\x12\n" +
	"\n" +
	"\x06N_BITS\x10\n" +
	"\x12\v\n" +
	"\aN_UBITS\x10\v\x12\b\n" +
	"\x04BOOL\x10\f\x12\v\n" +
	"\aFLOAT16\x10\r\x12\v\n" +
	"\aFLOAT32\x10\x0e\x12\t\n" +
	"\x05FLOAT\x10\x0e\x12\v\n" +
	"\aFLOAT64\x10\x0f\x12\n" +
	"\n" +
	"\x06DOUBLE\x10\x0f\x12\x0f\n" +
	"\vLONG_DOUBLE\x10\x10\x12\a\n" +
	"\x03PTR\x10\x11\x12\x0f\n" +
	"\vPTR_TO_VOID\x10\x12\x12\x0e\n" +
	"\n" +
	"PTR_TO_PTR\x10\x13\x12\x0e\n" +
	"\n" +
	"PTR_TO_ARR\x10\x14\x12\x0f\n" +
	"\vPTR_TO_CHAR\x10\x15\x12\x0e\n" +
	"\n" +
	"PTR_TO_INT\x10\x16\x12\x10\n" +
	"\fPTR_TO_FLOAT\x10\x17\x12\x11\n" +
	"\rPTR_TO_RECORD\x10\x18\x12\x0f\n" +
	"\vPTR_TO_FUNC\x10\x19\x12\r\n" +
	"\tARR_FIXED\x10\x1a\x12\x10\n" +
	"\fARR_VARIABLE\x10\x1b\x12\x0f\n" +
	"\vARR_PARTIAL\x10\x1c\x12\t\n" +
	"\x05UNION\x10\x1d\x12\n" +
	"\n" +
	"\x06STRUCT\x10\x1e\x12\x0e\n" +
	"\n" +
	"OTHER_TYPE\x10\x1f\x1a\x02\x10\x01*\xf6\x01\n" +
	"\x04K_QK\x12\t\n" +
	"\x05QNONE\x10\x00\x12\n" +
	"\n" +
	"\x06QCONST\x10\x01\x12\x0f\n" +
	"\vQCONST_DEST\x10\x02\x12\x10\n" +
	"\fQFUNC_STATIC\x10\x04\x12\x10\n" +
	"\fQGLBL_STATIC\x10\b\x12\r\n" +
	"\tQVOLATILE\x10\x10\x12\t\n" +
	"\x05QWEAK\x10 \x12\x11\n" +
	"\rQTHREAD_LOCAL\x10@\x12\r\n" +
	"\bQNO_INIT\x10\x80\x01\x12\x0e\n" +
	"\tQEXTERNAL\x10\x80\x02\x12\f\n" +
	"\aQNO_DEF\x10\x80\x04\x12\x0e\n" +
	"\tQRESTRICT\x10\x80\b\x12\f\n" +
	"\aQINLINE\x10\x80\x10\x12\f\n" +
	"\aQATOMIC\x10\x80 \x12\x0e\n" +
	"\tQREGISTER\x10\x80@\x12\f\n" +
	"\x06QOTHER\x10\x80\x80\x01B\bZ\x06./spirb\x06proto3"

var (
	file_span_pkg_spir_spir_proto_rawDescOnce sync.Once
	file_span_pkg_spir_spir_proto_rawDescData []byte
)

func file_span_pkg_spir_spir_proto_rawDescGZIP() []byte {
	file_span_pkg_spir_spir_proto_rawDescOnce.Do(func() {
		file_span_pkg_spir_spir_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)))
	})
	return file_span_pkg_spir_spir_proto_rawDescData
}

var file_span_pkg_spir_spir_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_span_pkg_spir_spir_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_span_pkg_spir_spir_proto_goTypes = []any{
	(K_EK)(0),             // 0: spir.K_EK
	(K_IK)(0),             // 1: spir.K_IK
	(K_XK)(0),             // 2: spir.K_XK
	(K_VK)(0),             // 3: spir.K_VK
	(K_QK)(0),             // 4: spir.K_QK
	(*BitSrcLoc)(nil),     // 5: spir.BitSrcLoc
	(*BitDataType)(nil),   // 6: spir.BitDataType
	(*BitEntityInfo)(nil), // 7: spir.BitEntityInfo
	(*BitEntity)(nil),     // 8: spir.BitEntity
	(*BitExpr)(nil),       // 9: spir.BitExpr
	(*BitInsn)(nil),       // 10: spir.BitInsn
	(*BitFunc)(nil),       // 11: spir.BitFunc
	(*BitTU)(nil),         // 12: spir.BitTU
	nil,                   // 13: spir.BitTU.EntitiesEntry
	nil,                   // 14: spir.BitTU.EntityInfoEntry
}
var file_span_pkg_spir_spir_proto_depIdxs = []int32{
	3,  // 0: spir.BitDataType.kind:type_name -> spir.K_VK
	6,  // 1: spir.BitDataType.subType:type_name -> spir.BitDataType
	6,  // 2: spir.BitDataType.types:type_name -> spir.BitDataType
	5,  // 3: spir.BitDataType.loc:type_name -> spir.BitSrcLoc
	0,  // 4: spir.BitEntityInfo.kind:type_name -> spir.K_EK
	6,  // 5: spir.BitEntityInfo.dt:type_name -> spir.BitDataType
	5,  // 6: spir.BitEntityInfo.loc:type_name -> spir.BitSrcLoc
	5,  // 7: spir.BitEntity.loc:type_name -> spir.BitSrcLoc
	2,  // 8: spir.BitExpr.kind:type_name -> spir.K_XK
	8,  // 9: spir.BitExpr.opr1:type_name -> spir.BitEntity
	8,  // 10: spir.BitExpr.opr2:type_name -> spir.BitEntity
	5,  // 11: spir.BitExpr.loc:type_name -> spir.BitSrcLoc
	8,  // 12: spir.BitExpr.exprs:type_name -> spir.BitEntity
	1,  // 13: spir.BitInsn.kind:type_name -> spir.K_IK
	9,  // 14: spir.BitInsn.expr1:type_name -> spir.BitExpr
	9,  // 15: spir.BitInsn.expr2:type_name -> spir.BitExpr
	10, // 16: spir.BitFunc.insns:type_name -> spir.BitInsn
	13, // 17: spir.BitTU.entities:type_name -> spir.BitTU.EntitiesEntry
	14, // 18: spir.BitTU.entityInfo:type_name -> spir.BitTU.EntityInfoEntry
	11, // 19: spir.BitTU.functions:type_name -> spir.BitFunc
	8,  // 20: spir.BitTU.EntitiesEntry.value:type_name -> spir.BitEntity
	7,  // 21: spir.BitTU.EntityInfoEntry.value:type_name -> spir.BitEntityInfo
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_span_pkg_spir_spir_proto_init() }
func file_span_pkg_spir_spir_proto_init() {
	if File_span_pkg_spir_spir_proto != nil {
		return
	}
	file_span_pkg_spir_spir_proto_msgTypes[1].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[2].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[3].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[4].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[5].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[6].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[7].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_span_pkg_spir_spir_proto_goTypes,
		DependencyIndexes: file_span_pkg_spir_spir_proto_depIdxs,
		EnumInfos:         file_span_pkg_spir_spir_proto_enumTypes,
		MessageInfos:      file_span_pkg_spir_spir_proto_msgTypes,
	}.Build()
	File_span_pkg_spir_spir_proto = out.File
	file_span_pkg_spir_spir_proto_goTypes = nil
	file_span_pkg_spir_spir_proto_depIdxs = nil
}

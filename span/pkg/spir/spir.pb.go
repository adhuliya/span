// Version = 0.0.1

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: span/pkg/spir/spir.proto

package spir

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
type K_EK int32

const (
	// Entity kinds which can be in an expression (4 bit values)
	K_EK_NONE          K_EK = 0
	K_EK_VAR           K_EK = 1 // The function locals, static vars, and parameters.
	K_EK_VAR_GLOBAL    K_EK = 2 // A global variable, function etc.
	K_EK_VAR_TMP       K_EK = 3
	K_EK_VAR_SSA       K_EK = 4
	K_EK_VAR_PSEUDO    K_EK = 5 // To give names to, for e.g., memory allocations
	K_EK_LIT_NUM       K_EK = 6 // A numeric literal
	K_EK_LIT_NUM_IMM   K_EK = 7 // A numeric litreal with immediate value
	K_EK_LIT_STR       K_EK = 8 // A string literal
	K_EK_VALUE_TYPE    K_EK = 9 // A type, like int, float, record etc.
	K_EK_FUNC          K_EK = 10
	K_EK_FUNC_VAR_ARGS K_EK = 11
	K_EK_CLASS         K_EK = 12 // A class type; for future use.
	K_EK_LABEL         K_EK = 13 // In if-then-else statements
	K_EK_ENT1          K_EK = 14 // Reserved for future use
	K_EK_ENT2          K_EK = 15 // Reserved for future use
	// Entity kinds which cannot be in an expression (5 bit values)
	K_EK_INSN  K_EK = 16
	K_EK_BB    K_EK = 17
	K_EK_CFG   K_EK = 18
	K_EK_SCOPE K_EK = 19
	K_EK_TU    K_EK = 20
)

// Enum value maps for K_EK.
var (
	K_EK_name = map[int32]string{
		0:  "NONE",
		1:  "VAR",
		2:  "VAR_GLOBAL",
		3:  "VAR_TMP",
		4:  "VAR_SSA",
		5:  "VAR_PSEUDO",
		6:  "LIT_NUM",
		7:  "LIT_NUM_IMM",
		8:  "LIT_STR",
		9:  "VALUE_TYPE",
		10: "FUNC",
		11: "FUNC_VAR_ARGS",
		12: "CLASS",
		13: "LABEL",
		14: "ENT1",
		15: "ENT2",
		16: "INSN",
		17: "BB",
		18: "CFG",
		19: "SCOPE",
		20: "TU",
	}
	K_EK_value = map[string]int32{
		"NONE":          0,
		"VAR":           1,
		"VAR_GLOBAL":    2,
		"VAR_TMP":       3,
		"VAR_SSA":       4,
		"VAR_PSEUDO":    5,
		"LIT_NUM":       6,
		"LIT_NUM_IMM":   7,
		"LIT_STR":       8,
		"VALUE_TYPE":    9,
		"FUNC":          10,
		"FUNC_VAR_ARGS": 11,
		"CLASS":         12,
		"LABEL":         13,
		"ENT1":          14,
		"ENT2":          15,
		"INSN":          16,
		"BB":            17,
		"CFG":           18,
		"SCOPE":         19,
		"TU":            20,
	}
)

func (x K_EK) Enum() *K_EK {
	p := new(K_EK)
	*p = x
	return p
}

func (x K_EK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_EK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[0].Descriptor()
}

func (K_EK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[0]
}

func (x K_EK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_EK.Descriptor instead.
func (K_EK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

// All values must fit in 5 bits.
type K_IK int32

const (
	K_IK_INOP            K_IK = 0
	K_IK_IBARRIER        K_IK = 1
	K_IK_IASGN_SIMPLE    K_IK = 2
	K_IK_IASGN_BOP       K_IK = 3
	K_IK_IASGN_UOP       K_IK = 4
	K_IK_IASGN_RHS_DEREF K_IK = 5
	K_IK_IASGN_LHS_DEREF K_IK = 6
	K_IK_IASGN_RHS_ARRAY K_IK = 7
	K_IK_IASGN_LHS_ARRAY K_IK = 8
	K_IK_IASGN_CALL      K_IK = 9
	K_IK_IASGN_PHI       K_IK = 10
	K_IK_ICALL           K_IK = 11
	K_IK_IGOTO           K_IK = 12
	K_IK_ICOND           K_IK = 13 // IF-THEN-ELSE
	K_IK_ILABEL          K_IK = 14
	K_IK_IRETURN         K_IK = 15
)

// Enum value maps for K_IK.
var (
	K_IK_name = map[int32]string{
		0:  "INOP",
		1:  "IBARRIER",
		2:  "IASGN_SIMPLE",
		3:  "IASGN_BOP",
		4:  "IASGN_UOP",
		5:  "IASGN_RHS_DEREF",
		6:  "IASGN_LHS_DEREF",
		7:  "IASGN_RHS_ARRAY",
		8:  "IASGN_LHS_ARRAY",
		9:  "IASGN_CALL",
		10: "IASGN_PHI",
		11: "ICALL",
		12: "IGOTO",
		13: "ICOND",
		14: "ILABEL",
		15: "IRETURN",
	}
	K_IK_value = map[string]int32{
		"INOP":            0,
		"IBARRIER":        1,
		"IASGN_SIMPLE":    2,
		"IASGN_BOP":       3,
		"IASGN_UOP":       4,
		"IASGN_RHS_DEREF": 5,
		"IASGN_LHS_DEREF": 6,
		"IASGN_RHS_ARRAY": 7,
		"IASGN_LHS_ARRAY": 8,
		"IASGN_CALL":      9,
		"IASGN_PHI":       10,
		"ICALL":           11,
		"IGOTO":           12,
		"ICOND":           13,
		"ILABEL":          14,
		"IRETURN":         15,
	}
)

func (x K_IK) Enum() *K_IK {
	p := new(K_IK)
	*p = x
	return p
}

func (x K_IK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_IK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[1].Descriptor()
}

func (K_IK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[1]
}

func (x K_IK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_IK.Descriptor instead.
func (K_IK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

// All values must fit in 5 bits.
type K_XK int32

const (
	// Expression kinds that can be used in expressions
	K_XK_NIL               K_XK = 0  // Shows that there is no expression present
	K_XK_VAL               K_XK = 1  // A single value type: a constant, variable or function
	K_XK_ADD               K_XK = 2  // A binary addition expression
	K_XK_SUB               K_XK = 3  // A binary subtraction expression
	K_XK_MUL               K_XK = 4  // A binary multiplication expression
	K_XK_DIV               K_XK = 5  // A binary division expression
	K_XK_MOD               K_XK = 6  // A binary modulo expression
	K_XK_AND               K_XK = 7  // A binary AND expression
	K_XK_OR                K_XK = 8  // A binary OR expression
	K_XK_XOR               K_XK = 9  // A binary XOR expression
	K_XK_SHL               K_XK = 10 // A binary shift left expression
	K_XK_SHR               K_XK = 11 // A binary shift right expression
	K_XK_SHRL              K_XK = 12 // A binary shift right logical expression
	K_XK_BIT_NOT           K_XK = 13 // A unary bitwise NOT expression
	K_XK_NEGATE            K_XK = 14 // A unary minus expression
	K_XK_NOT               K_XK = 15 // A unary NOT expression
	K_XK_DEREF             K_XK = 16 // A dereference expression
	K_XK_ADDROF            K_XK = 17 // An address expression
	K_XK_SIZEOF            K_XK = 18 // A sizeof expression
	K_XK_ALIGNOF           K_XK = 19 // An alignof expression
	K_XK_ARRAY_SUBSCRIPT   K_XK = 20 // An array subscript expression
	K_XK_MEMBER_ACCESS     K_XK = 21 // A member access expression
	K_XK_MEMBER_PTR_ACCESS K_XK = 22 // A member pointer access expression
	K_XK_CALL              K_XK = 23 // A function call expression (all arguments may be stored separately)
	K_XK_CALL_0            K_XK = 24 // A call with zero arguments
	K_XK_CAST              K_XK = 25 // A cast expression
	K_XK_EQ                K_XK = 26
	K_XK_NE                K_XK = 27
	K_XK_LT                K_XK = 28
	K_XK_LE                K_XK = 29
)

// Enum value maps for K_XK.
var (
	K_XK_name = map[int32]string{
		0:  "NIL",
		1:  "VAL",
		2:  "ADD",
		3:  "SUB",
		4:  "MUL",
		5:  "DIV",
		6:  "MOD",
		7:  "AND",
		8:  "OR",
		9:  "XOR",
		10: "SHL",
		11: "SHR",
		12: "SHRL",
		13: "BIT_NOT",
		14: "NEGATE",
		15: "NOT",
		16: "DEREF",
		17: "ADDROF",
		18: "SIZEOF",
		19: "ALIGNOF",
		20: "ARRAY_SUBSCRIPT",
		21: "MEMBER_ACCESS",
		22: "MEMBER_PTR_ACCESS",
		23: "CALL",
		24: "CALL_0",
		25: "CAST",
		26: "EQ",
		27: "NE",
		28: "LT",
		29: "LE",
	}
	K_XK_value = map[string]int32{
		"NIL":               0,
		"VAL":               1,
		"ADD":               2,
		"SUB":               3,
		"MUL":               4,
		"DIV":               5,
		"MOD":               6,
		"AND":               7,
		"OR":                8,
		"XOR":               9,
		"SHL":               10,
		"SHR":               11,
		"SHRL":              12,
		"BIT_NOT":           13,
		"NEGATE":            14,
		"NOT":               15,
		"DEREF":             16,
		"ADDROF":            17,
		"SIZEOF":            18,
		"ALIGNOF":           19,
		"ARRAY_SUBSCRIPT":   20,
		"MEMBER_ACCESS":     21,
		"MEMBER_PTR_ACCESS": 22,
		"CALL":              23,
		"CALL_0":            24,
		"CAST":              25,
		"EQ":                26,
		"NE":                27,
		"LT":                28,
		"LE":                29,
	}
)

func (x K_XK) Enum() *K_XK {
	p := new(K_XK)
	*p = x
	return p
}

func (x K_XK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_XK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[2].Descriptor()
}

func (K_XK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[2]
}

func (x K_XK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_XK.Descriptor instead.
func (K_XK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

// All values must fit in 5 bits.
type K_VK int32

const (
	K_VK_VOID          K_VK = 0
	K_VK_CHAR          K_VK = 1
	K_VK_INT8          K_VK = 2
	K_VK_INT16         K_VK = 3
	K_VK_INT32         K_VK = 4
	K_VK_INT64         K_VK = 5
	K_VK_UINT8         K_VK = 6
	K_VK_UCHAR         K_VK = 6 // UINT8
	K_VK_UINT16        K_VK = 7
	K_VK_UINT32        K_VK = 8
	K_VK_UINT64        K_VK = 9
	K_VK_N_BITS        K_VK = 10
	K_VK_N_UBITS       K_VK = 11
	K_VK_BOOL          K_VK = 12
	K_VK_FLOAT16       K_VK = 13
	K_VK_FLOAT32       K_VK = 14
	K_VK_FLOAT         K_VK = 14 // FLOAT32
	K_VK_FLOAT64       K_VK = 15
	K_VK_DOUBLE        K_VK = 15 // FLOAT64
	K_VK_PTR_TO_VOID   K_VK = 16
	K_VK_PTR_TO_PTR    K_VK = 17
	K_VK_PTR_TO_ARR    K_VK = 18 // A pointer to an array of elements
	K_VK_PTR_TO_CHAR   K_VK = 19
	K_VK_PTR_TO_INT    K_VK = 20
	K_VK_PTR_TO_FLOAT  K_VK = 21
	K_VK_PTR_TO_RECORD K_VK = 22
	K_VK_PTR_TO_FUNC   K_VK = 23
	K_VK_ARR           K_VK = 24
	K_VK_UNION         K_VK = 25
	K_VK_STRUCT        K_VK = 26
)

// Enum value maps for K_VK.
var (
	K_VK_name = map[int32]string{
		0: "VOID",
		1: "CHAR",
		2: "INT8",
		3: "INT16",
		4: "INT32",
		5: "INT64",
		6: "UINT8",
		// Duplicate value: 6: "UCHAR",
		7:  "UINT16",
		8:  "UINT32",
		9:  "UINT64",
		10: "N_BITS",
		11: "N_UBITS",
		12: "BOOL",
		13: "FLOAT16",
		14: "FLOAT32",
		// Duplicate value: 14: "FLOAT",
		15: "FLOAT64",
		// Duplicate value: 15: "DOUBLE",
		16: "PTR_TO_VOID",
		17: "PTR_TO_PTR",
		18: "PTR_TO_ARR",
		19: "PTR_TO_CHAR",
		20: "PTR_TO_INT",
		21: "PTR_TO_FLOAT",
		22: "PTR_TO_RECORD",
		23: "PTR_TO_FUNC",
		24: "ARR",
		25: "UNION",
		26: "STRUCT",
	}
	K_VK_value = map[string]int32{
		"VOID":          0,
		"CHAR":          1,
		"INT8":          2,
		"INT16":         3,
		"INT32":         4,
		"INT64":         5,
		"UINT8":         6,
		"UCHAR":         6,
		"UINT16":        7,
		"UINT32":        8,
		"UINT64":        9,
		"N_BITS":        10,
		"N_UBITS":       11,
		"BOOL":          12,
		"FLOAT16":       13,
		"FLOAT32":       14,
		"FLOAT":         14,
		"FLOAT64":       15,
		"DOUBLE":        15,
		"PTR_TO_VOID":   16,
		"PTR_TO_PTR":    17,
		"PTR_TO_ARR":    18,
		"PTR_TO_CHAR":   19,
		"PTR_TO_INT":    20,
		"PTR_TO_FLOAT":  21,
		"PTR_TO_RECORD": 22,
		"PTR_TO_FUNC":   23,
		"ARR":           24,
		"UNION":         25,
		"STRUCT":        26,
	}
)

func (x K_VK) Enum() *K_VK {
	p := new(K_VK)
	*p = x
	return p
}

func (x K_VK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_VK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[3].Descriptor()
}

func (K_VK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[3]
}

func (x K_VK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_VK.Descriptor instead.
func (K_VK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

// All values must fit in 16 bits.
type K_QK int32

const (
	K_QK_QNONE          K_QK = 0
	K_QK_QCONST         K_QK = 1
	K_QK_QCONST_DEST    K_QK = 2
	K_QK_QFUNC_STATIC   K_QK = 4
	K_QK_QGLOBAL_STATIC K_QK = 8
	K_QK_QVOLATILE      K_QK = 16
	K_QK_QWEAK          K_QK = 32
	K_QK_QTHREAD_LOCAL  K_QK = 64
	K_QK_QNO_INIT       K_QK = 128
	K_QK_QEXTERNAL      K_QK = 256
	K_QK_QNO_DEF        K_QK = 256
)

// Enum value maps for K_QK.
var (
	K_QK_name = map[int32]string{
		0:   "QNONE",
		1:   "QCONST",
		2:   "QCONST_DEST",
		4:   "QFUNC_STATIC",
		8:   "QGLOBAL_STATIC",
		16:  "QVOLATILE",
		32:  "QWEAK",
		64:  "QTHREAD_LOCAL",
		128: "QNO_INIT",
		256: "QEXTERNAL",
		// Duplicate value: 256: "QNO_DEF",
	}
	K_QK_value = map[string]int32{
		"QNONE":          0,
		"QCONST":         1,
		"QCONST_DEST":    2,
		"QFUNC_STATIC":   4,
		"QGLOBAL_STATIC": 8,
		"QVOLATILE":      16,
		"QWEAK":          32,
		"QTHREAD_LOCAL":  64,
		"QNO_INIT":       128,
		"QEXTERNAL":      256,
		"QNO_DEF":        256,
	}
)

func (x K_QK) Enum() *K_QK {
	p := new(K_QK)
	*p = x
	return p
}

func (x K_QK) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (K_QK) Descriptor() protoreflect.EnumDescriptor {
	return file_span_pkg_spir_spir_proto_enumTypes[4].Descriptor()
}

func (K_QK) Type() protoreflect.EnumType {
	return &file_span_pkg_spir_spir_proto_enumTypes[4]
}

func (x K_QK) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use K_QK.Descriptor instead.
func (K_QK) EnumDescriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

// The location of an entity.
type BitSrcLoc struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Line          uint32                 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Col           uint32                 `protobuf:"varint,2,opt,name=col,proto3" json:"col,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitSrcLoc) Reset() {
	*x = BitSrcLoc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitSrcLoc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitSrcLoc) ProtoMessage() {}

func (x *BitSrcLoc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitSrcLoc.ProtoReflect.Descriptor instead.
func (*BitSrcLoc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{0}
}

func (x *BitSrcLoc) GetLine() uint32 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *BitSrcLoc) GetCol() uint32 {
	if x != nil {
		return x.Col
	}
	return 0
}

// The Translation Unit
type BitTU struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Name          string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Entities      map[string]*BitEntity    `protobuf:"bytes,2,rep,name=entities,proto3" json:"entities,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // name to entity mapping
	EntityTypes   map[uint64]*BitValueType `protobuf:"bytes,3,rep,name=entityTypes,proto3" json:"entityTypes,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Functions     []*BitFunc               `protobuf:"bytes,4,rep,name=functions,proto3" json:"functions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitTU) Reset() {
	*x = BitTU{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitTU) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitTU) ProtoMessage() {}

func (x *BitTU) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitTU.ProtoReflect.Descriptor instead.
func (*BitTU) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{1}
}

func (x *BitTU) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BitTU) GetEntities() map[string]*BitEntity {
	if x != nil {
		return x.Entities
	}
	return nil
}

func (x *BitTU) GetEntityTypes() map[uint64]*BitValueType {
	if x != nil {
		return x.EntityTypes
	}
	return nil
}

func (x *BitTU) GetFunctions() []*BitFunc {
	if x != nil {
		return x.Functions
	}
	return nil
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//
//	void __span_global_initializations()
type BitFunc struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id            uint64                 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Insns         []*BitInsn             `protobuf:"bytes,3,rep,name=insns,proto3" json:"insns,omitempty"`
	Locals        []uint64               `protobuf:"varint,4,rep,packed,name=locals,proto3" json:"locals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitFunc) Reset() {
	*x = BitFunc{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitFunc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitFunc) ProtoMessage() {}

func (x *BitFunc) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitFunc.ProtoReflect.Descriptor instead.
func (*BitFunc) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{2}
}

func (x *BitFunc) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BitFunc) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BitFunc) GetInsns() []*BitInsn {
	if x != nil {
		return x.Insns
	}
	return nil
}

func (x *BitFunc) GetLocals() []uint64 {
	if x != nil {
		return x.Locals
	}
	return nil
}

type BitValueType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_VK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_VK" json:"kind,omitempty"`
	Qtype *K_QK                  `protobuf:"varint,2,opt,name=qtype,proto3,enum=spir.K_QK,oneof" json:"qtype,omitempty"`
	Size  *uint32                `protobuf:"varint,3,opt,name=size,proto3,oneof" json:"size,omitempty"`
	Align *uint32                `protobuf:"varint,4,opt,name=align,proto3,oneof" json:"align,omitempty"`
	// Used for,
	//  1. Pointee of a pointer.
	//  2. Element of an array.
	//  3. Return type of a function.
	SubType *BitValueType `protobuf:"bytes,5,opt,name=subType,proto3,oneof" json:"subType,omitempty"`
	// Used to name the record or other special types
	ValTypeName *string `protobuf:"bytes,6,opt,name=valTypeName,proto3,oneof" json:"valTypeName,omitempty"`
	// Used for record and function types
	Names         []string        `protobuf:"bytes,7,rep,name=names,proto3" json:"names,omitempty"`
	Types         []*BitValueType `protobuf:"bytes,8,rep,name=types,proto3" json:"types,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitValueType) Reset() {
	*x = BitValueType{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitValueType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitValueType) ProtoMessage() {}

func (x *BitValueType) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitValueType.ProtoReflect.Descriptor instead.
func (*BitValueType) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{3}
}

func (x *BitValueType) GetKind() K_VK {
	if x != nil {
		return x.Kind
	}
	return K_VK_VOID
}

func (x *BitValueType) GetQtype() K_QK {
	if x != nil && x.Qtype != nil {
		return *x.Qtype
	}
	return K_QK_QNONE
}

func (x *BitValueType) GetSize() uint32 {
	if x != nil && x.Size != nil {
		return *x.Size
	}
	return 0
}

func (x *BitValueType) GetAlign() uint32 {
	if x != nil && x.Align != nil {
		return *x.Align
	}
	return 0
}

func (x *BitValueType) GetSubType() *BitValueType {
	if x != nil {
		return x.SubType
	}
	return nil
}

func (x *BitValueType) GetValTypeName() string {
	if x != nil && x.ValTypeName != nil {
		return *x.ValTypeName
	}
	return ""
}

func (x *BitValueType) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

func (x *BitValueType) GetTypes() []*BitValueType {
	if x != nil {
		return x.Types
	}
	return nil
}

type BitEntity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_EK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_EK" json:"kind,omitempty"`
	Id    uint64                 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// Store value if entity is a constant value.
	Num           *uint64    `protobuf:"varint,3,opt,name=num,proto3,oneof" json:"num,omitempty"` // for a numeric literal (int, float, etc.)
	Str           *string    `protobuf:"bytes,4,opt,name=str,proto3,oneof" json:"str,omitempty"`  // for a string literal
	Loc           *BitSrcLoc `protobuf:"bytes,5,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitEntity) Reset() {
	*x = BitEntity{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitEntity) ProtoMessage() {}

func (x *BitEntity) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitEntity.ProtoReflect.Descriptor instead.
func (*BitEntity) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{4}
}

func (x *BitEntity) GetKind() K_EK {
	if x != nil {
		return x.Kind
	}
	return K_EK_NONE
}

func (x *BitEntity) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BitEntity) GetNum() uint64 {
	if x != nil && x.Num != nil {
		return *x.Num
	}
	return 0
}

func (x *BitEntity) GetStr() string {
	if x != nil && x.Str != nil {
		return *x.Str
	}
	return ""
}

func (x *BitEntity) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

type BitExpr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Kind  K_XK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_XK" json:"kind,omitempty"`
	Opr1  *BitEntity             `protobuf:"bytes,2,opt,name=opr1,proto3,oneof" json:"opr1,omitempty"`
	Opr2  *BitEntity             `protobuf:"bytes,3,opt,name=opr2,proto3,oneof" json:"opr2,omitempty"`
	// More expressions, like call arguments.
	Exprs         []*BitEntity `protobuf:"bytes,4,rep,name=exprs,proto3" json:"exprs,omitempty"`
	Loc           *BitSrcLoc   `protobuf:"bytes,5,opt,name=loc,proto3,oneof" json:"loc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitExpr) Reset() {
	*x = BitExpr{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitExpr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitExpr) ProtoMessage() {}

func (x *BitExpr) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitExpr.ProtoReflect.Descriptor instead.
func (*BitExpr) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{5}
}

func (x *BitExpr) GetKind() K_XK {
	if x != nil {
		return x.Kind
	}
	return K_XK_NIL
}

func (x *BitExpr) GetOpr1() *BitEntity {
	if x != nil {
		return x.Opr1
	}
	return nil
}

func (x *BitExpr) GetOpr2() *BitEntity {
	if x != nil {
		return x.Opr2
	}
	return nil
}

func (x *BitExpr) GetExprs() []*BitEntity {
	if x != nil {
		return x.Exprs
	}
	return nil
}

func (x *BitExpr) GetLoc() *BitSrcLoc {
	if x != nil {
		return x.Loc
	}
	return nil
}

type BitInsn struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kind          K_IK                   `protobuf:"varint,1,opt,name=kind,proto3,enum=spir.K_IK" json:"kind,omitempty"`
	Rhs           *BitExpr               `protobuf:"bytes,2,opt,name=rhs,proto3,oneof" json:"rhs,omitempty"`
	Lhs           *BitExpr               `protobuf:"bytes,3,opt,name=lhs,proto3,oneof" json:"lhs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitInsn) Reset() {
	*x = BitInsn{}
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitInsn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitInsn) ProtoMessage() {}

func (x *BitInsn) ProtoReflect() protoreflect.Message {
	mi := &file_span_pkg_spir_spir_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitInsn.ProtoReflect.Descriptor instead.
func (*BitInsn) Descriptor() ([]byte, []int) {
	return file_span_pkg_spir_spir_proto_rawDescGZIP(), []int{6}
}

func (x *BitInsn) GetKind() K_IK {
	if x != nil {
		return x.Kind
	}
	return K_IK_INOP
}

func (x *BitInsn) GetRhs() *BitExpr {
	if x != nil {
		return x.Rhs
	}
	return nil
}

func (x *BitInsn) GetLhs() *BitExpr {
	if x != nil {
		return x.Lhs
	}
	return nil
}

var File_span_pkg_spir_spir_proto protoreflect.FileDescriptor

const file_span_pkg_spir_spir_proto_rawDesc = "" +
	"\n" +
	"\x18span/pkg/spir/spir.proto\x12\x04spir\"1\n" +
	"\tBitSrcLoc\x12\x12\n" +
	"\x04line\x18\x01 \x01(\rR\x04line\x12\x10\n" +
	"\x03col\x18\x02 \x01(\rR\x03col\"\xe1\x02\n" +
	"\x05BitTU\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x125\n" +
	"\bentities\x18\x02 \x03(\v2\x19.spir.BitTU.EntitiesEntryR\bentities\x12>\n" +
	"\ventityTypes\x18\x03 \x03(\v2\x1c.spir.BitTU.EntityTypesEntryR\ventityTypes\x12+\n" +
	"\tfunctions\x18\x04 \x03(\v2\r.spir.BitFuncR\tfunctions\x1aL\n" +
	"\rEntitiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12%\n" +
	"\x05value\x18\x02 \x01(\v2\x0f.spir.BitEntityR\x05value:\x028\x01\x1aR\n" +
	"\x10EntityTypesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spir.BitValueTypeR\x05value:\x028\x01\"j\n" +
	"\aBitFunc\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\x04R\x02id\x12#\n" +
	"\x05insns\x18\x03 \x03(\v2\r.spir.BitInsnR\x05insns\x12\x16\n" +
	"\x06locals\x18\x04 \x03(\x04R\x06locals\"\xdc\x02\n" +
	"\fBitValueType\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_VKR\x04kind\x12%\n" +
	"\x05qtype\x18\x02 \x01(\x0e2\n" +
	".spir.K_QKH\x00R\x05qtype\x88\x01\x01\x12\x17\n" +
	"\x04size\x18\x03 \x01(\rH\x01R\x04size\x88\x01\x01\x12\x19\n" +
	"\x05align\x18\x04 \x01(\rH\x02R\x05align\x88\x01\x01\x121\n" +
	"\asubType\x18\x05 \x01(\v2\x12.spir.BitValueTypeH\x03R\asubType\x88\x01\x01\x12%\n" +
	"\vvalTypeName\x18\x06 \x01(\tH\x04R\vvalTypeName\x88\x01\x01\x12\x14\n" +
	"\x05names\x18\a \x03(\tR\x05names\x12(\n" +
	"\x05types\x18\b \x03(\v2\x12.spir.BitValueTypeR\x05typesB\b\n" +
	"\x06_qtypeB\a\n" +
	"\x05_sizeB\b\n" +
	"\x06_alignB\n" +
	"\n" +
	"\b_subTypeB\x0e\n" +
	"\f_valTypeName\"\xa9\x01\n" +
	"\tBitEntity\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_EKR\x04kind\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\x04R\x02id\x12\x15\n" +
	"\x03num\x18\x03 \x01(\x04H\x00R\x03num\x88\x01\x01\x12\x15\n" +
	"\x03str\x18\x04 \x01(\tH\x01R\x03str\x88\x01\x01\x12&\n" +
	"\x03loc\x18\x05 \x01(\v2\x0f.spir.BitSrcLocH\x02R\x03loc\x88\x01\x01B\x06\n" +
	"\x04_numB\x06\n" +
	"\x04_strB\x06\n" +
	"\x04_loc\"\xe6\x01\n" +
	"\aBitExpr\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_XKR\x04kind\x12(\n" +
	"\x04opr1\x18\x02 \x01(\v2\x0f.spir.BitEntityH\x00R\x04opr1\x88\x01\x01\x12(\n" +
	"\x04opr2\x18\x03 \x01(\v2\x0f.spir.BitEntityH\x01R\x04opr2\x88\x01\x01\x12%\n" +
	"\x05exprs\x18\x04 \x03(\v2\x0f.spir.BitEntityR\x05exprs\x12&\n" +
	"\x03loc\x18\x05 \x01(\v2\x0f.spir.BitSrcLocH\x02R\x03loc\x88\x01\x01B\a\n" +
	"\x05_opr1B\a\n" +
	"\x05_opr2B\x06\n" +
	"\x04_loc\"\x85\x01\n" +
	"\aBitInsn\x12\x1e\n" +
	"\x04kind\x18\x01 \x01(\x0e2\n" +
	".spir.K_IKR\x04kind\x12$\n" +
	"\x03rhs\x18\x02 \x01(\v2\r.spir.BitExprH\x00R\x03rhs\x88\x01\x01\x12$\n" +
	"\x03lhs\x18\x03 \x01(\v2\r.spir.BitExprH\x01R\x03lhs\x88\x01\x01B\x06\n" +
	"\x04_rhsB\x06\n" +
	"\x04_lhs*\x83\x02\n" +
	"\x04K_EK\x12\b\n" +
	"\x04NONE\x10\x00\x12\a\n" +
	"\x03VAR\x10\x01\x12\x0e\n" +
	"\n" +
	"VAR_GLOBAL\x10\x02\x12\v\n" +
	"\aVAR_TMP\x10\x03\x12\v\n" +
	"\aVAR_SSA\x10\x04\x12\x0e\n" +
	"\n" +
	"VAR_PSEUDO\x10\x05\x12\v\n" +
	"\aLIT_NUM\x10\x06\x12\x0f\n" +
	"\vLIT_NUM_IMM\x10\a\x12\v\n" +
	"\aLIT_STR\x10\b\x12\x0e\n" +
	"\n" +
	"VALUE_TYPE\x10\t\x12\b\n" +
	"\x04FUNC\x10\n" +
	"\x12\x11\n" +
	"\rFUNC_VAR_ARGS\x10\v\x12\t\n" +
	"\x05CLASS\x10\f\x12\t\n" +
	"\x05LABEL\x10\r\x12\b\n" +
	"\x04ENT1\x10\x0e\x12\b\n" +
	"\x04ENT2\x10\x0f\x12\b\n" +
	"\x04INSN\x10\x10\x12\x06\n" +
	"\x02BB\x10\x11\x12\a\n" +
	"\x03CFG\x10\x12\x12\t\n" +
	"\x05SCOPE\x10\x13\x12\x06\n" +
	"\x02TU\x10\x14*\xfb\x01\n" +
	"\x04K_IK\x12\b\n" +
	"\x04INOP\x10\x00\x12\f\n" +
	"\bIBARRIER\x10\x01\x12\x10\n" +
	"\fIASGN_SIMPLE\x10\x02\x12\r\n" +
	"\tIASGN_BOP\x10\x03\x12\r\n" +
	"\tIASGN_UOP\x10\x04\x12\x13\n" +
	"\x0fIASGN_RHS_DEREF\x10\x05\x12\x13\n" +
	"\x0fIASGN_LHS_DEREF\x10\x06\x12\x13\n" +
	"\x0fIASGN_RHS_ARRAY\x10\a\x12\x13\n" +
	"\x0fIASGN_LHS_ARRAY\x10\b\x12\x0e\n" +
	"\n" +
	"IASGN_CALL\x10\t\x12\r\n" +
	"\tIASGN_PHI\x10\n" +
	"\x12\t\n" +
	"\x05ICALL\x10\v\x12\t\n" +
	"\x05IGOTO\x10\f\x12\t\n" +
	"\x05ICOND\x10\r\x12\n" +
	"\n" +
	"\x06ILABEL\x10\x0e\x12\v\n" +
	"\aIRETURN\x10\x0f*\xcc\x02\n" +
	"\x04K_XK\x12\a\n" +
	"\x03NIL\x10\x00\x12\a\n" +
	"\x03VAL\x10\x01\x12\a\n" +
	"\x03ADD\x10\x02\x12\a\n" +
	"\x03SUB\x10\x03\x12\a\n" +
	"\x03MUL\x10\x04\x12\a\n" +
	"\x03DIV\x10\x05\x12\a\n" +
	"\x03MOD\x10\x06\x12\a\n" +
	"\x03AND\x10\a\x12\x06\n" +
	"\x02OR\x10\b\x12\a\n" +
	"\x03XOR\x10\t\x12\a\n" +
	"\x03SHL\x10\n" +
	"\x12\a\n" +
	"\x03SHR\x10\v\x12\b\n" +
	"\x04SHRL\x10\f\x12\v\n" +
	"\aBIT_NOT\x10\r\x12\n" +
	"\n" +
	"\x06NEGATE\x10\x0e\x12\a\n" +
	"\x03NOT\x10\x0f\x12\t\n" +
	"\x05DEREF\x10\x10\x12\n" +
	"\n" +
	"\x06ADDROF\x10\x11\x12\n" +
	"\n" +
	"\x06SIZEOF\x10\x12\x12\v\n" +
	"\aALIGNOF\x10\x13\x12\x13\n" +
	"\x0fARRAY_SUBSCRIPT\x10\x14\x12\x11\n" +
	"\rMEMBER_ACCESS\x10\x15\x12\x15\n" +
	"\x11MEMBER_PTR_ACCESS\x10\x16\x12\b\n" +
	"\x04CALL\x10\x17\x12\n" +
	"\n" +
	"\x06CALL_0\x10\x18\x12\b\n" +
	"\x04CAST\x10\x19\x12\x06\n" +
	"\x02EQ\x10\x1a\x12\x06\n" +
	"\x02NE\x10\x1b\x12\x06\n" +
	"\x02LT\x10\x1c\x12\x06\n" +
	"\x02LE\x10\x1d*\x8c\x03\n" +
	"\x04K_VK\x12\b\n" +
	"\x04VOID\x10\x00\x12\b\n" +
	"\x04CHAR\x10\x01\x12\b\n" +
	"\x04INT8\x10\x02\x12\t\n" +
	"\x05INT16\x10\x03\x12\t\n" +
	"\x05INT32\x10\x04\x12\t\n" +
	"\x05INT64\x10\x05\x12\t\n" +
	"\x05UINT8\x10\x06\x12\t\n" +
	"\x05UCHAR\x10\x06\x12\n" +
	"\n" +
	"\x06UINT16\x10\a\x12\n" +
	"\n" +
	"\x06UINT32\x10\b\x12\n" +
	"\n" +
	"\x06UINT64\x10\t\x12\n" +
	"\n" +
	"\x06N_BITS\x10\n" +
	"\x12\v\n" +
	"\aN_UBITS\x10\v\x12\b\n" +
	"\x04BOOL\x10\f\x12\v\n" +
	"\aFLOAT16\x10\r\x12\v\n" +
	"\aFLOAT32\x10\x0e\x12\t\n" +
	"\x05FLOAT\x10\x0e\x12\v\n" +
	"\aFLOAT64\x10\x0f\x12\n" +
	"\n" +
	"\x06DOUBLE\x10\x0f\x12\x0f\n" +
	"\vPTR_TO_VOID\x10\x10\x12\x0e\n" +
	"\n" +
	"PTR_TO_PTR\x10\x11\x12\x0e\n" +
	"\n" +
	"PTR_TO_ARR\x10\x12\x12\x0f\n" +
	"\vPTR_TO_CHAR\x10\x13\x12\x0e\n" +
	"\n" +
	"PTR_TO_INT\x10\x14\x12\x10\n" +
	"\fPTR_TO_FLOAT\x10\x15\x12\x11\n" +
	"\rPTR_TO_RECORD\x10\x16\x12\x0f\n" +
	"\vPTR_TO_FUNC\x10\x17\x12\a\n" +
	"\x03ARR\x10\x18\x12\t\n" +
	"\x05UNION\x10\x19\x12\n" +
	"\n" +
	"\x06STRUCT\x10\x1a\x1a\x02\x10\x01*\xb2\x01\n" +
	"\x04K_QK\x12\t\n" +
	"\x05QNONE\x10\x00\x12\n" +
	"\n" +
	"\x06QCONST\x10\x01\x12\x0f\n" +
	"\vQCONST_DEST\x10\x02\x12\x10\n" +
	"\fQFUNC_STATIC\x10\x04\x12\x12\n" +
	"\x0eQGLOBAL_STATIC\x10\b\x12\r\n" +
	"\tQVOLATILE\x10\x10\x12\t\n" +
	"\x05QWEAK\x10 \x12\x11\n" +
	"\rQTHREAD_LOCAL\x10@\x12\r\n" +
	"\bQNO_INIT\x10\x80\x01\x12\x0e\n" +
	"\tQEXTERNAL\x10\x80\x02\x12\f\n" +
	"\aQNO_DEF\x10\x80\x02\x1a\x02\x10\x01B\bZ\x06./spirb\x06proto3"

var (
	file_span_pkg_spir_spir_proto_rawDescOnce sync.Once
	file_span_pkg_spir_spir_proto_rawDescData []byte
)

func file_span_pkg_spir_spir_proto_rawDescGZIP() []byte {
	file_span_pkg_spir_spir_proto_rawDescOnce.Do(func() {
		file_span_pkg_spir_spir_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)))
	})
	return file_span_pkg_spir_spir_proto_rawDescData
}

var file_span_pkg_spir_spir_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_span_pkg_spir_spir_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_span_pkg_spir_spir_proto_goTypes = []any{
	(K_EK)(0),            // 0: spir.K_EK
	(K_IK)(0),            // 1: spir.K_IK
	(K_XK)(0),            // 2: spir.K_XK
	(K_VK)(0),            // 3: spir.K_VK
	(K_QK)(0),            // 4: spir.K_QK
	(*BitSrcLoc)(nil),    // 5: spir.BitSrcLoc
	(*BitTU)(nil),        // 6: spir.BitTU
	(*BitFunc)(nil),      // 7: spir.BitFunc
	(*BitValueType)(nil), // 8: spir.BitValueType
	(*BitEntity)(nil),    // 9: spir.BitEntity
	(*BitExpr)(nil),      // 10: spir.BitExpr
	(*BitInsn)(nil),      // 11: spir.BitInsn
	nil,                  // 12: spir.BitTU.EntitiesEntry
	nil,                  // 13: spir.BitTU.EntityTypesEntry
}
var file_span_pkg_spir_spir_proto_depIdxs = []int32{
	12, // 0: spir.BitTU.entities:type_name -> spir.BitTU.EntitiesEntry
	13, // 1: spir.BitTU.entityTypes:type_name -> spir.BitTU.EntityTypesEntry
	7,  // 2: spir.BitTU.functions:type_name -> spir.BitFunc
	11, // 3: spir.BitFunc.insns:type_name -> spir.BitInsn
	3,  // 4: spir.BitValueType.kind:type_name -> spir.K_VK
	4,  // 5: spir.BitValueType.qtype:type_name -> spir.K_QK
	8,  // 6: spir.BitValueType.subType:type_name -> spir.BitValueType
	8,  // 7: spir.BitValueType.types:type_name -> spir.BitValueType
	0,  // 8: spir.BitEntity.kind:type_name -> spir.K_EK
	5,  // 9: spir.BitEntity.loc:type_name -> spir.BitSrcLoc
	2,  // 10: spir.BitExpr.kind:type_name -> spir.K_XK
	9,  // 11: spir.BitExpr.opr1:type_name -> spir.BitEntity
	9,  // 12: spir.BitExpr.opr2:type_name -> spir.BitEntity
	9,  // 13: spir.BitExpr.exprs:type_name -> spir.BitEntity
	5,  // 14: spir.BitExpr.loc:type_name -> spir.BitSrcLoc
	1,  // 15: spir.BitInsn.kind:type_name -> spir.K_IK
	10, // 16: spir.BitInsn.rhs:type_name -> spir.BitExpr
	10, // 17: spir.BitInsn.lhs:type_name -> spir.BitExpr
	9,  // 18: spir.BitTU.EntitiesEntry.value:type_name -> spir.BitEntity
	8,  // 19: spir.BitTU.EntityTypesEntry.value:type_name -> spir.BitValueType
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_span_pkg_spir_spir_proto_init() }
func file_span_pkg_spir_spir_proto_init() {
	if File_span_pkg_spir_spir_proto != nil {
		return
	}
	file_span_pkg_spir_spir_proto_msgTypes[3].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[4].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[5].OneofWrappers = []any{}
	file_span_pkg_spir_spir_proto_msgTypes[6].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_span_pkg_spir_spir_proto_rawDesc), len(file_span_pkg_spir_spir_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_span_pkg_spir_spir_proto_goTypes,
		DependencyIndexes: file_span_pkg_spir_spir_proto_depIdxs,
		EnumInfos:         file_span_pkg_spir_spir_proto_enumTypes,
		MessageInfos:      file_span_pkg_spir_spir_proto_msgTypes,
	}.Build()
	File_span_pkg_spir_spir_proto = out.File
	file_span_pkg_spir_spir_proto_goTypes = nil
	file_span_pkg_spir_spir_proto_depIdxs = nil
}

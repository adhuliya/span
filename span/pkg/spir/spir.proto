// Version = 0.0.1
// Note of caution: *The sequence of enum values may be significant.*

// To compile this proto file, run from project root:
// protoc --go_out=. --go_opt=paths=source_relative span/pkg/spir/spir.proto
// protoc --cpp_out=slang/src --proto_path=span/pkg/spir span/pkg/spir/spir.proto
// or run the Makefile target "gen-proto" from project root.

syntax = "proto3";
package spir;

option go_package = "./spir";

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
enum K_EK {
	// Entity kinds which can be in an expression (4 bit values)
	NONE			= 0;  // No entity
	VAR				= 1;  // An uncategorized variable.
	VAR_GLBL		= 2;  // A global variable, function etc.
	VAR_LOCL		= 3;  // Local variables in a function scope
	VAR_STATIC_LOCL	= 4;  // Static local variables in a function scope
	VAR_TMP			= 5;  // Temporary varibles created when creating SPAN IR.
	VAR_SSA			= 6;  // An SSA variable; assigned only once.
	VAR_PSEUDO		= 7;  // To give special names to, for e.g., memory allocations.
	LIT_NUM			= 8;  // A numeric literal.
	LIT_NUM_IMM		= 9;  // A numeric litreal with immediate value.
	LIT_STR			= 10; // A string literal.
	DATA_TYPE		= 11; // A data type, like int, float, function sig, record, class etc.
	FUNC			= 12; // A function with/without definition.
	FUNC_VARGS		= 13; // A function with var args like printf().
	LABEL			= 14; // In if-then-else statements.
	OTHER			= 15; // Other entity kind - for future use.

	// Entity kinds which cannot be in an expression (5 bit values)
	INSN	= 16;
	BB		= 17;
	CFG		= 18;
	SCOPE	= 19;
	TU		= 20;
}

// Instruction kinds.
// All values must fit in 5 bits.
enum K_IK {
	INOP         = 0; // No-operation - Connects two program points
	IBARRIER     = 1; // Disconnects two program points (no information flow)

	IASGN_SIMPLE = 2; // Simple assignment (no operator)
	IASGN_RHS_OP = 3; // RHS operator assignment
	IASGN_LHS_OP = 4; // LHS operator assignment
	IASGN_CALL   = 5; // Call assignment
	IASGN_PHI    = 6; // Phi assignment.

	ICALL  = 7; // Call instruction
	IGOTO  = 8; // Goto instruction
	ICOND  = 9; // IF-THEN-ELSE instruction
	ILABEL = 10; // Label instruction

	IRETURN = 11; // Return instruction
}

// Expression kinds.
// All values must fit in 5 bits.
enum K_XK {
	// Expression kinds that can be used in expressions
	NIL = 0; // Shows that there is no expression present
	VAL = 1; // A single value type: a constant, variable or function

	ADD = 2; // A binary addition expression
	SUB = 3; // A binary subtraction expression
	MUL = 4; // A binary multiplication expression
	DIV = 5; // A binary division expression
	MOD = 6; // A binary modulo expression

	AND	 = 7;  // A binary AND expression
	OR	 = 8;  // A binary OR expression
	XOR	 = 9;  // A binary XOR expression
	SHL	 = 10; // A binary shift left expression
	SHR	 = 11; // A binary shift right expression
	SHRL = 12; // A binary shift right logical expression

	EQ = 13; // Equality comparison (binary expr).
	NE = 14; // Inequality comparison (binary expr).
	LT = 15; // Less than comparison (binary expr).
	GE = 16; // Greater than or equal to comparison (binary expr).

	ARRAY_INDEX			= 17; // An array index expression (binary expr)
	MEMBER_ACCESS		= 18; // A member access expression (binary expr)
	MEMBER_PTR_ACCESS	= 19; // A member pointer access expression (binary expr)
	MEMBER_PTR_ADDROF	= 20; // A member pointer address expression (unary expr)

	CALL	= 21; // A function call expression (all arguments may be stored separately)
	CALL_0	= 22; // A call with zero arguments

	CAST	= 23; // A cast expression

	BIT_NOT = 24; // A unary bitwise NOT expression
	NEGATE	= 25; // A unary minus expression
	NOT		= 26; // A unary logical NOT expression

	DEREF	= 27; // A dereference expression (unary expr)
	ADDROF	= 28; // An address expression (unary expr)

	SIZEOF	= 29; // A sizeof expression
	ALIGNOF	= 30; // An alignof expression

	OTHER_EXPR = 31; // Other expression.
}

// Value kinds, i.e. the data types.
// All values must fit in 5 bits.
enum K_VK {
	option allow_alias = true;
	VOID		= 0;
	CHAR		= 1;
	INT8		= 2;
	INT16		= 3;
	INT32		= 4;
	INT64		= 5;
	UINT8		= 6;
	UCHAR		= 6; // UINT8
	UINT16		= 7;
	UINT32		= 8;
	UINT64		= 9;
	CHAR16		= 7; // UINT16
	WCHAR		= 8; // UINT32
	CHAR32		= 8; // UINT32
	N_BITS		= 10;
	N_UBITS		= 11;
	BOOL		= 12;

	FLOAT16		= 13;
	FLOAT32		= 14;
	FLOAT		= 14; // FLOAT32
	FLOAT64		= 15;
	DOUBLE		= 15; // FLOAT64
	LONG_DOUBLE	= 16; // 80-bit extended precision floating point

	PTR				= 17; // An unclassified pointer
	PTR_TO_VOID		= 18;
	PTR_TO_PTR		= 19; 
	PTR_TO_ARR		= 20; // A pointer to an array type
	PTR_TO_CHAR		= 21; // A pointer to any of the char types (possible overlap with INT)
	PTR_TO_INT		= 22; // A pointer to any of the integer types
	PTR_TO_FLOAT	= 23; // A pointer to any of the float types
	PTR_TO_RECORD	= 24; // A pointer to a struct or a union
	PTR_TO_FUNC		= 25; // A pointer to a function type

	ARR_FIXED		= 26; // An array with a fixed size known at compile time (e.g. "int x[10]")
	ARR_VARIABLE	= 27; // An array with a variable size determined at runtime
	ARR_PARTIAL		= 28; // An array with partially known size, e.g. "char[][32] x"

	UNION	= 29; // An unclassified union (a record)
	STRUCT	= 30; // An unclassified struct (a record)

	OTHER_TYPE	= 31; // Other value type
}

// All values must fit in 16 bits.
enum K_QK {
	QNONE         = 0;    // No qualifiers
	QCONST        = 1;    // Constant: e.g. "const int x = 10"
	QCONST_DEST   = 2;    // Constant pointee: e.g. "const int* x = &y"
	QFUNC_STATIC  = 4;    // A static function
	QGLBL_STATIC  = 8;    // A static global variable
	QVOLATILE     = 16;   // A volatile variable
	QWEAK         = 32;   // A weak variable
	QTHREAD_LOCAL = 64;   // A thread local variable
	QNO_INIT      = 128;  // A variable with no initializer
	QEXTERNAL     = 256;  // An external variable
	QNO_DEF       = 512;  // An entity with no definition (e.g. a function, class etc.)

	QRESTRICT     = 1024; // Restrict qualifier for pointers (e.g. "restrict int* x")
	QINLINE       = 2048; // Inline function qualifier (e.g. "inline int f()")
	QATOMIC       = 4096; // Atomic type qualifier (C11) (e.g. "atomic<int> x")
	QREGISTER     = 8192; // Register storage class (e.g. "register int x")

	QOTHER				= 16384; // Other qualifier (e.g. "noalias int* x")
}

// The location of an entity.
message BitSrcLoc {
	uint32 line = 1;
	uint32 col = 2;
}

// The type of an entity.
// It is a recursive data type, capable of representing all types in C.
message BitDataType {
	K_VK kind = 1;
	optional uint64 typeId = 2; // The id to the type present in BitTU.entityInfo map.

	optional uint32 qtype = 3; // Bitwise OR of one or more K_QK values
	// Colon separated attributes of the type (e.g. "packed:aligned(8)", etc.)
	// These are extra attributes not present in qtype
	optional string attributes = 4; 

	// The logical length of the type (e.g. length of an array)
	// Or number of bits in the type (for bit fields and built-in types)
	optional uint32 len   = 5;
	optional uint32 align = 6; // Number of bytes to align to

	// Used for,
	//   1. Pointee of a pointer.
	//   2. Element of an array.
	//   3. Return type of a function.
	optional BitDataType subType = 7;

	// Used to name the record or other special types
	optional string typeName = 8;
	optional bool anonymous  = 9;

	// Used for record and function types
	// length of names and types sequences must be the same
	repeated string names = 10; // A hyphen '-' for anonymous fields.
	repeated BitDataType types = 11;

	optional bool variadic = 12; // Whether the function is variadic
	optional BitSrcLoc loc = 13; // location of the record types in the source file
}

message BitEntityInfo {
	uint64 id = 1; // Entity id
	K_EK kind = 2;
	optional BitDataType dt = 3;
	// Store value if entity is a constant value.
	optional uint64 numVal = 4; // for a numeric literal (int, float, etc.)
	optional string strVal = 5; // for a string literal or entity name
	optional BitSrcLoc loc = 6; // location of the entity in the source file
}

// A single entity like a variable, constant etc.
message BitEntity {
	uint64 id = 1; // Entity id
	optional BitSrcLoc loc = 2;
}

// A unary, binary, and call expressions.
message BitExpr {
	K_XK kind = 1;
	optional BitEntity opr1 = 2;
	optional BitEntity opr2 = 3;
	// More expressions, e.g. call arguments, array subscript, etc.
	repeated BitEntity oprs = 4;
	optional BitSrcLoc loc = 5;
}

// All kinds of instructions.
// Either expr1 or expr2 or both may be missing depending on the instruction type.
message BitInsn {
	K_IK kind = 1;
	optional BitExpr expr1 = 2;
	optional BitExpr expr2 = 3;
	optional BitSrcLoc loc = 4;
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//   void 00_inits()
message BitFunc {
	uint64 id = 1; // The type info is placed in BitTU.entityInfo map.
	bool is_variadic = 2; // Whether the function is variadic
	string name = 3;
	optional string calling_convention = 4; // e.g. "cdecl", "stdcall", "fastcall", "thiscall", "vectorcall"
	repeated BitInsn insns = 5; // Instructions in the function
	repeated uint64 locals = 6; // 64 bit EntityId of locals
}

// The Translation Unit.
// It contains all the entities in a TU. E.g. functions, variables, etc.
message BitTU {
	string name = 1;
	optional string directory = 2; // Path to the source file TU was generated from
	optional string origin = 3; // Origin of the TU, e.g. "Clang AST"
	map<string, BitEntity> entities = 4; // name to entity id mapping
	map<uint64, BitEntityInfo> entityInfo = 5;
	repeated BitFunc functions = 6;
}
// Version = 0.0.1
// Note of caution: *The seqeunce of enum values may be significant.*

syntax = "proto3";
package spir;

option go_package = "./spir";

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
enum K_EK {
	// Entity kinds which can be in an expression (4 bit values)
	NONE			= 0; // No entity
	VAR				= 1;  // An uncategorized variable.
	VAR_GLBL		= 2;  // A global variable, function etc.
	VAR_STATIC_LOCL	= 3;  // To give special names to, for e.g., memory allocations.
	VAR_LOCL		= 4;  // Local variables in a function scope
	VAR_TMP			= 5;  // Temporary varibles created when creating SPAN IR.
	VAR_SSA			= 6;  // An SSA variable; assigned only once.
	VAR_PSEUDO		= 7;  // To give special names to, for e.g., memory allocations.
	LIT_NUM			= 8;  // A numeric literal.
	LIT_NUM_IMM		= 9;  // A numeric litreal with immediate value.
	LIT_STR			= 10; // A string literal.
	DATA_TYPE		= 11; // A data type, like int, float, function sig, record etc.
	FUNC			= 12; // A function with/without definition.
	FUNC_VARGS		= 13; // A function with var args like printf().
	CLASS			= 14; // A class type; for future use.
	LABEL			= 15; // In if-then-else statements.

	// Entity kinds which cannot be in an expression (5 bit values)
	INSN	= 16;
	BB		= 17;
	CFG		= 18;
	SCOPE	= 19;
	TU		= 20;
}

// Instruction kinds.
// All values must fit in 5 bits.
enum K_IK {
	INOP            = 0;  // No-operation
	IBARRIER        = 1;  // Disconnects two program points.
	IASGN_SIMPLE    = 2;  // Simple assignment.
	IASGN_BOP       = 3;  // Binary operation assignment.
	IASGN_UOP       = 4;  // Unary operation assignment.
	IASGN_RHS_DEREF = 5;  // RHS dereference assignment.
	IASGN_LHS_DEREF = 6;  // LHS dereference assignment.
	IASGN_RHS_ARRAY = 7;  // RHS array assignment.
	IASGN_LHS_ARRAY = 8;  // LHS array assignment.
	IASGN_CALL      = 9;  // Call assignment.
	IASGN_PHI       = 10; // Phi assignment.

	ICALL 	= 11; // Call instruction
	IGOTO 	= 12; // Goto instruction
	ICOND 	= 13; // IF-THEN-ELSE instruction
	ILABEL 	= 14; // Label instruction

	IRETURN = 15; // Return instruction.
}

// Expression kinds.
// All values must fit in 5 bits.
enum K_XK {
	// Expression kinds that can be used in expressions
	NIL = 0; // Shows that there is no expression present
	VAL = 1; // A single value type: a constant, variable or function

	ADD = 2; // A binary addition expression
	SUB = 3; // A binary subtraction expression
	MUL = 4; // A binary multiplication expression
	DIV = 5; // A binary division expression
	MOD = 6; // A binary modulo expression

	AND	 = 7;  // A binary AND expression
	OR	 = 8;  // A binary OR expression
	XOR	 = 9;  // A binary XOR expression
	SHL	 = 10; // A binary shift left expression
	SHR	 = 11; // A binary shift right expression
	SHRL = 12; // A binary shift right logical expression

	BIT_NOT = 13; // A unary bitwise NOT expression
	NEGATE	= 14; // A unary minus expression
	NOT			= 15; // A unary logical NOT expression

	DEREF		= 16; // A dereference expression
	ADDROF	= 17; // An address expression

	SIZEOF	= 18; // A sizeof expression
	ALIGNOF	= 19; // An alignof expression

	ARRAY_SUBSCRIPT	  = 20; // An array subscript expression
	MEMBER_ACCESS	  	= 21; // A member access expression
	MEMBER_PTR_ACCESS = 22; // A member pointer access expression

	CALL		= 23; // A function call expression (all arguments may be stored separately)
	CALL_0	= 24; // A call with zero arguments
	CALL_1	= 25; // A call with exactly one argument
	CAST		= 26; // A cast expression

	EQ = 27; // Equality comparison.
	NE = 28; // Inequality comparison.
	LT = 29; // Less than comparison.
	GE = 30; // Greater than or equal to comparison.

	XOTHER = 31; // Other expression.
}

// Value kinds, i.e. the data types.
// All values must fit in 5 bits.
enum K_VK {
	option allow_alias = true;
	VOID			= 0;
	CHAR			= 1;
	INT8			= 2;
	INT16			= 3;
	INT32			= 4;
	INT64			= 5;
	UINT8			= 6;
	UCHAR			= 6; // UINT8
	UINT16		= 7;
	UINT32		= 8;
	UINT64		= 9;
	CHAR16		= 7; // UINT16
	WCHAR			= 8; // UINT32
	CHAR32		= 8; // UINT32
	N_BITS		= 10;
	N_UBITS		= 11;
	BOOL			= 12;

	FLOAT16		= 13;
	FLOAT32		= 14;
	FLOAT			= 14; // FLOAT32
	FLOAT64		= 15;
	DOUBLE		= 15; // FLOAT64
	LONG_DOUBLE		= 16; // 80-bit extended precision floating point

	PTR						= 17; // An unclassified pointer
	PTR_TO_VOID		= 18;
	PTR_TO_PTR		= 19; 
	PTR_TO_ARR		= 20; // A pointer to an array type
	PTR_TO_CHAR		= 21; // A pointer to any of the char types (possible overlap with INT)
	PTR_TO_INT		= 22; // A pointer to any of the integer types
	PTR_TO_FLOAT	= 23; // A pointer to any of the float types
	PTR_TO_RECORD	= 24; // A pointer to a struct or a union
	PTR_TO_FUNC		= 25; // A pointer to a function type

	ARR_FIXED			= 26; // An array with a fixed size known at compile time (e.g. "int x[10]")
	ARR_VARIABLE	= 27; // An array with a variable size determined at runtime
	ARR_PARTIAL		= 28; // An array with partially known size, e.g. "char[][32] x"

	UNION		= 29; // An unclassified union (a record)
	STRUCT	= 30; // An unclassified struct (a record)

	VALUE_OTHER	= 31; // Other value type
}

// All values must fit in 16 bits.
enum K_QK {
	QNONE         = 0;    // No qualifiers
	QCONST        = 1;    // Constant: e.g. "const int x = 10"
	QCONST_DEST   = 2;    // Constant pointee: e.g. "const int* x = &y"
	QFUNC_STATIC  = 4;    // A static function
	QGLBL_STATIC  = 8;    // A static global variable
	QVOLATILE     = 16;   // A volatile variable
	QWEAK         = 32;   // A weak variable
	QTHREAD_LOCAL = 64;   // A thread local variable
	QNO_INIT      = 128;  // A variable with no initializer
	QEXTERNAL     = 256;  // An external variable
	QNO_DEF       = 512;  // An entity with no definition (e.g. a function, class etc.)

	QRESTRICT     = 1024; // Restrict qualifier for pointers (e.g. "restrict int* x")
	QINLINE       = 2048; // Inline function qualifier (e.g. "inline int f()")
	QATOMIC       = 4096; // Atomic type qualifier (C11) (e.g. "atomic<int> x")
	QREGISTER     = 8192; // Register storage class (e.g. "register int x")

	QOTHER				= 16384; // Other qualifier (e.g. "noalias int* x")
}

// The location of an entity.
message BitSrcLoc {
	uint32 line = 1;
	uint32 col = 2;
}

// The type of an entity.
// It is a recursive data type, capable of representing all types in C.
message BitDataType {
	K_VK kind = 1;
	optional uint64 typeId = 2; // The id to the type present in BitTU.entityInfo map.

	optional uint32 qtype = 3; // Bitwise OR of one or more K_QK values
	// Colon separated attributes of the type (e.g. "packed:aligned(8)", etc.) not in qtype
	optional string attributes = 4; 

	optional uint32 bits  = 5; // Number of bits in the type (for bit fields)
	optional uint32 size  = 6; // The logical size of the type (e.g. length of an array)
	optional uint32 align = 7; // Number of bytes to align to

	// Used for,
	//   1. Pointee of a pointer.
	//   2. Element of an array.
	//   3. Return type of a function.
	optional BitDataType subType = 8;

	// Used to name the record or other special types
	optional string str = 9;

	// Used for record and function types
	// size of names and types must be the same
	repeated string names = 10;
	repeated BitDataType types = 11;
}

message BitEntityInfo {
	K_EK kind = 1;
	optional BitDataType dt = 2;
	// Store value if entity is a constant value.
	optional uint64 num = 3; // for a numeric literal (int, float, etc.)
	optional string str = 4; // for a string literal (for LIT_STR)
}

// A single entity like a variable, constant etc.
message BitEntity {
	uint64 id = 1;
	optional BitSrcLoc loc = 2;
}

// A unary, binary, and call expressions.
message BitExpr {
	K_XK kind = 1;
	optional BitEntity opr1 = 2;
	optional BitEntity opr2 = 3;
	optional BitSrcLoc loc = 4;
	// More expressions, e.g. call arguments, array subscript, etc.
	repeated BitEntity exprs = 5;
}

// All kinds of instructions.
// Either expr1 or expr2 or both may be missing depending on the instruction type.
message BitInsn {
	K_IK kind = 1;
	optional BitExpr expr1 = 2;
	optional BitExpr expr2 = 3;
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//   void __span_global_inits()
message BitFunc {
	uint64 id = 1; // The type info is placed in BitTU.entityInfo map.
	bool is_variadic = 2; // Whether the function is variadic
	string name = 3;
	optional string calling_convention = 4; // e.g. "cdecl", "stdcall", "fastcall", "thiscall", "vectorcall"
	repeated BitInsn insns = 5; // Instructions in the function
	repeated uint64 locals = 6; // 64 bit EntityId of locals
}

// The Translation Unit.
// It contains all the entities in a TU. E.g. functions, variables, etc.
message BitTU {
	string name = 1;
	optional string path = 2; // Path to the source file TU was generated from
	map<string, BitEntity> entities = 3; // name to entity id mapping
	map<uint64, BitEntityInfo> entityInfo = 4;
	repeated BitFunc functions = 5;
}
// Version = 0.0.1
// Note of caution: *The sequence of enum values may be significant.*

// To compile this proto file, run from project root:
// protoc --go_out=. --go_opt=paths=source_relative span/pkg/spir/spir.proto
// protoc --cpp_out=slang/src --proto_path=span/pkg/spir span/pkg/spir/spir.proto
// or run the Makefile target "gen-proto" from project root.

syntax = "proto3";
package spir;

option go_package = "./spir";

// The EntityKind or K_EK type is used to represent the kind of an entity in the SPAN IR.
// It is an integer type in the range of 0 to 31 (5 bits)
// that can take on various values to indicate different kinds of entities.
enum K_EK {
	// Entity kinds which can be in an expression (4 bit values)
	ENIL 				= 0;  // No entity.
	EVAR_GLBL			= 1;  // A global variable.
	EVAR_LOCL			= 2;  // Local variables in a function body.
	EVAR_LOCL_ARG		= 3;  // A function argument variable.
	EVAR_LOCL_STATIC	= 4;  // Static local variables in a function body.
	EVAR_LOCL_TMP		= 5;  // Temporary varibles created when creating SPAN IR.
	EVAR_LOCL_SSA		= 6;  // An SSA variable; assigned only once.
	EVAR_LOCL_PSEUDO	= 7;  // To give special names to, for e.g., memory allocations.
	ELIT_NUM			= 8;  // A numeric literal.
	ELIT_NUM_IMM		= 9;  // A numeric literal with immediate value.
	ELIT_STR			= 10; // A string literal.
	EDATA_TYPE			= 11; // A data type, like int, function sig, record, class etc.
	EFUNC				= 12; // A function with/without definition.
	EFUNC_VARGS			= 13; // A function with varargs, e.g. printf().
	ELABEL				= 14; // A label in an if-then-else statement.
	EOTHER				= 15; // Other entity kind - used in case ID space is exhausted.

	// Entity kinds which cannot be in an expression (5 bit values)
	ERECORD_FIELD		= 16; // A field in a record
	EINSN				= 17; // An instruction.
	EBB					= 18; // A basic block.
	ECFG				= 19; // A control flow graph.
	ESCOPE				= 20; // A scope, e.g. a block scope.
	ETU					= 21; // A translation unit (TU).

	// More K_EK values can be dynamically created by SPAN, if the ID space is exhausted.
}

// Instruction kinds.
// All values must fit in 5 bits.
enum K_IK {
	INIL		 = 0; // No instruction
	INOP         = 1; // No-operation - Connects two program points
	IBARRIER     = 2; // Disconnects two program points (no information flow)

	IASGN_SIMPLE = 3; // Simple assignment (no operator)
	IASGN_RHS_OP = 4; // RHS operator assignment
	IASGN_LHS_OP = 5; // LHS operator assignment
	IASGN_CALL   = 6; // Call assignment
	IASGN_PHI    = 7; // Phi assignment.

	ICALL  = 8; // Call instruction
	IGOTO  = 9; // Goto instruction
	ICOND  = 10; // IF-THEN-ELSE instruction
	ILABEL = 11; // Label instruction (names a location in the code)

	IRETURN = 12; // Return instruction

	// More K_IK values can be dynamically created by SPAN, if the ID space is exhausted.
}

// Expression kinds.
// All values must fit in 5 bits.
enum K_XK {
	// Expression kinds that can be used in expressions
	XNIL = 0; // No expression
	XVAL = 1; // A unit expression, i.e. a constant, variable or function

	XADD = 2; // A binary addition expression
	XSUB = 3; // A binary subtraction expression
	XMUL = 4; // A binary multiplication expression
	XDIV = 5; // A binary division expression
	XMOD = 6; // A binary modulo expression

	XAND	= 7;  // A binary bit AND expression
	XOR		= 8;  // A binary bit OR expression
	XXOR	= 9;  // A binary bit XOR expression
	XSHL	= 10; // A binary shift left expression
	XSHR	= 11; // A binary shift right expression (logical)
	XSHRA	= 12; // A binary shift right expression (arithmetic)

	XEQ = 13; // Equality comparison (binary expr).
	XNE = 14; // Inequality comparison (binary expr).
	XLT = 15; // Less than comparison (binary expr).
	XGE = 16; // Greater than or equal to comparison (binary expr).
	// XGT and XLE can be represented using XLT and XGE respectively by reordering operands.

	XARRAY_INDEX		= 17; // An array index expression (binary expr)
	XMEMBER_ACCESS		= 18; // A member access expression (binary expr)
	XMEMBER_PTR_ACCESS	= 19; // A member pointer access expression (binary expr)
	XMEMBER_PTR_ADDROF	= 20; // A member pointer address expression (unary expr)

	XCALL	= 21; // A function call expression (all arguments may be stored separately)
	XCALL_0	= 22; // A call with zero arguments

	XCAST	= 23; // A cast expression

	XBIT_NOT = 24; // A unary bitwise NOT expression
	XNEGATE	 = 25; // A unary minus expression
	XNOT	 = 26; // A unary logical NOT expression

	XDEREF	= 27; // A dereference expression (unary expr)
	XADDROF	= 28; // An address expression (unary expr)

	XSIZEOF	 = 29; // A sizeof expression
	XALIGNOF = 30; // An alignof expression

	XOTHER  = 31; // Other expression.
}

// Value kinds, i.e. the data types.
// All values must fit in 5 bits.
enum K_VK {
	option allow_alias = true;
	TNIL		= 0;
	TVOID		= 0; // TNIL (no type)
	TCHAR		= 1;
	TINT8		= 2;
	TINT16		= 3;
	TINT32		= 4;
	TINT64		= 5;
	TUINT8		= 6;
	TUCHAR		= 6; // UINT8
	TUINT16		= 7;
	TUINT32		= 8;
	TUINT64		= 9;
	TCHAR16		= 7; // UINT16
	TWCHAR		= 8; // UINT32
	TCHAR32		= 8; // UINT32
	TN_BITS		= 10; // N signed bits
	TN_UBITS	= 11; // N unsigned bits
	TBOOL		= 12;

	TFLOAT16		= 13;
	TFLOAT32		= 14;
	TFLOAT			= 14; // FLOAT32
	TFLOAT64		= 15;
	TDOUBLE			= 15; // FLOAT64
	TFLOAT80		= 16; // 80-bit extended precision floating point
	TLONG_DOUBLE	= 16; // FLOAT80

	TPTR_TO_VOID	= 17; // An unclassified pointer
	TPTR_TO_PTR		= 18; 
	TPTR_TO_ARR		= 19; // A pointer to an array type
	TPTR_TO_CHAR	= 20; // A pointer to char type -- it identifies a C string
	TPTR_TO_INT		= 21; // A pointer to any of the integer types
	TPTR_TO_FLOAT	= 22; // A pointer to a float type
	TPTR_TO_RECORD	= 23; // A pointer to a struct or a union
	TPTR_TO_FUNC	= 24; // A pointer to a function type

	TARR_FIXED		= 25; // An array with a fixed size known at compile time (e.g. "int x[10]")
	TARR_VARIABLE	= 26; // An array with a variable size determined at runtime
	TARR_PARTIAL	= 27; // An array with partially known size, e.g. "char[][32] x"

	// Three record types: union, struct, class
	TUNION	= 28; // An unclassified union (a record)
	TSTRUCT	= 29; // An unclassified struct (a record)
	TCLASS  = 30; // A C++ class (for future use)

	TOTHER	= 31; // Other value type
}

// All values must fit in 16 bits.
enum K_QK {
	QNIL			= 0;    // No qualifiers
	QCONST			= 1;    // Constant: e.g. "const int x = 10"
	QCONST_DEST		= 2;    // Constant pointee: e.g. "const int* x = &y"
	QLOCL_STATIC	= 4;    // A static variable in a function body.
	QGLBL_STATIC	= 8;    // A static global function, variable or type.
	QVOLATILE		= 16;   // A volatile variable
	QWEAK			= 32;   // A weak variable
	QTHREAD_LOCAL	= 64;   // A thread local variable
	QNO_INIT		= 128;  // A variable with no initializer
	QEXTERNAL		= 256;  // An external variable
	QNO_DEF			= 512;  // An entity with no definition (e.g. a function, class etc.)

	QRESTRICT		= 1024; // Restrict qualifier for pointers (e.g. "restrict int* x")
	QINLINE			= 2048; // Inline function qualifier (e.g. "inline int f()")
	QATOMIC			= 4096; // Atomic type qualifier (C11) (e.g. "atomic<int> x")
	QREGISTER		= 8192; // Register storage class (e.g. "register int x")

    QRECORD_MEMBER	= 16384; // A member in a union, struct or a class.
	QOTHER			= 32768; // Other qualifier (e.g. "noalias int* x")
}

// The location of an entity.
message BitSrcLoc {
	uint32 line = 1;
	uint32 col  = 2;
}

// The type of an entity.
// It is a recursive data type, capable of representing all types in C.
message BitDataType {
	K_VK vkind						= 1;
	// The id to the type present in BitTU.entityInfo map.
	optional uint64 typeId			= 2; // also an entity id

	optional uint32 qtype			= 3; // Bitwise OR of one or more K_QK values
	// Colon separated attributes of the type (e.g. "packed:aligned(8)", etc.)
	// These are extra attributes not present in qtype
	optional string attributes		= 4; 

	// The logical length of the type (e.g. length of an array)
	// Or number of bits in the type (for bit fields and built-in types)
	optional uint32 len   			= 5;
	optional uint32 align 			= 6; // Number of bytes to align to

	// Used for,
	//   1. Pointee of a pointer.
	//   2. Element of an array.
	//   3. Return type of a function.
	optional BitDataType subType 	= 7;

	// Used to name the record or other special types
	optional string typeName 		= 8;
	optional bool anonymous			= 9;

	// Used for record fields and function parameters
	// length of fopIds and fopTypes sequences must be the same
	// Use hyphen '-' for anonymous fields and parameters (fop)
	repeated uint64 fopIds			= 10;
	repeated BitDataType fopTypes	= 11;

	optional bool variadic			= 12; // Whether the function is variadic
	optional BitSrcLoc loc			= 13; // location of the type definition
}

message BitEntityInfo {
	uint64 eid					= 1; // Entity id
	K_EK ekind					= 2;

	// Id of the parent if this entity is a record field or a function parameter
	optional uint64 parentId	= 3;
	optional BitDataType dt		= 4;

	// Store value if entity is a constant value.
	optional uint64 lowVal		= 5; // for a numeric literal (int, float, etc.)
	optional uint64 highVal		= 6; // Used for more than 64 bit numeric literal
	optional string strVal		= 7; // for a string literal or entity name

	optional BitSrcLoc loc  = 8; // location of the entity in the source file
}

// A single entity like a variable, constant etc.
message BitEntity {
	uint64 eid 				= 1; // Entity id
	optional BitSrcLoc loc 	= 2; // location of the entity's use in the source file
}

// A unary, binary, and call expressions.
message BitExpr {
	K_XK kind				= 1;
	optional BitEntity opr1 = 2;
	optional BitEntity opr2 = 3;
	// More expressions, e.g. call arguments, array subscript, etc.
	repeated BitEntity oprs	= 4;

	optional BitSrcLoc loc	= 5;
}

// All kinds of instructions.
// Either expr1 or expr2 or both may be missing depending on the instruction type.
message BitInsn {
	K_IK kind				= 1;
	optional BitExpr expr1	= 2;
	optional BitExpr expr2	= 3;
	optional BitSrcLoc loc	= 4;
}

// Functions in a Translation unit.
// All global initializations are put in a special function:
//   void 00_glbl_init()
message BitFunc {
	uint64 fid							= 1; // Function id (also an entity id)
	string fname						= 2; // Function name
	bool is_variadic					= 3; // Whether the function is variadic

    // Calling convention of the function,
	//   e.g. "cdecl", "stdcall", "fastcall", "thiscall", "vectorcall"
	optional string calling_convention	= 4;

	repeated BitInsn insns				= 5; // Instructions in the function
	repeated uint64 locals				= 6; // 64 bit EntityId of locals
}

// The Translation Unit.
// It contains all the entities in a TU. E.g. functions, variables, etc.
message BitTU {
	string tuName							= 1; // Translation unit name
	optional string absPath					= 2; // Absolute path to source file
	optional string origin					= 3; // Origin, e.g. "Clang AST"

	// Information about the entities
	map<string, uint64> namesToIds			= 4; // name to entity id mapping
	map<uint64, BitEntityInfo> entityInfo	= 5; // Type information of entities

	// Functions with definition
	repeated BitFunc functions				= 6;
}
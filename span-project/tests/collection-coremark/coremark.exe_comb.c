/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 110 "posix/core_portme.h"
typedef short ee_s16;
#line 111 "posix/core_portme.h"
typedef unsigned short ee_u16;
#line 112 "posix/core_portme.h"
typedef int ee_s32;
#line 114 "posix/core_portme.h"
typedef unsigned char ee_u8;
#line 115 "posix/core_portme.h"
typedef unsigned int ee_u32;
#line 280 "posix/core_portme.h"
struct CORE_PORTABLE_S {
   ee_u8 portable_id ;
};
#line 280 "posix/core_portme.h"
typedef struct CORE_PORTABLE_S core_portable;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 32 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 91 "./coremark.h"
struct list_data_s {
   ee_s16 data16 ;
   ee_s16 idx ;
};
#line 91 "./coremark.h"
typedef struct list_data_s list_data;
#line 97 "./coremark.h"
struct list_head_s {
   struct list_head_s *next ;
   struct list_data_s *info ;
};
#line 97 "./coremark.h"
typedef struct list_head_s list_head;
#line 106 "./coremark.h"
typedef ee_s16 MATDAT;
#line 107 "./coremark.h"
typedef ee_s32 MATRES;
#line 113 "./coremark.h"
struct MAT_PARAMS_S {
   int N ;
   MATDAT *A ;
   MATDAT *B ;
   MATRES *C ;
};
#line 113 "./coremark.h"
typedef struct MAT_PARAMS_S mat_params;
#line 137 "./coremark.h"
struct RESULTS_S {
   ee_s16 seed1 ;
   ee_s16 seed2 ;
   ee_s16 seed3 ;
   void *memblock[4] ;
   ee_u32 size ;
   ee_u32 iterations ;
   ee_u32 execs ;
   struct list_head_s *list ;
   mat_params mat ;
   ee_u16 crc ;
   ee_u16 crclist ;
   ee_u16 crcmatrix ;
   ee_u16 crcstate ;
   ee_s16 err ;
   core_portable port ;
};
#line 137 "./coremark.h"
typedef struct RESULTS_S core_results;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 73 "posix/core_portme.h"
typedef clock_t CORE_TICKS;
#line 117 "posix/core_portme.h"
typedef size_t ee_size_t;
#line 55 "./coremark.h"
typedef double secs_ret;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 116 "posix/core_portme.h"
typedef uintptr_t ee_ptr_int;
#line 123 "./coremark.h"
enum CORE_STATE {
    CORE_START = 0,
    CORE_INVALID = 1,
    CORE_S1 = 2,
    CORE_S2 = 3,
    CORE_INT = 4,
    CORE_FLOAT = 5,
    CORE_EXPONENT = 6,
    CORE_SCIENTIFIC = 7,
    NUM_CORE_STATES = 8
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 1 "cil-UjlmJqex.o"
#pragma merger("0","/tmp/cil-JPl82ndg.i","-O2")
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 333
__inline extern int __attribute__((__gnu_inline__))  vprintf(char const   * __restrict  __fmt ,
                                                             __gnuc_va_list __arg ) ;
#line 484
__inline extern int __attribute__((__gnu_inline__))  getchar(void) ;
#line 495
__inline extern int __attribute__((__gnu_inline__))  getc_unlocked(FILE *__fp ) ;
#line 496
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) ;
#line 506
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) ;
#line 524
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) ;
#line 537
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) ;
#line 545
__inline extern int __attribute__((__gnu_inline__))  putc_unlocked(int __c , FILE *__stream ) ;
#line 546
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  vprintf(char const   * __restrict  __fmt ,
                                                             __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
#line 38
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
#line 38
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) 
{ 


  {
#line 127
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 16) != 0));
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 134
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 32) != 0));
}
}
#line 75 "./coremark.h"
ee_u16 crc16(ee_s16 newval , ee_u16 crc ) ;
#line 76
ee_u16 crcu16(ee_u16 newval , ee_u16 crc ) ;
#line 166
list_head *core_list_init(ee_u32 blksize , list_head *memblock , ee_s16 seed ) ;
#line 167
ee_u16 core_bench_list(core_results *res , ee_s16 finder_idx ) ;
#line 171
ee_u16 core_bench_state(ee_u32 blksize , ee_u8 *memblock , ee_s16 seed1 , ee_s16 seed2 ,
                        ee_s16 step , ee_u16 crc ) ;
#line 183
ee_u16 core_bench_matrix(mat_params *p , ee_s16 seed , ee_u16 crc ) ;
#line 53 "core_list_join.c"
list_head *core_list_find(list_head *list , list_data *info ) ;
#line 54
list_head *core_list_reverse(list_head *list ) ;
#line 55
list_head *core_list_remove(list_head *item ) ;
#line 56
list_head *core_list_undo_remove(list_head *item_removed , list_head *item_modified ) ;
#line 58
list_head *core_list_insert_new(list_head *insert_point , list_data *info , list_head **memblock ,
                                list_data **datablock , list_head *memblock_end ,
                                list_data *datablock_end ) ;
#line 65
list_head *core_list_mergesort(list_head *list , ee_s32 (*cmp)(list_data *a , list_data *b ,
                                                               core_results *res ) ,
                               core_results *res ) ;
#line 69 "core_list_join.c"
ee_s16 calc_func(ee_s16 *pdata , core_results *res ) 
{ 
  ee_s16 data ;
  ee_s16 retval ;
  ee_u8 optype ;
  ee_s16 flag ;
  ee_s16 dtype ;
  ee_u16 tmp ;
  ee_u16 tmp___0 ;

  {
#line 72
  data = *pdata;
#line 74
  optype = (ee_u8 )(((int )data >> 7) & 1);
#line 77
  if (optype) {
#line 78
    return ((ee_s16 )((int )data & 127));
  } else {
#line 81
    flag = (ee_s16 )((int )data & 7);
#line 82
    dtype = (ee_s16 )(((int )data >> 3) & 15);
#line 85
    dtype = (ee_s16 )((int )dtype | ((int )dtype << 4));
#line 86
    switch ((int )flag) {
    case 0: 
#line 89
    if ((int )dtype < 34) {
#line 90
      dtype = (ee_s16 )34;
    }
#line 91
    tmp = core_bench_state(res->size, (ee_u8 *)res->memblock[3], res->seed1, res->seed2,
                           dtype, res->crc);
#line 91
    retval = (ee_s16 )tmp;
#line 97
    if ((int )res->crcstate == 0) {
#line 98
      res->crcstate = (ee_u16 )retval;
    }
#line 99
    break;
    case 1: 
#line 101
    tmp___0 = core_bench_matrix(& res->mat, dtype, res->crc);
#line 101
    retval = (ee_s16 )tmp___0;
#line 102
    if ((int )res->crcmatrix == 0) {
#line 103
      res->crcmatrix = (ee_u16 )retval;
    }
#line 104
    break;
    default: 
#line 106
    retval = data;
#line 107
    break;
    }
#line 109
    res->crc = crcu16((ee_u16 )retval, res->crc);
#line 110
    retval = (ee_s16 )((int )retval & 127);
#line 111
    *pdata = (ee_s16 )((((int )data & 65280) | 128) | (int )retval);
#line 112
    return (retval);
  }
}
}
#line 120 "core_list_join.c"
ee_s32 cmp_complex(list_data *a , list_data *b , core_results *res ) 
{ 
  ee_s16 val1 ;
  ee_s16 tmp ;
  ee_s16 val2 ;
  ee_s16 tmp___0 ;

  {
#line 123
  tmp = calc_func(& a->data16, res);
#line 123
  val1 = tmp;
#line 124
  tmp___0 = calc_func(& b->data16, res);
#line 124
  val2 = tmp___0;
#line 125
  return ((int )val1 - (int )val2);
}
}
#line 133 "core_list_join.c"
ee_s32 cmp_idx(list_data *a , list_data *b , core_results *res ) 
{ 


  {
#line 136
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 138
    a->data16 = (ee_s16 )(((int )a->data16 & 65280) | (255 & ((int )a->data16 >> 8)));
#line 139
    b->data16 = (ee_s16 )(((int )b->data16 & 65280) | (255 & ((int )b->data16 >> 8)));
  }
#line 141
  return ((int )a->idx - (int )b->idx);
}
}
#line 144 "core_list_join.c"
void copy_info(list_data *to , list_data *from ) 
{ 


  {
#line 147
  to->data16 = from->data16;
#line 148
  to->idx = from->idx;
#line 149
  return;
}
}
#line 158 "core_list_join.c"
ee_u16 core_bench_list(core_results *res , ee_s16 finder_idx ) 
{ 
  ee_u16 retval ;
  ee_u16 found ;
  ee_u16 missed ;
  list_head *list ;
  ee_s16 find_num ;
  list_head *this_find ;
  list_head *finder ;
  list_head *remover ;
  list_data info ;
  ee_s16 i ;

  {
#line 161
  retval = (ee_u16 )0;
#line 162
  found = (ee_u16 )0;
#line 162
  missed = (ee_u16 )0;
#line 163
  list = res->list;
#line 164
  find_num = res->seed3;
#line 170
  info.idx = finder_idx;
#line 173
  i = (ee_s16 )0;
#line 173
  while ((int )i < (int )find_num) {
#line 175
    info.data16 = (ee_s16 )((int )i & 255);
#line 176
    this_find = core_list_find(list, & info);
#line 177
    list = core_list_reverse(list);
#line 178
    if ((unsigned long )this_find == (unsigned long )((void *)0)) {
#line 180
      missed = (ee_u16 )((int )missed + 1);
#line 181
      retval = (ee_u16 )((int )retval + (((int )((list->next)->info)->data16 >> 8) & 1));
    } else {
#line 185
      found = (ee_u16 )((int )found + 1);
#line 186
      if ((int )(this_find->info)->data16 & 1) {
#line 187
        retval = (ee_u16 )((int )retval + (((int )(this_find->info)->data16 >> 9) & 1));
      }
#line 189
      if ((unsigned long )this_find->next != (unsigned long )((void *)0)) {
#line 191
        finder = this_find->next;
#line 192
        this_find->next = finder->next;
#line 193
        finder->next = list->next;
#line 194
        list->next = finder;
      }
    }
#line 197
    if ((int )info.idx >= 0) {
#line 198
      info.idx = (ee_s16 )((int )info.idx + 1);
    }
#line 173
    i = (ee_s16 )((int )i + 1);
  }
#line 203
  retval = (ee_u16 )((int )retval + ((int )found * 4 - (int )missed));
#line 205
  if ((int )finder_idx > 0) {
#line 206
    list = core_list_mergesort(list, & cmp_complex, res);
  }
#line 207
  remover = core_list_remove(list->next);
#line 210
  finder = core_list_find(list, & info);
#line 211
  if (! finder) {
#line 212
    finder = list->next;
  }
#line 213
  while (finder) {
#line 215
    retval = crc16((list->info)->data16, retval);
#line 216
    finder = finder->next;
  }
#line 221
  remover = core_list_undo_remove(remover, list->next);
#line 223
  list = core_list_mergesort(list, & cmp_idx, (core_results *)((void *)0));
#line 225
  finder = list->next;
#line 226
  while (finder) {
#line 228
    retval = crc16((list->info)->data16, retval);
#line 229
    finder = finder->next;
  }
#line 234
  return (retval);
}
}
#line 250 "core_list_join.c"
list_head *core_list_init(ee_u32 blksize , list_head *memblock , ee_s16 seed ) 
{ 
  ee_u32 per_item ;
  ee_u32 size ;
  list_head *memblock_end ;
  list_data *datablock ;
  list_data *datablock_end ;
  ee_u32 i ;
  list_head *finder ;
  list_head *list ;
  list_data info ;
  ee_u16 datpat ;
  ee_u16 dat ;
  ee_u32 tmp ;
  ee_u16 pat ;
  ee_u32 tmp___0 ;

  {
#line 254
  per_item = (ee_u32 )(16UL + sizeof(struct list_data_s ));
#line 255
  size = blksize / per_item - 2U;
#line 258
  memblock_end = memblock + size;
#line 259
  datablock = (list_data *)memblock_end;
#line 260
  datablock_end = datablock + size;
#line 263
  list = memblock;
#line 267
  list->next = (struct list_head_s *)((void *)0);
#line 268
  list->info = datablock;
#line 269
  (list->info)->idx = (ee_s16 )0;
#line 270
  (list->info)->data16 = (ee_s16 )32896;
#line 271
  memblock ++;
#line 272
  datablock ++;
#line 273
  info.idx = (ee_s16 )32767;
#line 274
  info.data16 = (ee_s16 )65535;
#line 275
  core_list_insert_new(list, & info, & memblock, & datablock, memblock_end, datablock_end);
#line 279
  i = (ee_u32 )0;
#line 279
  while (i < size) {
#line 281
    datpat = (ee_u16 )((int )((ee_u16 )((unsigned int )seed ^ i)) & 15);
#line 282
    dat = (ee_u16 )((unsigned int )((int )datpat << 3) | (i & 7U));
#line 284
    info.data16 = (ee_s16 )(((int )dat << 8) | (int )dat);
#line 286
    core_list_insert_new(list, & info, & memblock, & datablock, memblock_end, datablock_end);
#line 279
    i ++;
  }
#line 290
  finder = list->next;
#line 291
  i = (ee_u32 )1;
#line 292
  while ((unsigned long )finder->next != (unsigned long )((void *)0)) {
#line 294
    if (i < size / 5U) {
#line 295
      tmp = i;
#line 295
      i ++;
#line 295
      (finder->info)->idx = (ee_s16 )tmp;
    } else {
#line 298
      tmp___0 = i;
#line 298
      i ++;
#line 298
      pat = (ee_u16 )(tmp___0 ^ (unsigned int )seed);
#line 299
      (finder->info)->idx = (ee_s16 )(16383U & (((i & 7U) << 8) | (unsigned int )pat));
    }
#line 304
    finder = finder->next;
  }
#line 306
  list = core_list_mergesort(list, & cmp_idx, (core_results *)((void *)0));
#line 318
  return (list);
}
}
#line 335 "core_list_join.c"
list_head *core_list_insert_new(list_head *insert_point , list_data *info , list_head **memblock ,
                                list_data **datablock , list_head *memblock_end ,
                                list_data *datablock_end ) 
{ 
  list_head *newitem ;

  {
#line 345
  if ((unsigned long )(*memblock + 1) >= (unsigned long )memblock_end) {
#line 346
    return ((list_head *)((void *)0));
  }
#line 347
  if ((unsigned long )(*datablock + 1) >= (unsigned long )datablock_end) {
#line 348
    return ((list_head *)((void *)0));
  }
#line 350
  newitem = *memblock;
#line 351
  (*memblock) ++;
#line 352
  newitem->next = insert_point->next;
#line 353
  insert_point->next = newitem;
#line 355
  newitem->info = *datablock;
#line 356
  (*datablock) ++;
#line 357
  copy_info(newitem->info, info);
#line 359
  return (newitem);
}
}
#line 376 "core_list_join.c"
list_head *core_list_remove(list_head *item ) 
{ 
  list_data *tmp ;
  list_head *ret ;

  {
#line 380
  ret = item->next;
#line 382
  tmp = item->info;
#line 383
  item->info = ret->info;
#line 384
  ret->info = tmp;
#line 386
  item->next = (item->next)->next;
#line 387
  ret->next = (struct list_head_s *)((void *)0);
#line 388
  return (ret);
}
}
#line 407 "core_list_join.c"
list_head *core_list_undo_remove(list_head *item_removed , list_head *item_modified ) 
{ 
  list_data *tmp ;

  {
#line 412
  tmp = item_removed->info;
#line 413
  item_removed->info = item_modified->info;
#line 414
  item_modified->info = tmp;
#line 416
  item_removed->next = item_modified->next;
#line 417
  item_modified->next = item_removed;
#line 418
  return (item_removed);
}
}
#line 434 "core_list_join.c"
list_head *core_list_find(list_head *list , list_data *info ) 
{ 


  {
#line 437
  if ((int )info->idx >= 0) {
#line 439
    while (1) {
#line 439
      if (list) {
#line 439
        if (! ((int )(list->info)->idx != (int )info->idx)) {
#line 439
          break;
        }
      } else {
#line 439
        break;
      }
#line 440
      list = list->next;
    }
#line 441
    return (list);
  } else {
#line 445
    while (1) {
#line 445
      if (list) {
#line 445
        if (! (((int )(list->info)->data16 & 255) != (int )info->data16)) {
#line 445
          break;
        }
      } else {
#line 445
        break;
      }
#line 446
      list = list->next;
    }
#line 447
    return (list);
  }
}
}
#line 464 "core_list_join.c"
list_head *core_list_reverse(list_head *list ) 
{ 
  list_head *next ;
  list_head *tmp ;

  {
#line 467
  next = (list_head *)((void *)0);
#line 468
  while (list) {
#line 470
    tmp = list->next;
#line 471
    list->next = next;
#line 472
    next = list;
#line 473
    list = tmp;
  }
#line 475
  return (next);
}
}
#line 499 "core_list_join.c"
list_head *core_list_mergesort(list_head *list , ee_s32 (*cmp)(list_data *a , list_data *b ,
                                                               core_results *res ) ,
                               core_results *res ) 
{ 
  list_head *p ;
  list_head *q ;
  list_head *e ;
  list_head *tail ;
  ee_s32 insize ;
  ee_s32 nmerges ;
  ee_s32 psize ;
  ee_s32 qsize ;
  ee_s32 i ;
  ee_s32 tmp ;

  {
#line 505
  insize = 1;
#line 507
  while (1) {
#line 509
    p = list;
#line 510
    list = (list_head *)((void *)0);
#line 511
    tail = (list_head *)((void *)0);
#line 513
    nmerges = 0;
#line 515
    while (p) {
#line 517
      nmerges ++;
#line 519
      q = p;
#line 520
      psize = 0;
#line 521
      i = 0;
#line 521
      while (i < insize) {
#line 523
        psize ++;
#line 524
        q = q->next;
#line 525
        if (! q) {
#line 526
          break;
        }
#line 521
        i ++;
      }
#line 530
      qsize = insize;
#line 533
      while (1) {
#line 533
        if (! (psize > 0)) {
#line 533
          if (qsize > 0) {
#line 533
            if (! q) {
#line 533
              break;
            }
          } else {
#line 533
            break;
          }
        }
#line 537
        if (psize == 0) {
#line 540
          e = q;
#line 541
          q = q->next;
#line 542
          qsize --;
        } else
#line 544
        if (qsize == 0) {
#line 547
          e = p;
#line 548
          p = p->next;
#line 549
          psize --;
        } else
#line 544
        if (! q) {
#line 547
          e = p;
#line 548
          p = p->next;
#line 549
          psize --;
        } else {
#line 551
          tmp = (*cmp)(p->info, q->info, res);
#line 551
          if (tmp <= 0) {
#line 555
            e = p;
#line 556
            p = p->next;
#line 557
            psize --;
          } else {
#line 562
            e = q;
#line 563
            q = q->next;
#line 564
            qsize --;
          }
        }
#line 568
        if (tail) {
#line 570
          tail->next = e;
        } else {
#line 574
          list = e;
        }
#line 576
        tail = e;
      }
#line 580
      p = q;
    }
#line 583
    tail->next = (struct list_head_s *)((void *)0);
#line 586
    if (nmerges <= 1) {
#line 587
      return (list);
    }
#line 590
    insize *= 2;
  }
}
}
#line 1 "cil-EHpfNgMI.o"
#pragma merger("0","/tmp/cil-JqaC778d.i","-O2")
#line 248 "posix/core_portme.h"
ee_u32 default_num_contexts ;
#line 299
void portable_init(core_portable *p , int *argc , char **argv ) ;
#line 300
void portable_fini(core_portable *p ) ;
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 48 "./coremark.h"
void *iterate(void *pres ) ;
#line 68
void start_time(void) ;
#line 69
void stop_time(void) ;
#line 70
CORE_TICKS get_time(void) ;
#line 71
secs_ret time_in_secs(CORE_TICKS ticks ) ;
#line 78
ee_u8 check_data_types(void) ;
#line 79
void *portable_malloc(unsigned long size ) ;
#line 80
void portable_free(void *p ) ;
#line 170
void core_init_state(ee_u32 size , ee_s16 seed , ee_u8 *p ) ;
#line 179
ee_u32 core_init_matrix(ee_u32 blksize , void *memblk , ee_s32 seed , mat_params *p ) ;
#line 36 "core_main.c"
static ee_u16 list_known_crc[5]  = {      (ee_u16 )54448,      (ee_u16 )13120,      (ee_u16 )27257,      (ee_u16 )59156, 
        (ee_u16 )58305};
#line 41 "core_main.c"
static ee_u16 matrix_known_crc[5]  = {      (ee_u16 )48722,      (ee_u16 )4505,      (ee_u16 )22024,      (ee_u16 )8151, 
        (ee_u16 )1863};
#line 46 "core_main.c"
static ee_u16 state_known_crc[5]  = {      (ee_u16 )24135,      (ee_u16 )14783,      (ee_u16 )58788,      (ee_u16 )36410, 
        (ee_u16 )36228};
#line 51 "core_main.c"
void *iterate(void *pres ) 
{ 
  ee_u32 i ;
  ee_u16 crc ;
  core_results *res ;
  ee_u32 iterations ;

  {
#line 56
  res = (core_results *)pres;
#line 57
  iterations = res->iterations;
#line 58
  res->crc = (ee_u16 )0;
#line 59
  res->crclist = (ee_u16 )0;
#line 60
  res->crcmatrix = (ee_u16 )0;
#line 61
  res->crcstate = (ee_u16 )0;
#line 63
  i = (ee_u32 )0;
#line 63
  while (i < iterations) {
#line 65
    crc = core_bench_list(res, (ee_s16 )1);
#line 66
    res->crc = crcu16(crc, res->crc);
#line 67
    crc = core_bench_list(res, (ee_s16 )-1);
#line 68
    res->crc = crcu16(crc, res->crc);
#line 69
    if (i == 0U) {
#line 70
      res->crclist = res->crc;
    }
#line 63
    i ++;
  }
#line 72
  return ((void *)0);
}
}
#line 76
ee_s32 get_seed_args(int i , int argc , char **argv ) ;
#line 87 "core_main.c"
char *mem_name[3]  = {      (char *)"Static",      (char *)"Heap",      (char *)"Stack"};
#line 114 "core_main.c"
int main(int argc , char **argv ) 
{ 
  ee_u16 i ;
  ee_u16 j ;
  ee_u16 num_algorithms ;
  ee_s16 known_id ;
  ee_s16 total_errors ;
  ee_u16 seedcrc ;
  CORE_TICKS total_time ;
  core_results results[1] ;
  ee_s32 tmp ;
  ee_s32 tmp___0 ;
  ee_s32 tmp___1 ;
  ee_s32 tmp___2 ;
  ee_s32 tmp___3 ;
  ee_s32 malloc_override ;
  ee_s32 tmp___4 ;
  ee_u32 ctx ;
  secs_ret secs_passed ;
  ee_u32 divisor ;
  CORE_TICKS tmp___5 ;
  ee_u8 tmp___6 ;
  secs_ret tmp___7 ;
  secs_ret tmp___8 ;
  secs_ret tmp___9 ;
  secs_ret tmp___10 ;
  secs_ret tmp___11 ;

  {
#line 118
  j = (ee_u16 )0;
#line 118
  num_algorithms = (ee_u16 )0;
#line 119
  known_id = (ee_s16 )-1;
#line 119
  total_errors = (ee_s16 )0;
#line 120
  seedcrc = (ee_u16 )0;
#line 127
  portable_init(& results[0].port, & argc, argv);
#line 129
  if (sizeof(struct list_head_s ) > 128UL) {
#line 131
    printf((char const   * __restrict  )"list_head structure too big for comparable data!\n");
#line 132
    return (0);
  }
#line 134
  tmp = get_seed_args(1, argc, argv);
#line 134
  results[0].seed1 = (ee_s16 )tmp;
#line 135
  tmp___0 = get_seed_args(2, argc, argv);
#line 135
  results[0].seed2 = (ee_s16 )tmp___0;
#line 136
  tmp___1 = get_seed_args(3, argc, argv);
#line 136
  results[0].seed3 = (ee_s16 )tmp___1;
#line 137
  tmp___2 = get_seed_args(4, argc, argv);
#line 137
  results[0].iterations = (ee_u32 )tmp___2;
#line 141
  tmp___3 = get_seed_args(5, argc, argv);
#line 141
  results[0].execs = (ee_u32 )tmp___3;
#line 142
  if (results[0].execs == 0U) {
#line 144
    results[0].execs = (ee_u32 )((1 | (1 << 1)) | (1 << 2));
  }
#line 147
  if ((int )results[0].seed1 == 0) {
#line 147
    if ((int )results[0].seed2 == 0) {
#line 147
      if ((int )results[0].seed3 == 0) {
#line 150
        results[0].seed1 = (ee_s16 )0;
#line 151
        results[0].seed2 = (ee_s16 )0;
#line 152
        results[0].seed3 = (ee_s16 )102;
      }
    }
  }
#line 154
  if ((int )results[0].seed1 == 1) {
#line 154
    if ((int )results[0].seed2 == 0) {
#line 154
      if ((int )results[0].seed3 == 0) {
#line 157
        results[0].seed1 = (ee_s16 )13333;
#line 158
        results[0].seed2 = (ee_s16 )13333;
#line 159
        results[0].seed3 = (ee_s16 )102;
      }
    }
  }
#line 169
  i = (ee_u16 )0;
#line 169
  while ((int )i < 1) {
#line 171
    tmp___4 = get_seed_args(7, argc, argv);
#line 171
    malloc_override = (ee_s32 )((ee_s16 )tmp___4);
#line 172
    if (malloc_override != 0) {
#line 173
      results[i].size = (ee_u32 )malloc_override;
    } else {
#line 175
      results[i].size = (ee_u32 )2000;
    }
#line 176
    results[i].memblock[0] = portable_malloc((ee_size_t )results[i].size);
#line 177
    results[i].seed1 = results[0].seed1;
#line 178
    results[i].seed2 = results[0].seed2;
#line 179
    results[i].seed3 = results[0].seed3;
#line 180
    results[i].err = (ee_s16 )0;
#line 181
    results[i].execs = results[0].execs;
#line 169
    i = (ee_u16 )((int )i + 1);
  }
#line 199
  i = (ee_u16 )0;
#line 199
  while ((int )i < 3) {
#line 201
    if ((unsigned int )(1 << (ee_u32 )i) & results[0].execs) {
#line 202
      num_algorithms = (ee_u16 )((int )num_algorithms + 1);
    }
#line 199
    i = (ee_u16 )((int )i + 1);
  }
#line 204
  i = (ee_u16 )0;
#line 204
  while ((int )i < 1) {
#line 205
    results[i].size /= (ee_u32 )num_algorithms;
#line 204
    i = (ee_u16 )((int )i + 1);
  }
#line 207
  i = (ee_u16 )0;
#line 207
  while ((int )i < 3) {
#line 210
    if ((unsigned int )(1 << (ee_u32 )i) & results[0].execs) {
#line 212
      ctx = (ee_u32 )0;
#line 212
      while (ctx < 1U) {
#line 213
        results[ctx].memblock[(int )i + 1] = (void *)((char *)results[ctx].memblock[0] + results[0].size * (ee_u32 )j);
#line 212
        ctx ++;
      }
#line 215
      j = (ee_u16 )((int )j + 1);
    }
#line 207
    i = (ee_u16 )((int )i + 1);
  }
#line 219
  i = (ee_u16 )0;
#line 219
  while ((int )i < 1) {
#line 221
    if (results[i].execs & 1U) {
#line 223
      results[i].list = core_list_init(results[0].size, (list_head *)results[i].memblock[1],
                                       results[i].seed1);
    }
#line 226
    if (results[i].execs & (unsigned int )(1 << 1)) {
#line 228
      core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32 )results[i].seed1 | ((ee_s32 )results[i].seed2 << 16),
                       & results[i].mat);
    }
#line 234
    if (results[i].execs & (unsigned int )(1 << 2)) {
#line 236
      core_init_state(results[0].size, results[i].seed1, (ee_u8 *)results[i].memblock[3]);
    }
#line 219
    i = (ee_u16 )((int )i + 1);
  }
#line 242
  if (results[0].iterations == 0U) {
#line 244
    secs_passed = (secs_ret )0;
#line 246
    results[0].iterations = (ee_u32 )1;
#line 247
    while (secs_passed < (secs_ret )1) {
#line 249
      results[0].iterations *= 10U;
#line 250
      start_time();
#line 251
      iterate((void *)(& results[0]));
#line 252
      stop_time();
#line 253
      tmp___5 = get_time();
#line 253
      secs_passed = time_in_secs(tmp___5);
    }
#line 257
    divisor = (ee_u32 )secs_passed;
#line 258
    if (divisor == 0U) {
#line 261
      divisor = (ee_u32 )1;
    }
#line 262
    results[0].iterations *= 1U + 10U / divisor;
  }
#line 265
  start_time();
#line 282
  iterate((void *)(& results[0]));
#line 284
  stop_time();
#line 285
  total_time = get_time();
#line 287
  seedcrc = crc16(results[0].seed1, seedcrc);
#line 288
  seedcrc = crc16(results[0].seed2, seedcrc);
#line 289
  seedcrc = crc16(results[0].seed3, seedcrc);
#line 290
  seedcrc = crc16((ee_s16 )results[0].size, seedcrc);
#line 292
  switch ((int )seedcrc) {
  case 35330: 
#line 295
  known_id = (ee_s16 )0;
#line 296
  printf((char const   * __restrict  )"6k performance run parameters for coremark.\n");
#line 297
  break;
  case 31493: 
#line 300
  known_id = (ee_s16 )1;
#line 301
  printf((char const   * __restrict  )"6k validation run parameters for coremark.\n");
#line 302
  break;
  case 20143: 
#line 305
  known_id = (ee_s16 )2;
#line 306
  printf((char const   * __restrict  )"Profile generation run parameters for coremark.\n");
#line 307
  break;
  case 59893: 
#line 309
  known_id = (ee_s16 )3;
#line 310
  printf((char const   * __restrict  )"2K performance run parameters for coremark.\n");
#line 311
  break;
  case 6386: 
#line 314
  known_id = (ee_s16 )4;
#line 315
  printf((char const   * __restrict  )"2K validation run parameters for coremark.\n");
#line 316
  break;
  default: 
#line 318
  total_errors = (ee_s16 )-1;
#line 319
  break;
  }
#line 321
  if ((int )known_id >= 0) {
#line 323
    i = (ee_u16 )0;
#line 323
    while ((ee_u32 )i < default_num_contexts) {
#line 325
      results[i].err = (ee_s16 )0;
#line 326
      if (results[i].execs & 1U) {
#line 326
        if ((int )results[i].crclist != (int )list_known_crc[known_id]) {
#line 329
          printf((char const   * __restrict  )"[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",
                 (int )i, (int )results[i].crclist, (int )list_known_crc[known_id]);
#line 333
          results[i].err = (ee_s16 )((int )results[i].err + 1);
        }
      }
#line 335
      if (results[i].execs & (unsigned int )(1 << 1)) {
#line 335
        if ((int )results[i].crcmatrix != (int )matrix_known_crc[known_id]) {
#line 338
          printf((char const   * __restrict  )"[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",
                 (int )i, (int )results[i].crcmatrix, (int )matrix_known_crc[known_id]);
#line 342
          results[i].err = (ee_s16 )((int )results[i].err + 1);
        }
      }
#line 344
      if (results[i].execs & (unsigned int )(1 << 2)) {
#line 344
        if ((int )results[i].crcstate != (int )state_known_crc[known_id]) {
#line 347
          printf((char const   * __restrict  )"[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",
                 (int )i, (int )results[i].crcstate, (int )state_known_crc[known_id]);
#line 351
          results[i].err = (ee_s16 )((int )results[i].err + 1);
        }
      }
#line 353
      total_errors = (ee_s16 )((int )total_errors + (int )results[i].err);
#line 323
      i = (ee_u16 )((int )i + 1);
    }
  }
#line 356
  tmp___6 = check_data_types();
#line 356
  total_errors = (ee_s16 )((int )total_errors + (int )tmp___6);
#line 358
  printf((char const   * __restrict  )"CoreMark Size    : %lu\n", (unsigned long )results[0].size);
#line 359
  printf((char const   * __restrict  )"Total ticks      : %lu\n", (unsigned long )total_time);
#line 361
  tmp___7 = time_in_secs(total_time);
#line 361
  printf((char const   * __restrict  )"Total time (secs): %f\n", tmp___7);
#line 362
  tmp___9 = time_in_secs(total_time);
#line 362
  if (tmp___9 > (secs_ret )0) {
#line 363
    tmp___8 = time_in_secs(total_time);
#line 363
    printf((char const   * __restrict  )"Iterations/Sec   : %f\n", (secs_ret )(default_num_contexts * results[0].iterations) / tmp___8);
  }
#line 373
  tmp___10 = time_in_secs(total_time);
#line 373
  if (tmp___10 < (secs_ret )10) {
#line 375
    printf((char const   * __restrict  )"ERROR! Must execute for at least 10 secs for a valid result!\n");
#line 377
    total_errors = (ee_s16 )((int )total_errors + 1);
  }
#line 380
  printf((char const   * __restrict  )"Iterations       : %lu\n", (unsigned long )default_num_contexts * (unsigned long )results[0].iterations);
#line 382
  printf((char const   * __restrict  )"Compiler version : %s\n", "GCCClang 9.0.0 (tags/RELEASE_900/final)");
#line 383
  printf((char const   * __restrict  )"Compiler flags   : %s\n", "-O2 -DPERFORMANCE_RUN=1  -lrt");
#line 387
  printf((char const   * __restrict  )"Memory location  : %s\n", "Please put data memory location here\n\t\t\t(e.g. code in flash, data on heap etc)");
#line 389
  printf((char const   * __restrict  )"seedcrc          : 0x%04x\n", (int )seedcrc);
#line 390
  if (results[0].execs & 1U) {
#line 391
    i = (ee_u16 )0;
#line 391
    while ((ee_u32 )i < default_num_contexts) {
#line 392
      printf((char const   * __restrict  )"[%d]crclist       : 0x%04x\n", (int )i,
             (int )results[i].crclist);
#line 391
      i = (ee_u16 )((int )i + 1);
    }
  }
#line 393
  if (results[0].execs & (unsigned int )(1 << 1)) {
#line 394
    i = (ee_u16 )0;
#line 394
    while ((ee_u32 )i < default_num_contexts) {
#line 395
      printf((char const   * __restrict  )"[%d]crcmatrix     : 0x%04x\n", (int )i,
             (int )results[i].crcmatrix);
#line 394
      i = (ee_u16 )((int )i + 1);
    }
  }
#line 396
  if (results[0].execs & (unsigned int )(1 << 2)) {
#line 397
    i = (ee_u16 )0;
#line 397
    while ((ee_u32 )i < default_num_contexts) {
#line 398
      printf((char const   * __restrict  )"[%d]crcstate      : 0x%04x\n", (int )i,
             (int )results[i].crcstate);
#line 397
      i = (ee_u16 )((int )i + 1);
    }
  }
#line 399
  i = (ee_u16 )0;
#line 399
  while ((ee_u32 )i < default_num_contexts) {
#line 400
    printf((char const   * __restrict  )"[%d]crcfinal      : 0x%04x\n", (int )i, (int )results[i].crc);
#line 399
    i = (ee_u16 )((int )i + 1);
  }
#line 401
  if ((int )total_errors == 0) {
#line 403
    printf((char const   * __restrict  )"Correct operation validated. See README.md for run and reporting rules.\n");
#line 407
    if ((int )known_id == 3) {
#line 409
      tmp___11 = time_in_secs(total_time);
#line 409
      printf((char const   * __restrict  )"CoreMark 1.0 : %f / %s %s", (secs_ret )(default_num_contexts * results[0].iterations) / tmp___11,
             "GCCClang 9.0.0 (tags/RELEASE_900/final)", "-O2 -DPERFORMANCE_RUN=1  -lrt");
#line 417
      printf((char const   * __restrict  )" / %s", mem_name[1]);
#line 423
      printf((char const   * __restrict  )"\n");
    }
  }
#line 427
  if ((int )total_errors > 0) {
#line 428
    printf((char const   * __restrict  )"Errors detected\n");
  }
#line 429
  if ((int )total_errors < 0) {
#line 430
    printf((char const   * __restrict  )"Cannot validate operation for these seed values, please compare with results on a known platform.\n");
  }
#line 435
  i = (ee_u16 )0;
#line 435
  while ((int )i < 1) {
#line 436
    portable_free(results[i].memblock[0]);
#line 435
    i = (ee_u16 )((int )i + 1);
  }
#line 439
  portable_fini(& results[0].port);
#line 441
  return (0);
}
}
#line 1 "cil-YE3pQmnZ.o"
#pragma merger("0","/tmp/cil-b8LcX3kF.i","-O2")
#line 38 "core_matrix.c"
ee_s16 matrix_test(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B , MATDAT val ) ;
#line 39
ee_s16 matrix_sum(ee_u32 N , MATRES *C , MATDAT clipval ) ;
#line 40
void matrix_mul_const(ee_u32 N , MATRES *C , MATDAT *A , MATDAT val ) ;
#line 41
void matrix_mul_vect(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) ;
#line 42
void matrix_mul_matrix(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) ;
#line 43
void matrix_mul_matrix_bitextract(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) ;
#line 44
void matrix_add_const(ee_u32 N , MATDAT *A , MATDAT val ) ;
#line 91 "core_matrix.c"
ee_u16 core_bench_matrix(mat_params *p , ee_s16 seed , ee_u16 crc ) 
{ 
  ee_u32 N ;
  MATRES *C ;
  MATDAT *A ;
  MATDAT *B ;
  MATDAT val ;
  ee_s16 tmp ;

  {
#line 94
  N = (ee_u32 )p->N;
#line 95
  C = p->C;
#line 96
  A = p->A;
#line 97
  B = p->B;
#line 98
  val = seed;
#line 100
  tmp = matrix_test(N, C, A, B, val);
#line 100
  crc = crc16(tmp, crc);
#line 102
  return (crc);
}
}
#line 129 "core_matrix.c"
ee_s16 matrix_test(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B , MATDAT val ) 
{ 
  ee_u16 crc ;
  MATDAT clipval ;
  ee_s16 tmp ;
  ee_s16 tmp___0 ;
  ee_s16 tmp___1 ;
  ee_s16 tmp___2 ;

  {
#line 132
  crc = (ee_u16 )0;
#line 133
  clipval = (MATDAT )(61440 | (int )val);
#line 135
  matrix_add_const(N, A, val);
#line 139
  matrix_mul_const(N, C, A, val);
#line 140
  tmp = matrix_sum(N, C, clipval);
#line 140
  crc = crc16(tmp, crc);
#line 144
  matrix_mul_vect(N, C, A, B);
#line 145
  tmp___0 = matrix_sum(N, C, clipval);
#line 145
  crc = crc16(tmp___0, crc);
#line 149
  matrix_mul_matrix(N, C, A, B);
#line 150
  tmp___1 = matrix_sum(N, C, clipval);
#line 150
  crc = crc16(tmp___1, crc);
#line 154
  matrix_mul_matrix_bitextract(N, C, A, B);
#line 155
  tmp___2 = matrix_sum(N, C, clipval);
#line 155
  crc = crc16(tmp___2, crc);
#line 160
  matrix_add_const(N, A, (MATDAT )(- ((int )val)));
#line 161
  return ((ee_s16 )crc);
}
}
#line 180 "core_matrix.c"
ee_u32 core_init_matrix(ee_u32 blksize , void *memblk , ee_s32 seed , mat_params *p ) 
{ 
  ee_u32 N ;
  MATDAT *A ;
  MATDAT *B ;
  ee_s32 order ;
  MATDAT val ;
  ee_u32 i ;
  ee_u32 j ;

  {
#line 183
  N = (ee_u32 )0;
#line 186
  order = 1;
#line 188
  i = (ee_u32 )0;
#line 188
  j = (ee_u32 )0;
#line 189
  if (seed == 0) {
#line 190
    seed = 1;
  }
#line 191
  while (j < blksize) {
#line 193
    i ++;
#line 194
    j = ((i * i) * 2U) * 4U;
  }
#line 196
  N = i - 1U;
#line 197
  A = (MATDAT *)((void *)(4UL + (((ee_ptr_int )memblk - 1UL) & 0xfffffffffffffffcUL)));
#line 198
  B = A + N * N;
#line 200
  i = (ee_u32 )0;
#line 200
  while (i < N) {
#line 202
    j = (ee_u32 )0;
#line 202
    while (j < N) {
#line 204
      seed = (order * seed) % 65536;
#line 205
      val = (MATDAT )(seed + order);
#line 206
      val = (MATDAT )((int )val & 65535);
#line 207
      *(B + (i * N + j)) = val;
#line 208
      val = (MATDAT )((int )val + order);
#line 209
      val = (MATDAT )((int )val & 255);
#line 210
      *(A + (i * N + j)) = val;
#line 211
      order ++;
#line 202
      j ++;
    }
#line 200
    i ++;
  }
#line 215
  p->A = A;
#line 216
  p->B = B;
#line 217
  p->C = (MATRES *)((void *)(4UL + (((ee_ptr_int )(B + N * N) - 1UL) & 0xfffffffffffffffcUL)));
#line 218
  p->N = (int )N;
#line 223
  return (N);
}
}
#line 237 "core_matrix.c"
ee_s16 matrix_sum(ee_u32 N , MATRES *C , MATDAT clipval ) 
{ 
  MATRES tmp ;
  MATRES prev ;
  MATRES cur ;
  ee_s16 ret ;
  ee_u32 i ;
  ee_u32 j ;
  int tmp___0 ;

  {
#line 240
  tmp = 0;
#line 240
  prev = 0;
#line 240
  cur = 0;
#line 241
  ret = (ee_s16 )0;
#line 243
  i = (ee_u32 )0;
#line 243
  while (i < N) {
#line 245
    j = (ee_u32 )0;
#line 245
    while (j < N) {
#line 247
      cur = *(C + (i * N + j));
#line 248
      tmp += cur;
#line 249
      if (tmp > (MATRES )clipval) {
#line 251
        ret = (ee_s16 )((int )ret + 10);
#line 252
        tmp = 0;
      } else {
#line 256
        if (cur > prev) {
#line 256
          tmp___0 = 1;
        } else {
#line 256
          tmp___0 = 0;
        }
#line 256
        ret = (ee_s16 )((int )ret + tmp___0);
      }
#line 258
      prev = cur;
#line 245
      j ++;
    }
#line 243
    i ++;
  }
#line 261
  return (ret);
}
}
#line 268 "core_matrix.c"
void matrix_mul_const(ee_u32 N , MATRES *C , MATDAT *A , MATDAT val ) 
{ 
  ee_u32 i ;
  ee_u32 j ;

  {
#line 272
  i = (ee_u32 )0;
#line 272
  while (i < N) {
#line 274
    j = (ee_u32 )0;
#line 274
    while (j < N) {
#line 276
      *(C + (i * N + j)) = (MATRES )*(A + (i * N + j)) * (MATRES )val;
#line 274
      j ++;
    }
#line 272
    i ++;
  }
#line 279
  return;
}
}
#line 284 "core_matrix.c"
void matrix_add_const(ee_u32 N , MATDAT *A , MATDAT val ) 
{ 
  ee_u32 i ;
  ee_u32 j ;

  {
#line 288
  i = (ee_u32 )0;
#line 288
  while (i < N) {
#line 290
    j = (ee_u32 )0;
#line 290
    while (j < N) {
#line 292
      *(A + (i * N + j)) = (MATDAT )((int )*(A + (i * N + j)) + (int )val);
#line 290
      j ++;
    }
#line 288
    i ++;
  }
#line 295
  return;
}
}
#line 302 "core_matrix.c"
void matrix_mul_vect(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) 
{ 
  ee_u32 i ;
  ee_u32 j ;

  {
#line 306
  i = (ee_u32 )0;
#line 306
  while (i < N) {
#line 308
    *(C + i) = 0;
#line 309
    j = (ee_u32 )0;
#line 309
    while (j < N) {
#line 311
      *(C + i) += (MATRES )*(A + (i * N + j)) * (MATRES )*(B + j);
#line 309
      j ++;
    }
#line 306
    i ++;
  }
#line 314
  return;
}
}
#line 321 "core_matrix.c"
void matrix_mul_matrix(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) 
{ 
  ee_u32 i ;
  ee_u32 j ;
  ee_u32 k ;

  {
#line 325
  i = (ee_u32 )0;
#line 325
  while (i < N) {
#line 327
    j = (ee_u32 )0;
#line 327
    while (j < N) {
#line 329
      *(C + (i * N + j)) = 0;
#line 330
      k = (ee_u32 )0;
#line 330
      while (k < N) {
#line 332
        *(C + (i * N + j)) += (MATRES )*(A + (i * N + k)) * (MATRES )*(B + (k * N + j));
#line 330
        k ++;
      }
#line 327
      j ++;
    }
#line 325
    i ++;
  }
#line 336
  return;
}
}
#line 343 "core_matrix.c"
void matrix_mul_matrix_bitextract(ee_u32 N , MATRES *C , MATDAT *A , MATDAT *B ) 
{ 
  ee_u32 i ;
  ee_u32 j ;
  ee_u32 k ;
  MATRES tmp ;

  {
#line 347
  i = (ee_u32 )0;
#line 347
  while (i < N) {
#line 349
    j = (ee_u32 )0;
#line 349
    while (j < N) {
#line 351
      *(C + (i * N + j)) = 0;
#line 352
      k = (ee_u32 )0;
#line 352
      while (k < N) {
#line 354
        tmp = (MATRES )*(A + (i * N + k)) * (MATRES )*(B + (k * N + j));
#line 355
        *(C + (i * N + j)) = (MATRES )((unsigned int )*(C + (i * N + j)) + ((unsigned int )(tmp >> 2) & ~ (4294967295U << 4)) * ((unsigned int )(tmp >> 5) & ~ (4294967295U << 7)));
#line 352
        k ++;
      }
#line 349
      j ++;
    }
#line 347
    i ++;
  }
#line 359
  return;
}
}
#line 1 "cil-keUdUanJ.o"
#pragma merger("0","/tmp/cil-LwoMniD7.i","-O2")
#line 77 "./coremark.h"
ee_u16 crcu32(ee_u32 newval , ee_u16 crc ) ;
#line 21 "core_state.c"
enum CORE_STATE core_state_transition(ee_u8 **instr , ee_u32 *transition_count ) ;
#line 45 "core_state.c"
ee_u16 core_bench_state(ee_u32 blksize , ee_u8 *memblock , ee_s16 seed1 , ee_s16 seed2 ,
                        ee_s16 step , ee_u16 crc ) 
{ 
  ee_u32 final_counts[8] ;
  ee_u32 track_counts[8] ;
  ee_u8 *p ;
  ee_u32 i ;
  ee_u32 tmp ;
  enum CORE_STATE fstate ;
  enum CORE_STATE tmp___0 ;
  enum CORE_STATE fstate___0 ;
  enum CORE_STATE tmp___1 ;

  {
#line 55
  p = memblock;
#line 61
  i = (ee_u32 )0;
#line 61
  while (i < 8U) {
#line 63
    tmp = (ee_u32 )0;
#line 63
    track_counts[i] = tmp;
#line 63
    final_counts[i] = tmp;
#line 61
    i ++;
  }
#line 66
  while ((int )*p != 0) {
#line 68
    tmp___0 = core_state_transition(& p, track_counts);
#line 68
    fstate = tmp___0;
#line 69
    (final_counts[fstate]) ++;
  }
#line 77
  p = memblock;
#line 78
  while ((unsigned long )p < (unsigned long )(memblock + blksize)) {
#line 80
    if ((int )*p != 44) {
#line 81
      *p = (ee_u8 )((int )*p ^ (int )((ee_u8 )seed1));
    }
#line 82
    p += (int )step;
  }
#line 84
  p = memblock;
#line 86
  while ((int )*p != 0) {
#line 88
    tmp___1 = core_state_transition(& p, track_counts);
#line 88
    fstate___0 = tmp___1;
#line 89
    (final_counts[fstate___0]) ++;
  }
#line 97
  p = memblock;
#line 98
  while ((unsigned long )p < (unsigned long )(memblock + blksize)) {
#line 100
    if ((int )*p != 44) {
#line 101
      *p = (ee_u8 )((int )*p ^ (int )((ee_u8 )seed2));
    }
#line 102
    p += (int )step;
  }
#line 105
  i = (ee_u32 )0;
#line 105
  while (i < 8U) {
#line 107
    crc = crcu32(final_counts[i], crc);
#line 108
    crc = crcu32(track_counts[i], crc);
#line 105
    i ++;
  }
#line 110
  return (crc);
}
}
#line 114 "core_state.c"
static ee_u8 *intpat[4]  = {      (ee_u8 *)"5012",      (ee_u8 *)"1234",      (ee_u8 *)"-874",      (ee_u8 *)"+122"};
#line 116 "core_state.c"
static ee_u8 *floatpat[4]  = {      (ee_u8 *)"35.54400",      (ee_u8 *)".1234500",      (ee_u8 *)"-110.700",      (ee_u8 *)"+0.64400"};
#line 120 "core_state.c"
static ee_u8 *scipat[4]  = {      (ee_u8 *)"5.500e+3",      (ee_u8 *)"-.123e-2",      (ee_u8 *)"-87e+832",      (ee_u8 *)"+0.6e-12"};
#line 124 "core_state.c"
static ee_u8 *errpat[4]  = {      (ee_u8 *)"T0.3e-1F",      (ee_u8 *)"-T.T++Tq",      (ee_u8 *)"1T3.4e4z",      (ee_u8 *)"34.0e-T^"};
#line 139 "core_state.c"
void core_init_state(ee_u32 size , ee_s16 seed , ee_u8 *p ) 
{ 
  ee_u32 total ;
  ee_u32 next ;
  ee_u32 i ;
  ee_u8 *buf ;

  {
#line 142
  total = (ee_u32 )0;
#line 142
  next = (ee_u32 )0;
#line 143
  buf = (ee_u8 *)0;
#line 148
  size --;
#line 149
  next = (ee_u32 )0;
#line 150
  while ((total + next) + 1U < size) {
#line 152
    if (next > 0U) {
#line 154
      i = (ee_u32 )0;
#line 154
      while (i < next) {
#line 155
        *((p + total) + i) = *(buf + i);
#line 154
        i ++;
      }
#line 156
      *((p + total) + i) = (ee_u8 )',';
#line 157
      total += next + 1U;
    }
#line 159
    seed = (ee_s16 )((int )seed + 1);
#line 160
    switch ((int )seed & 7) {
    case 2: 
    case 1: 
    case 0: 
#line 165
    buf = intpat[((int )seed >> 3) & 3];
#line 166
    next = (ee_u32 )4;
#line 167
    break;
    case 4: 
    case 3: 
#line 170
    buf = floatpat[((int )seed >> 3) & 3];
#line 171
    next = (ee_u32 )8;
#line 172
    break;
    case 6: 
    case 5: 
#line 175
    buf = scipat[((int )seed >> 3) & 3];
#line 176
    next = (ee_u32 )8;
#line 177
    break;
    case 7: 
#line 179
    buf = errpat[((int )seed >> 3) & 3];
#line 180
    next = (ee_u32 )8;
#line 181
    break;
    default: 
#line 183
    break;
    }
  }
#line 186
  size ++;
#line 187
  while (total < size) {
#line 189
    *(p + total) = (ee_u8 )0;
#line 190
    total ++;
  }
#line 195
  return;
}
}
#line 197 "core_state.c"
static ee_u8 ee_isdigit(ee_u8 c ) 
{ 
  ee_u8 retval ;

  {
#line 201
  if (((int )c >= 48) & ((int )c <= 57)) {
#line 201
    retval = (ee_u8 )1;
  } else {
#line 201
    retval = (ee_u8 )0;
  }
#line 202
  return (retval);
}
}
#line 216 "core_state.c"
enum CORE_STATE core_state_transition(ee_u8 **instr , ee_u32 *transition_count ) 
{ 
  ee_u8 *str ;
  ee_u8 NEXT_SYMBOL ;
  enum CORE_STATE state ;
  ee_u8 tmp ;
  ee_u8 tmp___0 ;
  ee_u8 tmp___1 ;
  ee_u8 tmp___2 ;
  ee_u8 tmp___3 ;
  ee_u8 tmp___4 ;

  {
#line 219
  str = *instr;
#line 221
  state = (enum CORE_STATE )0;
#line 222
  while (1) {
#line 222
    if (*str) {
#line 222
      if (! ((unsigned int )state != 1U)) {
#line 222
        break;
      }
    } else {
#line 222
      break;
    }
#line 224
    NEXT_SYMBOL = *str;
#line 225
    if ((int )NEXT_SYMBOL == 44) {
#line 227
      str ++;
#line 228
      break;
    }
#line 230
    switch ((unsigned int )state) {
    case 0U: 
#line 233
    tmp = ee_isdigit(NEXT_SYMBOL);
#line 233
    if (tmp) {
#line 235
      state = (enum CORE_STATE )4;
    } else
#line 237
    if ((int )NEXT_SYMBOL == 43) {
#line 239
      state = (enum CORE_STATE )2;
    } else
#line 237
    if ((int )NEXT_SYMBOL == 45) {
#line 239
      state = (enum CORE_STATE )2;
    } else
#line 241
    if ((int )NEXT_SYMBOL == 46) {
#line 243
      state = (enum CORE_STATE )5;
    } else {
#line 247
      state = (enum CORE_STATE )1;
#line 248
      (*(transition_count + 1)) ++;
    }
#line 250
    (*(transition_count + 0)) ++;
#line 251
    break;
    case 2U: 
#line 253
    tmp___0 = ee_isdigit(NEXT_SYMBOL);
#line 253
    if (tmp___0) {
#line 255
      state = (enum CORE_STATE )4;
#line 256
      (*(transition_count + 2)) ++;
    } else
#line 258
    if ((int )NEXT_SYMBOL == 46) {
#line 260
      state = (enum CORE_STATE )5;
#line 261
      (*(transition_count + 2)) ++;
    } else {
#line 265
      state = (enum CORE_STATE )1;
#line 266
      (*(transition_count + 2)) ++;
    }
#line 268
    break;
    case 4U: 
#line 270
    if ((int )NEXT_SYMBOL == 46) {
#line 272
      state = (enum CORE_STATE )5;
#line 273
      (*(transition_count + 4)) ++;
    } else {
#line 275
      tmp___1 = ee_isdigit(NEXT_SYMBOL);
#line 275
      if (! tmp___1) {
#line 277
        state = (enum CORE_STATE )1;
#line 278
        (*(transition_count + 4)) ++;
      }
    }
#line 280
    break;
    case 5U: 
#line 282
    if ((int )NEXT_SYMBOL == 69) {
#line 284
      state = (enum CORE_STATE )3;
#line 285
      (*(transition_count + 5)) ++;
    } else
#line 282
    if ((int )NEXT_SYMBOL == 101) {
#line 284
      state = (enum CORE_STATE )3;
#line 285
      (*(transition_count + 5)) ++;
    } else {
#line 287
      tmp___2 = ee_isdigit(NEXT_SYMBOL);
#line 287
      if (! tmp___2) {
#line 289
        state = (enum CORE_STATE )1;
#line 290
        (*(transition_count + 5)) ++;
      }
    }
#line 292
    break;
    case 3U: 
#line 294
    if ((int )NEXT_SYMBOL == 43) {
#line 296
      state = (enum CORE_STATE )6;
#line 297
      (*(transition_count + 3)) ++;
    } else
#line 294
    if ((int )NEXT_SYMBOL == 45) {
#line 296
      state = (enum CORE_STATE )6;
#line 297
      (*(transition_count + 3)) ++;
    } else {
#line 301
      state = (enum CORE_STATE )1;
#line 302
      (*(transition_count + 3)) ++;
    }
#line 304
    break;
    case 6U: 
#line 306
    tmp___3 = ee_isdigit(NEXT_SYMBOL);
#line 306
    if (tmp___3) {
#line 308
      state = (enum CORE_STATE )7;
#line 309
      (*(transition_count + 6)) ++;
    } else {
#line 313
      state = (enum CORE_STATE )1;
#line 314
      (*(transition_count + 6)) ++;
    }
#line 316
    break;
    case 7U: 
#line 318
    tmp___4 = ee_isdigit(NEXT_SYMBOL);
#line 318
    if (! tmp___4) {
#line 320
      state = (enum CORE_STATE )1;
#line 321
      (*(transition_count + 1)) ++;
    }
#line 323
    break;
    default: 
#line 325
    break;
    }
#line 222
    str ++;
  }
#line 328
  *instr = str;
#line 329
  return (state);
}
}
#line 1 "cil-tRZ7rZij.o"
#pragma merger("0","/tmp/cil-1CbLu432.i","-O2")
#line 74 "./coremark.h"
ee_u16 crcu8(ee_u8 data , ee_u16 crc ) ;
#line 81
ee_s32 parseval(char *valstring ) ;
#line 70 "core_util.c"
ee_s32 parseval(char *valstring ) 
{ 
  ee_s32 retval ;
  ee_s32 neg ;
  int hexmode ;
  ee_s32 digit ;
  ee_s32 digit___0 ;

  {
#line 73
  retval = 0;
#line 74
  neg = 1;
#line 75
  hexmode = 0;
#line 76
  if ((int )*valstring == 45) {
#line 78
    neg = -1;
#line 79
    valstring ++;
  }
#line 81
  if ((int )*(valstring + 0) == 48) {
#line 81
    if ((int )*(valstring + 1) == 120) {
#line 83
      hexmode = 1;
#line 84
      valstring += 2;
    }
  }
#line 87
  if (hexmode) {
#line 89
    while (1) {
#line 89
      if ((int )*valstring >= 48) {
#line 89
        if (! ((int )*valstring <= 57)) {
#line 89
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 89
      if ((int )*valstring >= 97) {
#line 89
        if (! ((int )*valstring <= 102)) {
#line 89
          break;
        }
      } else {
#line 89
        break;
      }
#line 92
      digit = (int )*valstring - 48;
#line 93
      if (digit > 9) {
#line 94
        digit = (10 + (int )*valstring) - 97;
      }
#line 95
      retval *= 16;
#line 96
      retval += digit;
#line 97
      valstring ++;
    }
  } else {
#line 102
    while (1) {
#line 102
      if ((int )*valstring >= 48) {
#line 102
        if (! ((int )*valstring <= 57)) {
#line 102
          break;
        }
      } else {
#line 102
        break;
      }
#line 104
      digit___0 = (int )*valstring - 48;
#line 105
      retval *= 10;
#line 106
      retval += digit___0;
#line 107
      valstring ++;
    }
  }
#line 111
  if ((int )*valstring == 75) {
#line 112
    retval *= 1024;
  }
#line 113
  if ((int )*valstring == 77) {
#line 114
    retval *= 1048576;
  }
#line 116
  retval *= neg;
#line 117
  return (retval);
}
}
#line 120 "core_util.c"
ee_s32 get_seed_args(int i , int argc , char **argv ) 
{ 
  ee_s32 tmp ;

  {
#line 123
  if (argc > i) {
#line 124
    tmp = parseval(*(argv + i));
#line 124
    return (tmp);
  }
#line 125
  return (0);
}
}
#line 164 "core_util.c"
ee_u16 crcu8(ee_u8 data , ee_u16 crc ) 
{ 
  ee_u8 i ;
  ee_u8 x16 ;
  ee_u8 carry ;

  {
#line 167
  i = (ee_u8 )0;
#line 167
  x16 = (ee_u8 )0;
#line 167
  carry = (ee_u8 )0;
#line 169
  i = (ee_u8 )0;
#line 169
  while ((int )i < 8) {
#line 171
    x16 = (ee_u8 )(((int )data & 1) ^ ((int )((ee_u8 )crc) & 1));
#line 172
    data = (ee_u8 )((int )data >> 1);
#line 174
    if ((int )x16 == 1) {
#line 176
      crc = (ee_u16 )((int )crc ^ 16386);
#line 177
      carry = (ee_u8 )1;
    } else {
#line 180
      carry = (ee_u8 )0;
    }
#line 181
    crc = (ee_u16 )((int )crc >> 1);
#line 182
    if (carry) {
#line 183
      crc = (ee_u16 )((int )crc | 32768);
    } else {
#line 185
      crc = (ee_u16 )((int )crc & 32767);
    }
#line 169
    i = (ee_u8 )((int )i + 1);
  }
#line 187
  return (crc);
}
}
#line 189 "core_util.c"
ee_u16 crcu16(ee_u16 newval , ee_u16 crc ) 
{ 


  {
#line 192
  crc = crcu8((ee_u8 )newval, crc);
#line 193
  crc = crcu8((ee_u8 )((int )newval >> 8), crc);
#line 194
  return (crc);
}
}
#line 196 "core_util.c"
ee_u16 crcu32(ee_u32 newval , ee_u16 crc ) 
{ 


  {
#line 199
  crc = crc16((ee_s16 )newval, crc);
#line 200
  crc = crc16((ee_s16 )(newval >> 16), crc);
#line 201
  return (crc);
}
}
#line 203 "core_util.c"
ee_u16 crc16(ee_s16 newval , ee_u16 crc ) 
{ 
  ee_u16 tmp ;

  {
#line 206
  tmp = crcu16((ee_u16 )newval, crc);
#line 206
  return (tmp);
}
}
#line 209 "core_util.c"
ee_u8 check_data_types(void) 
{ 
  ee_u8 retval ;

  {
#line 212
  retval = (ee_u8 )0;
#line 213
  if (sizeof(ee_u8 ) != 1UL) {
#line 215
    printf((char const   * __restrict  )"ERROR: ee_u8 is not an 8b datatype!\n");
#line 216
    retval = (ee_u8 )((int )retval + 1);
  }
#line 218
  if (sizeof(ee_u16 ) != 2UL) {
#line 220
    printf((char const   * __restrict  )"ERROR: ee_u16 is not a 16b datatype!\n");
#line 221
    retval = (ee_u8 )((int )retval + 1);
  }
#line 223
  if (sizeof(ee_s16 ) != 2UL) {
#line 225
    printf((char const   * __restrict  )"ERROR: ee_s16 is not a 16b datatype!\n");
#line 226
    retval = (ee_u8 )((int )retval + 1);
  }
#line 228
  if (sizeof(ee_s32 ) != 4UL) {
#line 230
    printf((char const   * __restrict  )"ERROR: ee_s32 is not a 32b datatype!\n");
#line 231
    retval = (ee_u8 )((int )retval + 1);
  }
#line 233
  if (sizeof(ee_u32 ) != 4UL) {
#line 235
    printf((char const   * __restrict  )"ERROR: ee_u32 is not a 32b datatype!\n");
#line 236
    retval = (ee_u8 )((int )retval + 1);
  }
#line 238
  if (sizeof(ee_ptr_int ) != sizeof(int *)) {
#line 240
    printf((char const   * __restrict  )"ERROR: ee_ptr_int is not a datatype that holds an int pointer!\n");
#line 242
    retval = (ee_u8 )((int )retval + 1);
  }
#line 244
  if ((int )retval > 0) {
#line 246
    printf((char const   * __restrict  )"ERROR: Please modify the datatypes in core_portme.h!\n");
  }
#line 248
  return (retval);
}
}
#line 1 "cil-3iMhGMQn.o"
#pragma merger("0","/tmp/cil-bF6LUaw2.i","-O2")
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
#line 360
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 363
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 363
  return ((int __attribute__((__gnu_inline__))  )((int )tmp));
}
}
#line 365
__inline extern  __attribute__((__nothrow__)) long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 368
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 368
  return ((long __attribute__((__gnu_inline__))  )tmp);
}
}
#line 372
__inline extern  __attribute__((__nothrow__)) long long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 375
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 375
  return ((long long __attribute__((__gnu_inline__))  )tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(__dev_t __dev )  __attribute__((__const__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(__dev_t __dev )  __attribute__((__const__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                                                       unsigned int __minor )  __attribute__((__const__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(__dev_t __dev )  __attribute__((__const__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int __attribute__((__gnu_inline__))  gnu_dev_major(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major = (unsigned int )((unsigned long )__major | ((__dev & 0xfffff00000000000UL) >> 32));
#line 79
  return ((unsigned int __attribute__((__gnu_inline__))  )__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(__dev_t __dev )  __attribute__((__const__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int __attribute__((__gnu_inline__))  gnu_dev_minor(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor = (unsigned int )((unsigned long )__minor | ((__dev & 17592184995840UL) >> 12));
#line 80
  return ((unsigned int __attribute__((__gnu_inline__))  )__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                                                       unsigned int __minor )  __attribute__((__const__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t __attribute__((__gnu_inline__))  gnu_dev_makedev(unsigned int __major ,
                                                                         unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return ((__dev_t __attribute__((__gnu_inline__))  )__dev);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 817
__inline extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                                                                      void const   *__base ,
                                                                                                      size_t __nmemb ,
                                                                                                      size_t __size ,
                                                                                                      int (*__compar)(void const   * ,
                                                                                                                      void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void __attribute__((__gnu_inline__))  *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                                                                      void const   *__base ,
                                                                                                      size_t __nmemb ,
                                                                                                      size_t __size ,
                                                                                                      int (*__compar)(void const   * ,
                                                                                                                      void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
#line 29
  while (__l < __u) {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void __attribute__((__gnu_inline__))  *)((void *)__p));
    }
  }
#line 42
  return ((void __attribute__((__gnu_inline__))  *)((void *)0));
}
}
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 27
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 27
  return ((double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 30 "posix/core_portme.c"
void *portable_malloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 33
  tmp = malloc(size);
#line 33
  return (tmp);
}
}
#line 38 "posix/core_portme.c"
void portable_free(void *p ) 
{ 


  {
#line 41
  free(p);
#line 42
  return;
}
}
#line 129 "posix/core_portme.c"
static struct timespec start_time_val  ;
#line 129 "posix/core_portme.c"
static struct timespec stop_time_val  ;
#line 139 "posix/core_portme.c"
void start_time(void) 
{ 


  {
#line 142
  clock_gettime(0, & start_time_val);
#line 149
  return;
}
}
#line 158 "posix/core_portme.c"
void stop_time(void) 
{ 


  {
#line 167
  clock_gettime(0, & stop_time_val);
#line 168
  return;
}
}
#line 178 "posix/core_portme.c"
CORE_TICKS get_time(void) 
{ 
  CORE_TICKS elapsed ;

  {
#line 181
  elapsed = (stop_time_val.tv_sec - start_time_val.tv_sec) * 1000L + (stop_time_val.tv_nsec - start_time_val.tv_nsec) / 1000000L;
#line 183
  return (elapsed);
}
}
#line 192 "posix/core_portme.c"
secs_ret time_in_secs(CORE_TICKS ticks ) 
{ 
  secs_ret retval ;

  {
#line 195
  retval = (secs_ret )ticks / (secs_ret )1000;
#line 196
  return (retval);
}
}
#line 202 "posix/core_portme.c"
ee_u32 default_num_contexts  =    (ee_u32 )1;
#line 208 "posix/core_portme.c"
void portable_init(core_portable *p , int *argc , char **argv ) 
{ 


  {
#line 218
  if (sizeof(ee_ptr_int ) != sizeof(ee_u8 *)) {
#line 220
    printf((char const   * __restrict  )"ERROR! Please define ee_ptr_int to a type that holds a pointer!\n");
  }
#line 224
  if (sizeof(ee_u32 ) != 4UL) {
#line 226
    printf((char const   * __restrict  )"ERROR! Please define ee_u32 to a 32b unsigned type!\n");
  }
#line 249
  p->portable_id = (ee_u8 )1;
#line 250
  return;
}
}
#line 254 "posix/core_portme.c"
void portable_fini(core_portable *p ) 
{ 


  {
#line 257
  p->portable_id = (ee_u8 )0;
#line 258
  return;
}
}

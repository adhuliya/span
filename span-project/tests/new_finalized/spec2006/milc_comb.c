/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 73 "./complex.h"
struct __anonstruct_complex_25 {
   double real ;
   double imag ;
};
#line 73 "./complex.h"
typedef struct __anonstruct_complex_25 complex;
#line 6 "./random.h"
struct __anonstruct_double_prn_27 {
   unsigned long r0 ;
   unsigned long r1 ;
   unsigned long r2 ;
   unsigned long r3 ;
   unsigned long r4 ;
   unsigned long r5 ;
   unsigned long r6 ;
   unsigned long multiplier ;
   unsigned long addend ;
   unsigned long ic_state ;
   double scale ;
};
#line 6 "./random.h"
typedef struct __anonstruct_double_prn_27 double_prn;
#line 14 "./su3.h"
struct __anonstruct_su3_matrix_28 {
   complex e[3][3] ;
};
#line 14 "./su3.h"
typedef struct __anonstruct_su3_matrix_28 su3_matrix;
#line 15 "./su3.h"
struct __anonstruct_su3_vector_29 {
   complex c[3] ;
};
#line 15 "./su3.h"
typedef struct __anonstruct_su3_vector_29 su3_vector;
#line 16 "./su3.h"
struct __anonstruct_anti_hermitmat_30 {
   complex m01 ;
   complex m02 ;
   complex m12 ;
   double m00im ;
   double m11im ;
   double m22im ;
   double space ;
};
#line 16 "./su3.h"
typedef struct __anonstruct_anti_hermitmat_30 anti_hermitmat;
#line 31 "./int32type.h"
typedef int int32type;
#line 32 "./int32type.h"
typedef unsigned int u_int32type;
#line 42 "./macros.h"
typedef int field_offset;
#line 65 "./io_lat.h"
struct __anonstruct_gauge_header_43 {
   int32type magic_number ;
   char time_stamp[64] ;
   int32type dims[4] ;
   int32type header_bytes ;
   int32type order ;
};
#line 65 "./io_lat.h"
typedef struct __anonstruct_gauge_header_43 gauge_header;
#line 96 "./io_lat.h"
struct __anonstruct_gauge_check_44 {
   u_int32type sum31 ;
   u_int32type sum29 ;
};
#line 96 "./io_lat.h"
typedef struct __anonstruct_gauge_check_44 gauge_check;
#line 254 "./io_lat.h"
struct __anonstruct_gauge_file_48 {
   FILE *fp ;
   gauge_header *header ;
   char *filename ;
   int byterevflag ;
   int32type *rank2rcv ;
   int parallel ;
   gauge_check check ;
};
#line 254 "./io_lat.h"
typedef struct __anonstruct_gauge_file_48 gauge_file;
#line 31 "./lattice.h"
struct __anonstruct_site_49 {
   short x ;
   short y ;
   short z ;
   short t ;
   char parity ;
   int index ;
   double_prn site_prn ;
   int space1 ;
   su3_matrix link[4] ;
   anti_hermitmat mom[4] ;
   double phase[4] ;
   su3_vector phi ;
   su3_vector resid ;
   su3_vector cg_p ;
   su3_vector xxx ;
   su3_vector ttt ;
   su3_vector g_rand ;
   su3_vector tempvec[4] ;
   su3_vector templongvec[4] ;
   su3_vector templongv1 ;
   su3_matrix tempmat1 ;
   su3_matrix staple ;
};
#line 31 "./lattice.h"
typedef struct __anonstruct_site_49 site;
#line 7 "./params.h"
struct __anonstruct_params_51 {
   int stopflag ;
   int nx ;
   int ny ;
   int nz ;
   int nt ;
   int iseed ;
   int nflavors ;
   int warms ;
   int trajecs ;
   int steps ;
   int propinterval ;
   double beta ;
   double mass ;
   double u0 ;
   int niter ;
   double rsqmin ;
   double rsqprop ;
   double epsilon ;
   int source_start ;
   int source_inc ;
   int n_sources ;
   int startflag ;
   int saveflag ;
   char startfile[256] ;
   char savefile[256] ;
};
#line 7 "./params.h"
typedef struct __anonstruct_params_51 params;
#line 26 "check_unitarity.c"
union __anonunion_ifval_51 {
   double fval ;
   int ival ;
};
#line 53 "./comdefs.h"
struct __anonstruct_msg_tag_50 {
   int msg_node ;
   int msg_size ;
   char *msg_buf ;
   int msg_id ;
};
#line 53 "./comdefs.h"
typedef struct __anonstruct_msg_tag_50 msg_tag;
#line 20 "./su3.h"
struct __anonstruct_su2_matrix_31 {
   complex e[2][2] ;
};
#line 20 "./su3.h"
typedef struct __anonstruct_su2_matrix_31 su2_matrix;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 57 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 213 "./io_lat.h"
struct __anonstruct_QCDheader_47 {
   int ntoken ;
   char **token ;
   char **value ;
};
#line 213 "./io_lat.h"
typedef struct __anonstruct_QCDheader_47 QCDheader;
#line 84 "io_lat4.c"
typedef double OUTPUT_TYPE;
#line 150 "io_lat4.c"
union __anonunion_u_51 {
   long l ;
   char c[sizeof(long )] ;
};
#line 1099 "io_lat4.c"
struct __anonstruct_gauge_field_52 {
   int32type n_descript ;
   char descript[200] ;
   int32type n_param ;
   double param[2] ;
};
#line 2125 "io_lat4.c"
struct __anonstruct_msg_53 {
   short x ;
   short y ;
   short z ;
   short t ;
   su3_matrix link[4] ;
};
#line 2486 "io_lat4.c"
struct __anonstruct_msg_54 {
   short x ;
   short y ;
   short z ;
   short t ;
   su3_matrix link[4] ;
};
#line 78 "reunitarize2.c"
union __anonunion_ifval_51___0 {
   double fval ;
   int ival ;
};
#line 47 "./su3.h"
struct __anonstruct_half_wilson_vector_44 {
   su3_vector h[2] ;
};
#line 47 "./su3.h"
typedef struct __anonstruct_half_wilson_vector_44 half_wilson_vector;
#line 83 "quark_stuff.c"
struct __anonstruct_q_paths_51 {
   int dir[7] ;
   int length ;
   double coeff ;
   double forwback ;
};
#line 77 "./complex.h"
struct __anonstruct_double_complex_26 {
   double real ;
   double imag ;
};
#line 77 "./complex.h"
typedef struct __anonstruct_double_complex_26 double_complex;
#line 46 "./su3.h"
struct __anonstruct_wilson_vector_32 {
   su3_vector d[4] ;
};
#line 46 "./su3.h"
typedef struct __anonstruct_wilson_vector_32 wilson_vector;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 1 "control.o"
#pragma merger("0","/tmp/cil-Uoxov8EC.i","")
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 118 "./io_lat.h"
char *gauge_info_keyword[36]  = 
#line 118 "./io_lat.h"
  {      (char *)"magic_number",      (char *)"time_stamp",      (char *)"checksums",      (char *)"nx", 
        (char *)"ny",      (char *)"nz",      (char *)"nt",      (char *)"action.description", 
        (char *)"gauge.description",      (char *)"gauge.beta11",      (char *)"gauge.beta12",      (char *)"gauge.tadpole.u0", 
        (char *)"gauge.nloops",      (char *)"gauge.nreps",      (char *)"gauge.previous.filename",      (char *)"gauge.previous.time_stamp", 
        (char *)"gauge.previous.checksums",      (char *)"gauge.fix.description",      (char *)"gauge.fix.tolerance",      (char *)"gauge.smear.description", 
        (char *)"gauge.smear.steps",      (char *)"gauge.smear.factor",      (char *)"quark.description",      (char *)"quark.flavors", 
        (char *)"quark.flavors1",      (char *)"quark.flavors2",      (char *)"quark.mass",      (char *)"quark.mass1", 
        (char *)"quark.mass2",      (char *)"quark.kappa",      (char *)"quark.link.c1",      (char *)"quark.link.c3", 
        (char *)"quark.staple.w3",      (char *)"quark.clover.c0",      (char *)"quark.clover.u0",      (char *)""};
#line 270 "./io_lat.h"
char ensemble_id[256]  ;
#line 271 "./io_lat.h"
int sequence_number  ;
#line 306
gauge_file *save_lattice(int flag , char *filename ) ;
#line 116 "./lattice.h"
int nx  ;
#line 116 "./lattice.h"
int ny  ;
#line 116 "./lattice.h"
int nz  ;
#line 116 "./lattice.h"
int nt  ;
#line 117 "./lattice.h"
int volume  ;
#line 118 "./lattice.h"
int iseed  ;
#line 119 "./lattice.h"
int warms  ;
#line 119 "./lattice.h"
int trajecs  ;
#line 119 "./lattice.h"
int steps  ;
#line 119 "./lattice.h"
int niter  ;
#line 119 "./lattice.h"
int propinterval  ;
#line 119 "./lattice.h"
int nflavors  ;
#line 120 "./lattice.h"
double epsilon  ;
#line 121 "./lattice.h"
double beta  ;
#line 121 "./lattice.h"
double mass  ;
#line 121 "./lattice.h"
double u0  ;
#line 122 "./lattice.h"
double rsqmin  ;
#line 122 "./lattice.h"
double rsqprop  ;
#line 123 "./lattice.h"
int startflag  ;
#line 125 "./lattice.h"
int saveflag  ;
#line 127 "./lattice.h"
char startfile[256]  ;
#line 127 "./lattice.h"
char savefile[256]  ;
#line 128 "./lattice.h"
int total_iters  ;
#line 129 "./lattice.h"
int phases_in  ;
#line 130 "./lattice.h"
int source_start  ;
#line 130 "./lattice.h"
int source_inc  ;
#line 130 "./lattice.h"
int n_sources  ;
#line 135 "./lattice.h"
int sites_on_node  ;
#line 136 "./lattice.h"
int even_sites_on_node  ;
#line 137 "./lattice.h"
int odd_sites_on_node  ;
#line 138 "./lattice.h"
int number_of_nodes  ;
#line 139 "./lattice.h"
int this_node  ;
#line 142 "./lattice.h"
int valid_longlinks  ;
#line 143 "./lattice.h"
int valid_fatlinks  ;
#line 145 "./lattice.h"
gauge_file *startlat_p  ;
#line 149 "./lattice.h"
double_prn node_prn  ;
#line 154 "./lattice.h"
site *lattice  ;
#line 159 "./lattice.h"
char **gen_pt[16]  ;
#line 163 "./lattice.h"
su3_matrix *t_longlink  ;
#line 164 "./lattice.h"
su3_matrix *t_fatlink  ;
#line 72 "./comdefs.h"
void initialize_machine(int argc , char **argv ) ;
#line 173
void g_sync(void) ;
#line 195
double dclock(void) ;
#line 35 "./generic_ks.h"
void rephase(int flag ) ;
#line 86
void f_meas_imp(field_offset phi_off , field_offset xxx_off , double mass___0 ) ;
#line 28 "./ks_imp_includes.h"
int setup(void) ;
#line 29
int readin(int prompt ) ;
#line 30
int update(void) ;
#line 37
void g_measure(void) ;
#line 18 "control.c"
gauge_header start_lat_hdr  ;
#line 20 "control.c"
int main(int argc , char **argv ) 
{ 
  int meascount ;
  int traj_done ;
  int prompt ;
  int s_iters ;
  int avs_iters ;
  int avspect_iters ;
  int avbcorr_iters ;
  double dtime ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
#line 27
  initialize_machine(argc, argv);
#line 28
  g_sync();
#line 30
  prompt = setup();
#line 32
  while (1) {
#line 32
    tmp___1 = readin(prompt);
#line 32
    if (! (tmp___1 == 0)) {
#line 32
      break;
    }
#line 35
    tmp = dclock();
#line 35
    dtime = - tmp;
#line 36
    traj_done = 0;
#line 36
    while (traj_done < warms) {
#line 37
      update();
#line 36
      traj_done ++;
    }
#line 39
    if (this_node == 0) {
#line 39
      printf((char const   * __restrict  )"WARMUPS COMPLETED\n");
    }
#line 39
    fflush(stdout);
#line 42
    meascount = 0;
#line 43
    avbcorr_iters = 0;
#line 43
    avs_iters = avbcorr_iters;
#line 43
    avspect_iters = avs_iters;
#line 44
    traj_done = 0;
#line 44
    while (traj_done < trajecs) {
#line 47
      s_iters = update();
#line 50
      if (traj_done % propinterval == propinterval - 1) {
#line 54
        rephase(0);
#line 55
        g_measure();
#line 56
        rephase(1);
#line 57
        f_meas_imp((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                   (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
                   mass);
#line 91
        avs_iters += s_iters;
#line 92
        meascount ++;
#line 93
        fflush(stdout);
      }
#line 44
      traj_done ++;
    }
#line 97
    if (this_node == 0) {
#line 97
      printf((char const   * __restrict  )"RUNNING COMPLETED\n");
    }
#line 97
    fflush(stdout);
#line 98
    if (meascount > 0) {
#line 99
      if (this_node == 0) {
#line 99
        printf((char const   * __restrict  )"average cg iters for step= %e\n", (double )avs_iters / (double )meascount);
      }
    }
#line 107
    tmp___0 = dclock();
#line 107
    dtime += tmp___0;
#line 108
    if (this_node == 0) {
#line 110
      printf((char const   * __restrict  )"total_iters = %d\n", total_iters);
    }
#line 112
    fflush(stdout);
#line 115
    if (saveflag != 20) {
#line 116
      rephase(0);
#line 117
      save_lattice(saveflag, savefile);
#line 118
      rephase(1);
    }
  }
#line 121
  return (0);
}
}
#line 1 "f_meas.o"
#pragma merger("0","/tmp/cil-GJhdhGiZ.i","")
#line 388 "./su3.h"
complex su3_dot(su3_vector *a , su3_vector *b ) ;
#line 174 "./comdefs.h"
void g_doublesum(double *dpt ) ;
#line 108 "./generic_ks.h"
void grsource_imp(field_offset dest , double mass___0 , int parity ) ;
#line 113
int mat_invert_uml(field_offset src , field_offset dest , field_offset temp___0 ,
                   double mass___0 ) ;
#line 126
void load_longlinks(void) ;
#line 127
void load_fatlinks(void) ;
#line 21 "f_meas.c"
void f_meas_imp(field_offset phi_off , field_offset xxx_off , double mass___0 ) 
{ 
  double r_psi_bar_psi_even ;
  double r_psi_bar_psi_odd ;
  double r_ferm_action ;
  register int i ;
  register site *st ;
  double rpbp_e ;
  double rpbp_o ;
  double rfaction ;
  complex cc ;
  int npbp_reps ;
  int jpbp_reps ;

  {
#line 38
  npbp_reps = 1;
#line 43
  if (! (valid_longlinks == 1)) {
#line 43
    load_longlinks();
  }
#line 44
  if (! (valid_fatlinks == 1)) {
#line 44
    load_fatlinks();
  }
#line 47
  jpbp_reps = 0;
#line 47
  while (jpbp_reps < npbp_reps) {
#line 48
    rfaction = 0.0;
#line 48
    rpbp_o = rfaction;
#line 48
    rpbp_e = rpbp_o;
#line 51
    grsource_imp(phi_off, mass___0, 3);
#line 52
    mat_invert_uml((field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
                   xxx_off, phi_off, mass___0);
#line 56
    i = 0;
#line 56
    st = lattice;
#line 56
    while (i < even_sites_on_node) {
#line 57
      cc = su3_dot((su3_vector *)((char *)st + phi_off), (su3_vector *)((char *)st + xxx_off));
#line 59
      rfaction += cc.real;
#line 60
      cc = su3_dot(& st->g_rand, (su3_vector *)((char *)st + xxx_off));
#line 61
      rpbp_e += cc.real;
#line 56
      i ++;
#line 56
      st ++;
    }
#line 64
    i = even_sites_on_node;
#line 64
    st = lattice + i;
#line 64
    while (i < sites_on_node) {
#line 65
      cc = su3_dot(& st->g_rand, (su3_vector *)((char *)st + xxx_off));
#line 66
      rpbp_o += cc.real;
#line 64
      i ++;
#line 64
      st ++;
    }
#line 69
    g_doublesum(& rpbp_o);
#line 70
    g_doublesum(& rpbp_e);
#line 71
    g_doublesum(& rfaction);
#line 73
    r_psi_bar_psi_odd = rpbp_o * (2.0 / (double )volume);
#line 74
    r_psi_bar_psi_even = rpbp_e * (2.0 / (double )volume);
#line 75
    r_ferm_action = rfaction * (1.0 / (double )volume);
#line 76
    if (this_node == 0) {
#line 76
      printf((char const   * __restrict  )"PBP: mass %e     %e  %e ( %d of %d )\n",
             mass___0, r_psi_bar_psi_even, r_psi_bar_psi_odd, jpbp_reps + 1, npbp_reps);
    }
#line 78
    if (this_node == 0) {
#line 78
      printf((char const   * __restrict  )"FACTION: mass = %e,  %e ( %d of %d )\n",
             mass___0, r_ferm_action, jpbp_reps + 1, npbp_reps);
    }
#line 47
    jpbp_reps ++;
  }
#line 81
  return;
}
}
#line 1 "gauge_info.o"
#pragma merger("0","/tmp/cil-ekMTnLn7.i","")
#line 288 "./io_lat.h"
int write_gauge_info_item(FILE *fpout , char *keyword , char *fmt , char *src , int count ,
                          int stride ) ;
#line 302
void write_appl_gauge_info(FILE *fp ) ;
#line 41 "./quark_action.h"
static char quark_action_description[72]  = 
#line 41 "./quark_action.h"
  {      (char )'\"',      (char )'O',      (char )'(',      (char )'a', 
        (char )'^',      (char )'2',      (char )')',      (char )':', 
        (char )' ',      (char )'c',      (char )'o',      (char )'u', 
        (char )'p',      (char )'l',      (char )'i',      (char )'n', 
        (char )'g',      (char )'s',      (char )'(',      (char )'p', 
        (char )'i',      (char )')',      (char )'=',      (char )'0', 
        (char )',',      (char )' ',      (char )'N',      (char )'a', 
        (char )'i',      (char )'k',      (char )' ',      (char )'t', 
        (char )'e',      (char )'r',      (char )'m',      (char )',', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'O',      (char )'(',      (char )'a',      (char )'^', 
        (char )'2',      (char )')',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'s',      (char )',',      (char )' ',      (char )'t', 
        (char )'a',      (char )'d',      (char )'p',      (char )'o', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'e',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )'s',      (char )'\"',      (char )'\000'};
#line 31 "gauge_info.c"
char gauge_action_description[128] ;
#line 32
int gauge_action_nloops ;
#line 32
int gauge_action_nreps ;
#line 33 "gauge_info.c"
void write_appl_gauge_info(FILE *fp ) 
{ 


  {
#line 42
  write_gauge_info_item(fp, (char *)"action.description", (char *)"%s", (char *)"\"Gauge plus fermion (improved)\"",
                        0, 0);
#line 45
  write_gauge_info_item(fp, (char *)"gauge.description", (char *)"%s", gauge_action_description,
                        0, 0);
#line 47
  write_gauge_info_item(fp, (char *)"gauge.nloops", (char *)"%d", (char *)(& gauge_action_nloops),
                        0, 0);
#line 48
  write_gauge_info_item(fp, (char *)"gauge.nreps", (char *)"%d", (char *)(& gauge_action_nreps),
                        0, 0);
#line 49
  write_gauge_info_item(fp, (char *)"gauge.beta11", (char *)"%f", (char *)(& beta),
                        0, 0);
#line 50
  write_gauge_info_item(fp, (char *)"gauge.tadpole.u0", (char *)"%f", (char *)(& u0),
                        0, 0);
#line 52
  write_gauge_info_item(fp, (char *)"quark.description", (char *)"%s", quark_action_description,
                        0, 0);
#line 53
  write_gauge_info_item(fp, (char *)"quark.flavors", (char *)"%d", (char *)(& nflavors),
                        0, 0);
#line 54
  write_gauge_info_item(fp, (char *)"quark.mass", (char *)"%f", (char *)(& mass),
                        0, 0);
#line 56
  return;
}
}
#line 1 "setup.o"
#pragma merger("0","/tmp/cil-bxg6RmS4.i","")
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 307 "./io_lat.h"
gauge_file *reload_lattice(int flag , char *filename ) ;
#line 308
int ask_starting_lattice(int prompt , int *flag , char *filename ) ;
#line 309
int ask_ending_lattice(int prompt , int *flag , char *filename ) ;
#line 312
int get_f(int prompt , char *variable_name_string , double *value ) ;
#line 313
int get_i(int prompt , char *variable_name_string , int *value ) ;
#line 315
int get_prompt(int *prompt ) ;
#line 73 "./comdefs.h"
void make_nn_gathers(void) ;
#line 74
void sort_eight_neighborlists(int index___0 ) ;
#line 83
int make_gather(void (*func)(int  , int  , int  , int  , int * , int  , int * , int * ,
                             int * , int * ) , int *args , int inverse , int want_even_odd ,
                int parity_conserve ) ;
#line 170
char *machine_type(void) ;
#line 171
int mynode(void) ;
#line 172
int numnodes(void) ;
#line 188
void broadcast_bytes(char *buf , int size ) ;
#line 200
void normal_exit(int status ) ;
#line 34 "./generic_ks.h"
void phaseset(void) ;
#line 122
void make_path_table(void) ;
#line 45 "./generic.h"
void make_loop_table(void) ;
#line 52
void setup_layout(void) ;
#line 58
void make_lattice(void) ;
#line 83
void initialize_prn(double_prn *prn_pt , int seed , int index___0 ) ;
#line 25 "setup.c"
gauge_file *gf  ;
#line 37 "setup.c"
params par_buf  ;
#line 40
int initial_set(void) ;
#line 41
void make_3n_gathers(void) ;
#line 39 "setup.c"
int setup(void) 
{ 
  int prompt ;
  int tmp ;

  {
#line 45
  prompt = initial_set();
#line 47
  tmp = mynode();
#line 47
  initialize_prn(& node_prn, iseed, volume + tmp);
#line 49
  setup_layout();
#line 51
  make_lattice();
#line 52
  if (this_node == 0) {
#line 52
    printf((char const   * __restrict  )"Made lattice\n");
  }
#line 52
  fflush(stdout);
#line 55
  make_nn_gathers();
#line 56
  if (this_node == 0) {
#line 56
    printf((char const   * __restrict  )"Made nn gathers\n");
  }
#line 56
  fflush(stdout);
#line 59
  make_3n_gathers();
#line 60
  if (this_node == 0) {
#line 60
    printf((char const   * __restrict  )"Made 3nn gathers\n");
  }
#line 60
  fflush(stdout);
#line 62
  phaseset();
#line 64
  if (this_node == 0) {
#line 64
    printf((char const   * __restrict  )"Finished setup\n");
  }
#line 64
  fflush(stdout);
#line 65
  return (prompt);
}
}
#line 70 "setup.c"
int initial_set(void) 
{ 
  int prompt ;
  int status ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 73
  tmp___7 = mynode();
#line 73
  if (tmp___7 == 0) {
#line 75
    printf((char const   * __restrict  )"SU3 with improved KS action\n");
#line 76
    printf((char const   * __restrict  )"Microcanonical simulation with refreshing\n");
#line 77
    printf((char const   * __restrict  )"MIMD version 6\n");
#line 78
    tmp = numnodes();
#line 78
    tmp___0 = machine_type();
#line 78
    printf((char const   * __restrict  )"Machine = %s, with %d nodes\n", tmp___0,
           tmp);
#line 85
    printf((char const   * __restrict  )"R algorithm\n");
#line 90
    status = get_prompt(& prompt);
#line 91
    if (status == 0) {
#line 91
      tmp___1 = get_i(prompt, (char *)"nflavors", & par_buf.nflavors);
#line 91
      status += tmp___1;
    }
#line 98
    if (status == 0) {
#line 98
      tmp___2 = get_i(prompt, (char *)"nx", & par_buf.nx);
#line 98
      status += tmp___2;
    }
#line 99
    if (status == 0) {
#line 99
      tmp___3 = get_i(prompt, (char *)"ny", & par_buf.ny);
#line 99
      status += tmp___3;
    }
#line 100
    if (status == 0) {
#line 100
      tmp___4 = get_i(prompt, (char *)"nz", & par_buf.nz);
#line 100
      status += tmp___4;
    }
#line 101
    if (status == 0) {
#line 101
      tmp___5 = get_i(prompt, (char *)"nt", & par_buf.nt);
#line 101
      status += tmp___5;
    }
#line 102
    if (status == 0) {
#line 102
      tmp___6 = get_i(prompt, (char *)"iseed", & par_buf.iseed);
#line 102
      status += tmp___6;
    }
#line 104
    if (status > 0) {
#line 104
      par_buf.stopflag = 1;
    } else {
#line 104
      par_buf.stopflag = 0;
    }
  }
#line 108
  broadcast_bytes((char *)(& par_buf), (int )sizeof(par_buf));
#line 110
  if (par_buf.stopflag != 0) {
#line 111
    normal_exit(0);
  }
#line 113
  nx = par_buf.nx;
#line 114
  ny = par_buf.ny;
#line 115
  nz = par_buf.nz;
#line 116
  nt = par_buf.nt;
#line 117
  iseed = par_buf.iseed;
#line 118
  nflavors = par_buf.nflavors;
#line 120
  this_node = mynode();
#line 121
  number_of_nodes = numnodes();
#line 122
  volume = ((nx * ny) * nz) * nt;
#line 123
  total_iters = 0;
#line 124
  return (prompt);
}
}
#line 128 "setup.c"
int readin(int prompt ) 
{ 
  int status ;
  double x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 136
  if (this_node == 0) {
#line 138
    printf((char const   * __restrict  )"\n\n");
#line 139
    status = 0;
#line 142
    if (status == 0) {
#line 142
      tmp = get_i(prompt, (char *)"warms", & par_buf.warms);
#line 142
      status += tmp;
    }
#line 143
    if (status == 0) {
#line 143
      tmp___0 = get_i(prompt, (char *)"trajecs", & par_buf.trajecs);
#line 143
      status += tmp___0;
    }
#line 146
    if (status == 0) {
#line 146
      tmp___1 = get_i(prompt, (char *)"traj_between_meas", & par_buf.propinterval);
#line 146
      status += tmp___1;
    }
#line 151
    if (status == 0) {
#line 151
      tmp___2 = get_f(prompt, (char *)"beta", & par_buf.beta);
#line 151
      status += tmp___2;
    }
#line 152
    if (status == 0) {
#line 152
      tmp___3 = get_f(prompt, (char *)"mass", & par_buf.mass);
#line 152
      status += tmp___3;
    }
#line 153
    if (status == 0) {
#line 153
      tmp___4 = get_f(prompt, (char *)"u0", & par_buf.u0);
#line 153
      status += tmp___4;
    }
#line 156
    if (status == 0) {
#line 156
      tmp___5 = get_f(prompt, (char *)"microcanonical_time_step", & par_buf.epsilon);
#line 156
      status += tmp___5;
    }
#line 160
    if (status == 0) {
#line 160
      tmp___6 = get_i(prompt, (char *)"steps_per_trajectory", & par_buf.steps);
#line 160
      status += tmp___6;
    }
#line 163
    if (status == 0) {
#line 163
      tmp___7 = get_i(prompt, (char *)"max_cg_iterations", & par_buf.niter);
#line 163
      status += tmp___7;
    }
#line 166
    if (status == 0) {
#line 166
      tmp___8 = get_f(prompt, (char *)"error_per_site", & x);
#line 166
      status += tmp___8;
    }
#line 167
    if (status == 0) {
#line 167
      par_buf.rsqmin = x * x;
    }
#line 171
    if (status == 0) {
#line 171
      tmp___9 = get_f(prompt, (char *)"error_for_propagator", & x);
#line 171
      status += tmp___9;
    }
#line 172
    if (status == 0) {
#line 172
      par_buf.rsqprop = x * x;
    }
#line 182
    if (status == 0) {
#line 182
      tmp___10 = ask_starting_lattice(prompt, & par_buf.startflag, par_buf.startfile);
#line 182
      status += tmp___10;
    }
#line 186
    if (status == 0) {
#line 186
      tmp___11 = ask_ending_lattice(prompt, & par_buf.saveflag, par_buf.savefile);
#line 186
      status += tmp___11;
    }
#line 189
    if (status > 0) {
#line 189
      par_buf.stopflag = 1;
    } else {
#line 189
      par_buf.stopflag = 0;
    }
  }
#line 193
  broadcast_bytes((char *)(& par_buf), (int )sizeof(par_buf));
#line 195
  if (par_buf.stopflag != 0) {
#line 196
    normal_exit(0);
  }
#line 198
  warms = par_buf.warms;
#line 199
  trajecs = par_buf.trajecs;
#line 200
  steps = par_buf.steps;
#line 201
  propinterval = par_buf.propinterval;
#line 202
  niter = par_buf.niter;
#line 203
  rsqmin = par_buf.rsqmin;
#line 204
  rsqprop = par_buf.rsqprop;
#line 205
  epsilon = par_buf.epsilon;
#line 206
  beta = par_buf.beta;
#line 207
  mass = par_buf.mass;
#line 208
  u0 = par_buf.u0;
#line 214
  startflag = par_buf.startflag;
#line 215
  saveflag = par_buf.saveflag;
#line 216
  strcpy((char * __restrict  )(startfile), (char const   * __restrict  )(par_buf.startfile));
#line 217
  strcpy((char * __restrict  )(savefile), (char const   * __restrict  )(par_buf.savefile));
#line 220
  if (startflag == 10) {
#line 221
    rephase(0);
  }
#line 223
  startlat_p = reload_lattice(startflag, startfile);
#line 225
  valid_longlinks = 0;
#line 225
  valid_fatlinks = valid_longlinks;
#line 226
  phases_in = 0;
#line 227
  rephase(1);
#line 230
  make_loop_table();
#line 232
  make_path_table();
#line 234
  return (0);
}
}
#line 243
void third_neighbor(int x , int y , int z , int t , int *dirpt , int FB , int *xp ,
                    int *yp , int *zp , int *tp ) ;
#line 241 "setup.c"
void make_3n_gathers(void) 
{ 
  int i ;

  {
#line 245
  i = 0;
#line 245
  while (i <= 3) {
#line 246
    make_gather(& third_neighbor, & i, 1, 0, 1);
#line 245
    i ++;
  }
#line 253
  sort_eight_neighborlists(8);
#line 254
  return;
}
}
#line 260 "setup.c"
void third_neighbor(int x , int y , int z , int t , int *dirpt , int FB , int *xp ,
                    int *yp , int *zp , int *tp ) 
{ 
  int dir ;

  {
#line 266
  if (FB == 1) {
#line 266
    dir = *dirpt;
  } else {
#line 266
    dir = 7 - *dirpt;
  }
#line 267
  *xp = x;
#line 267
  *yp = y;
#line 267
  *zp = z;
#line 267
  *tp = t;
#line 268
  switch (dir) {
  case 0: 
#line 269
  *xp = (x + 3) % nx;
#line 269
  break;
  case 7: 
#line 270
  *xp = ((x + 4 * nx) - 3) % nx;
#line 270
  break;
  case 1: 
#line 271
  *yp = (y + 3) % ny;
#line 271
  break;
  case 6: 
#line 272
  *yp = ((y + 4 * ny) - 3) % ny;
#line 272
  break;
  case 2: 
#line 273
  *zp = (z + 3) % nz;
#line 273
  break;
  case 5: 
#line 274
  *zp = ((z + 4 * nz) - 3) % nz;
#line 274
  break;
  case 3: 
#line 275
  *tp = (t + 3) % nt;
#line 275
  break;
  case 4: 
#line 276
  *tp = ((t + 4 * nt) - 3) % nt;
#line 276
  break;
  default: 
#line 277
  printf((char const   * __restrict  )"third_neighb: bad direction\n");
#line 277
  exit(1);
  }
#line 279
  return;
}
}
#line 1 "update.o"
#pragma merger("0","/tmp/cil-7pB6DEM_.i","")
#line 37 "./generic_ks.h"
int ks_congrad(field_offset src , field_offset dest , double mass___0 , int niter___0 ,
               double rsqmin___0 , int parity , double *final_rsq_ptr ) ;
#line 80 "./generic.h"
void ranmom(void) ;
#line 100
void reunitarize(void) ;
#line 31 "./ks_imp_includes.h"
void update_h(double eps ) ;
#line 32
void update_u(double eps ) ;
#line 20 "update.c"
int update(void) 
{ 
  int step ;
  int iters ;
  double final_rsq ;
  double cg_time ;
  int tmp ;

  {
#line 21
  iters = 0;
#line 31
  ranmom();
#line 40
  step = 1;
#line 40
  while (step <= steps) {
#line 70
    update_u(epsilon * (0.5 - (double )nflavors / 8.0));
#line 73
    grsource_imp((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                 mass, 2);
#line 73
    cg_time = - 1.0e6;
#line 76
    update_u((epsilon * (double )nflavors) / 8.0);
#line 80
    tmp = ks_congrad((field_offset )((char *)(& (lattice + 0)->phi) - (char *)(lattice + 0)),
                     (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
                     mass, niter, rsqmin, 2, & final_rsq);
#line 80
    iters += tmp;
#line 82
    cg_time = ((double )step - 0.5) * epsilon;
#line 84
    update_h(epsilon);
#line 87
    update_u(epsilon * 0.5);
#line 90
    rephase(0);
#line 91
    reunitarize();
#line 92
    rephase(1);
#line 40
    step ++;
  }
#line 122
  if (steps > 0) {
#line 122
    return (iters / steps);
  } else {
#line 123
    return (-99);
  }
}
}
#line 1 "update_h.o"
#pragma merger("0","/tmp/cil-GrdGfTdT.i","")
#line 42 "./generic_ks.h"
void dslash_fn(field_offset src , field_offset dest , int parity ) ;
#line 123
void eo_fermion_force(double eps , int nflavors___0 , field_offset x_off ) ;
#line 44 "./generic.h"
void imp_gauge_force(double eps , field_offset mom_off ) ;
#line 12 "update_h.c"
void update_h(double eps ) 
{ 


  {
#line 14
  rephase(0);
#line 15
  imp_gauge_force(eps, (field_offset )((char *)(& (lattice + 0)->mom) - (char *)(lattice + 0)));
#line 16
  rephase(1);
#line 21
  dslash_fn((field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
            (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)),
            1);
#line 22
  eo_fermion_force(eps, nflavors, (field_offset )((char *)(& (lattice + 0)->xxx) - (char *)(lattice + 0)));
#line 23
  return;
}
}
#line 1 "update_u.o"
#pragma merger("0","/tmp/cil-67KkIs7u.i","")
#line 358 "./su3.h"
void mult_su3_nn(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
#line 368
void scalar_mult_add_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) ;
#line 381
void uncompress_anti_hermitian(anti_hermitmat *mat_antihermit , su3_matrix *mat_su3 ) ;
#line 384
void su3mat_copy(su3_matrix *a , su3_matrix *b ) ;
#line 16 "update_u.c"
void update_u(double eps ) 
{ 
  register int i ;
  register int dir ;
  register site *s ;
  su3_matrix *link ;
  su3_matrix temp1 ;
  su3_matrix temp2 ;
  su3_matrix htemp ;
  register double t2 ;
  register double t3 ;
  register double t4 ;
  register double t5 ;
  register double t6 ;

  {
#line 31
  t2 = eps / 2.0;
#line 32
  t3 = eps / 3.0;
#line 33
  t4 = eps / 4.0;
#line 34
  t5 = eps / 5.0;
#line 35
  t6 = eps / 6.0;
#line 40
  i = 0;
#line 40
  s = lattice;
#line 40
  while (i < sites_on_node) {
#line 41
    dir = 0;
#line 41
    while (dir <= 3) {
#line 42
      uncompress_anti_hermitian(& s->mom[dir], & htemp);
#line 43
      link = & s->link[dir];
#line 44
      mult_su3_nn(& htemp, link, & temp1);
#line 46
      scalar_mult_add_su3_matrix(link, & temp1, t6, & temp2);
#line 47
      mult_su3_nn(& htemp, & temp2, & temp1);
#line 49
      scalar_mult_add_su3_matrix(link, & temp1, t5, & temp2);
#line 50
      mult_su3_nn(& htemp, & temp2, & temp1);
#line 52
      scalar_mult_add_su3_matrix(link, & temp1, t4, & temp2);
#line 53
      mult_su3_nn(& htemp, & temp2, & temp1);
#line 55
      scalar_mult_add_su3_matrix(link, & temp1, t3, & temp2);
#line 56
      mult_su3_nn(& htemp, & temp2, & temp1);
#line 58
      scalar_mult_add_su3_matrix(link, & temp1, t2, & temp2);
#line 59
      mult_su3_nn(& htemp, & temp2, & temp1);
#line 60
      scalar_mult_add_su3_matrix(link, & temp1, eps, & temp2);
#line 61
      su3mat_copy(& temp2, link);
#line 41
      dir ++;
    }
#line 40
    i ++;
#line 40
    s ++;
  }
#line 65
  valid_longlinks = 0;
#line 66
  valid_fatlinks = 0;
#line 71
  return;
}
}
#line 1 "layout_hyper.o"
#pragma merger("0","/tmp/cil-bWj8wu_N.i","")
#line 198 "./comdefs.h"
void terminate(int status ) ;
#line 53 "./generic.h"
int node_number(int x , int y , int z , int t ) ;
#line 54
int node_index(int x , int y , int z , int t ) ;
#line 55
int num_sites(int node ) ;
#line 34 "layout_hyper.c"
int squaresize[4]  ;
#line 35 "layout_hyper.c"
int nsquares[4]  ;
#line 37 "layout_hyper.c"
void setup_layout(void) 
{ 
  register int i ;
  register int j ;
  register int dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 39
  tmp = mynode();
#line 39
  if (tmp == 0) {
#line 40
    printf((char const   * __restrict  )"LAYOUT = Hypercubes, options = ");
#line 41
    printf((char const   * __restrict  )"EVENFIRST,");
#line 42
    printf((char const   * __restrict  )"\n");
  }
#line 46
  squaresize[0] = nx;
#line 46
  squaresize[1] = ny;
#line 47
  squaresize[2] = nz;
#line 47
  squaresize[3] = nt;
#line 48
  nsquares[3] = 1;
#line 48
  nsquares[2] = nsquares[3];
#line 48
  nsquares[1] = nsquares[2];
#line 48
  nsquares[0] = nsquares[1];
#line 50
  i = 1;
#line 51
  while (1) {
#line 51
    tmp___1 = numnodes();
#line 51
    if (! (i < tmp___1)) {
#line 51
      break;
    }
#line 55
    j = 1;
#line 55
    dir = 0;
#line 55
    while (dir <= 3) {
#line 56
      if (squaresize[dir] > j) {
#line 56
        if (squaresize[dir] % 2 == 0) {
#line 56
          j = squaresize[dir];
        }
      }
#line 55
      dir ++;
    }
#line 61
    dir = 0;
#line 61
    while (dir <= 3) {
#line 62
      if (squaresize[dir] == j) {
#line 62
        if (nsquares[dir] > 1) {
#line 62
          break;
        }
      }
#line 61
      dir ++;
    }
#line 63
    if (dir > 3) {
#line 63
      dir = 0;
#line 63
      while (dir <= 3) {
#line 64
        if (squaresize[dir] == j) {
#line 64
          break;
        }
#line 63
        dir ++;
      }
    }
#line 66
    if (dir > 3) {
#line 67
      tmp___0 = mynode();
#line 67
      if (tmp___0 == 0) {
#line 67
        printf((char const   * __restrict  )"LAYOUT: Can\'t lay out this lattice, not enough factors of 2\n");
      }
#line 69
      terminate(1);
    }
#line 73
    i *= 2;
#line 73
    squaresize[dir] /= 2;
#line 73
    nsquares[dir] *= 2;
  }
#line 76
  sites_on_node = ((squaresize[0] * squaresize[1]) * squaresize[2]) * squaresize[3];
#line 79
  tmp___2 = mynode();
#line 79
  if (tmp___2 == 0) {
#line 79
    if (sites_on_node % 2 != 0) {
#line 80
      printf((char const   * __restrict  )"SORRY, CAN\'T LAY OUT THIS LATTICE\n");
#line 81
      terminate(0);
    }
  }
#line 83
  odd_sites_on_node = sites_on_node / 2;
#line 83
  even_sites_on_node = odd_sites_on_node;
#line 84
  return;
}
}
#line 86 "layout_hyper.c"
int node_number(int x , int y , int z , int t ) 
{ 
  register int i ;

  {
#line 88
  x /= squaresize[0];
#line 88
  y /= squaresize[1];
#line 89
  z /= squaresize[2];
#line 89
  t /= squaresize[3];
#line 90
  i = x + nsquares[0] * (y + nsquares[1] * (z + nsquares[2] * t));
#line 91
  return (i);
}
}
#line 94 "layout_hyper.c"
int node_index(int x , int y , int z , int t ) 
{ 
  register int i ;
  register int xr ;
  register int yr ;
  register int zr ;
  register int tr ;

  {
#line 96
  xr = x % squaresize[0];
#line 96
  yr = y % squaresize[1];
#line 97
  zr = z % squaresize[2];
#line 97
  tr = t % squaresize[3];
#line 98
  i = xr + squaresize[0] * (yr + squaresize[1] * (zr + squaresize[2] * tr));
#line 99
  if ((((x + y) + z) + t) % 2 == 0) {
#line 100
    return (i / 2);
  } else {
#line 103
    return ((i + sites_on_node) / 2);
  }
}
}
#line 107 "layout_hyper.c"
int num_sites(int node ) 
{ 


  {
#line 108
  return (sites_on_node);
}
}
#line 1 "check_unitarity.o"
#pragma merger("0","/tmp/cil-JfXPM1lt.i","")
#line 143 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 30 "./generic.h"
double check_unitarity(void) ;
#line 17 "check_unitarity.c"
double check_su3(su3_matrix *c ) ;
#line 19 "check_unitarity.c"
double check_unitarity(void) 
{ 
  register int i ;
  register int dir ;
  int ii ;
  int jj ;
  register site *s ;
  register su3_matrix *mat ;
  double deviation ;
  double max_deviation___0 ;
  double av_deviation___0 ;
  union __anonunion_ifval_51 ifval ;
  int tmp ;
  int tmp___0 ;

  {
#line 31
  av_deviation___0 = (double )0;
#line 31
  max_deviation___0 = av_deviation___0;
#line 32
  i = 0;
#line 32
  s = lattice;
#line 32
  while (i < sites_on_node) {
#line 36
    dir = 0;
#line 36
    while (dir <= 3) {
#line 38
      mat = & s->link[dir];
#line 39
      deviation = check_su3(mat);
#line 40
      if (deviation > 0.0001) {
#line 41
        tmp = mynode();
#line 41
        printf((char const   * __restrict  )"Unitarity problem on node %d, site %d, dir %d, deviation=%f\n",
               tmp, i, dir, deviation);
#line 43
        printf((char const   * __restrict  )"SU3 matrix:\n");
#line 44
        ii = 0;
#line 44
        while (ii <= 2) {
#line 45
          jj = 0;
#line 45
          while (jj <= 2) {
#line 46
            printf((char const   * __restrict  )"%f ", mat->e[ii][jj].real);
#line 47
            printf((char const   * __restrict  )"%f ", mat->e[ii][jj].imag);
#line 45
            jj ++;
          }
#line 49
          printf((char const   * __restrict  )"\n");
#line 44
          ii ++;
        }
#line 51
        printf((char const   * __restrict  )"repeat in hex:\n");
#line 52
        ii = 0;
#line 52
        while (ii <= 2) {
#line 53
          jj = 0;
#line 53
          while (jj <= 2) {
#line 54
            ifval.fval = mat->e[ii][jj].real;
#line 55
            printf((char const   * __restrict  )"%08x ", ifval.ival);
#line 56
            ifval.fval = mat->e[ii][jj].imag;
#line 57
            printf((char const   * __restrict  )"%08x ", ifval.ival);
#line 53
            jj ++;
          }
#line 59
          printf((char const   * __restrict  )"\n");
#line 52
          ii ++;
        }
#line 61
        printf((char const   * __restrict  )"  \n \n");
#line 62
        fflush(stdout);
#line 62
        terminate(1);
      }
#line 64
      if (max_deviation___0 < deviation) {
#line 64
        max_deviation___0 = deviation;
      }
#line 65
      av_deviation___0 += deviation * deviation;
#line 36
      dir ++;
    }
#line 32
    i ++;
#line 32
    s ++;
  }
#line 68
  av_deviation___0 = sqrt(av_deviation___0 / (double )(4 * i));
#line 73
  if (max_deviation___0 > 0.0001) {
#line 74
    tmp___0 = mynode();
#line 74
    printf((char const   * __restrict  )"Unitarity problem on node %d, maximum deviation=%f\n",
           tmp___0, max_deviation___0);
  }
#line 76
  return (max_deviation___0);
}
}
#line 79 "check_unitarity.c"
double check_su3(su3_matrix *c ) 
{ 
  register double ar ;
  register double ai ;
  register double ari ;
  register double max ;
  register int i ;
  double tmp ;

  {
#line 84
  i = 0;
#line 84
  max = 0.;
#line 84
  while (i < 3) {
#line 85
    ar = ((((c->e[i][0].real * c->e[i][0].real + c->e[i][0].imag * c->e[i][0].imag) + c->e[i][1].real * c->e[i][1].real) + c->e[i][1].imag * c->e[i][1].imag) + c->e[i][2].real * c->e[i][2].real) + c->e[i][2].imag * c->e[i][2].imag;
#line 91
    tmp = sqrt(ar);
#line 91
    ar = fabs(tmp - 1.);
#line 92
    if (max < ar) {
#line 92
      max = ar;
    }
#line 84
    i ++;
  }
#line 98
  ar = ((((c->e[0][0].real * c->e[1][0].real + c->e[0][0].imag * c->e[1][0].imag) + c->e[0][1].real * c->e[1][1].real) + c->e[0][1].imag * c->e[1][1].imag) + c->e[0][2].real * c->e[1][2].real) + c->e[0][2].imag * c->e[1][2].imag;
#line 104
  ai = ((((c->e[0][0].real * c->e[1][0].imag - c->e[0][0].imag * c->e[1][0].real) + c->e[0][1].real * c->e[1][1].imag) - c->e[0][1].imag * c->e[1][1].real) + c->e[0][2].real * c->e[1][2].imag) - c->e[0][2].imag * c->e[1][2].real;
#line 111
  ari = sqrt(ar * ar + ai * ai);
#line 112
  if (max < ari) {
#line 112
    max = ari;
  }
#line 115
  ar = ((((c->e[0][0].real * c->e[2][0].real + c->e[0][0].imag * c->e[2][0].imag) + c->e[0][1].real * c->e[2][1].real) + c->e[0][1].imag * c->e[2][1].imag) + c->e[0][2].real * c->e[2][2].real) + c->e[0][2].imag * c->e[2][2].imag;
#line 121
  ai = ((((c->e[0][0].real * c->e[2][0].imag - c->e[0][0].imag * c->e[2][0].real) + c->e[0][1].real * c->e[2][1].imag) - c->e[0][1].imag * c->e[2][1].real) + c->e[0][2].real * c->e[2][2].imag) - c->e[0][2].imag * c->e[2][2].real;
#line 128
  ari = sqrt(ar * ar + ai * ai);
#line 129
  if (max < ari) {
#line 129
    max = ari;
  }
#line 132
  ar = ((((c->e[1][0].real * c->e[2][0].real + c->e[1][0].imag * c->e[2][0].imag) + c->e[1][1].real * c->e[2][1].real) + c->e[1][1].imag * c->e[2][1].imag) + c->e[1][2].real * c->e[2][2].real) + c->e[1][2].imag * c->e[2][2].imag;
#line 138
  ai = ((((c->e[1][0].real * c->e[2][0].imag - c->e[1][0].imag * c->e[2][0].real) + c->e[1][1].real * c->e[2][1].imag) - c->e[1][1].imag * c->e[2][1].real) + c->e[1][2].real * c->e[2][2].imag) - c->e[1][2].imag * c->e[2][2].real;
#line 145
  ari = sqrt(ar * ar + ai * ai);
#line 146
  if (max < ari) {
#line 146
    max = ari;
  }
#line 150
  return (max);
}
}
#line 1 "d_plaq4.o"
#pragma merger("0","/tmp/cil-0134MEGG.i","")
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 360 "./su3.h"
void mult_su3_an(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
#line 361
double realtrace_su3(su3_matrix *a , su3_matrix *b ) ;
#line 96 "./comdefs.h"
msg_tag *start_gather(field_offset field , int size , int index___0 , int parity ,
                      char **dest ) ;
#line 138
void wait_gather(msg_tag *mbuf ) ;
#line 139
void cleanup_gather(msg_tag *mbuf ) ;
#line 33 "./generic.h"
void d_plaquette(double *ss_plaq , double *st_plaq ) ;
#line 13 "d_plaq4.c"
void d_plaquette(double *ss_plaq , double *st_plaq ) 
{ 
  su3_matrix *su3mat ;
  register int i ;
  register int dir1 ;
  register int dir2 ;
  register site *s ;
  register su3_matrix *m1 ;
  register su3_matrix *m4 ;
  su3_matrix mtmp ;
  double ss_sum ;
  double st_sum ;
  msg_tag *mtag0 ;
  msg_tag *mtag1 ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 22
  st_sum = 0.0;
#line 22
  ss_sum = st_sum;
#line 24
//AD  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 24
//AD  su3mat = (su3_matrix *)tmp;
      su3mat = (su3_matrix *)calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 25
  if ((unsigned long )su3mat == (unsigned long )((void *)0)) {
#line 27
    printf((char const   * __restrict  )"plaquette: can\'t malloc su3mat\n");
#line 28
    fflush(stdout);
#line 28
    terminate(1);
  }
#line 31
  dir1 = 1;
#line 31
  while (dir1 <= 3) {
#line 32
    dir2 = 0;
#line 32
    while (dir2 < dir1) {
#line 34
      mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir2]) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), dir1, 3, gen_pt[0]);
#line 36
      mtag1 = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir1]) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), dir2, 3, gen_pt[1]);
#line 39
      i = 0;
#line 39
      s = lattice;
#line 39
      while (i < sites_on_node) {
#line 40
        m1 = & s->link[dir1];
#line 41
        m4 = & s->link[dir2];
#line 42
        mult_su3_an(m4, m1, su3mat + i);
#line 39
        i ++;
#line 39
        s ++;
      }
#line 45
      wait_gather(mtag0);
#line 46
      wait_gather(mtag1);
#line 48
      i = 0;
#line 48
      s = lattice;
#line 48
      while (i < sites_on_node) {
#line 69
        mult_su3_nn(su3mat + i, (su3_matrix *)*(gen_pt[0] + i), & mtmp);
#line 72
        if (dir1 == 3) {
#line 72
          tmp___0 = realtrace_su3((su3_matrix *)*(gen_pt[1] + i), & mtmp);
#line 72
          st_sum += tmp___0;
        } else {
#line 74
          tmp___1 = realtrace_su3((su3_matrix *)*(gen_pt[1] + i), & mtmp);
#line 74
          ss_sum += tmp___1;
        }
#line 48
        i ++;
#line 48
        s ++;
      }
#line 79
      cleanup_gather(mtag0);
#line 80
      cleanup_gather(mtag1);
#line 32
      dir2 ++;
    }
#line 31
    dir1 ++;
  }
#line 83
  g_doublesum(& ss_sum);
#line 84
  g_doublesum(& st_sum);
#line 88
  *ss_plaq = ss_sum / (double )((((3 * nx) * ny) * nz) * nt);
#line 90
  *st_plaq = st_sum / (double )((((3 * nx) * ny) * nz) * nt);
#line 92
  free((void *)su3mat);
#line 93
  return;
}
}
#line 1 "gaugefix2.o"
#pragma merger("0","/tmp/cil-Ivq8QDBH.i","")
#line 95 "./complex.h"
complex cmplx(double x , double y ) ;
#line 362 "./su3.h"
complex trace_su3(su3_matrix *a ) ;
#line 365
void add_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
#line 366
void sub_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
#line 379
void make_anti_hermitian(su3_matrix *m3 , anti_hermitmat *ah3 ) ;
#line 383
void clear_su3mat(su3_matrix *dest ) ;
#line 393
void clearvec(su3_vector *v ) ;
#line 438
void left_su2_hit_n(su2_matrix *u , int p , int q , su3_matrix *link ) ;
#line 439
void right_su2_hit_a(su2_matrix *u , int p , int q , su3_matrix *link ) ;
#line 441
void mult_su2_mat_vec_elem_n(su2_matrix *u , complex *x0 , complex *x1 ) ;
#line 117 "./comdefs.h"
msg_tag *start_gather_from_temp(void *field , int size , int index___0 , int parity ,
                                char **dest ) ;
#line 36 "./generic.h"
void gaugefix(int gauge_dir , double relax_boost , int max_gauge_iter , double gauge_fix_tol ,
              field_offset diffmat , field_offset sumvec , int nvector , field_offset *vector_offset ,
              int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
              int *antiherm_parity ) ;
#line 79 "gaugefix2.c"
su3_matrix *diffmatp  ;
#line 80 "gaugefix2.c"
su3_vector *sumvecp  ;
#line 81 "gaugefix2.c"
field_offset diffmat_offset  ;
#line 81 "gaugefix2.c"
field_offset sumvec_offset  ;
#line 83 "gaugefix2.c"
void accum_gauge_hit(int gauge_dir , int parity ) 
{ 
  register int j ;
  register su3_matrix *m1 ;
  register su3_matrix *m2 ;
  register int dir ;
  register int i ;
  register site *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 98
  if (parity == 1) {
#line 98
    i = even_sites_on_node;
  } else {
#line 98
    i = 0;
  }
#line 98
  s = lattice + i;
#line 98
  while (1) {
#line 98
    if (parity == 2) {
#line 98
      tmp = even_sites_on_node;
    } else {
#line 98
      tmp = sites_on_node;
    }
#line 98
    if (! (i < tmp)) {
#line 98
      break;
    }
#line 100
    if (diffmat_offset >= 0) {
#line 101
      clear_su3mat((su3_matrix *)((char *)s + diffmat_offset));
    } else {
#line 103
      clear_su3mat(diffmatp + i);
    }
#line 104
    if (sumvec_offset >= 0) {
#line 105
      clearvec((su3_vector *)((char *)s + sumvec_offset));
    } else {
#line 107
      clearvec(sumvecp + i);
    }
#line 98
    i ++;
#line 98
    s ++;
  }
#line 112
  if (parity == 1) {
#line 112
    i = even_sites_on_node;
  } else {
#line 112
    i = 0;
  }
#line 112
  s = lattice + i;
#line 112
  while (1) {
#line 112
    if (parity == 2) {
#line 112
      tmp___0 = even_sites_on_node;
    } else {
#line 112
      tmp___0 = sites_on_node;
    }
#line 112
    if (! (i < tmp___0)) {
#line 112
      break;
    }
#line 114
    dir = 0;
#line 114
    while (dir <= 3) {
#line 114
      if (dir != gauge_dir) {
#line 117
        m1 = & s->link[dir];
#line 118
        if (diffmat_offset >= 0) {
#line 119
          sub_su3_matrix((su3_matrix *)((char *)s + diffmat_offset), m1, (su3_matrix *)((char *)s + diffmat_offset));
        } else {
#line 122
          sub_su3_matrix(diffmatp + i, m1, diffmatp + i);
        }
#line 124
        if (sumvec_offset >= 0) {
#line 126
          j = 0;
#line 126
          while (j < 3) {
#line 126
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].real += m1->e[j][j].real;
#line 126
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].imag += m1->e[j][j].imag;
#line 126
            j ++;
          }
        } else {
#line 131
          j = 0;
#line 131
          while (j < 3) {
#line 131
            (sumvecp + i)->c[j].real += m1->e[j][j].real;
#line 131
            (sumvecp + i)->c[j].imag += m1->e[j][j].imag;
#line 131
            j ++;
          }
        }
      }
#line 114
      dir ++;
    }
#line 112
    i ++;
#line 112
    s ++;
  }
#line 138
  if (parity == 1) {
#line 138
    i = even_sites_on_node;
  } else {
#line 138
    i = 0;
  }
#line 138
  s = lattice + i;
#line 138
  while (1) {
#line 138
    if (parity == 2) {
#line 138
      tmp___1 = even_sites_on_node;
    } else {
#line 138
      tmp___1 = sites_on_node;
    }
#line 138
    if (! (i < tmp___1)) {
#line 138
      break;
    }
#line 140
    dir = 0;
#line 140
    while (dir <= 3) {
#line 140
      if (dir != gauge_dir) {
#line 143
        m2 = (su3_matrix *)*(gen_pt[dir] + i);
#line 145
        if (diffmat_offset >= 0) {
#line 146
          add_su3_matrix((su3_matrix *)((char *)s + diffmat_offset), m2, (su3_matrix *)((char *)s + diffmat_offset));
        } else {
#line 149
          add_su3_matrix(diffmatp + i, m2, diffmatp + i);
        }
#line 151
        if (sumvec_offset >= 0) {
#line 153
          j = 0;
#line 153
          while (j < 3) {
#line 153
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].real += m2->e[j][j].real;
#line 153
            ((su3_vector *)((char *)s + sumvec_offset))->c[j].imag += m2->e[j][j].imag;
#line 153
            j ++;
          }
        } else {
#line 158
          j = 0;
#line 158
          while (j < 3) {
#line 158
            (sumvecp + i)->c[j].real += m2->e[j][j].real;
#line 158
            (sumvecp + i)->c[j].imag += m2->e[j][j].imag;
#line 158
            j ++;
          }
        }
      }
#line 140
      dir ++;
    }
#line 138
    i ++;
#line 138
    s ++;
  }
#line 164
  return;
}
}
#line 167 "gaugefix2.c"
void do_hit(int gauge_dir , int parity , int p , int q , double relax_boost , int nvector ,
            field_offset *vector_offset , int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
            int *antiherm_parity ) 
{ 
  double a0 ;
  double a1 ;
  double a2 ;
  double a3 ;
  double asq ;
  double a0sq ;
  double x ;
  double r ;
  double xdr ;
  register int dir ;
  register int i ;
  register int j ;
  register site *s ;
  su2_matrix u ;
  su3_matrix htemp ;
  int tmp ;

  {
#line 182
  accum_gauge_hit(gauge_dir, parity);
#line 184
  if (parity == 1) {
#line 184
    i = even_sites_on_node;
  } else {
#line 184
    i = 0;
  }
#line 184
  s = lattice + i;
#line 184
  while (1) {
#line 184
    if (parity == 2) {
#line 184
      tmp = even_sites_on_node;
    } else {
#line 184
      tmp = sites_on_node;
    }
#line 184
    if (! (i < tmp)) {
#line 184
      break;
    }
#line 200
    if (sumvec_offset >= 0) {
#line 201
      a0 = ((su3_vector *)((char *)s + sumvec_offset))->c[p].real + ((su3_vector *)((char *)s + sumvec_offset))->c[q].real;
    } else {
#line 204
      a0 = (sumvecp + i)->c[p].real + (sumvecp + i)->c[q].real;
    }
#line 206
    if (diffmat_offset >= 0) {
#line 208
      a1 = ((su3_matrix *)((char *)s + diffmat_offset))->e[q][p].imag + ((su3_matrix *)((char *)s + diffmat_offset))->e[p][q].imag;
#line 210
      a2 = - ((su3_matrix *)((char *)s + diffmat_offset))->e[q][p].real + ((su3_matrix *)((char *)s + diffmat_offset))->e[p][q].real;
#line 212
      a3 = ((su3_matrix *)((char *)s + diffmat_offset))->e[p][p].imag - ((su3_matrix *)((char *)s + diffmat_offset))->e[q][q].imag;
    } else {
#line 217
      a1 = (diffmatp + i)->e[q][p].imag + (diffmatp + i)->e[p][q].imag;
#line 218
      a2 = - (diffmatp + i)->e[q][p].real + (diffmatp + i)->e[p][q].real;
#line 219
      a3 = (diffmatp + i)->e[p][p].imag - (diffmatp + i)->e[q][q].imag;
    }
#line 228
    asq = (a1 * a1 + a2 * a2) + a3 * a3;
#line 229
    a0sq = a0 * a0;
#line 230
    x = (relax_boost * a0sq + asq) / (a0sq + asq);
#line 231
    r = sqrt(a0sq + (x * x) * asq);
#line 232
    xdr = x / r;
#line 234
    a0 /= r;
#line 234
    a1 *= xdr;
#line 234
    a2 *= xdr;
#line 234
    a3 *= xdr;
#line 238
    u.e[0][0] = cmplx(a0, a3);
#line 239
    u.e[0][1] = cmplx(a2, a1);
#line 240
    u.e[1][0] = cmplx(- a2, a1);
#line 241
    u.e[1][1] = cmplx(a0, - a3);
#line 246
    dir = 0;
#line 246
    while (dir <= 3) {
#line 247
      left_su2_hit_n(& u, p, q, & s->link[dir]);
#line 246
      dir ++;
    }
#line 251
    dir = 0;
#line 251
    while (dir <= 3) {
#line 252
      right_su2_hit_a(& u, p, q, (su3_matrix *)*(gen_pt[dir] + i));
#line 251
      dir ++;
    }
#line 256
    j = 0;
#line 256
    while (j < nvector) {
#line 261
      if (*(vector_parity + j) == 3) {
#line 262
        mult_su2_mat_vec_elem_n(& u, & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[p],
                                & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[q]);
      } else
#line 261
      if (*(vector_parity + j) == parity) {
#line 262
        mult_su2_mat_vec_elem_n(& u, & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[p],
                                & ((su3_vector *)((char *)s + *(vector_offset + j)))->c[q]);
      }
#line 256
      j ++;
    }
#line 268
    j = 0;
#line 268
    while (j < nantiherm) {
#line 270
      if (*(antiherm_parity + j) == 3) {
#line 272
        uncompress_anti_hermitian((anti_hermitmat *)((char *)s + *(antiherm_offset + j)),
                                  & htemp);
#line 276
        left_su2_hit_n(& u, p, q, & htemp);
#line 277
        right_su2_hit_a(& u, p, q, & htemp);
#line 278
        make_anti_hermitian(& htemp, (anti_hermitmat *)((char *)s + *(antiherm_offset + j)));
      } else
#line 270
      if (*(antiherm_parity + j) == parity) {
#line 272
        uncompress_anti_hermitian((anti_hermitmat *)((char *)s + *(antiherm_offset + j)),
                                  & htemp);
#line 276
        left_su2_hit_n(& u, p, q, & htemp);
#line 277
        right_su2_hit_a(& u, p, q, & htemp);
#line 278
        make_anti_hermitian(& htemp, (anti_hermitmat *)((char *)s + *(antiherm_offset + j)));
      }
#line 268
      j ++;
    }
#line 184
    i ++;
#line 184
    s ++;
  }
#line 284
  return;
}
}
#line 286 "gaugefix2.c"
double get_gauge_fix_action(int gauge_dir , int parity ) 
{ 
  register int dir ;
  register int i ;
  register int ndir ;
  register site *s ;
  register su3_matrix *m1 ;
  register su3_matrix *m2 ;
  double gauge_fix_action ;
  complex trace ;
  int tmp ;

  {
#line 299
  gauge_fix_action = 0.0;
#line 301
  if (parity == 1) {
#line 301
    i = even_sites_on_node;
  } else {
#line 301
    i = 0;
  }
#line 301
  s = lattice + i;
#line 301
  while (1) {
#line 301
    if (parity == 2) {
#line 301
      tmp = even_sites_on_node;
    } else {
#line 301
      tmp = sites_on_node;
    }
#line 301
    if (! (i < tmp)) {
#line 301
      break;
    }
#line 303
    dir = 0;
#line 303
    while (dir <= 3) {
#line 303
      if (dir != gauge_dir) {
#line 305
        m1 = & s->link[dir];
#line 306
        m2 = (su3_matrix *)*(gen_pt[dir] + i);
#line 308
        trace = trace_su3(m1);
#line 309
        gauge_fix_action += trace.real;
#line 311
        trace = trace_su3(m2);
#line 312
        gauge_fix_action += trace.real;
      }
#line 303
      dir ++;
    }
#line 301
    i ++;
#line 301
    s ++;
  }
#line 317
  ndir = 0;
#line 317
  dir = 0;
#line 317
  while (dir <= 3) {
#line 317
    if (dir != gauge_dir) {
#line 317
      ndir ++;
    }
#line 317
    dir ++;
  }
#line 320
  g_doublesum(& gauge_fix_action);
#line 323
  return (gauge_fix_action / (double )(((((6 * ndir) * nx) * ny) * nz) * nt));
}
}
#line 326 "gaugefix2.c"
void gaugefixstep(int gauge_dir , double *av_gauge_fix_action , double relax_boost ,
                  int nvector , field_offset *vector_offset , int *vector_parity ,
                  int nantiherm , field_offset *antiherm_offset , int *antiherm_parity ) 
{ 
  int parity ;
  msg_tag *mtag[8] ;
  double gauge_fix_action ;
  register int dir ;
  register int i ;
  register site *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 340
  *av_gauge_fix_action = 0.;
#line 341
  g_sync();
#line 342
  fflush(stdout);
#line 344
  parity = 1;
#line 344
  while (parity <= 2) {
#line 348
    dir = 0;
#line 348
    while (dir <= 3) {
#line 350
      mtag[dir] = start_gather((field_offset )((char *)(& (lattice + 0)->link[dir]) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), 7 - dir, parity, gen_pt[dir]);
#line 348
      dir ++;
    }
#line 356
    dir = 0;
#line 356
    while (dir <= 3) {
#line 358
      wait_gather(mtag[dir]);
#line 356
      dir ++;
    }
#line 362
    gauge_fix_action = get_gauge_fix_action(gauge_dir, parity);
#line 366
    do_hit(gauge_dir, parity, 0, 1, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
#line 369
    do_hit(gauge_dir, parity, 1, 2, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
#line 372
    do_hit(gauge_dir, parity, 2, 0, relax_boost, nvector, vector_offset, vector_parity,
           nantiherm, antiherm_offset, antiherm_parity);
#line 377
    gauge_fix_action = get_gauge_fix_action(gauge_dir, parity);
#line 379
    *av_gauge_fix_action += gauge_fix_action;
#line 384
    dir = 0;
#line 384
    while (dir <= 3) {
#line 389
      g_sync();
#line 394
      if (parity == 1) {
#line 394
        i = even_sites_on_node;
      } else {
#line 394
        i = 0;
      }
#line 394
      s = lattice + i;
#line 394
      while (1) {
#line 394
        if (parity == 2) {
#line 394
          tmp = even_sites_on_node;
        } else {
#line 394
          tmp = sites_on_node;
        }
#line 394
        if (! (i < tmp)) {
#line 394
          break;
        }
#line 396
        if (diffmat_offset >= 0) {
#line 397
          su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), (su3_matrix *)((char *)s + diffmat_offset));
        } else {
#line 399
          su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), diffmatp + i);
        }
#line 394
        i ++;
#line 394
        s ++;
      }
#line 403
      cleanup_gather(mtag[dir]);
#line 407
      g_sync();
#line 410
      if (diffmat_offset >= 0) {
#line 411
        mtag[dir] = start_gather(diffmat_offset, (int )sizeof(su3_matrix ), dir, 3 ^ parity,
                                 gen_pt[dir]);
      } else {
#line 414
        mtag[dir] = start_gather_from_temp((void *)diffmatp, (int )sizeof(su3_matrix ),
                                           dir, 3 ^ parity, gen_pt[dir]);
      }
#line 417
      wait_gather(mtag[dir]);
#line 421
      if ((3 ^ parity) == 1) {
#line 421
        i = even_sites_on_node;
      } else {
#line 421
        i = 0;
      }
#line 421
      s = lattice + i;
#line 421
      while (1) {
#line 421
        if ((3 ^ parity) == 2) {
#line 421
          tmp___0 = even_sites_on_node;
        } else {
#line 421
          tmp___0 = sites_on_node;
        }
#line 421
        if (! (i < tmp___0)) {
#line 421
          break;
        }
#line 422
        su3mat_copy((su3_matrix *)*(gen_pt[dir] + i), & s->link[dir]);
#line 421
        i ++;
#line 421
        s ++;
      }
#line 424
      cleanup_gather(mtag[dir]);
#line 384
      dir ++;
    }
#line 344
    parity ++;
  }
#line 428
  return;
}
}
#line 430 "gaugefix2.c"
void gaugefixscratch(field_offset diffmat , field_offset sumvec ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 432
  diffmat_offset = diffmat;
#line 433
  diffmatp = (su3_matrix *)((void *)0);
#line 434
  if (diffmat_offset < 0) {
#line 436
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 436
//AD    diffmatp = (su3_matrix *)tmp;
    diffmatp = (su3_matrix *)calloc((size_t )sites_on_node, sizeof(su3_matrix )); //AD
#line 437
    if ((unsigned long )diffmatp == (unsigned long )((void *)0)) {
#line 439
      if (this_node == 0) {
#line 439
        printf((char const   * __restrict  )"gaugefix: Can\'t malloc diffmat\n");
      }
#line 440
      fflush(stdout);
#line 440
      terminate(1);
    }
  }
#line 444
  sumvec_offset = sumvec;
#line 445
  sumvecp = (su3_vector *)((void *)0);
#line 446
  if (sumvec_offset < 0) {
#line 448
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 448
//AD    sumvecp = (su3_vector *)tmp___0;
    sumvecp = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 449
    if ((unsigned long )sumvecp == (unsigned long )((void *)0)) {
#line 451
      if (this_node == 0) {
#line 451
        printf((char const   * __restrict  )"gaugefix: Can\'t malloc sumvec\n");
      }
#line 452
      fflush(stdout);
#line 452
      terminate(1);
    }
  }
#line 455
  return;
}
}
#line 457 "gaugefix2.c"
void gaugefix(int gauge_dir , double relax_boost , int max_gauge_iter , double gauge_fix_tol ,
              field_offset diffmat , field_offset sumvec , int nvector , field_offset *vector_offset ,
              int *vector_parity , int nantiherm , field_offset *antiherm_offset ,
              int *antiherm_parity ) 
{ 
  int gauge_iter ;
  double current_av ;
  double old_av ;
  double del_av ;
  double tmp ;

  {
#line 476
  gaugefixscratch(diffmat, sumvec);
#line 481
  gauge_iter = 0;
#line 481
  while (gauge_iter < max_gauge_iter) {
#line 483
    gaugefixstep(gauge_dir, & current_av, relax_boost, nvector, vector_offset, vector_parity,
                 nantiherm, antiherm_offset, antiherm_parity);
#line 487
    if (gauge_iter != 0) {
#line 489
      del_av = current_av - old_av;
#line 490
      tmp = fabs(del_av);
#line 490
      if (tmp < gauge_fix_tol) {
#line 490
        break;
      }
    }
#line 492
    old_av = current_av;
#line 495
    if (gauge_iter % 20 == 19) {
#line 499
      reunitarize();
    }
#line 481
    gauge_iter ++;
  }
#line 503
  if (gauge_iter % 20 != 0) {
#line 504
    reunitarize();
  }
#line 507
  if (diffmat_offset < 0) {
#line 507
    free((void *)diffmatp);
  }
#line 508
  if (sumvec_offset < 0) {
#line 508
    free((void *)sumvecp);
  }
#line 510
  if (this_node == 0) {
#line 511
    printf((char const   * __restrict  )"GFIX: Ended at step %d. Av gf action %.8e, delta %.3e\n",
           gauge_iter, current_av, del_av);
  }
#line 513
  return;
}
}
#line 1 "io_helpers.o"
#pragma merger("0","/tmp/cil-s3EQsscL.i","")
#line 383 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 385
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 279 "./io_lat.h"
gauge_file *restore_ascii(char *filename ) ;
#line 280
gauge_file *save_ascii(char *filename ) ;
#line 281
gauge_file *restore_serial(char *filename ) ;
#line 282
gauge_file *save_serial(char *filename ) ;
#line 283
gauge_file *restore_parallel(char *filename ) ;
#line 284
gauge_file *save_parallel(char *filename ) ;
#line 285
gauge_file *save_checkpoint(char *filename ) ;
#line 286
gauge_file *save_serial_archive(char *filename ) ;
#line 287
gauge_file *save_parallel_archive(char *filename ) ;
#line 310
void coldlat(void) ;
#line 311
void funnylat(void) ;
#line 314
int get_s(int prompt , char *variable_name_string , char *value ) ;
#line 182 "./comdefs.h"
void g_doublemax(double *dpt ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 15 "io_helpers.c"
gauge_file *save_lattice(int flag , char *filename ) 
{ 
  double dtime ;
  gauge_file *gf___0 ;
  double ssplaq ;
  double stplaq ;
  double tmp ;
  double tmp___0 ;

  {
#line 20
  tmp = dclock();
#line 20
  dtime = - tmp;
#line 21
  switch (flag) {
  case 20: 
#line 23
  gf___0 = (gauge_file *)((void *)0);
#line 24
  break;
  case 21: 
#line 26
  gf___0 = save_ascii(filename);
#line 27
  break;
  case 22: 
#line 29
  gf___0 = save_serial(filename);
#line 30
  break;
  case 28: 
#line 32
  gf___0 = save_parallel(filename);
#line 33
  break;
  case 23: 
#line 35
  gf___0 = save_checkpoint(filename);
#line 36
  break;
  case 30: 
#line 38
  gf___0 = save_serial_archive(filename);
#line 39
  break;
  case 31: 
#line 41
  gf___0 = save_parallel_archive(filename);
#line 42
  break;
  default: 
#line 44
  printf((char const   * __restrict  )"save_lattice: ERROR: unknown type for saving lattice\n");
#line 45
  terminate(1);
  }
#line 47
  tmp___0 = dclock();
#line 47
  dtime += tmp___0;
#line 48
  if (flag != 20) {
#line 49
    if (this_node == 0) {
#line 49
      printf((char const   * __restrict  )"Time to save = %e\n", dtime);
    }
  }
#line 50
  d_plaquette(& ssplaq, & stplaq);
#line 51
  if (this_node == 0) {
#line 51
    printf((char const   * __restrict  )"CHECK PLAQ: %e %e\n", ssplaq, stplaq);
  }
#line 52
  return (gf___0);
}
}
#line 60 "io_helpers.c"
gauge_file *reload_lattice(int flag , char *filename ) 
{ 
  double dtime ;
  gauge_file *gf___0 ;
  double ssplaq ;
  double stplaq ;
  double max_deviation___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 67
  tmp = dclock();
#line 67
  dtime = - tmp;
#line 68
  switch (flag) {
  case 10: 
#line 70
  gf___0 = (gauge_file *)((void *)0);
#line 71
  break;
  case 11: 
#line 73
  coldlat();
#line 74
  gf___0 = (gauge_file *)((void *)0);
#line 75
  break;
  case 12: 
#line 77
  gf___0 = restore_ascii(filename);
#line 78
  break;
  case 13: 
#line 80
  gf___0 = restore_serial(filename);
#line 81
  break;
  case 19: 
#line 83
  gf___0 = restore_parallel(filename);
#line 84
  break;
  default: 
#line 86
  if (this_node == 0) {
#line 86
    printf((char const   * __restrict  )"reload_lattice: Bad startflag %d\n", flag);
  }
#line 87
  terminate(1);
  }
#line 89
  tmp___0 = dclock();
#line 89
  dtime += tmp___0;
#line 90
  if (flag != 11) {
#line 90
    if (flag != 10) {
#line 91
      if (this_node == 0) {
#line 91
        printf((char const   * __restrict  )"Time to reload gauge configuration = %e\n",
               dtime);
      }
    }
  }
#line 95
  d_plaquette(& ssplaq, & stplaq);
#line 96
  if (this_node == 0) {
#line 97
    printf((char const   * __restrict  )"CHECK PLAQ: %e %e\n", ssplaq, stplaq);
#line 97
    fflush(stdout);
  }
#line 99
  tmp___1 = dclock();
#line 99
  dtime = - tmp___1;
#line 100
  max_deviation___0 = check_unitarity();
#line 101
  g_doublemax(& max_deviation___0);
#line 102
  tmp___2 = dclock();
#line 102
  dtime += tmp___2;
#line 103
  if (this_node == 0) {
#line 103
    printf((char const   * __restrict  )"Unitarity checked.  Max deviation %.2e\n",
           max_deviation___0);
  }
#line 104
  fflush(stdout);
#line 106
  return (gf___0);
}
}
#line 112 "io_helpers.c"
int ask_starting_lattice(int prompt , int *flag , char *filename ) 
{ 
  char savebuf[256] ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 116
  if (prompt != 0) {
#line 116
    printf((char const   * __restrict  )"enter \'continue\', \'fresh\', \'reload_ascii\', \'reload_serial\', or \'reload_parallel\'\n");
  }
#line 118
  status = scanf((char const   * __restrict  )"%s", savebuf);
#line 119
  if (status != 1) {
#line 120
    printf((char const   * __restrict  )"ask_starting_lattice: ERROR IN INPUT: starting lattice command\n");
#line 121
    return (1);
  }
#line 124
  printf((char const   * __restrict  )"%s ", savebuf);
#line 125
  tmp___3 = strcmp("fresh", (char const   *)(savebuf));
#line 125
  if (tmp___3 == 0) {
#line 126
    *flag = 11;
#line 127
    printf((char const   * __restrict  )"\n");
  } else {
#line 129
    tmp___2 = strcmp("continue", (char const   *)(savebuf));
#line 129
    if (tmp___2 == 0) {
#line 130
      *flag = 10;
#line 131
      printf((char const   * __restrict  )"\n");
    } else {
#line 133
      tmp___1 = strcmp("reload_ascii", (char const   *)(savebuf));
#line 133
      if (tmp___1 == 0) {
#line 134
        *flag = 12;
      } else {
#line 136
        tmp___0 = strcmp("reload_serial", (char const   *)(savebuf));
#line 136
        if (tmp___0 == 0) {
#line 137
          *flag = 13;
        } else {
#line 139
          tmp = strcmp("reload_parallel", (char const   *)(savebuf));
#line 139
          if (tmp == 0) {
#line 140
            *flag = 19;
          } else {
#line 143
            printf((char const   * __restrict  )"ask_starting_lattice: ERROR IN INPUT: lattice_command %s is invalid\n",
                   savebuf);
#line 143
            return (1);
          }
        }
      }
    }
  }
#line 147
  if (*flag != 11) {
#line 147
    if (*flag != 10) {
#line 148
      if (prompt != 0) {
#line 148
        printf((char const   * __restrict  )"enter name of file containing lattice\n");
      }
#line 149
      status = scanf((char const   * __restrict  )"%s", filename);
#line 150
      if (status != 1) {
#line 151
        printf((char const   * __restrict  )"ask_starting_lattice: ERROR IN INPUT: file name read\n");
#line 151
        return (1);
      }
#line 153
      printf((char const   * __restrict  )"%s\n", filename);
    }
  }
#line 155
  return (0);
}
}
#line 161 "io_helpers.c"
int ask_ending_lattice(int prompt , int *flag , char *filename ) 
{ 
  char savebuf[256] ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 165
  if (prompt != 0) {
#line 165
    printf((char const   * __restrict  )"\'forget\' lattice at end,  \'save_ascii\', \'save_serial\', \'save_parallel\', \'save_checkpoint\', \'save_serial_archive\', or \'save_parallel_archive\'\n");
  }
#line 167
  status = scanf((char const   * __restrict  )"%s", savebuf);
#line 168
  if (status != 1) {
#line 169
    printf((char const   * __restrict  )"ask_ending_lattice: ERROR IN INPUT: ending lattice command\n");
#line 170
    return (1);
  }
#line 172
  printf((char const   * __restrict  )"%s ", savebuf);
#line 173
  tmp___5 = strcmp("save_ascii", (char const   *)(savebuf));
#line 173
  if (tmp___5 == 0) {
#line 174
    *flag = 21;
  } else {
#line 176
    tmp___4 = strcmp("save_serial", (char const   *)(savebuf));
#line 176
    if (tmp___4 == 0) {
#line 177
      *flag = 22;
    } else {
#line 179
      tmp___3 = strcmp("save_parallel", (char const   *)(savebuf));
#line 179
      if (tmp___3 == 0) {
#line 180
        *flag = 28;
      } else {
#line 182
        tmp___2 = strcmp("save_checkpoint", (char const   *)(savebuf));
#line 182
        if (tmp___2 == 0) {
#line 183
          *flag = 23;
        } else {
#line 185
          tmp___1 = strcmp("save_serial_archive", (char const   *)(savebuf));
#line 185
          if (tmp___1 == 0) {
#line 186
            *flag = 30;
          } else {
#line 188
            tmp___0 = strcmp("save_parallel_archive", (char const   *)(savebuf));
#line 188
            if (tmp___0 == 0) {
#line 189
              *flag = 31;
            } else {
#line 191
              tmp = strcmp("forget", (char const   *)(savebuf));
#line 191
              if (tmp == 0) {
#line 192
                *flag = 20;
#line 193
                printf((char const   * __restrict  )"\n");
              } else {
#line 196
                printf((char const   * __restrict  )"ask_ending_lattice: ERROR IN INPUT: %s is not a save lattice command\n",
                       savebuf);
#line 197
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 202
  if (*flag != 20) {
#line 203
    if (prompt != 0) {
#line 203
      printf((char const   * __restrict  )"enter filename\n");
    }
#line 204
    status = scanf((char const   * __restrict  )"%s", filename);
#line 205
    if (status != 1) {
#line 206
      printf((char const   * __restrict  )"ask_ending_lattice: ERROR IN INPUT: save filename\n");
#line 206
      return (1);
    }
#line 208
    printf((char const   * __restrict  )"%s\n", filename);
  }
#line 211
  return (0);
}
}
#line 215 "io_helpers.c"
void coldlat(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *sit ;

  {
#line 220
  i = 0;
#line 220
  sit = lattice;
#line 220
  while (i < sites_on_node) {
#line 221
    dir = 0;
#line 221
    while (dir <= 3) {
#line 222
      j = 0;
#line 222
      while (j < 3) {
#line 223
        k = 0;
#line 223
        while (k < 3) {
#line 224
          if (j != k) {
#line 225
            sit->link[dir].e[j][k] = cmplx(0.0, 0.0);
          } else {
#line 228
            sit->link[dir].e[j][k] = cmplx(1.0, 0.0);
          }
#line 223
          k ++;
        }
#line 222
        j ++;
      }
#line 221
      dir ++;
    }
#line 220
    i ++;
#line 220
    sit ++;
  }
#line 235
  if (this_node == 0) {
#line 235
    printf((char const   * __restrict  )"unit gauge configuration loaded\n");
  }
#line 236
  return;
}
}
#line 238 "io_helpers.c"
void funnylat(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *sit ;

  {
#line 243
  i = 0;
#line 243
  sit = lattice;
#line 243
  while (i < sites_on_node) {
#line 244
    dir = 0;
#line 244
    while (dir <= 3) {
#line 245
      j = 0;
#line 245
      while (j < 3) {
#line 246
        k = 0;
#line 246
        while (k < 3) {
#line 247
          sit->link[dir].e[j][k] = cmplx(0.0, 0.0);
#line 246
          k ++;
        }
#line 245
        j ++;
      }
#line 250
      sit->link[dir].e[0][0].real = (double )dir;
#line 251
      sit->link[dir].e[1][1].real = (double )(10 * (int )sit->x);
#line 252
      sit->link[dir].e[2][2].real = (double )(100 * (int )sit->y);
#line 253
      sit->link[dir].e[0][0].imag = (double )dir;
#line 254
      sit->link[dir].e[1][1].imag = (double )(10 * (int )sit->z);
#line 255
      sit->link[dir].e[2][2].imag = (double )(100 * (int )sit->t);
#line 244
      dir ++;
    }
#line 243
    i ++;
#line 243
    sit ++;
  }
#line 258
  return;
}
}
#line 267 "io_helpers.c"
int get_f(int prompt , char *variable_name_string , double *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
#line 271
  if (prompt) {
#line 272
    s = 0;
#line 273
    while (s != 1) {
#line 274
      printf((char const   * __restrict  )"enter %s ", variable_name_string);
#line 275
      scanf((char const   * __restrict  )"%s", checkname);
#line 276
      s = sscanf((char const   * __restrict  )(checkname), (char const   * __restrict  )"%lf",
                 value);
#line 277
      if (s == 1) {
#line 278
        printf((char const   * __restrict  )"%s %g\n", variable_name_string, *value);
      } else {
#line 280
        printf((char const   * __restrict  )"Data format error.\n");
      }
    }
  } else {
#line 284
    s = scanf((char const   * __restrict  )"%s", checkname);
#line 285
    if (s == -1) {
#line 286
      printf((char const   * __restrict  )"get_f: EOF on STDIN while expecting %s.\n",
             variable_name_string);
#line 288
      return (1);
    } else
#line 290
    if (s == 0) {
#line 291
      printf((char const   * __restrict  )"get_f: Format error looking for %s\n",
             variable_name_string);
#line 292
      return (1);
    } else {
#line 294
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
#line 294
      if (tmp != 0) {
#line 295
        printf((char const   * __restrict  )"get_f: ERROR IN INPUT: expected %s but found %s\n",
               variable_name_string, checkname);
#line 297
        return (1);
      }
    }
#line 300
    printf((char const   * __restrict  )"%s ", variable_name_string);
#line 302
    s = scanf((char const   * __restrict  )"%lf", value);
#line 303
    if (s == -1) {
#line 304
      printf((char const   * __restrict  )"\nget_f: Expecting value for %s but found EOF.\n",
             variable_name_string);
#line 306
      return (1);
    } else
#line 308
    if (s == 0) {
#line 309
      printf((char const   * __restrict  )"\nget_f: Format error reading value for %s\n",
             variable_name_string);
#line 311
      return (1);
    }
#line 313
    printf((char const   * __restrict  )"%g\n", *value);
  }
#line 316
  return (0);
}
}
#line 319 "io_helpers.c"
int get_i(int prompt , char *variable_name_string , int *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
#line 323
  if (prompt) {
#line 324
    s = 0;
#line 325
    while (s != 1) {
#line 326
      printf((char const   * __restrict  )"enter %s ", variable_name_string);
#line 327
      scanf((char const   * __restrict  )"%s", checkname);
#line 328
      s = sscanf((char const   * __restrict  )(checkname), (char const   * __restrict  )"%d",
                 value);
#line 329
      if (s == 1) {
#line 330
        printf((char const   * __restrict  )"%s %d\n", variable_name_string, *value);
      } else {
#line 332
        printf((char const   * __restrict  )"Data format error.\n");
      }
    }
  } else {
#line 336
    s = scanf((char const   * __restrict  )"%s", checkname);
#line 337
    if (s == -1) {
#line 338
      printf((char const   * __restrict  )"get_i: EOF on STDIN while expecting %s.\n",
             variable_name_string);
#line 340
      return (1);
    } else
#line 342
    if (s == 0) {
#line 343
      printf((char const   * __restrict  )"get_i: Format error looking for %s\n",
             variable_name_string);
#line 344
      return (1);
    } else {
#line 346
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
#line 346
      if (tmp != 0) {
#line 347
        printf((char const   * __restrict  )"get_i: ERROR IN INPUT: expected %s but found %s\n",
               variable_name_string, checkname);
#line 349
        return (1);
      }
    }
#line 352
    printf((char const   * __restrict  )"%s ", variable_name_string);
#line 354
    s = scanf((char const   * __restrict  )"%d", value);
#line 355
    if (s == -1) {
#line 356
      printf((char const   * __restrict  )"\nget_i: Expecting value for %s but found EOF.\n",
             variable_name_string);
#line 358
      return (1);
    } else
#line 360
    if (s == 0) {
#line 361
      printf((char const   * __restrict  )"\nget_i: Format error reading value for %s\n",
             variable_name_string);
#line 363
      return (1);
    }
#line 365
    printf((char const   * __restrict  )"%d\n", *value);
  }
#line 368
  return (0);
}
}
#line 374 "io_helpers.c"
int get_s(int prompt , char *variable_name_string , char *value ) 
{ 
  int s ;
  char checkname[80] ;
  int tmp ;

  {
#line 378
  if (prompt) {
#line 379
    s = 0;
#line 380
    while (s != 1) {
#line 381
      printf((char const   * __restrict  )"enter %s ", variable_name_string);
#line 382
      s = scanf((char const   * __restrict  )"%s", value);
#line 383
      if (s == 1) {
#line 384
        printf((char const   * __restrict  )"%s %s\n", variable_name_string, value);
      } else {
#line 386
        printf((char const   * __restrict  )"Data format error.\n");
      }
    }
  } else {
#line 390
    s = scanf((char const   * __restrict  )"%s", checkname);
#line 391
    if (s == -1) {
#line 392
      printf((char const   * __restrict  )"get_s: EOF on STDIN while expecting %s.\n",
             variable_name_string);
#line 394
      return (1);
    } else
#line 396
    if (s == 0) {
#line 397
      printf((char const   * __restrict  )"get_s: Format error looking for %s\n",
             variable_name_string);
#line 398
      return (1);
    } else {
#line 400
      tmp = strcmp((char const   *)(checkname), (char const   *)variable_name_string);
#line 400
      if (tmp != 0) {
#line 401
        printf((char const   * __restrict  )"get_s: ERROR IN INPUT: expected %s but found %s\n",
               variable_name_string, checkname);
#line 403
        return (1);
      }
    }
#line 406
    printf((char const   * __restrict  )"%s ", variable_name_string);
#line 408
    s = scanf((char const   * __restrict  )"%s", value);
#line 409
    if (s == -1) {
#line 410
      printf((char const   * __restrict  )"\nget_s: Expecting value for %s but found EOF.\n",
             variable_name_string);
#line 412
      return (1);
    } else
#line 414
    if (s == 0) {
#line 415
      printf((char const   * __restrict  )"\nget_s: Format error reading value for %s\n",
             variable_name_string);
#line 417
      return (1);
    }
#line 419
    printf((char const   * __restrict  )"%s\n", value);
  }
#line 421
  return (0);
}
}
#line 428 "io_helpers.c"
int get_prompt(int *prompt ) 
{ 
  char initial_prompt[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 431
  *prompt = -1;
#line 432
  printf((char const   * __restrict  )"type 0 for no prompts  or 1 for prompts\n");
#line 433
  scanf((char const   * __restrict  )"%s", initial_prompt);
#line 434
  tmp___1 = strcmp((char const   *)(initial_prompt), "prompt");
#line 434
  if (tmp___1 == 0) {
#line 435
    scanf((char const   * __restrict  )"%d", prompt);
  } else {
#line 437
    tmp___0 = strcmp((char const   *)(initial_prompt), "0");
#line 437
    if (tmp___0 == 0) {
#line 437
      *prompt = 0;
    } else {
#line 438
      tmp = strcmp((char const   *)(initial_prompt), "1");
#line 438
      if (tmp == 0) {
#line 438
        *prompt = 1;
      }
    }
  }
#line 440
  if (*prompt == 0) {
#line 440
    return (0);
  } else
#line 440
  if (*prompt == 1) {
#line 440
    return (0);
  } else {
#line 442
    printf((char const   * __restrict  )"get_prompt: ERROR IN INPUT: initial prompt\n");
#line 443
    return (1);
  }
}
}
#line 1 "io_lat4.o"
#pragma merger("0","/tmp/cil-cGxfYwBI.i","")
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 486 "./su3.h"
void byterevn(int32type *w , int n ) ;
#line 276 "./io_lat.h"
void complete_U(double *u ) ;
#line 277
int big_endian(void) ;
#line 322
FILE *g_open(char const   *filename , char const   *mode ) ;
#line 323
int g_seek(FILE *stream , off_t offset , int whence ) ;
#line 324
size_t g_write(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 325
size_t g_read(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 326
int g_close(FILE *stream ) ;
#line 332
void swrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
#line 334
void pwrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
#line 336
void pswrite_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                  char *descrip ) ;
#line 338
int sread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
#line 340
int pread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) ;
#line 342
int pread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) ;
#line 344
int sread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) ;
#line 346
int psread_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                char *descrip ) ;
#line 348
int psread_byteorder(int byterevflag , int parallel , FILE *fp , void *src , size_t size ,
                     char *myname , char *descrip ) ;
#line 168 "./comdefs.h"
void send_field(char *buf , int size , int tonode ) ;
#line 169
void get_field(char *buf , int size ) ;
#line 181
void g_xor32(u_int32type *pt ) ;
#line 189
void send_integer(int tonode , int *address ) ;
#line 190
void receive_integer(int *address ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 100 "io_lat4.c"
int qcdhdr_get_str(char *s , QCDheader *hdr , char **q ) 
{ 
  int i ;
  int tmp ;

  {
#line 103
  i = 0;
#line 103
  while (i < (int )((char )hdr->ntoken)) {
#line 104
    tmp = strcmp((char const   *)s, (char const   *)*(hdr->token + i));
#line 104
    if (tmp == 0) {
#line 105
      *q = *(hdr->value + i);
#line 106
      return (0);
    }
#line 103
    i ++;
  }
#line 109
  *q = (char *)((void *)0);
#line 110
  return (-1);
}
}
#line 113 "io_lat4.c"
int qcdhdr_get_int(char *s , QCDheader *hdr , int *q ) 
{ 
  char *p ;

  {
#line 115
  qcdhdr_get_str(s, hdr, & p);
#line 116
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 116
    return (-1);
  }
#line 117
  sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%d", q);
#line 118
  return (0);
}
}
#line 120 "io_lat4.c"
int qcdhdr_get_int32x(char *s , QCDheader *hdr , u_int32type *q ) 
{ 
  char *p ;
  int r ;

  {
#line 123
  qcdhdr_get_str(s, hdr, & p);
#line 124
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 124
    return (-1);
  }
#line 125
  sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%x", & r);
#line 126
  *q = (u_int32type )r;
#line 127
  return (0);
}
}
#line 129 "io_lat4.c"
int qcdhdr_get_double(char *s , QCDheader *hdr , double *q ) 
{ 
  char *p ;

  {
#line 131
  qcdhdr_get_str(s, hdr, & p);
#line 132
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 132
    return (-1);
  }
#line 133
  sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%lf", q);
#line 134
  return (0);
}
}
#line 137 "io_lat4.c"
void error_exit(char *s ) 
{ 


  {
#line 137
  printf((char const   * __restrict  )"%s\n", s);
#line 137
  terminate(1);
#line 137
  return;
}
}
#line 139 "io_lat4.c"
void complete_U(double *u ) 
{ 


  {
#line 140
  *(u + 12) = ((*(u + 2) * *(u + 10) - *(u + 4) * *(u + 8)) - *(u + 3) * *(u + 11)) + *(u + 5) * *(u + 9);
#line 141
  *(u + 13) = ((*(u + 4) * *(u + 9) - *(u + 2) * *(u + 11)) + *(u + 5) * *(u + 8)) - *(u + 3) * *(u + 10);
#line 142
  *(u + 14) = ((*(u + 4) * *(u + 6) - *(u + 0) * *(u + 10)) - *(u + 5) * *(u + 7)) + *(u + 1) * *(u + 11);
#line 143
  *(u + 15) = ((*(u + 0) * *(u + 11) - *(u + 4) * *(u + 7)) + *(u + 1) * *(u + 10)) - *(u + 5) * *(u + 6);
#line 144
  *(u + 16) = ((*(u + 0) * *(u + 8) - *(u + 2) * *(u + 6)) - *(u + 1) * *(u + 9)) + *(u + 3) * *(u + 7);
#line 145
  *(u + 17) = ((*(u + 2) * *(u + 7) - *(u + 0) * *(u + 9)) + *(u + 3) * *(u + 6)) - *(u + 1) * *(u + 8);
#line 146
  return;
}
}
#line 149 "io_lat4.c"
int big_endian(void) 
{ 
  union __anonunion_u_51 u ;

  {
#line 154
  u.l = 1L;
#line 155
  return ((int )u.c[sizeof(long ) - 1UL] == 1);
}
}
#line 158 "io_lat4.c"
QCDheader *qcdhdr_get_hdr(FILE *in ) 
{ 
  char line[1024] ;
  int n ;
  int len ;
  QCDheader *hdr ;
  char **tokens ;
  char **values ;
  char *p ;
  char *q ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 169
  fgets((char * __restrict  )(line), 1024, (FILE * __restrict  )in);
#line 175
//AD  tmp = calloc((size_t )512, sizeof(char *));
#line 175
//AD  tokens = (char **)tmp;
  tokens = (char **)calloc((size_t )512, sizeof(char *)); //AD
#line 176
//AD  tmp___0 = calloc((size_t )512, sizeof(char *));
#line 176
//AD  values = (char **)tmp___0;
  values = (char **)calloc((size_t )512, sizeof(char *));
#line 177
//AD  tmp___1 = calloc((size_t )1, sizeof(QCDheader ));
#line 177
//AD  hdr = (QCDheader *)tmp___1;
  hdr = (QCDheader *)calloc((size_t )1, sizeof(QCDheader ));
#line 178
  hdr->token = tokens;
#line 179
  hdr->value = values;
#line 182
  n = 0;
#line 183
  printf((char const   * __restrict  )"reading Archive header:\n");
#line 184
  while (1) {
#line 185
    fgets((char * __restrict  )(line), 1024, (FILE * __restrict  )in);
#line 186
    printf((char const   * __restrict  )"%s", line);
#line 188
    tmp___2 = strcmp((char const   *)(line), "END_HEADER\n");
#line 188
    if (tmp___2 == 0) {
#line 188
      break;
    }
#line 191
    q = strchr((char const   *)(line), ' ');
#line 194
    *q = (char )'\000';
#line 195
    len = (int )q - (int )(line);
#line 198
//AD    tmp___3 = calloc((size_t )((len + 1) / 8 + 1), (size_t )8);
#line 198
//AD    p = (char *)tmp___3;
    p = (char *)calloc((size_t )((len + 1) / 8 + 1), (size_t )8); //AD
#line 199
    *(hdr->token + n) = p;
#line 200
    strcpy((char * __restrict  )p, (char const   * __restrict  )(line));
#line 202
    q ++;
#line 202
    q = strchr((char const   *)q, '=');
#line 202
    q ++;
#line 203
    tmp___4 = strlen((char const   *)q);
#line 203
    len = (int )tmp___4;
#line 204
    *(q + (len - 1)) = (char)0;
#line 205
//AD    tmp___5 = calloc((size_t )len, sizeof(char ));
#line 205
//AD    p = (char *)tmp___5;
    p = (char *)calloc((size_t )len, sizeof(char ));
#line 206
    *(hdr->value + n) = p;
#line 207
    strcpy((char * __restrict  )p, (char const   * __restrict  )q);
#line 208
    n ++;
  }
#line 210
  hdr->ntoken = n;
#line 211
  return (hdr);
}
}
#line 215 "io_lat4.c"
void qcdhdr_destroy_hdr(QCDheader *hdr ) 
{ 
  int i ;

  {
#line 218
  if ((unsigned long )hdr == (unsigned long )((void *)0)) {
#line 218
    return;
  }
#line 220
  i = 0;
#line 220
  while (i < hdr->ntoken) {
#line 221
    free((void *)*(hdr->value + i));
#line 222
    free((void *)*(hdr->token + i));
#line 220
    i ++;
  }
#line 225
  free((void *)hdr->token);
#line 226
  free((void *)hdr->value);
#line 227
  free((void *)hdr);
#line 228
  return;
}
}
#line 231 "io_lat4.c"
void swrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
#line 233
  tmp___0 = fwrite((void const   * __restrict  )src, size, (size_t )1, (FILE * __restrict  )fp);
#line 233
  if (tmp___0 != 1UL) {
#line 235
    tmp = __errno_location();
#line 235
    printf((char const   * __restrict  )"%s: Node %d %s write error %d\n", myname,
           this_node, descrip, *tmp);
#line 237
    fflush(stdout);
#line 238
    terminate(1);
  }
#line 240
  return;
}
}
#line 242 "io_lat4.c"
void pwrite_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
#line 244
  tmp___0 = g_write((void const   *)src, size, (size_t )1, fp);
#line 244
  if (tmp___0 != 1UL) {
#line 246
    tmp = __errno_location();
#line 246
    printf((char const   * __restrict  )"%s: Node %d %s descrip,write error %d\n",
           myname, this_node, descrip, *tmp);
#line 248
    fflush(stdout);
#line 249
    terminate(1);
  }
#line 251
  return;
}
}
#line 253 "io_lat4.c"
void pswrite_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                  char *descrip ) 
{ 


  {
#line 256
  if (parallel) {
#line 256
    pwrite_data(fp, src, size, myname, descrip);
  } else {
#line 257
    swrite_data(fp, src, size, myname, descrip);
  }
#line 258
  return;
}
}
#line 260 "io_lat4.c"
int sread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
#line 262
  tmp___0 = fread((void * __restrict  )src, size, (size_t )1, (FILE * __restrict  )fp);
#line 262
  if (tmp___0 != 1UL) {
#line 264
    tmp = __errno_location();
#line 264
    printf((char const   * __restrict  )"%s: Node %d %s read error %d\n", myname,
           this_node, descrip, *tmp);
#line 266
    fflush(stdout);
#line 267
    return (1);
  }
#line 269
  return (0);
}
}
#line 272 "io_lat4.c"
int pread_data(FILE *fp , void *src , size_t size , char *myname , char *descrip ) 
{ 
  int *tmp ;
  size_t tmp___0 ;

  {
#line 274
  tmp___0 = g_read(src, size, (size_t )1, fp);
#line 274
  if (tmp___0 != 1UL) {
#line 276
    tmp = __errno_location();
#line 276
    printf((char const   * __restrict  )"%s: Node %d %s read error %d\n", myname,
           this_node, descrip, *tmp);
#line 278
    fflush(stdout);
#line 279
    return (1);
  }
#line 281
  return (0);
}
}
#line 284 "io_lat4.c"
int pread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) 
{ 
  int status ;

  {
#line 288
  status = pread_data(fp, src, size, myname, descrip);
#line 289
  if (byterevflag == 1) {
#line 290
    byterevn((int32type *)src, (int )(size / sizeof(int32type )));
  }
#line 291
  return (status);
}
}
#line 294 "io_lat4.c"
int sread_byteorder(int byterevflag , FILE *fp , void *src , size_t size , char *myname ,
                    char *descrip ) 
{ 
  int status ;

  {
#line 298
  status = sread_data(fp, src, size, myname, descrip);
#line 299
  if (byterevflag == 1) {
#line 300
    byterevn((int32type *)src, (int )(size / sizeof(int32type )));
  }
#line 301
  return (status);
}
}
#line 304 "io_lat4.c"
int psread_data(int parallel , FILE *fp , void *src , size_t size , char *myname ,
                char *descrip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 307
  if (parallel) {
#line 307
    tmp = pread_data(fp, src, size, myname, descrip);
#line 307
    return (tmp);
  } else {
#line 308
    tmp___0 = sread_data(fp, src, size, myname, descrip);
#line 308
    return (tmp___0);
  }
}
}
#line 311 "io_lat4.c"
int psread_byteorder(int byterevflag , int parallel , FILE *fp , void *src , size_t size ,
                     char *myname , char *descrip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 315
  if (parallel) {
#line 315
    tmp = pread_byteorder(byterevflag, fp, src, size, myname, descrip);
#line 315
    return (tmp);
  } else {
#line 316
    tmp___0 = sread_byteorder(byterevflag, fp, src, size, myname, descrip);
#line 316
    return (tmp___0);
  }
}
}
#line 328 "io_lat4.c"
void pwrite_gauge_hdr(FILE *fp , gauge_header *gh ) 
{ 
  char myname[17] ;

  {
#line 331
  myname[0] = (char )'p';
#line 331
  myname[1] = (char )'w';
#line 331
  myname[2] = (char )'r';
#line 331
  myname[3] = (char )'i';
#line 331
  myname[4] = (char )'t';
#line 331
  myname[5] = (char )'e';
#line 331
  myname[6] = (char )'_';
#line 331
  myname[7] = (char )'g';
#line 331
  myname[8] = (char )'a';
#line 331
  myname[9] = (char )'u';
#line 331
  myname[10] = (char )'g';
#line 331
  myname[11] = (char )'e';
#line 331
  myname[12] = (char )'_';
#line 331
  myname[13] = (char )'h';
#line 331
  myname[14] = (char )'d';
#line 331
  myname[15] = (char )'r';
#line 331
  myname[16] = (char )'\000';
#line 333
  pwrite_data(fp, (void *)(& gh->magic_number), sizeof(gh->magic_number), myname,
              (char *)"magic_number");
#line 335
  pwrite_data(fp, (void *)(gh->dims), sizeof(gh->dims), myname, (char *)"dimensions");
#line 337
  pwrite_data(fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp), myname, (char *)"time_stamp");
#line 339
  pwrite_data(fp, (void *)(& gh->order), sizeof(gh->order), myname, (char *)"order");
#line 344
  gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
#line 347
  return;
}
}
#line 353 "io_lat4.c"
void swrite_gauge_hdr(FILE *fp , gauge_header *gh ) 
{ 
  char myname[17] ;

  {
#line 356
  myname[0] = (char )'s';
#line 356
  myname[1] = (char )'w';
#line 356
  myname[2] = (char )'r';
#line 356
  myname[3] = (char )'i';
#line 356
  myname[4] = (char )'t';
#line 356
  myname[5] = (char )'e';
#line 356
  myname[6] = (char )'_';
#line 356
  myname[7] = (char )'g';
#line 356
  myname[8] = (char )'a';
#line 356
  myname[9] = (char )'u';
#line 356
  myname[10] = (char )'g';
#line 356
  myname[11] = (char )'e';
#line 356
  myname[12] = (char )'_';
#line 356
  myname[13] = (char )'h';
#line 356
  myname[14] = (char )'d';
#line 356
  myname[15] = (char )'r';
#line 356
  myname[16] = (char )'\000';
#line 358
  swrite_data(fp, (void *)(& gh->magic_number), sizeof(gh->magic_number), myname,
              (char *)"magic_number");
#line 360
  swrite_data(fp, (void *)(gh->dims), sizeof(gh->dims), myname, (char *)"dimensions");
#line 362
  swrite_data(fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp), myname, (char *)"time_stamp");
#line 364
  swrite_data(fp, (void *)(& gh->order), sizeof(gh->order), myname, (char *)"order");
#line 369
  gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
#line 372
  return;
}
}
#line 377 "io_lat4.c"
int write_gauge_info_item(FILE *fpout , char *keyword , char *fmt , char *src , int count ,
                          int stride ) 
{ 
  int i ;
  int k ;
  int n ;
  char *data ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 394
  i = 0;
#line 394
  while (1) {
#line 394
    tmp = strlen((char const   *)gauge_info_keyword[i]);
#line 394
    if (tmp > 0UL) {
#line 394
      tmp___0 = strcmp((char const   *)gauge_info_keyword[i], (char const   *)keyword);
#line 394
      if (! (tmp___0 != 0)) {
#line 394
        break;
      }
    } else {
#line 394
      break;
    }
#line 394
    i ++;
  }
#line 396
  tmp___1 = strlen((char const   *)gauge_info_keyword[i]);
#line 396
  if (tmp___1 == 0UL) {
#line 397
    printf((char const   * __restrict  )"write_gauge_info_item: WARNING: keyword %s not in table\n",
           keyword);
  }
#line 402
  fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )"%s =", keyword);
#line 405
  if (count > 1) {
#line 406
    fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )"[%d]", count);
  }
#line 408
  n = count;
#line 408
  if (n == 0) {
#line 408
    n = 1;
  }
#line 411
  k = 0;
#line 411
  data = src;
#line 411
  while (k < n) {
#line 413
    fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )" ");
#line 414
    tmp___6 = strstr((char const   *)fmt, "s");
#line 414
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 415
      fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )fmt, data);
    } else {
#line 416
      tmp___5 = strstr((char const   *)fmt, "d");
#line 416
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 417
        fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )fmt, *((int *)data));
      } else {
#line 418
        tmp___4 = strstr((char const   *)fmt, "e");
#line 418
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 419
          fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )fmt, *((double *)data));
        } else {
#line 420
          tmp___3 = strstr((char const   *)fmt, "f");
#line 420
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 421
            fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )fmt,
                    *((double *)data));
          } else {
#line 422
            tmp___2 = strstr((char const   *)fmt, "g");
#line 422
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 423
              fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )fmt,
                      *((double *)data));
            } else {
#line 426
              printf((char const   * __restrict  )"write_gauge_info_item: Unrecognized data type %s\n",
                     fmt);
#line 427
              return (1);
            }
          }
        }
      }
    }
#line 411
    k ++;
#line 411
    data += stride;
  }
#line 430
  fprintf((FILE * __restrict  )fpout, (char const   * __restrict  )"\n");
#line 431
  return (0);
}
}
#line 437 "io_lat4.c"
void write_gauge_info_file(gauge_file *gf___0 ) 
{ 
  FILE *info_fp ;
  gauge_header *gh ;
  char info_filename[256] ;
  char sums[20] ;

  {
#line 444
  gh = gf___0->header;
#line 449
  strcpy((char * __restrict  )(info_filename), (char const   * __restrict  )gf___0->filename);
#line 450
  strcat((char * __restrict  )(info_filename), (char const   * __restrict  )".info");
#line 454
  info_fp = fopen((char const   * __restrict  )(info_filename), (char const   * __restrict  )"w");
#line 454
  if ((unsigned long )info_fp == (unsigned long )((void *)0)) {
#line 456
    printf((char const   * __restrict  )"write_gauge_info_file: Can\'t open ascii info file %s\n",
           info_filename);
#line 457
    return;
  }
#line 462
  write_gauge_info_item(info_fp, (char *)"magic_number", (char *)"%d", (char *)(& gh->magic_number),
                        0, 0);
#line 463
  write_gauge_info_item(info_fp, (char *)"time_stamp", (char *)"\"%s\"", gh->time_stamp,
                        0, 0);
#line 464
  sprintf((char * __restrict  )(sums), (char const   * __restrict  )"%x %x", gf___0->check.sum29,
          gf___0->check.sum31);
#line 465
  write_gauge_info_item(info_fp, (char *)"checksums", (char *)"\"%s\"", sums, 0, 0);
#line 466
  write_gauge_info_item(info_fp, (char *)"nx", (char *)"%d", (char *)(& nx), 0, 0);
#line 467
  write_gauge_info_item(info_fp, (char *)"ny", (char *)"%d", (char *)(& ny), 0, 0);
#line 468
  write_gauge_info_item(info_fp, (char *)"nz", (char *)"%d", (char *)(& nz), 0, 0);
#line 469
  write_gauge_info_item(info_fp, (char *)"nt", (char *)"%d", (char *)(& nt), 0, 0);
#line 471
  write_appl_gauge_info(info_fp);
#line 473
  fclose(info_fp);
#line 475
  printf((char const   * __restrict  )"Wrote info file %s\n", info_filename);
#line 477
  return;
}
}
#line 483 "io_lat4.c"
gauge_file *setup_input_gauge_file(char *filename ) 
{ 
  char myname[23] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 485
  myname[0] = (char )'s';
#line 485
  myname[1] = (char )'e';
#line 485
  myname[2] = (char )'t';
#line 485
  myname[3] = (char )'u';
#line 485
  myname[4] = (char )'p';
#line 485
  myname[5] = (char )'_';
#line 485
  myname[6] = (char )'i';
#line 485
  myname[7] = (char )'n';
#line 485
  myname[8] = (char )'p';
#line 485
  myname[9] = (char )'u';
#line 485
  myname[10] = (char )'t';
#line 485
  myname[11] = (char )'_';
#line 485
  myname[12] = (char )'g';
#line 485
  myname[13] = (char )'a';
#line 485
  myname[14] = (char )'u';
#line 485
  myname[15] = (char )'g';
#line 485
  myname[16] = (char )'e';
#line 485
  myname[17] = (char )'_';
#line 485
  myname[18] = (char )'f';
#line 485
  myname[19] = (char )'i';
#line 485
  myname[20] = (char )'l';
#line 485
  myname[21] = (char )'e';
#line 485
  myname[22] = (char )'\000';
#line 491
//AD  tmp = calloc((size_t )1, sizeof(gauge_file ));
#line 491
//AD  gf___0 = (gauge_file *)tmp;
  gf___0 = (gauge_file *)calloc((size_t )1, sizeof(gauge_file )); //AD
#line 492
  if ((unsigned long )gf___0 == (unsigned long )((void *)0)) {
#line 494
    printf((char const   * __restrict  )"%s: Can\'t malloc gf\n", myname);
#line 495
    terminate(1);
  }
#line 498
  gf___0->filename = filename;
#line 505
//AD  tmp___0 = calloc((size_t )1, sizeof(gauge_header ));
#line 505
//AD  gh = (gauge_header *)tmp___0;
  gh = (gauge_header *)calloc((size_t )1, sizeof(gauge_header )); //AD
#line 506
  if ((unsigned long )gh == (unsigned long )((void *)0)) {
#line 508
    printf((char const   * __restrict  )"%s: Can\'t malloc gh\n", myname);
#line 509
    terminate(1);
  }
#line 512
  gf___0->header = gh;
#line 513
  gf___0->check.sum29 = (u_int32type )0;
#line 514
  gf___0->check.sum31 = (u_int32type )0;
#line 516
  return (gf___0);
}
}
#line 523 "io_lat4.c"
gauge_file *setup_output_gauge_file(void) 
{ 
  char myname[24] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  time_t time_stamp___0 ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 525
  myname[0] = (char )'s';
#line 525
  myname[1] = (char )'e';
#line 525
  myname[2] = (char )'t';
#line 525
  myname[3] = (char )'u';
#line 525
  myname[4] = (char )'p';
#line 525
  myname[5] = (char )'_';
#line 525
  myname[6] = (char )'o';
#line 525
  myname[7] = (char )'u';
#line 525
  myname[8] = (char )'t';
#line 525
  myname[9] = (char )'p';
#line 525
  myname[10] = (char )'u';
#line 525
  myname[11] = (char )'t';
#line 525
  myname[12] = (char )'_';
#line 525
  myname[13] = (char )'g';
#line 525
  myname[14] = (char )'a';
#line 525
  myname[15] = (char )'u';
#line 525
  myname[16] = (char )'g';
#line 525
  myname[17] = (char )'e';
#line 525
  myname[18] = (char )'_';
#line 525
  myname[19] = (char )'f';
#line 525
  myname[20] = (char )'i';
#line 525
  myname[21] = (char )'l';
#line 525
  myname[22] = (char )'e';
#line 525
  myname[23] = (char )'\000';
#line 533
//AD  tmp = calloc((size_t )1, sizeof(gauge_file ));
#line 533
//AD  gf___0 = (gauge_file *)tmp;
  gf___0 = (gauge_file *)calloc((size_t )1, sizeof(gauge_file )); //AD
#line 534
  if ((unsigned long )gf___0 == (unsigned long )((void *)0)) {
#line 536
    printf((char const   * __restrict  )"%s: Can\'t malloc gf\n", myname);
#line 537
    terminate(1);
  }
#line 545
//AD  tmp___0 = calloc((size_t )1, sizeof(gauge_header ));
#line 545
//AD  gh = (gauge_header *)tmp___0;
  gh = (gauge_header *)calloc((size_t )1, sizeof(gauge_header )); //AD
#line 546
  if ((unsigned long )gh == (unsigned long )((void *)0)) {
#line 548
    printf((char const   * __restrict  )"%s: Can\'t malloc gh\n", myname);
#line 549
    terminate(1);
  }
#line 553
  gf___0->header = gh;
#line 556
  gf___0->check.sum29 = (u_int32type )0;
#line 557
  gf___0->check.sum31 = (u_int32type )0;
#line 561
  gh->magic_number = 20103;
#line 563
  gh->dims[0] = nx;
#line 564
  gh->dims[1] = ny;
#line 565
  gh->dims[2] = nz;
#line 566
  gh->dims[3] = nt;
#line 570
  if (this_node == 0) {
#line 572
    time(& time_stamp___0);
#line 573
    tmp___1 = ctime((time_t const   *)(& time_stamp___0));
#line 573
    strcpy((char * __restrict  )(gh->time_stamp), (char const   * __restrict  )tmp___1);
#line 576
    tmp___2 = strlen((char const   *)(gh->time_stamp));
#line 576
    i = (int )(tmp___2 + 1UL);
#line 576
    while (i < (int )sizeof(gh->time_stamp)) {
#line 577
      gh->time_stamp[i] = (char )'\000';
#line 576
      i ++;
    }
#line 580
    tmp___4 = strlen((char const   *)(gh->time_stamp));
#line 580
    if ((int )gh->time_stamp[tmp___4 - 1UL] == 10) {
#line 581
      tmp___3 = strlen((char const   *)(gh->time_stamp));
#line 581
      gh->time_stamp[tmp___3 - 1UL] = (char )'\000';
    }
  }
#line 585
  broadcast_bytes(gh->time_stamp, (int )sizeof(gh->time_stamp));
#line 587
  return (gf___0);
}
}
#line 593 "io_lat4.c"
gauge_file *w_serial_i(char *filename ) 
{ 
  char myname[11] ;
  FILE *fp ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;

  {
#line 598
  myname[0] = (char )'w';
#line 598
  myname[1] = (char )'_';
#line 598
  myname[2] = (char )'s';
#line 598
  myname[3] = (char )'e';
#line 598
  myname[4] = (char )'r';
#line 598
  myname[5] = (char )'i';
#line 598
  myname[6] = (char )'a';
#line 598
  myname[7] = (char )'l';
#line 598
  myname[8] = (char )'_';
#line 598
  myname[9] = (char )'i';
#line 598
  myname[10] = (char )'\000';
#line 604
  gf___0 = setup_output_gauge_file();
#line 605
  gh = gf___0->header;
#line 609
  gh->order = 0;
#line 613
  if (this_node == 0) {
#line 615
    fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"wb");
#line 616
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 618
      tmp = __errno_location();
#line 618
      printf((char const   * __restrict  )"%s: Node %d can\'t open file %s, error %d\n",
             myname, this_node, filename, *tmp);
#line 619
      fflush(stdout);
#line 620
      terminate(1);
    }
#line 625
    swrite_gauge_hdr(fp, gh);
  }
#line 631
  if (this_node == 0) {
#line 631
    gf___0->fp = fp;
  } else {
#line 632
    gf___0->fp = (FILE *)((void *)0);
  }
#line 634
  gf___0->filename = filename;
#line 635
  gf___0->byterevflag = 0;
#line 636
  gf___0->rank2rcv = (int32type *)((void *)0);
#line 637
  gf___0->parallel = 0;
#line 639
  return (gf___0);
}
}
#line 650 "io_lat4.c"
void read_checksum(int parallel , gauge_file *gf___0 , gauge_check *test_gc ) 
{ 
  char myname[14] ;
  int tmp ;
  int tmp___0 ;

  {
#line 653
  myname[0] = (char )'r';
#line 653
  myname[1] = (char )'e';
#line 653
  myname[2] = (char )'a';
#line 653
  myname[3] = (char )'d';
#line 653
  myname[4] = (char )'_';
#line 653
  myname[5] = (char )'c';
#line 653
  myname[6] = (char )'h';
#line 653
  myname[7] = (char )'e';
#line 653
  myname[8] = (char )'c';
#line 653
  myname[9] = (char )'k';
#line 653
  myname[10] = (char )'s';
#line 653
  myname[11] = (char )'u';
#line 653
  myname[12] = (char )'m';
#line 653
  myname[13] = (char )'\000';
#line 657
  tmp = psread_byteorder(gf___0->byterevflag, parallel, gf___0->fp, (void *)(& gf___0->check.sum29),
                         sizeof(gf___0->check.sum29), myname, (char *)"checksum");
#line 657
  if (tmp != 0) {
#line 659
    terminate(1);
  }
#line 660
  tmp___0 = psread_byteorder(gf___0->byterevflag, parallel, gf___0->fp, (void *)(& gf___0->check.sum31),
                             sizeof(gf___0->check.sum31), myname, (char *)"checksum");
#line 660
  if (tmp___0 != 0) {
#line 662
    terminate(1);
  }
#line 664
  if (gf___0->check.sum29 != test_gc->sum29) {
#line 666
    printf((char const   * __restrict  )"%s: Checksum violation. Computed %x %x.  Read %x %x.\n",
           myname, test_gc->sum29, test_gc->sum31, gf___0->check.sum29, gf___0->check.sum31);
  } else
#line 664
  if (gf___0->check.sum31 != test_gc->sum31) {
#line 666
    printf((char const   * __restrict  )"%s: Checksum violation. Computed %x %x.  Read %x %x.\n",
           myname, test_gc->sum29, test_gc->sum31, gf___0->check.sum29, gf___0->check.sum31);
  } else {
#line 671
    printf((char const   * __restrict  )"Checksums %x %x OK\n", gf___0->check.sum29,
           gf___0->check.sum31);
#line 672
    fflush(stdout);
  }
#line 674
  return;
}
}
#line 682 "io_lat4.c"
void write_checksum(int parallel , gauge_file *gf___0 ) 
{ 
  char myname[15] ;

  {
#line 685
  myname[0] = (char )'w';
#line 685
  myname[1] = (char )'r';
#line 685
  myname[2] = (char )'i';
#line 685
  myname[3] = (char )'t';
#line 685
  myname[4] = (char )'e';
#line 685
  myname[5] = (char )'_';
#line 685
  myname[6] = (char )'c';
#line 685
  myname[7] = (char )'h';
#line 685
  myname[8] = (char )'e';
#line 685
  myname[9] = (char )'c';
#line 685
  myname[10] = (char )'k';
#line 685
  myname[11] = (char )'s';
#line 685
  myname[12] = (char )'u';
#line 685
  myname[13] = (char )'m';
#line 685
  myname[14] = (char )'\000';
#line 687
  pswrite_data(parallel, gf___0->fp, (void *)(& gf___0->check.sum29), sizeof(gf___0->check.sum29),
               myname, (char *)"checksum");
#line 689
  pswrite_data(parallel, gf___0->fp, (void *)(& gf___0->check.sum31), sizeof(gf___0->check.sum31),
               myname, (char *)"checksum");
#line 691
  printf((char const   * __restrict  )"Checksums %x %x\n", gf___0->check.sum29, gf___0->check.sum31);
#line 692
  return;
}
}
#line 698 "io_lat4.c"
void w_serial(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix *lbuf ;
  su3_matrix tbuf[4] ;
  int buf_length ;
  register int i ;
  register int j ;
  register int k ;
  off_t offset ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  off_t gauge_check_size ;
  int currentnode ;
  int newnode ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 719
  if (this_node == 0) {
#line 721
    if (gf___0->parallel) {
#line 722
      printf((char const   * __restrict  )"w_serial: Attempting serial write to parallel file \n");
    }
#line 724
//AD    tmp = calloc((size_t )16384, sizeof(su3_matrix ));
#line 724
//AD    lbuf = (su3_matrix *)tmp;
    lbuf = (su3_matrix *)calloc((size_t )16384, sizeof(su3_matrix )); //AD
#line 725
    if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 727
      printf((char const   * __restrict  )"w_serial: Node 0 can\'t malloc lbuf\n");
#line 728
      fflush(stdout);
#line 728
      terminate(1);
    }
#line 731
    fp = gf___0->fp;
#line 732
    gh = gf___0->header;
#line 737
    coord_list_size = (off_t )0;
#line 738
    head_size = (off_t )gh->header_bytes + coord_list_size;
#line 740
    checksum_offset = head_size;
#line 742
    gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
#line 744
    offset = head_size + gauge_check_size;
#line 746
    tmp___1 = fseek(fp, offset, 0);
#line 746
    if (tmp___1 < 0) {
#line 749
      tmp___0 = __errno_location();
#line 749
      printf((char const   * __restrict  )"w_serial: Node %d fseeko failed error %d file %s\n",
             this_node, *tmp___0, gf___0->filename);
#line 758
      fflush(stdout);
#line 758
      terminate(1);
    }
  }
#line 765
  gf___0->check.sum31 = (u_int32type )0;
#line 766
  gf___0->check.sum29 = (u_int32type )0;
#line 769
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
#line 770
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
#line 772
  g_sync();
#line 773
  currentnode = 0;
#line 775
  buf_length = 0;
#line 777
  j = 0;
#line 777
  t = 0;
#line 777
  while (t < nt) {
#line 777
    z = 0;
#line 777
    while (z < nz) {
#line 777
      y = 0;
#line 777
      while (y < ny) {
#line 777
        x = 0;
#line 777
        while (x < nx) {
#line 779
          newnode = node_number(x, y, z, t);
#line 780
          if (newnode != currentnode) {
#line 782
            if (this_node == 0) {
#line 782
              if (newnode != 0) {
#line 782
                send_field((char *)(tbuf), 4, newnode);
              }
            }
#line 783
            if (this_node == newnode) {
#line 783
              if (newnode != 0) {
#line 783
                get_field((char *)(tbuf), 4);
              }
            }
#line 784
            currentnode = newnode;
          }
#line 787
          if (this_node == 0) {
#line 789
            if (currentnode == 0) {
#line 791
              i = node_index(x, y, z, t);
#line 792
              k = 0;
#line 792
              while (k < 4) {
#line 792
                tbuf[k] = (lattice + i)->link[k];
#line 792
                k ++;
              }
            } else {
#line 796
              get_field((char *)(tbuf), (int )(4UL * sizeof(su3_matrix )));
            }
#line 799
            memcpy((void * __restrict  )((void *)(lbuf + 4 * buf_length)), (void const   * __restrict  )((void *)(tbuf)),
                   4UL * sizeof(su3_matrix ));
#line 804
            k = 0;
#line 804
            val = (u_int32type *)(lbuf + 4 * buf_length);
#line 804
            while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 807
              gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 808
              gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 809
              rank29 ++;
#line 809
              if (rank29 >= 29) {
#line 809
                rank29 = 0;
              }
#line 810
              rank31 ++;
#line 810
              if (rank31 >= 31) {
#line 810
                rank31 = 0;
              }
#line 804
              k ++;
#line 804
              val ++;
            }
#line 813
            buf_length ++;
#line 816
            if (buf_length == 4096) {
#line 816
              goto _L;
            } else
#line 816
            if (j == volume - 1) {
              _L: /* CIL Label */ 
#line 820
              tmp___3 = fwrite((void const   * __restrict  )lbuf, 4UL * sizeof(su3_matrix ),
                               (size_t )buf_length, (FILE * __restrict  )fp);
#line 820
              if ((int )tmp___3 != buf_length) {
#line 822
                tmp___2 = __errno_location();
#line 822
                printf((char const   * __restrict  )"w_serial: Node %d gauge configuration write error %d file %s\n",
                       this_node, *tmp___2, gf___0->filename);
#line 824
                fflush(stdout);
#line 825
                terminate(1);
              }
#line 827
              buf_length = 0;
            }
          } else
#line 832
          if (this_node == currentnode) {
#line 833
            i = node_index(x, y, z, t);
#line 834
            send_field((char *)((lattice + i)->link), (int )(4UL * sizeof(su3_matrix )),
                       0);
          }
#line 777
          x ++;
#line 777
          j ++;
        }
#line 777
        y ++;
      }
#line 777
      z ++;
    }
#line 777
    t ++;
  }
#line 840
  g_sync();
#line 842
  if (this_node == 0) {
#line 844
    free((void *)lbuf);
#line 845
    printf((char const   * __restrict  )"Saved gauge configuration serially to binary file %s\n",
           gf___0->filename);
#line 847
    printf((char const   * __restrict  )"Time stamp %s\n", gh->time_stamp);
#line 851
    tmp___5 = fseek(fp, checksum_offset, 0);
#line 851
    if (tmp___5 < 0) {
#line 854
      tmp___4 = __errno_location();
#line 854
      printf((char const   * __restrict  )"w_serial: Node %d fseeko failed error %d file %s\n",
             this_node, *tmp___4, gf___0->filename);
#line 863
      fflush(stdout);
#line 863
      terminate(1);
    }
#line 865
    write_checksum(0, gf___0);
  }
#line 868
  return;
}
}
#line 872 "io_lat4.c"
void w_serial_f(gauge_file *gf___0 ) 
{ 


  {
#line 876
  g_sync();
#line 877
  if (this_node == 0) {
#line 879
    if (gf___0->parallel) {
#line 880
      printf((char const   * __restrict  )"w_serial_f: Attempting serial close on parallel file \n");
    }
#line 882
    fclose(gf___0->fp);
  }
#line 887
  if (this_node == 0) {
#line 887
    write_gauge_info_file(gf___0);
  }
#line 891
  return;
}
}
#line 898 "io_lat4.c"
void read_site_list(int parallel , gauge_file *gf___0 ) 
{ 
  void *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
#line 904
  if ((gf___0->header)->order != 0) {
#line 906
//AD    tmp = calloc((size_t )volume, sizeof(int32type ));
#line 906
//AD    gf___0->rank2rcv = (int32type *)tmp;
    gf___0->rank2rcv = (int32type *)calloc((size_t )volume, sizeof(int32type )); //AD
#line 907
    if ((unsigned long )gf___0->rank2rcv == (unsigned long )((void *)0)) {
#line 909
      printf((char const   * __restrict  )"read_site_list: Can\'t malloc rank2rcv table\n");
#line 910
      terminate(1);
    }
#line 915
    if (this_node == 0) {
#line 919
      if (parallel) {
#line 921
        tmp___1 = g_read((void *)gf___0->rank2rcv, sizeof(int32type ), (size_t )volume,
                         gf___0->fp);
#line 921
        if ((int )tmp___1 != volume) {
#line 923
          tmp___0 = __errno_location();
#line 923
          printf((char const   * __restrict  )"read_site_list: Node %d site list read error %d\n",
                 this_node, *tmp___0);
#line 925
          terminate(1);
        }
      } else {
#line 930
        tmp___3 = fread((void * __restrict  )gf___0->rank2rcv, sizeof(int32type ),
                        (size_t )volume, (FILE * __restrict  )gf___0->fp);
#line 930
        if ((int )tmp___3 != volume) {
#line 932
          tmp___2 = __errno_location();
#line 932
          printf((char const   * __restrict  )"read_site_list: Node %d site list read error %d\n",
                 this_node, *tmp___2);
#line 934
          terminate(1);
        }
      }
#line 938
      if (gf___0->byterevflag == 1) {
#line 938
        byterevn(gf___0->rank2rcv, volume);
      }
    }
#line 943
    broadcast_bytes((char *)gf___0->rank2rcv, (int )((unsigned long )volume * sizeof(int32type )));
  } else {
#line 946
    gf___0->rank2rcv = (int32type *)((void *)0);
  }
#line 948
  return;
}
}
#line 953 "io_lat4.c"
int read_v3_gauge_hdr(gauge_file *gf___0 , int parallel , int *byterevflag ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int j ;
  int sixtyfourbits ;
  double c1 ;
  double c2 ;
  char myname[18] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 966
  myname[0] = (char )'r';
#line 966
  myname[1] = (char )'e';
#line 966
  myname[2] = (char )'a';
#line 966
  myname[3] = (char )'d';
#line 966
  myname[4] = (char )'_';
#line 966
  myname[5] = (char )'v';
#line 966
  myname[6] = (char )'3';
#line 966
  myname[7] = (char )'_';
#line 966
  myname[8] = (char )'g';
#line 966
  myname[9] = (char )'a';
#line 966
  myname[10] = (char )'u';
#line 966
  myname[11] = (char )'g';
#line 966
  myname[12] = (char )'e';
#line 966
  myname[13] = (char )'_';
#line 966
  myname[14] = (char )'h';
#line 966
  myname[15] = (char )'d';
#line 966
  myname[16] = (char )'r';
#line 966
  myname[17] = (char )'\000';
#line 968
  fp = gf___0->fp;
#line 969
  gh = gf___0->header;
#line 976
  if (gh->magic_number == 0) {
#line 978
    sixtyfourbits = 1;
#line 979
    printf((char const   * __restrict  )"First 4 bytes were zero. Trying to interpret with 64 bit integer format.\n");
#line 982
    tmp___0 = psread_data(parallel, fp, (void *)(& gh->magic_number), sizeof(gh->magic_number),
                          myname, (char *)"magic number");
#line 982
    if (tmp___0 != 0) {
#line 983
      terminate(1);
    }
  } else {
#line 986
    sixtyfourbits = 0;
  }
#line 988
  tmp = gh->magic_number;
#line 990
  if (gh->magic_number == 59354) {
#line 992
    printf((char const   * __restrict  )"Reading as old-style gauge field configuration.\n");
#line 993
    *byterevflag = 0;
  } else {
#line 997
    byterevn(& gh->magic_number, 1);
#line 998
    if (gh->magic_number == 59354) {
#line 1000
      *byterevflag = 1;
#line 1001
      printf((char const   * __restrict  )"Reading as old-style gauge field configuration with byte reversal\n");
#line 1002
      if (sizeof(double ) != sizeof(int32type )) {
#line 1003
        printf((char const   * __restrict  )"read_v3_gauge_hdr: Can\'t byte reverse\n");
#line 1004
        printf((char const   * __restrict  )"requires size of int32type(%d) = size of double(%d)\n",
               (int )sizeof(int32type ), (int )sizeof(double ));
#line 1006
        terminate(1);
      }
    } else {
#line 1013
      gh->magic_number = tmp;
#line 1014
      return (1);
    }
  }
#line 1023
  j = 0;
#line 1023
  while (j < 4) {
#line 1025
    tmp___1 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->dims[j]),
                               sizeof(gh->dims[j]), myname, (char *)"dimensions");
#line 1025
    if (tmp___1 != 0) {
#line 1027
      terminate(1);
    }
#line 1030
    if (sixtyfourbits) {
#line 1031
      tmp___2 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->dims[j]),
                                 sizeof(gh->dims[j]), myname, (char *)"dimensions");
#line 1031
      if (tmp___2 != 0) {
#line 1033
        terminate(1);
      }
    }
#line 1023
    j ++;
  }
#line 1036
  if (gh->dims[0] != nx) {
#line 1036
    goto _L___0;
  } else
#line 1036
  if (gh->dims[1] != ny) {
#line 1036
    goto _L___0;
  } else
#line 1036
  if (gh->dims[2] != nz) {
#line 1036
    goto _L___0;
  } else
#line 1036
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
#line 1044
    if (nx != -1) {
#line 1044
      goto _L;
    } else
#line 1044
    if (ny != -1) {
#line 1044
      goto _L;
    } else
#line 1044
    if (nz != -1) {
#line 1044
      goto _L;
    } else
#line 1044
    if (nt != -1) {
      _L: /* CIL Label */ 
#line 1046
      printf((char const   * __restrict  )"read_v3_gauge_hdr: Incorrect lattice dimensions ");
#line 1047
      j = 0;
#line 1047
      while (j < 4) {
#line 1048
        printf((char const   * __restrict  )"%d ", gh->dims[j]);
#line 1047
        j ++;
      }
#line 1049
      printf((char const   * __restrict  )"\n");
#line 1049
      fflush(stdout);
#line 1049
      terminate(1);
    } else {
#line 1053
      nx = gh->dims[0];
#line 1054
      ny = gh->dims[1];
#line 1055
      nz = gh->dims[2];
#line 1056
      nt = gh->dims[3];
#line 1057
      volume = ((nx * ny) * nz) * nt;
    }
  }
#line 1064
  if (sixtyfourbits == 0) {
#line 1065
    gh->header_bytes = 28;
  } else {
#line 1067
    gh->header_bytes = 48;
  }
#line 1071
  gh->order = 0;
#line 1075
  tmp___3 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& c1), sizeof(double ),
                             myname, (char *)"c1");
#line 1075
  if (tmp___3 != 0) {
#line 1076
    terminate(1);
  }
#line 1077
  tmp___4 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& c2), sizeof(double ),
                             myname, (char *)"c2");
#line 1077
  if (tmp___4 != 0) {
#line 1078
    terminate(1);
  }
#line 1080
  printf((char const   * __restrict  )"Old format header parameters are %f %f\n",
         c1, c2);
#line 1082
  return (0);
}
}
#line 1087 "io_lat4.c"
int read_1996_gauge_hdr(gauge_file *gf___0 , int parallel , int *byterevflag ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int j ;
  struct __anonstruct_gauge_field_52 gauge_field ;
  char myname[20] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1105
  myname[0] = (char )'r';
#line 1105
  myname[1] = (char )'e';
#line 1105
  myname[2] = (char )'a';
#line 1105
  myname[3] = (char )'d';
#line 1105
  myname[4] = (char )'_';
#line 1105
  myname[5] = (char )'1';
#line 1105
  myname[6] = (char )'9';
#line 1105
  myname[7] = (char )'9';
#line 1105
  myname[8] = (char )'6';
#line 1105
  myname[9] = (char )'_';
#line 1105
  myname[10] = (char )'g';
#line 1105
  myname[11] = (char )'a';
#line 1105
  myname[12] = (char )'u';
#line 1105
  myname[13] = (char )'g';
#line 1105
  myname[14] = (char )'e';
#line 1105
  myname[15] = (char )'_';
#line 1105
  myname[16] = (char )'h';
#line 1105
  myname[17] = (char )'d';
#line 1105
  myname[18] = (char )'r';
#line 1105
  myname[19] = (char )'\000';
#line 1107
  fp = gf___0->fp;
#line 1108
  gh = gf___0->header;
#line 1112
  tmp = gh->magic_number;
#line 1114
  if (gh->magic_number == 53546) {
#line 1116
    printf((char const   * __restrict  )"Reading as 1996-style gauge field configuration.\n");
#line 1117
    *byterevflag = 0;
  } else {
#line 1121
    byterevn(& gh->magic_number, 1);
#line 1122
    if (gh->magic_number == 53546) {
#line 1124
      *byterevflag = 1;
#line 1125
      printf((char const   * __restrict  )"Reading as 1996-style gauge field configuration with byte reversal\n");
#line 1126
      if (sizeof(double ) != sizeof(int32type )) {
#line 1127
        printf((char const   * __restrict  )"read_1996_gauge_hdr: Can\'t byte reverse\n");
#line 1128
        printf((char const   * __restrict  )"requires size of int32type(%d) = size of double(%d)\n",
               (int )sizeof(int32type ), (int )sizeof(double ));
#line 1130
        terminate(1);
      }
    } else {
#line 1138
      gh->magic_number = tmp;
#line 1139
      return (1);
    }
  }
#line 1148
  tmp___0 = psread_byteorder(*byterevflag, parallel, fp, (void *)(gh->dims), sizeof(gh->dims),
                             myname, (char *)"dimensions");
#line 1148
  if (tmp___0 != 0) {
#line 1149
    terminate(1);
  }
#line 1151
  if (gh->dims[0] != nx) {
#line 1151
    goto _L___0;
  } else
#line 1151
  if (gh->dims[1] != ny) {
#line 1151
    goto _L___0;
  } else
#line 1151
  if (gh->dims[2] != nz) {
#line 1151
    goto _L___0;
  } else
#line 1151
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
#line 1159
    if (nx != -1) {
#line 1159
      goto _L;
    } else
#line 1159
    if (ny != -1) {
#line 1159
      goto _L;
    } else
#line 1159
    if (nz != -1) {
#line 1159
      goto _L;
    } else
#line 1159
    if (nt != -1) {
      _L: /* CIL Label */ 
#line 1161
      printf((char const   * __restrict  )"read_1996_gauge_hdr: Incorrect lattice dimensions ");
#line 1162
      j = 0;
#line 1162
      while (j < 4) {
#line 1163
        printf((char const   * __restrict  )"%d ", gh->dims[j]);
#line 1162
        j ++;
      }
#line 1164
      printf((char const   * __restrict  )"\n");
#line 1164
      fflush(stdout);
#line 1164
      terminate(1);
    } else {
#line 1168
      nx = gh->dims[0];
#line 1169
      ny = gh->dims[1];
#line 1170
      nz = gh->dims[2];
#line 1171
      nt = gh->dims[3];
#line 1172
      volume = ((nx * ny) * nz) * nt;
    }
  }
#line 1178
  tmp___1 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->header_bytes),
                             sizeof(gh->header_bytes), myname, (char *)"header size");
#line 1178
  if (tmp___1 != 0) {
#line 1180
    terminate(1);
  }
#line 1184
  tmp___2 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gh->order), sizeof(gh->order),
                             myname, (char *)"order");
#line 1184
  if (tmp___2 != 0) {
#line 1186
    terminate(1);
  }
#line 1190
  tmp___3 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.n_descript),
                             sizeof(gauge_field.n_descript), myname, (char *)"n_descript");
#line 1190
  if (tmp___3 != 0) {
#line 1192
    terminate(1);
  }
#line 1194
  if (gauge_field.n_descript > 200) {
#line 1196
    printf((char const   * __restrict  )"read_1996_gauge_hdr: gauge field descriptor length %d\n",
           gauge_field.n_descript);
#line 1198
    printf((char const   * __restrict  )" exceeds allocated space %d\n", 200);
#line 1200
    terminate(1);
  }
#line 1208
  tmp___4 = psread_data(parallel, fp, (void *)(gauge_field.descript), sizeof(gauge_field.descript),
                        myname, (char *)"descrip");
#line 1208
  if (tmp___4 != 0) {
#line 1209
    terminate(1);
  }
#line 1212
  gauge_field.descript[gauge_field.n_descript - 1] = (char )'\000';
#line 1215
  printf((char const   * __restrict  )"gauge_field.descript: %s\n", gauge_field.descript);
#line 1219
  tmp___5 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.n_param),
                             sizeof(gauge_field.n_param), myname, (char *)"n_param");
#line 1219
  if (tmp___5 != 0) {
#line 1221
    terminate(1);
  }
#line 1223
  if (gauge_field.n_param > 2) {
#line 1225
    printf((char const   * __restrict  )"read_1996_gauge_hdr: gauge field parameter vector length %d\n",
           gauge_field.n_param);
#line 1227
    printf((char const   * __restrict  )" exceeds allocated space %d\n", 2);
#line 1229
    terminate(1);
  }
#line 1234
  j = 0;
#line 1234
  while (j < gauge_field.n_param) {
#line 1236
    tmp___6 = psread_byteorder(*byterevflag, parallel, fp, (void *)(& gauge_field.param[j]),
                               sizeof(gauge_field.param[j]), myname, (char *)"gauge param");
#line 1236
    if (tmp___6 != 0) {
#line 1238
      terminate(1);
    }
#line 1239
    printf((char const   * __restrict  )"gauge_field.param[%d] = %f\n", j, gauge_field.param[j]);
#line 1234
    j ++;
  }
#line 1245
  return (0);
}
}
#line 1251 "io_lat4.c"
int read_gauge_hdr(gauge_file *gf___0 , int parallel ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  int32type tmp ;
  int32type btmp ;
  int j ;
  int byterevflag ;
  char myname[15] ;
  int i ;
  QCDheader *hdr ;
  int dims[4] ;
  int ARCHYES ;
  u_int32type chksum ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1261
  myname[0] = (char )'r';
#line 1261
  myname[1] = (char )'e';
#line 1261
  myname[2] = (char )'a';
#line 1261
  myname[3] = (char )'d';
#line 1261
  myname[4] = (char )'_';
#line 1261
  myname[5] = (char )'g';
#line 1261
  myname[6] = (char )'a';
#line 1261
  myname[7] = (char )'u';
#line 1261
  myname[8] = (char )'g';
#line 1261
  myname[9] = (char )'e';
#line 1261
  myname[10] = (char )'_';
#line 1261
  myname[11] = (char )'h';
#line 1261
  myname[12] = (char )'d';
#line 1261
  myname[13] = (char )'r';
#line 1261
  myname[14] = (char )'\000';
#line 1265
  ARCHYES = 0;
#line 1268
  fp = gf___0->fp;
#line 1269
  gh = gf___0->header;
#line 1276
  tmp___0 = psread_data(parallel, fp, (void *)(& gh->magic_number), sizeof(gh->magic_number),
                        myname, (char *)"magic number");
#line 1276
  if (tmp___0 != 0) {
#line 1277
    terminate(1);
  }
#line 1279
  tmp = gh->magic_number;
#line 1280
  btmp = gh->magic_number;
#line 1281
  byterevn(& btmp, 1);
#line 1286
  if (tmp == 1111836489) {
#line 1288
    printf((char const   * __restrict  )"reading as archive format\n");
#line 1289
    ARCHYES = 1;
#line 1290
    byterevflag = 0;
  } else
#line 1292
  if (btmp == 1111836489) {
#line 1294
    printf((char const   * __restrict  )"reading as archive format with byte reversal\n");
#line 1295
    ARCHYES = 1;
#line 1296
    byterevflag = 1;
#line 1297
    gh->magic_number = btmp;
#line 1298
    if (sizeof(double ) != sizeof(int32type )) {
#line 1299
      printf((char const   * __restrict  )"%s: Can\'t byte reverse\n", myname);
#line 1300
      printf((char const   * __restrict  )"requires size of int32type(%d) = size of double(%d)\n",
             (int )sizeof(int32type ), (int )sizeof(double ));
#line 1302
      terminate(1);
    }
  } else
#line 1305
  if (tmp == 20103) {
#line 1307
    byterevflag = 0;
  } else
#line 1311
  if (btmp == 20103) {
#line 1313
    byterevflag = 1;
#line 1314
    gh->magic_number = btmp;
#line 1315
    printf((char const   * __restrict  )"Reading with byte reversal\n");
#line 1316
    if (sizeof(double ) != sizeof(int32type )) {
#line 1317
      printf((char const   * __restrict  )"%s: Can\'t byte reverse\n", myname);
#line 1318
      printf((char const   * __restrict  )"requires size of int32type(%d) = size of double(%d)\n",
             (int )sizeof(int32type ), (int )sizeof(double ));
#line 1320
      terminate(1);
    }
  } else {
#line 1326
    tmp___1 = read_v3_gauge_hdr(gf___0, parallel, & byterevflag);
#line 1326
    if (tmp___1 != 0) {
#line 1326
      tmp___2 = read_1996_gauge_hdr(gf___0, parallel, & byterevflag);
#line 1326
      if (tmp___2 != 0) {
#line 1330
        printf((char const   * __restrict  )"%s: Unrecognized magic number in gauge configuration file header.\n",
               myname);
#line 1331
        printf((char const   * __restrict  )"Expected %x but read %x\n", 20103, tmp);
#line 1333
        printf((char const   * __restrict  )"Expected %s but read %s\n", (char *)20103,
               (char *)tmp);
#line 1335
        terminate(1);
      }
    }
#line 1337
    return (byterevflag);
  }
#line 1345
  if (ARCHYES == 1) {
#line 1347
    (gf___0->header)->order = 0;
#line 1349
    if (parallel) {
#line 1350
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Must use reload_serial with archive files for now.\n",
              myname);
#line 1353
      terminate(1);
    }
#line 1357
    hdr = qcdhdr_get_hdr(fp);
#line 1360
    tmp___3 = qcdhdr_get_int((char *)"DIMENSION_1", hdr, dims + 0);
#line 1360
    if (tmp___3 == -1) {
#line 1361
      error_exit((char *)"DIMENSION_1 not present");
    }
#line 1362
    tmp___4 = qcdhdr_get_int((char *)"DIMENSION_2", hdr, dims + 1);
#line 1362
    if (tmp___4 == -1) {
#line 1363
      error_exit((char *)"DIMENSION_2 not present");
    }
#line 1364
    tmp___5 = qcdhdr_get_int((char *)"DIMENSION_3", hdr, dims + 2);
#line 1364
    if (tmp___5 == -1) {
#line 1365
      error_exit((char *)"DIMENSION_3 not present");
    }
#line 1366
    tmp___6 = qcdhdr_get_int((char *)"DIMENSION_4", hdr, dims + 3);
#line 1366
    if (tmp___6 == -1) {
#line 1367
      error_exit((char *)"DIMENSION_4 not present");
    }
#line 1369
    i = 0;
#line 1369
    while (i < 4) {
#line 1369
      gh->dims[i] = dims[i];
#line 1369
      i ++;
    }
#line 1372
    tmp___7 = qcdhdr_get_int32x((char *)"CHECKSUM", hdr, & chksum);
#line 1372
    if (tmp___7 == -1) {
#line 1373
      error_exit((char *)"CHECKSUM not present");
    }
#line 1374
    gf___0->check.sum31 = chksum;
  } else {
#line 1380
    tmp___8 = psread_byteorder(byterevflag, parallel, fp, (void *)(gh->dims), sizeof(gh->dims),
                               myname, (char *)"dimensions");
#line 1380
    if (tmp___8 != 0) {
#line 1381
      terminate(1);
    }
  }
#line 1386
  if (gh->dims[0] != nx) {
#line 1386
    goto _L___0;
  } else
#line 1386
  if (gh->dims[1] != ny) {
#line 1386
    goto _L___0;
  } else
#line 1386
  if (gh->dims[2] != nz) {
#line 1386
    goto _L___0;
  } else
#line 1386
  if (gh->dims[3] != nt) {
    _L___0: /* CIL Label */ 
#line 1394
    if (nx != -1) {
#line 1394
      goto _L;
    } else
#line 1394
    if (ny != -1) {
#line 1394
      goto _L;
    } else
#line 1394
    if (nz != -1) {
#line 1394
      goto _L;
    } else
#line 1394
    if (nt != -1) {
      _L: /* CIL Label */ 
#line 1396
      printf((char const   * __restrict  )"%s: Incorrect lattice dimensions ", myname);
#line 1397
      j = 0;
#line 1397
      while (j < 4) {
#line 1398
        printf((char const   * __restrict  )"%d ", gh->dims[j]);
#line 1397
        j ++;
      }
#line 1399
      printf((char const   * __restrict  )"\n");
#line 1399
      fflush(stdout);
#line 1399
      terminate(1);
    } else {
#line 1403
      nx = gh->dims[0];
#line 1404
      ny = gh->dims[1];
#line 1405
      nz = gh->dims[2];
#line 1406
      nt = gh->dims[3];
#line 1407
      volume = ((nx * ny) * nz) * nt;
    }
  }
#line 1411
  if (ARCHYES) {
#line 1416
    qcdhdr_destroy_hdr(hdr);
  } else {
#line 1423
    tmp___9 = psread_data(parallel, fp, (void *)(gh->time_stamp), sizeof(gh->time_stamp),
                          myname, (char *)"time stamp");
#line 1423
    if (tmp___9 != 0) {
#line 1424
      terminate(1);
    }
#line 1428
    gh->header_bytes = (int32type )(((sizeof(gh->magic_number) + sizeof(gh->dims)) + sizeof(gh->time_stamp)) + sizeof(gh->order));
#line 1433
    tmp___10 = psread_byteorder(byterevflag, parallel, fp, (void *)(& gh->order),
                                sizeof(gh->order), myname, (char *)"order parameter");
#line 1433
    if (tmp___10 != 0) {
#line 1434
      terminate(1);
    }
  }
#line 1437
  return (byterevflag);
}
}
#line 1443 "io_lat4.c"
gauge_file *r_serial_i(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int byterevflag ;
  int *tmp ;

  {
#line 1454
  gf___0 = setup_input_gauge_file(filename);
#line 1455
  gh = gf___0->header;
#line 1458
  gf___0->parallel = 0;
#line 1462
  if (this_node == 0) {
#line 1464
    fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 1465
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1467
      tmp = __errno_location();
#line 1467
      printf((char const   * __restrict  )"r_serial_i: Node %d can\'t open file %s, error %d\n",
             this_node, filename, *tmp);
#line 1468
      fflush(stdout);
#line 1468
      terminate(1);
    }
#line 1471
    gf___0->fp = fp;
#line 1473
    byterevflag = read_gauge_hdr(gf___0, 0);
  } else {
#line 1477
    gf___0->fp = (FILE *)((void *)0);
  }
#line 1481
  broadcast_bytes((char *)(& byterevflag), (int )sizeof(byterevflag));
#line 1482
  gf___0->byterevflag = byterevflag;
#line 1486
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
#line 1490
  read_site_list(0, gf___0);
#line 1492
  return (gf___0);
}
}
#line 1500 "io_lat4.c"
void r_serial(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  off_t offset ;
  off_t gauge_check_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  int rcv_rank ;
  int rcv_coords ;
  int destnode ;
  int i ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  int buf_length ;
  int where_in_buf ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix *lbuf ;
  char myname[9] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1523
  myname[0] = (char )'r';
#line 1523
  myname[1] = (char )'_';
#line 1523
  myname[2] = (char )'s';
#line 1523
  myname[3] = (char )'e';
#line 1523
  myname[4] = (char )'r';
#line 1523
  myname[5] = (char )'i';
#line 1523
  myname[6] = (char )'a';
#line 1523
  myname[7] = (char )'l';
#line 1523
  myname[8] = (char )'\000';
#line 1525
  fp = gf___0->fp;
#line 1526
  gh = gf___0->header;
#line 1527
  filename = gf___0->filename;
#line 1528
  byterevflag = gf___0->byterevflag;
#line 1530
  if (this_node == 0) {
#line 1536
    if (gh->magic_number == 20103) {
#line 1537
      gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
    } else
#line 1539
    if (gh->magic_number == 53546) {
#line 1540
      gauge_check_size = (off_t )4;
    } else {
#line 1542
      gauge_check_size = (off_t )0;
    }
#line 1544
    if ((gf___0->header)->order == 0) {
#line 1544
      coord_list_size = (off_t )0;
    } else {
#line 1545
      coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
    }
#line 1546
    checksum_offset = (off_t )(gf___0->header)->header_bytes + coord_list_size;
#line 1547
    head_size = checksum_offset + gauge_check_size;
#line 1551
    if (gf___0->parallel) {
#line 1552
      printf((char const   * __restrict  )"%s: Attempting serial read from parallel file \n",
             myname);
    }
#line 1554
//AD    tmp = calloc((size_t )16384, sizeof(su3_matrix ));
#line 1554
//AD    lbuf = (su3_matrix *)tmp;
    lbuf = (su3_matrix *)calloc((size_t )16384, sizeof(su3_matrix )); //AD
#line 1555
    if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 1557
      printf((char const   * __restrict  )"%s: Node %d can\'t malloc lbuf\n", myname,
             this_node);
#line 1558
      fflush(stdout);
#line 1559
      terminate(1);
    }
#line 1564
    offset = head_size;
#line 1566
    tmp___1 = fseek(fp, offset, 0);
#line 1566
    if (tmp___1 < 0) {
#line 1569
      tmp___0 = __errno_location();
#line 1569
      printf((char const   * __restrict  )"%s: Node 0 fseeko failed error %d file %s\n",
             myname, *tmp___0, filename);
#line 1578
      fflush(stdout);
#line 1578
      terminate(1);
    }
#line 1581
    buf_length = 0;
#line 1582
    where_in_buf = 0;
  }
#line 1587
  test_gc.sum29 = (u_int32type )0;
#line 1588
  test_gc.sum31 = (u_int32type )0;
#line 1592
  rank29 = 0;
#line 1593
  rank31 = 0;
#line 1595
  g_sync();
#line 1599
  rcv_rank = 0;
#line 1599
  while (rcv_rank < volume) {
#line 1604
    if ((gf___0->header)->order == 0) {
#line 1605
      rcv_coords = rcv_rank;
    } else {
#line 1607
      rcv_coords = *(gf___0->rank2rcv + rcv_rank);
    }
#line 1609
    x = rcv_coords % nx;
#line 1609
    rcv_coords /= nx;
#line 1610
    y = rcv_coords % ny;
#line 1610
    rcv_coords /= ny;
#line 1611
    z = rcv_coords % nz;
#line 1611
    rcv_coords /= nz;
#line 1612
    t = rcv_coords % nt;
#line 1615
    destnode = node_number(x, y, z, t);
#line 1617
    if (this_node == 0) {
#line 1619
      if (where_in_buf == buf_length) {
#line 1623
        buf_length = volume - rcv_rank;
#line 1624
        if (buf_length > 4096) {
#line 1624
          buf_length = 4096;
        }
#line 1627
        tmp___3 = fread((void * __restrict  )lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                        (FILE * __restrict  )fp);
#line 1627
        if ((int )tmp___3 != buf_length) {
#line 1629
          tmp___2 = __errno_location();
#line 1629
          printf((char const   * __restrict  )"%s: node %d gauge configuration read error %d file %s\n",
                 myname, this_node, *tmp___2, filename);
#line 1631
          fflush(stdout);
#line 1631
          terminate(1);
        }
#line 1633
        where_in_buf = 0;
      }
#line 1636
      if (destnode == 0) {
#line 1637
        i = node_index(x, y, z, t);
#line 1638
        memcpy((void * __restrict  )((void *)(& (lattice + i)->link[0])), (void const   * __restrict  )((void *)(lbuf + 4 * where_in_buf)),
               4UL * sizeof(su3_matrix ));
      } else {
#line 1642
        send_field((char *)(lbuf + 4 * where_in_buf), (int )(4UL * sizeof(su3_matrix )),
                   destnode);
      }
#line 1645
      where_in_buf ++;
    } else
#line 1650
    if (this_node == destnode) {
#line 1651
      i = node_index(x, y, z, t);
#line 1652
      get_field((char *)(& (lattice + i)->link[0]), (int )(4UL * sizeof(su3_matrix )));
    }
#line 1659
    if (this_node == destnode) {
#line 1661
      if (byterevflag == 1) {
#line 1662
        byterevn((int32type *)(& (lattice + i)->link[0]), (int )((4UL * sizeof(su3_matrix )) / sizeof(int32type )));
      }
#line 1665
      k = 0;
#line 1665
      val = (u_int32type *)(& (lattice + i)->link[0]);
#line 1665
      while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 1668
        test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 1669
        test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 1670
        rank29 ++;
#line 1670
        if (rank29 >= 29) {
#line 1670
          rank29 = 0;
        }
#line 1671
        rank31 ++;
#line 1671
        if (rank31 >= 31) {
#line 1671
          rank31 = 0;
        }
#line 1665
        k ++;
#line 1665
        val ++;
      }
    } else {
#line 1676
      rank29 = (int )((unsigned long )rank29 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
#line 1677
      rank31 = (int )((unsigned long )rank31 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
#line 1678
      rank29 %= 29;
#line 1679
      rank31 %= 31;
    }
#line 1599
    rcv_rank ++;
  }
#line 1684
  g_xor32(& test_gc.sum29);
#line 1685
  g_xor32(& test_gc.sum31);
#line 1687
  if (this_node == 0) {
#line 1692
    printf((char const   * __restrict  )"Restored binary gauge configuration serially from file %s\n",
           filename);
#line 1694
    if (gh->magic_number == 20103) {
#line 1696
      printf((char const   * __restrict  )"Time stamp %s\n", gh->time_stamp);
#line 1697
      tmp___5 = fseek(fp, checksum_offset, 0);
#line 1697
      if (tmp___5 < 0) {
#line 1700
        tmp___4 = __errno_location();
#line 1700
        printf((char const   * __restrict  )"%s: Node 0 fseeko failed error %d file %s\n",
               myname, *tmp___4, filename);
#line 1709
        fflush(stdout);
#line 1709
        terminate(1);
      }
#line 1711
      read_checksum(0, gf___0, & test_gc);
    }
#line 1713
    fflush(stdout);
#line 1714
    free((void *)lbuf);
  }
#line 1717
  return;
}
}
#line 1721 "io_lat4.c"
void r_serial_arch(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  off_t gauge_check_size ;
  int rcv_rank ;
  int rcv_coords ;
  int destnode ;
  int i ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  su3_matrix tmpsu3[4] ;
  char myname[14] ;
  int mu ;
  int a ;
  int b ;
  int p ;
  double *uin ;
  double *q ;
  int big_end ;
  double U[4][18] ;
  u_int32type chksum ;
  void *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  double *tmp___2 ;

  {
#line 1739
  myname[0] = (char )'r';
#line 1739
  myname[1] = (char )'_';
#line 1739
  myname[2] = (char )'s';
#line 1739
  myname[3] = (char )'e';
#line 1739
  myname[4] = (char )'r';
#line 1739
  myname[5] = (char )'i';
#line 1739
  myname[6] = (char )'a';
#line 1739
  myname[7] = (char )'l';
#line 1739
  myname[8] = (char )'_';
#line 1739
  myname[9] = (char )'a';
#line 1739
  myname[10] = (char )'r';
#line 1739
  myname[11] = (char )'c';
#line 1739
  myname[12] = (char )'h';
#line 1739
  myname[13] = (char )'\000';
#line 1747
  fp = gf___0->fp;
#line 1748
  gh = gf___0->header;
#line 1749
  filename = gf___0->filename;
#line 1750
  byterevflag = gf___0->byterevflag;
#line 1752
  if (this_node == 0) {
#line 1754
    gauge_check_size = (off_t )0;
#line 1756
    if (gf___0->parallel) {
#line 1757
      printf((char const   * __restrict  )"%s: Attempting serial read from parallel file \n",
             myname);
    }
#line 1759
    big_end = big_endian();
#line 1761
//AD    tmp = calloc((size_t )(((nx * ny) * nz) * 48), sizeof(double ));
#line 1761
//AD    uin = (double *)tmp;
    uin = (double *)calloc((size_t )(((nx * ny) * nz) * 48), sizeof(double )); //AD
#line 1762
    if ((unsigned long )uin == (unsigned long )((void *)0)) {
#line 1764
      printf((char const   * __restrict  )"%s: Node %d can\'t malloc uin buffer to read timeslice\n",
             myname, this_node);
#line 1766
      printf((char const   * __restrict  )"recompile with smaller read buffer: uin\n");
#line 1767
      fflush(stdout);
#line 1768
      terminate(1);
    }
  }
#line 1773
  chksum = (u_int32type )0;
#line 1774
  test_gc.sum29 = (u_int32type )0;
#line 1775
  test_gc.sum31 = (u_int32type )0;
#line 1779
  rank29 = 0;
#line 1780
  rank31 = 0;
#line 1782
  g_sync();
#line 1785
  rcv_rank = 0;
#line 1785
  while (rcv_rank < volume) {
#line 1787
    rcv_coords = rcv_rank;
#line 1789
    x = rcv_coords % nx;
#line 1789
    rcv_coords /= nx;
#line 1790
    y = rcv_coords % ny;
#line 1790
    rcv_coords /= ny;
#line 1791
    z = rcv_coords % nz;
#line 1791
    rcv_coords /= nz;
#line 1792
    t = rcv_coords % nt;
#line 1795
    destnode = node_number(x, y, z, t);
#line 1797
    if (this_node == 0) {
#line 1798
      tmp___1 = fread((void * __restrict  )uin, 48UL * sizeof(double ), (size_t )1,
                      (FILE * __restrict  )fp);
#line 1798
      if ((int )tmp___1 != 1) {
#line 1800
        tmp___0 = __errno_location();
#line 1800
        printf((char const   * __restrict  )"%s: node %d gauge configuration read error %d file %s\n",
               myname, this_node, *tmp___0, filename);
#line 1802
        fflush(stdout);
#line 1802
        terminate(1);
      }
#line 1805
      if (! big_end) {
#line 1805
        byterevn((int32type *)uin, 48);
      }
#line 1806
      q = uin;
#line 1807
      mu = 0;
#line 1807
      while (mu < 4) {
#line 1808
        p = 0;
#line 1808
        while (p < 12) {
#line 1809
          chksum += *((u_int32type *)q);
#line 1810
          tmp___2 = q;
#line 1810
          q ++;
#line 1810
          U[mu][p] = *tmp___2;
#line 1808
          p ++;
        }
#line 1812
        complete_U(U[mu]);
#line 1817
        a = 0;
#line 1817
        while (a < 3) {
#line 1817
          b = 0;
#line 1817
          while (b < 3) {
#line 1818
            tmpsu3[mu].e[a][b].real = U[mu][2 * (3 * a + b)];
#line 1820
            tmpsu3[mu].e[a][b].imag = U[mu][2 * (3 * a + b) + 1];
#line 1817
            b ++;
          }
#line 1817
          a ++;
        }
#line 1807
        mu ++;
      }
#line 1825
      if (destnode == 0) {
#line 1826
        i = node_index(x, y, z, t);
#line 1828
        memcpy((void * __restrict  )((void *)(& (lattice + i)->link[0])), (void const   * __restrict  )((void *)(& tmpsu3)),
               4UL * sizeof(su3_matrix ));
      } else {
#line 1831
        send_field((char *)(tmpsu3), (int )(4UL * sizeof(su3_matrix )), destnode);
      }
    } else
#line 1836
    if (this_node == destnode) {
#line 1837
      i = node_index(x, y, z, t);
#line 1838
      get_field((char *)(& (lattice + i)->link[0]), (int )(4UL * sizeof(su3_matrix )));
    }
#line 1844
    if (this_node == destnode) {
#line 1847
      k = 0;
#line 1847
      val = (u_int32type *)(& (lattice + i)->link[0]);
#line 1847
      while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 1850
        test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 1851
        test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 1852
        rank29 ++;
#line 1852
        if (rank29 >= 29) {
#line 1852
          rank29 = 0;
        }
#line 1853
        rank31 ++;
#line 1853
        if (rank31 >= 31) {
#line 1853
          rank31 = 0;
        }
#line 1847
        k ++;
#line 1847
        val ++;
      }
    } else {
#line 1858
      rank29 = (int )((unsigned long )rank29 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
#line 1859
      rank31 = (int )((unsigned long )rank31 + (4UL * sizeof(su3_matrix )) / sizeof(int32type ));
#line 1860
      rank29 %= 29;
#line 1861
      rank31 %= 31;
    }
#line 1785
    rcv_rank ++;
  }
#line 1866
  g_xor32(& test_gc.sum29);
#line 1867
  g_xor32(& test_gc.sum31);
#line 1869
  if (this_node == 0) {
#line 1873
    printf((char const   * __restrict  )"Restored archive gauge configuration serially from file %s\n",
           filename);
#line 1875
    if (chksum != gf___0->check.sum31) {
#line 1877
      printf((char const   * __restrict  )"Archive style checksum violation: computed %x, read %x\n",
             chksum, gf___0->check.sum31);
    } else {
#line 1882
      printf((char const   * __restrict  )"Archive style checksum = %x OK\n", chksum);
    }
#line 1884
    fflush(stdout);
#line 1885
    free((void *)uin);
#line 1888
    gf___0->check.sum29 = test_gc.sum29;
#line 1889
    gf___0->check.sum31 = test_gc.sum31;
  }
#line 1892
  return;
}
}
#line 1900 "io_lat4.c"
void r_serial_f(gauge_file *gf___0 ) 
{ 


  {
#line 1904
  g_sync();
#line 1905
  if (this_node == 0) {
#line 1907
    if (gf___0->parallel) {
#line 1908
      printf((char const   * __restrict  )"r_serial_f: Attempting serial close on parallel file \n");
    }
#line 1910
    fclose(gf___0->fp);
  }
#line 1913
  if ((unsigned long )gf___0->rank2rcv != (unsigned long )((void *)0)) {
#line 1913
    free((void *)gf___0->rank2rcv);
  }
#line 1917
  return;
}
}
#line 1923 "io_lat4.c"
void write_site_list(FILE *fp , gauge_header *gh ) 
{ 
  off_t offset ;
  int i ;
  int buf_length ;
  register site *s ;
  int32type coords ;
  int32type *cbuf ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;

  {
#line 1940
  offset = (off_t )((unsigned long )gh->header_bytes + (sizeof(int32type ) * (unsigned long )sites_on_node) * (unsigned long )this_node);
#line 1943
//AD  tmp = calloc((size_t )sites_on_node, sizeof(int32type ));
#line 1943
//AD  cbuf = (int32type *)tmp;
  cbuf = (int32type *)calloc((size_t )sites_on_node, sizeof(int32type )); //AD
#line 1944
  if ((unsigned long )cbuf == (unsigned long )((void *)0)) {
#line 1946
    printf((char const   * __restrict  )"write_site_list: node %d can\'t malloc cbuf\n",
           this_node);
#line 1947
    fflush(stdout);
#line 1947
    terminate(1);
  }
#line 1950
  tmp___1 = g_seek(fp, offset, 0);
#line 1950
  if (tmp___1 < 0) {
#line 1952
    tmp___0 = __errno_location();
#line 1952
    printf((char const   * __restrict  )"write_site_list: node %d g_seek %ld failed errno %d\n",
           this_node, offset, *tmp___0);
#line 1954
    fflush(stdout);
#line 1954
    terminate(1);
  }
#line 1957
  buf_length = 0;
#line 1959
  i = 0;
#line 1959
  s = lattice;
#line 1959
  while (i < sites_on_node) {
#line 1962
    coords = nx * (ny * (nz * (int )s->t + (int )s->z) + (int )s->y) + (int )s->x;
#line 1963
    *(cbuf + buf_length) = coords;
#line 1964
    buf_length ++;
#line 1959
    i ++;
#line 1959
    s ++;
  }
#line 1967
  tmp___3 = g_write((void const   *)cbuf, sizeof(int32type ), (size_t )sites_on_node,
                    fp);
#line 1967
  if ((int )tmp___3 != sites_on_node) {
#line 1969
    tmp___2 = __errno_location();
#line 1969
    printf((char const   * __restrict  )"write_site_list: Node %d coords write error %d\n",
           this_node, *tmp___2);
#line 1970
    fflush(stdout);
#line 1970
    terminate(1);
  }
#line 1973
  free((void *)cbuf);
#line 1974
  return;
}
}
#line 1979 "io_lat4.c"
gauge_file *parallel_open(int order , char *filename ) 
{ 
  FILE *fp ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;

  {
#line 1992
  gf___0 = setup_output_gauge_file();
#line 1993
  gh = gf___0->header;
#line 1995
  gh->order = order;
#line 1999
  fp = g_open((char const   *)filename, "wb");
#line 2000
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 2002
    tmp = __errno_location();
#line 2002
    printf((char const   * __restrict  )"parallel_open: Node %d can\'t open file %s, error %d\n",
           this_node, filename, *tmp);
#line 2003
    fflush(stdout);
#line 2003
    terminate(1);
  }
#line 2008
  if (this_node == 0) {
#line 2009
    pwrite_gauge_hdr(fp, gh);
  }
#line 2011
  broadcast_bytes((char *)(& gh->header_bytes), (int )sizeof(gh->header_bytes));
#line 2015
  if (order != 0) {
#line 2015
    write_site_list(fp, gh);
  }
#line 2019
  gf___0->fp = fp;
#line 2020
  gf___0->filename = filename;
#line 2021
  gf___0->byterevflag = 0;
#line 2022
  gf___0->parallel = 1;
#line 2024
  return (gf___0);
}
}
#line 2030 "io_lat4.c"
gauge_file *w_parallel_i(char *filename ) 
{ 
  gauge_file *tmp ;

  {
#line 2035
  tmp = parallel_open(0, filename);
#line 2035
  return (tmp);
}
}
#line 2042 "io_lat4.c"
gauge_file *w_checkpoint_i(char *filename ) 
{ 
  gauge_file *tmp ;

  {
#line 2047
  tmp = parallel_open(1, filename);
#line 2047
  return (tmp);
}
}
#line 2055 "io_lat4.c"
su3_matrix *w_parallel_setup(gauge_file *gf___0 , off_t *checksum_offset ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  su3_matrix *lbuf ;
  off_t offset ;
  off_t gauge_node_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t gauge_check_size ;
  char myname[17] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 2069
  myname[0] = (char )'w';
#line 2069
  myname[1] = (char )'_';
#line 2069
  myname[2] = (char )'p';
#line 2069
  myname[3] = (char )'a';
#line 2069
  myname[4] = (char )'r';
#line 2069
  myname[5] = (char )'a';
#line 2069
  myname[6] = (char )'l';
#line 2069
  myname[7] = (char )'l';
#line 2069
  myname[8] = (char )'e';
#line 2069
  myname[9] = (char )'l';
#line 2069
  myname[10] = (char )'_';
#line 2069
  myname[11] = (char )'s';
#line 2069
  myname[12] = (char )'e';
#line 2069
  myname[13] = (char )'t';
#line 2069
  myname[14] = (char )'u';
#line 2069
  myname[15] = (char )'p';
#line 2069
  myname[16] = (char )'\000';
#line 2071
  if (! gf___0->parallel) {
#line 2072
    printf((char const   * __restrict  )"%s: Attempting parallel write to serial file.\n",
           myname);
  }
#line 2074
//AD  tmp = calloc((size_t )16384, sizeof(su3_matrix ));
#line 2074
//AD  lbuf = (su3_matrix *)tmp;
  lbuf = (su3_matrix *)calloc((size_t )16384, sizeof(su3_matrix )); //AD
#line 2075
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 2077
    printf((char const   * __restrict  )"%s: Node %d can\'t malloc lbuf\n", myname,
           this_node);
#line 2078
    fflush(stdout);
#line 2079
    terminate(1);
  }
#line 2082
  fp = gf___0->fp;
#line 2083
  gh = gf___0->header;
#line 2085
  gauge_node_size = (off_t )((unsigned long )(sites_on_node * 4) * sizeof(su3_matrix ));
#line 2087
  if ((gf___0->header)->order == 0) {
#line 2087
    coord_list_size = (off_t )0;
  } else {
#line 2088
    coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
  }
#line 2089
  head_size = (off_t )(gf___0->header)->header_bytes + coord_list_size;
#line 2090
  *checksum_offset = head_size;
#line 2091
  gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
#line 2093
  offset = head_size + gauge_check_size;
#line 2097
  offset += gauge_node_size * (off_t )this_node;
#line 2099
  tmp___1 = g_seek(fp, offset, 0);
#line 2099
  if (tmp___1 < 0) {
#line 2101
    tmp___0 = __errno_location();
#line 2101
    printf((char const   * __restrict  )"%s: Node %d g_seek %ld failed error %d file %s\n",
           myname, this_node, offset, *tmp___0, gf___0->filename);
#line 2103
    fflush(stdout);
#line 2103
    terminate(1);
  }
#line 2106
  return (lbuf);
}
}
#line 2112 "io_lat4.c"
void w_parallel(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  su3_matrix *lbuf ;
  int buf_length ;
  int where_in_buf ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  off_t checksum_offset ;
  register int i ;
  int j ;
  int k ;
  int x ;
  int y ;
  int z ;
  int t ;
  struct __anonstruct_msg_53 msg ;
  int isite ;
  int ksite ;
  int site_block ;
  int rcv_coords ;
  int rcv_rank ;
  int destnode ;
  int sendnode ;
  char myname[11] ;
  double tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 2132
  myname[0] = (char )'w';
#line 2132
  myname[1] = (char )'_';
#line 2132
  myname[2] = (char )'p';
#line 2132
  myname[3] = (char )'a';
#line 2132
  myname[4] = (char )'r';
#line 2132
  myname[5] = (char )'a';
#line 2132
  myname[6] = (char )'l';
#line 2132
  myname[7] = (char )'l';
#line 2132
  myname[8] = (char )'e';
#line 2132
  myname[9] = (char )'l';
#line 2132
  myname[10] = (char )'\000';
#line 2134
  fp = gf___0->fp;
#line 2136
  lbuf = w_parallel_setup(gf___0, & checksum_offset);
#line 2141
  gf___0->check.sum31 = (u_int32type )0;
#line 2142
  gf___0->check.sum29 = (u_int32type )0;
#line 2146
  g_sync();
#line 2147
  buf_length = 0;
#line 2151
  i = 0;
#line 2151
  while (i < 4096) {
#line 2152
    j = 0;
#line 2152
    while (j < 3) {
#line 2152
      k = 0;
#line 2152
      while (k < 3) {
#line 2153
        tmp = 0.;
#line 2153
        (lbuf + i)->e[j][k].imag = tmp;
#line 2153
        (lbuf + i)->e[j][k].real = tmp;
#line 2152
        k ++;
      }
#line 2152
      j ++;
    }
#line 2151
    i ++;
  }
#line 2163
  site_block = 4096;
#line 2164
  if (4096 % site_block != 0) {
#line 2165
    printf((char const   * __restrict  )"%s: site_block incommensurate with buffer size\n",
           myname);
#line 2166
    fflush(stdout);
#line 2166
    terminate(1);
  }
#line 2168
  ksite = 0;
#line 2168
  while (ksite < sites_on_node) {
#line 2170
    destnode = 0;
#line 2170
    while (destnode < number_of_nodes) {
#line 2171
      isite = ksite;
#line 2171
      while (1) {
#line 2171
        if (isite < sites_on_node) {
#line 2171
          if (! (isite < ksite + site_block)) {
#line 2171
            break;
          }
        } else {
#line 2171
          break;
        }
#line 2178
        rcv_coords = destnode * sites_on_node + isite;
#line 2178
        rcv_rank = rcv_coords;
#line 2182
        x = rcv_coords % nx;
#line 2182
        rcv_coords /= nx;
#line 2183
        y = rcv_coords % ny;
#line 2183
        rcv_coords /= ny;
#line 2184
        z = rcv_coords % nz;
#line 2184
        rcv_coords /= nz;
#line 2185
        t = rcv_coords % nt;
#line 2188
        sendnode = node_number(x, y, z, t);
#line 2191
        if (this_node == sendnode) {
#line 2191
          if (destnode != sendnode) {
#line 2193
            msg.x = (short )x;
#line 2193
            msg.y = (short )y;
#line 2193
            msg.z = (short )z;
#line 2193
            msg.t = (short )t;
#line 2194
            i = node_index(x, y, z, t);
#line 2195
            memcpy((void * __restrict  )((void *)(msg.link)), (void const   * __restrict  )((void *)((lattice + i)->link)),
                   4UL * sizeof(su3_matrix ));
#line 2198
            send_field((char *)(& msg), (int )sizeof(msg), destnode);
          } else {
#line 2191
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2201
        if (this_node == destnode) {
#line 2202
          if (destnode == sendnode) {
#line 2203
            i = node_index(x, y, z, t);
#line 2204
            where_in_buf = buf_length;
#line 2205
            memcpy((void * __restrict  )((void *)(lbuf + 4 * where_in_buf)), (void const   * __restrict  )((void *)((lattice + i)->link)),
                   4UL * sizeof(su3_matrix ));
#line 2207
            rank31 = (int )(((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )rcv_rank);
#line 2207
            rank29 = rank31;
          } else {
#line 2215
            get_field((char *)(& msg), (int )sizeof(msg));
#line 2217
            i = (int )msg.x + nx * ((int )msg.y + ny * ((int )msg.z + nz * (int )msg.t));
#line 2219
            where_in_buf = (i % sites_on_node) % 4096;
#line 2222
            memcpy((void * __restrict  )((void *)(lbuf + 4 * where_in_buf)), (void const   * __restrict  )((void *)(msg.link)),
                   4UL * sizeof(su3_matrix ));
#line 2224
            rank31 = (int )(((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )i);
#line 2224
            rank29 = rank31;
          }
#line 2229
          rank29 %= 29;
#line 2229
          rank31 %= 31;
#line 2230
          k = 0;
#line 2230
          val = (u_int32type *)(lbuf + 4 * where_in_buf);
#line 2230
          while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 2233
            gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 2234
            gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 2235
            rank29 ++;
#line 2235
            if (rank29 >= 29) {
#line 2235
              rank29 = 0;
            }
#line 2236
            rank31 ++;
#line 2236
            if (rank31 >= 31) {
#line 2236
              rank31 = 0;
            }
#line 2230
            k ++;
#line 2230
            val ++;
          }
#line 2239
          buf_length ++;
#line 2240
          if (buf_length == 4096) {
#line 2240
            goto _L;
          } else
#line 2240
          if (isite == sites_on_node - 1) {
            _L: /* CIL Label */ 
#line 2245
            tmp___1 = g_write((void const   *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                              fp);
#line 2245
            if ((int )tmp___1 != buf_length) {
#line 2248
              tmp___0 = __errno_location();
#line 2248
              printf((char const   * __restrict  )"%s: Node %d gauge configuration write error %d file %s\n",
                     myname, this_node, *tmp___0, gf___0->filename);
#line 2250
              fflush(stdout);
#line 2251
              terminate(1);
            }
#line 2253
            buf_length = 0;
#line 2255
            i = 0;
#line 2255
            while (i < 4096) {
#line 2256
              j = 0;
#line 2256
              while (j < 3) {
#line 2256
                k = 0;
#line 2256
                while (k < 3) {
#line 2257
                  tmp___2 = 0.;
#line 2257
                  (lbuf + i)->e[j][k].imag = tmp___2;
#line 2257
                  (lbuf + i)->e[j][k].real = tmp___2;
#line 2256
                  k ++;
                }
#line 2256
                j ++;
              }
#line 2255
              i ++;
            }
          }
        }
#line 2171
        isite ++;
      }
#line 2170
      destnode ++;
    }
#line 2262
    g_sync();
#line 2168
    ksite += site_block;
  }
#line 2266
  free((void *)lbuf);
#line 2270
  g_xor32(& gf___0->check.sum29);
#line 2271
  g_xor32(& gf___0->check.sum31);
#line 2278
  if (this_node == 0) {
#line 2279
    tmp___4 = g_seek(fp, checksum_offset, 0);
#line 2279
    if (tmp___4 < 0) {
#line 2281
      tmp___3 = __errno_location();
#line 2281
      printf((char const   * __restrict  )"%s: Node %d g_seek %ld for checksum failed error %d file %s\n",
             myname, this_node, checksum_offset, *tmp___3, gf___0->filename);
#line 2283
      fflush(stdout);
#line 2283
      terminate(1);
    }
#line 2286
    write_checksum(1, gf___0);
#line 2288
    printf((char const   * __restrict  )"Saved gauge configuration in parallel to binary file %s\n",
           gf___0->filename);
#line 2290
    printf((char const   * __restrict  )"Time stamp %s\n", (gf___0->header)->time_stamp);
  }
#line 2294
  return;
}
}
#line 2300 "io_lat4.c"
void w_checkpoint(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  su3_matrix *lbuf ;
  u_int32type *val ;
  int k ;
  int rank29 ;
  int rank31 ;
  off_t checksum_offset ;
  int buf_length ;
  register site *s ;
  register int i ;
  char myname[13] ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2313
  myname[0] = (char )'w';
#line 2313
  myname[1] = (char )'_';
#line 2313
  myname[2] = (char )'c';
#line 2313
  myname[3] = (char )'h';
#line 2313
  myname[4] = (char )'e';
#line 2313
  myname[5] = (char )'c';
#line 2313
  myname[6] = (char )'k';
#line 2313
  myname[7] = (char )'p';
#line 2313
  myname[8] = (char )'o';
#line 2313
  myname[9] = (char )'i';
#line 2313
  myname[10] = (char )'n';
#line 2313
  myname[11] = (char )'t';
#line 2313
  myname[12] = (char )'\000';
#line 2315
  fp = gf___0->fp;
#line 2317
  lbuf = w_parallel_setup(gf___0, & checksum_offset);
#line 2322
  gf___0->check.sum31 = (u_int32type )0;
#line 2323
  gf___0->check.sum29 = (u_int32type )0;
#line 2326
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
#line 2327
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
#line 2329
  buf_length = 0;
#line 2331
  i = 0;
#line 2331
  s = lattice;
#line 2331
  while (i < sites_on_node) {
#line 2335
    memcpy((void * __restrict  )((void *)(lbuf + 4 * buf_length)), (void const   * __restrict  )((void *)((lattice + i)->link)),
           4UL * sizeof(su3_matrix ));
#line 2339
    k = 0;
#line 2339
    val = (u_int32type *)(lbuf + 4 * buf_length);
#line 2339
    while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 2342
      gf___0->check.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 2343
      gf___0->check.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 2344
      rank29 ++;
#line 2344
      if (rank29 >= 29) {
#line 2344
        rank29 = 0;
      }
#line 2345
      rank31 ++;
#line 2345
      if (rank31 >= 31) {
#line 2345
        rank31 = 0;
      }
#line 2339
      k ++;
#line 2339
      val ++;
    }
#line 2348
    buf_length ++;
#line 2350
    if (buf_length == 4096) {
#line 2350
      goto _L;
    } else
#line 2350
    if (i == sites_on_node - 1) {
      _L: /* CIL Label */ 
#line 2354
      fflush(stdout);
#line 2355
      tmp___0 = g_write((void const   *)lbuf, 4UL * sizeof(su3_matrix ), (size_t )buf_length,
                        fp);
#line 2355
      if ((int )tmp___0 != buf_length) {
#line 2357
        tmp = __errno_location();
#line 2357
        printf((char const   * __restrict  )"%s: Node %d gauge configuration write error %d file %s\n",
               myname, this_node, *tmp, gf___0->filename);
#line 2359
        fflush(stdout);
#line 2360
        terminate(1);
      }
#line 2362
      buf_length = 0;
    }
#line 2331
    i ++;
#line 2331
    s ++;
  }
#line 2367
  free((void *)lbuf);
#line 2371
  g_xor32(& gf___0->check.sum29);
#line 2372
  g_xor32(& gf___0->check.sum31);
#line 2379
  if (this_node == 0) {
#line 2381
    tmp___2 = g_seek(fp, checksum_offset, 0);
#line 2381
    if (tmp___2 < 0) {
#line 2383
      tmp___1 = __errno_location();
#line 2383
      printf((char const   * __restrict  )"%s: Node %d g_seek %ld for checksum failed error %d file %s\n",
             myname, this_node, checksum_offset, *tmp___1, gf___0->filename);
#line 2385
      fflush(stdout);
#line 2385
      terminate(1);
    }
#line 2388
    write_checksum(1, gf___0);
#line 2390
    printf((char const   * __restrict  )"Saved gauge configuration checkpoint file %s\n",
           gf___0->filename);
#line 2392
    printf((char const   * __restrict  )"Time stamp %s\n", (gf___0->header)->time_stamp);
  }
#line 2395
  return;
}
}
#line 2399 "io_lat4.c"
void w_parallel_f(gauge_file *gf___0 ) 
{ 


  {
#line 2403
  g_sync();
#line 2404
  if ((unsigned long )gf___0->fp != (unsigned long )((void *)0)) {
#line 2406
    if (! gf___0->parallel) {
#line 2407
      printf((char const   * __restrict  )"w_parallel_f: Attempting parallel close on serial file.\n");
    }
#line 2409
    g_close(gf___0->fp);
#line 2410
    gf___0->fp = (FILE *)((void *)0);
  }
#line 2415
  if (this_node == 0) {
#line 2415
    write_gauge_info_file(gf___0);
  }
#line 2419
  return;
}
}
#line 2424 "io_lat4.c"
gauge_file *r_parallel_i(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int byterevflag ;
  int *tmp ;

  {
#line 2435
  gf___0 = setup_input_gauge_file(filename);
#line 2436
  gh = gf___0->header;
#line 2438
  gf___0->parallel = 1;
#line 2442
  fp = g_open((char const   *)filename, "rb");
#line 2443
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 2445
    tmp = __errno_location();
#line 2445
    printf((char const   * __restrict  )"r_parallel_i: Node %d can\'t open file %s, error %d\n",
           this_node, filename, *tmp);
#line 2446
    fflush(stdout);
#line 2446
    terminate(1);
  }
#line 2449
  gf___0->fp = fp;
#line 2453
  if (this_node == 0) {
#line 2454
    byterevflag = read_gauge_hdr(gf___0, 1);
  }
#line 2458
  broadcast_bytes((char *)(& byterevflag), (int )sizeof(byterevflag));
#line 2460
  gf___0->byterevflag = byterevflag;
#line 2464
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
#line 2468
  read_site_list(1, gf___0);
#line 2470
  return (gf___0);
}
}
#line 2477 "io_lat4.c"
void r_parallel(gauge_file *gf___0 ) 
{ 
  FILE *fp ;
  gauge_header *gh ;
  char *filename ;
  int byterevflag ;
  su3_matrix *lbuf ;
  struct __anonstruct_msg_54 msg ;
  int buf_length ;
  int where_in_buf ;
  gauge_check test_gc ;
  u_int32type *val ;
  int rank29 ;
  int rank31 ;
  int destnode ;
  int sendnode ;
  int isite ;
  int ksite ;
  int site_block ;
  int x ;
  int y ;
  int z ;
  int t ;
  int rcv_rank ;
  int rcv_coords ;
  register int i ;
  register int k ;
  off_t offset ;
  off_t gauge_node_size ;
  off_t gauge_check_size ;
  off_t coord_list_size ;
  off_t head_size ;
  off_t checksum_offset ;
  char myname[11] ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 2507
  myname[0] = (char )'r';
#line 2507
  myname[1] = (char )'_';
#line 2507
  myname[2] = (char )'p';
#line 2507
  myname[3] = (char )'a';
#line 2507
  myname[4] = (char )'r';
#line 2507
  myname[5] = (char )'a';
#line 2507
  myname[6] = (char )'l';
#line 2507
  myname[7] = (char )'l';
#line 2507
  myname[8] = (char )'e';
#line 2507
  myname[9] = (char )'l';
#line 2507
  myname[10] = (char )'\000';
#line 2509
  fp = gf___0->fp;
#line 2510
  gh = gf___0->header;
#line 2512
  filename = gf___0->filename;
#line 2513
  byterevflag = gf___0->byterevflag;
#line 2515
  if (! gf___0->parallel) {
#line 2516
    printf((char const   * __restrict  )"%s: Attempting parallel read from serial file.\n",
           myname);
  }
#line 2519
//AD  tmp = calloc((size_t )16384, sizeof(su3_matrix ));
#line 2519
//AD  lbuf = (su3_matrix *)tmp;
  lbuf = (su3_matrix *)calloc((size_t )16384, sizeof(su3_matrix )); //AD
#line 2520
  if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 2522
    printf((char const   * __restrict  )"%s: Node %d can\'t malloc lbuf\n", myname,
           this_node);
#line 2523
    fflush(stdout);
#line 2523
    terminate(1);
  }
#line 2526
  gauge_node_size = (off_t )((unsigned long )(sites_on_node * 4) * sizeof(su3_matrix ));
#line 2530
  if (gh->magic_number == 20103) {
#line 2531
    gauge_check_size = (off_t )(sizeof(gf___0->check.sum29) + sizeof(gf___0->check.sum31));
  } else
#line 2533
  if (gh->magic_number == 53546) {
#line 2534
    gauge_check_size = (off_t )4;
  } else {
#line 2536
    gauge_check_size = (off_t )0;
  }
#line 2538
  if ((gf___0->header)->order == 0) {
#line 2538
    coord_list_size = (off_t )0;
  } else {
#line 2539
    coord_list_size = (off_t )(sizeof(int32type ) * (unsigned long )volume);
  }
#line 2540
  checksum_offset = (off_t )(gf___0->header)->header_bytes + coord_list_size;
#line 2541
  head_size = checksum_offset + gauge_check_size;
#line 2543
  offset = head_size;
#line 2548
  offset += gauge_node_size * (off_t )this_node;
#line 2550
  tmp___1 = g_seek(fp, offset, 0);
#line 2550
  if (tmp___1 < 0) {
#line 2552
    tmp___0 = __errno_location();
#line 2552
    printf((char const   * __restrict  )"%s: Node %d g_seek %ld failed error %d file %s\n",
           myname, this_node, offset, *tmp___0, filename);
#line 2554
    fflush(stdout);
#line 2554
    terminate(1);
  }
#line 2558
  test_gc.sum29 = (u_int32type )0;
#line 2559
  test_gc.sum31 = (u_int32type )0;
#line 2562
  rank29 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 29UL);
#line 2563
  rank31 = (int )(((((4UL * sizeof(su3_matrix )) / sizeof(int32type )) * (unsigned long )sites_on_node) * (unsigned long )this_node) % 31UL);
#line 2567
  g_sync();
#line 2568
  buf_length = 0;
#line 2569
  where_in_buf = 0;
#line 2578
  site_block = 4;
#line 2579
  ksite = 0;
#line 2579
  while (ksite < sites_on_node) {
#line 2581
    sendnode = 0;
#line 2581
    while (sendnode < number_of_nodes) {
#line 2582
      isite = ksite;
#line 2582
      while (1) {
#line 2582
        if (isite < sites_on_node) {
#line 2582
          if (! (isite < ksite + site_block)) {
#line 2582
            break;
          }
        } else {
#line 2582
          break;
        }
#line 2597
        rcv_rank = sendnode * sites_on_node + isite;
#line 2602
        if ((gf___0->header)->order == 0) {
#line 2603
          rcv_coords = rcv_rank;
        } else {
#line 2605
          rcv_coords = *(gf___0->rank2rcv + rcv_rank);
        }
#line 2607
        x = rcv_coords % nx;
#line 2607
        rcv_coords /= nx;
#line 2608
        y = rcv_coords % ny;
#line 2608
        rcv_coords /= ny;
#line 2609
        z = rcv_coords % nz;
#line 2609
        rcv_coords /= nz;
#line 2610
        t = rcv_coords % nt;
#line 2614
        destnode = node_number(x, y, z, t);
#line 2617
        if (this_node == sendnode) {
#line 2619
          if (where_in_buf == buf_length) {
#line 2625
            buf_length = sites_on_node - isite;
#line 2626
            if (buf_length > 4096) {
#line 2626
              buf_length = 4096;
            }
#line 2630
            tmp___3 = g_read((void *)lbuf, (unsigned long )(buf_length * 4) * sizeof(su3_matrix ),
                             (size_t )1, fp);
#line 2630
            if (tmp___3 != 1UL) {
#line 2632
              tmp___2 = __errno_location();
#line 2632
              printf((char const   * __restrict  )"%s: node %d gauge configuration read error %d file %s\n",
                     myname, this_node, *tmp___2, filename);
#line 2634
              fflush(stdout);
#line 2634
              terminate(1);
            }
#line 2636
            where_in_buf = 0;
          }
#line 2640
          if (gf___0->byterevflag == 1) {
#line 2641
            byterevn((int32type *)(lbuf + 4 * where_in_buf), (int )((4UL * sizeof(su3_matrix )) / sizeof(int32type )));
          }
#line 2645
          k = 0;
#line 2645
          val = (u_int32type *)(lbuf + 4 * where_in_buf);
#line 2645
          while (k < (4 * (int )sizeof(su3_matrix )) / (int )sizeof(int32type )) {
#line 2648
            test_gc.sum29 ^= (*val << rank29) | (*val >> (32 - rank29));
#line 2649
            test_gc.sum31 ^= (*val << rank31) | (*val >> (32 - rank31));
#line 2650
            rank29 ++;
#line 2650
            if (rank29 >= 29) {
#line 2650
              rank29 = 0;
            }
#line 2651
            rank31 ++;
#line 2651
            if (rank31 >= 31) {
#line 2651
              rank31 = 0;
            }
#line 2645
            k ++;
#line 2645
            val ++;
          }
#line 2654
          if (destnode == sendnode) {
#line 2655
            i = node_index(x, y, z, t);
#line 2656
            memcpy((void * __restrict  )((void *)((lattice + i)->link)), (void const   * __restrict  )((void *)(lbuf + 4 * where_in_buf)),
                   4UL * sizeof(su3_matrix ));
          } else {
#line 2661
            msg.x = (short )x;
#line 2661
            msg.y = (short )y;
#line 2661
            msg.z = (short )z;
#line 2661
            msg.t = (short )t;
#line 2662
            memcpy((void * __restrict  )((void *)(msg.link)), (void const   * __restrict  )((void *)(lbuf + 4 * where_in_buf)),
                   4UL * sizeof(su3_matrix ));
#line 2665
            send_field((char *)(& msg), (int )sizeof(msg), destnode);
          }
#line 2667
          where_in_buf ++;
        } else
#line 2671
        if (this_node == destnode) {
#line 2672
          get_field((char *)(& msg), (int )sizeof(msg));
#line 2673
          i = node_index((int )msg.x, (int )msg.y, (int )msg.z, (int )msg.t);
#line 2674
          tmp___4 = node_number((int )msg.x, (int )msg.y, (int )msg.z, (int )msg.t);
#line 2674
          if (this_node != tmp___4) {
#line 2676
            printf((char const   * __restrict  )"BOTCH. Node %d received %d %d %d %d\n",
                   this_node, (int )msg.x, (int )msg.y, (int )msg.z, (int )msg.t);
#line 2678
            fflush(stdout);
#line 2678
            terminate(1);
          }
#line 2680
          memcpy((void * __restrict  )((void *)((lattice + i)->link)), (void const   * __restrict  )((void *)(msg.link)),
                 4UL * sizeof(su3_matrix ));
        }
#line 2582
        isite ++;
      }
#line 2581
      sendnode ++;
    }
#line 2686
    g_sync();
#line 2579
    ksite += site_block;
  }
#line 2689
  free((void *)lbuf);
#line 2692
  g_xor32(& test_gc.sum29);
#line 2693
  g_xor32(& test_gc.sum31);
#line 2697
  if (this_node == 0) {
#line 2701
    printf((char const   * __restrict  )"Restored binary gauge configuration in parallel from file %s\n",
           filename);
#line 2703
    if (gh->magic_number == 20103) {
#line 2705
      printf((char const   * __restrict  )"Time stamp %s\n", gh->time_stamp);
#line 2706
      tmp___6 = g_seek(fp, checksum_offset, 0);
#line 2706
      if (tmp___6 < 0) {
#line 2708
        tmp___5 = __errno_location();
#line 2708
        printf((char const   * __restrict  )"%s: Node 0 g_seek %ld for checksum failed error %d file %s\n",
               myname, offset, *tmp___5, filename);
#line 2710
        fflush(stdout);
#line 2710
        terminate(1);
      }
#line 2713
      read_checksum(1, gf___0, & test_gc);
    }
#line 2715
    fflush(stdout);
  }
#line 2718
  return;
}
}
#line 2722 "io_lat4.c"
void r_parallel_f(gauge_file *gf___0 ) 
{ 


  {
#line 2726
  g_sync();
#line 2727
  if ((unsigned long )gf___0->fp != (unsigned long )((void *)0)) {
#line 2729
    if (! gf___0->parallel) {
#line 2730
      printf((char const   * __restrict  )"r_parallel_f: Attempting parallel close on serial file.\n");
    }
#line 2731
    g_close(gf___0->fp);
#line 2732
    gf___0->fp = (FILE *)((void *)0);
  }
#line 2737
  return;
}
}
#line 2757 "io_lat4.c"
gauge_file *restore_ascii(char *filename ) 
{ 
  gauge_header *gh ;
  gauge_file *gf___0 ;
  FILE *fp ;
  int destnode ;
  int version_number ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int t ;
  int dir ;
  su3_matrix lbuf[4] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2767
  gf___0 = setup_input_gauge_file(filename);
#line 2768
  gh = gf___0->header;
#line 2771
  gf___0->parallel = 0;
#line 2775
  if (this_node == 0) {
#line 2776
    fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 2777
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 2778
      tmp = __errno_location();
#line 2778
      printf((char const   * __restrict  )"Can\'t open file %s, error %d\n", filename,
             *tmp);
#line 2779
      terminate(1);
    }
#line 2782
    gf___0->fp = fp;
#line 2784
    tmp___0 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%d", & version_number);
#line 2784
    if (tmp___0 != 1) {
#line 2785
      printf((char const   * __restrict  )"restore_ascii: Error reading version number\n");
#line 2785
      terminate(1);
    }
#line 2787
    gh->magic_number = version_number;
#line 2788
    if (gh->magic_number != 20103) {
#line 2789
      printf((char const   * __restrict  )"restore_ascii: Incorrect version number in lattice header\n");
#line 2790
      printf((char const   * __restrict  )"  read %d but expected %d\n", gh->magic_number,
             20103);
#line 2792
      terminate(1);
    }
#line 2796
    i = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%*[ \f\n\r\t\v]%*[\"]%[^\"]%*[\"]",
               gh->time_stamp);
#line 2796
    if (i != 1) {
#line 2797
      printf((char const   * __restrict  )"restore_ascii: Error reading time stamp\n");
#line 2798
      printf((char const   * __restrict  )"count %d time_stamp %s\n", i, gh->time_stamp);
#line 2799
      terminate(1);
    }
#line 2801
    tmp___1 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%d%d%d%d",
                     & x, & y, & z, & t);
#line 2801
    if (tmp___1 != 4) {
#line 2802
      printf((char const   * __restrict  )"restore_ascii: Error in reading dimensions\n");
#line 2802
      terminate(1);
    }
#line 2804
    gh->dims[0] = x;
#line 2804
    gh->dims[1] = y;
#line 2804
    gh->dims[2] = z;
#line 2804
    gh->dims[3] = t;
#line 2805
    if (gh->dims[0] != nx) {
#line 2805
      goto _L;
    } else
#line 2805
    if (gh->dims[1] != ny) {
#line 2805
      goto _L;
    } else
#line 2805
    if (gh->dims[2] != nz) {
#line 2805
      goto _L;
    } else
#line 2805
    if (gh->dims[3] != nt) {
      _L: /* CIL Label */ 
#line 2811
      if (nx != -1) {
#line 2813
        printf((char const   * __restrict  )"restore_ascii: Incorrect lattice size %d,%d,%d,%d\n",
               gh->dims[0], gh->dims[1], gh->dims[2], gh->dims[3]);
#line 2815
        terminate(1);
      } else
#line 2811
      if (ny != -1) {
#line 2813
        printf((char const   * __restrict  )"restore_ascii: Incorrect lattice size %d,%d,%d,%d\n",
               gh->dims[0], gh->dims[1], gh->dims[2], gh->dims[3]);
#line 2815
        terminate(1);
      } else
#line 2811
      if (nz != -1) {
#line 2813
        printf((char const   * __restrict  )"restore_ascii: Incorrect lattice size %d,%d,%d,%d\n",
               gh->dims[0], gh->dims[1], gh->dims[2], gh->dims[3]);
#line 2815
        terminate(1);
      } else
#line 2811
      if (nt != -1) {
#line 2813
        printf((char const   * __restrict  )"restore_ascii: Incorrect lattice size %d,%d,%d,%d\n",
               gh->dims[0], gh->dims[1], gh->dims[2], gh->dims[3]);
#line 2815
        terminate(1);
      } else {
#line 2819
        nx = gh->dims[0];
#line 2820
        ny = gh->dims[1];
#line 2821
        nz = gh->dims[2];
#line 2822
        nt = gh->dims[3];
#line 2823
        volume = ((nx * ny) * nz) * nt;
      }
    }
#line 2827
    gh->order = 0;
  } else {
#line 2831
    gf___0->fp = (FILE *)((void *)0);
  }
#line 2833
  gf___0->byterevflag = 0;
#line 2837
  broadcast_bytes((char *)gh, (int )sizeof(gauge_header ));
#line 2840
  g_sync();
#line 2842
  t = 0;
#line 2842
  while (t < nt) {
#line 2842
    z = 0;
#line 2842
    while (z < nz) {
#line 2842
      y = 0;
#line 2842
      while (y < ny) {
#line 2842
        x = 0;
#line 2842
        while (x < nx) {
#line 2843
          destnode = node_number(x, y, z, t);
#line 2846
          if (this_node == 0) {
#line 2847
            dir = 0;
#line 2847
            while (dir <= 3) {
#line 2848
              i = 0;
#line 2848
              while (i < 3) {
#line 2848
                j = 0;
#line 2848
                while (j < 3) {
#line 2849
                  tmp___2 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%lf%lf\n",
                                   & lbuf[dir].e[i][j].real, & lbuf[dir].e[i][j].imag);
#line 2849
                  if (tmp___2 != 2) {
#line 2851
                    printf((char const   * __restrict  )"restore_ascii: gauge link read error\n");
#line 2852
                    terminate(1);
                  }
#line 2848
                  j ++;
                }
#line 2848
                i ++;
              }
#line 2847
              dir ++;
            }
#line 2856
            if (destnode == 0) {
#line 2857
              i = node_index(x, y, z, t);
#line 2858
              dir = 0;
#line 2858
              while (dir <= 3) {
#line 2858
                (lattice + i)->link[dir] = lbuf[dir];
#line 2858
                dir ++;
              }
            } else {
#line 2861
              send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), destnode);
            }
          } else
#line 2867
          if (this_node == destnode) {
#line 2868
            get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
#line 2869
            i = node_index(x, y, z, t);
#line 2870
            dir = 0;
#line 2870
            while (dir <= 3) {
#line 2870
              (lattice + i)->link[dir] = lbuf[dir];
#line 2870
              dir ++;
            }
          }
#line 2842
          x ++;
        }
#line 2842
        y ++;
      }
#line 2842
      z ++;
    }
#line 2842
    t ++;
  }
#line 2875
  g_sync();
#line 2876
  if (this_node == 0) {
#line 2877
    printf((char const   * __restrict  )"Restored gauge configuration from ascii file  %s\n",
           filename);
#line 2879
    printf((char const   * __restrict  )"Time stamp %s\n", gh->time_stamp);
#line 2880
    fclose(fp);
#line 2881
    gf___0->fp = (FILE *)((void *)0);
#line 2882
    fflush(stdout);
  }
#line 2885
  return (gf___0);
}
}
#line 2892 "io_lat4.c"
gauge_file *save_ascii(char *filename ) 
{ 
  FILE *fp ;
  int currentnode ;
  int newnode ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int t ;
  int dir ;
  su3_matrix lbuf[4] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2901
  gf___0 = setup_output_gauge_file();
#line 2902
  gh = gf___0->header;
#line 2905
  if (this_node == 0) {
#line 2907
    fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
#line 2908
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 2909
      tmp = __errno_location();
#line 2909
      printf((char const   * __restrict  )"Can\'t open file %s, error %d\n", filename,
             *tmp);
#line 2909
      terminate(1);
    }
#line 2912
    gf___0->fp = fp;
#line 2913
    gf___0->parallel = 0;
#line 2914
    gf___0->filename = filename;
#line 2915
    gf___0->byterevflag = 0;
#line 2917
    tmp___0 = fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d\n",
                      20103);
#line 2917
    if (tmp___0 == 0) {
#line 2918
      printf((char const   * __restrict  )"Error in writing version number\n");
#line 2918
      terminate(1);
    }
#line 2920
    tmp___1 = fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\"%s\"\n",
                      gh->time_stamp);
#line 2920
    if (tmp___1 == 0) {
#line 2921
      printf((char const   * __restrict  )"Error in writing time stamp\n");
#line 2921
      terminate(1);
    }
#line 2924
    tmp___2 = fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d\t%d\t%d\t%d\n",
                      nx, ny, nz, nt);
#line 2924
    if (tmp___2 == 0) {
#line 2925
      printf((char const   * __restrict  )"Error in writing dimensions\n");
#line 2925
      terminate(1);
    }
#line 2928
    write_gauge_info_file(gf___0);
  }
#line 2933
  g_sync();
#line 2934
  currentnode = 0;
#line 2936
  t = 0;
#line 2936
  while (t < nt) {
#line 2936
    z = 0;
#line 2936
    while (z < nz) {
#line 2936
      y = 0;
#line 2936
      while (y < ny) {
#line 2936
        x = 0;
#line 2936
        while (x < nx) {
#line 2937
          newnode = node_number(x, y, z, t);
#line 2938
          if (newnode != currentnode) {
#line 2941
            if (this_node == 0) {
#line 2941
              if (newnode != 0) {
#line 2941
                send_field((char *)(lbuf), 4, newnode);
              }
            }
#line 2942
            if (this_node == newnode) {
#line 2942
              if (newnode != 0) {
#line 2942
                get_field((char *)(lbuf), 4);
              }
            }
#line 2943
            currentnode = newnode;
          }
#line 2946
          if (this_node == 0) {
#line 2947
            if (currentnode == 0) {
#line 2948
              i = node_index(x, y, z, t);
#line 2949
              dir = 0;
#line 2949
              while (dir <= 3) {
#line 2949
                lbuf[dir] = (lattice + i)->link[dir];
#line 2949
                dir ++;
              }
            } else {
#line 2952
              get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
            }
#line 2954
            dir = 0;
#line 2954
            while (dir <= 3) {
#line 2955
              i = 0;
#line 2955
              while (i < 3) {
#line 2955
                j = 0;
#line 2955
                while (j < 3) {
#line 2956
                  tmp___3 = fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.7e\t%.7e\n",
                                    lbuf[dir].e[i][j].real, lbuf[dir].e[i][j].imag);
#line 2956
                  if (tmp___3 == -1) {
#line 2958
                    printf((char const   * __restrict  )"Write error in save_ascii\n");
#line 2958
                    terminate(1);
                  }
#line 2955
                  j ++;
                }
#line 2955
                i ++;
              }
#line 2954
              dir ++;
            }
          } else
#line 2964
          if (this_node == currentnode) {
#line 2965
            i = node_index(x, y, z, t);
#line 2966
            dir = 0;
#line 2966
            while (dir <= 3) {
#line 2966
              lbuf[dir] = (lattice + i)->link[dir];
#line 2966
              dir ++;
            }
#line 2967
            send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), 0);
          }
#line 2936
          x ++;
        }
#line 2936
        y ++;
      }
#line 2936
      z ++;
    }
#line 2936
    t ++;
  }
#line 2971
  g_sync();
#line 2972
  if (this_node == 0) {
#line 2973
    fflush(fp);
#line 2974
    printf((char const   * __restrict  )"Saved gauge configuration to ascii file %s\n",
           gf___0->filename);
#line 2976
    printf((char const   * __restrict  )"Time stamp %s\n", gh->time_stamp);
#line 2977
    fclose(fp);
#line 2978
    fflush(stdout);
  }
#line 2980
  return (gf___0);
}
}
#line 2988 "io_lat4.c"
gauge_file *restore_serial(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
#line 2992
  gf___0 = r_serial_i(filename);
#line 2993
  if ((gf___0->header)->magic_number == 1111836489) {
#line 2994
    r_serial_arch(gf___0);
  } else {
#line 2996
    r_serial(gf___0);
  }
#line 2998
  r_serial_f(gf___0);
#line 3000
  return (gf___0);
}
}
#line 3008 "io_lat4.c"
gauge_file *restore_parallel(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
#line 3012
  gf___0 = r_parallel_i(filename);
#line 3013
  r_parallel(gf___0);
#line 3014
  r_parallel_f(gf___0);
#line 3016
  return (gf___0);
}
}
#line 3024 "io_lat4.c"
gauge_file *save_serial(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
#line 3028
  gf___0 = w_serial_i(filename);
#line 3029
  w_serial(gf___0);
#line 3030
  w_serial_f(gf___0);
#line 3032
  return (gf___0);
}
}
#line 3040 "io_lat4.c"
gauge_file *save_parallel(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
#line 3044
  gf___0 = w_parallel_i(filename);
#line 3045
  w_parallel(gf___0);
#line 3046
  w_parallel_f(gf___0);
#line 3048
  return (gf___0);
}
}
#line 3061 "io_lat4.c"
gauge_file *save_checkpoint(char *filename ) 
{ 
  gauge_file *gf___0 ;

  {
#line 3065
  gf___0 = w_checkpoint_i(filename);
#line 3066
  w_checkpoint(gf___0);
#line 3067
  w_parallel_f(gf___0);
#line 3069
  return (gf___0);
}
}
#line 3074 "io_lat4.c"
gauge_file *save_serial_archive(char *filename ) 
{ 
  int currentnode ;
  int newnode ;
  int i ;
  int j ;
  int x ;
  int y ;
  int z ;
  int dir ;
  su3_matrix lbuf[4] ;
  gauge_file *gf___0 ;
  gauge_header *gh ;
  FILE *outfile ;
  site *s ;
  u_int32type chksum ;
  u_int32type utmp ;
  u_int32type *p32 ;
  char sums[30] ;
  OUTPUT_TYPE *uout ;
  int big_end_p ;
  double ssplaq ;
  double stplaq ;
  double avgtrace ;
  double avgplaq ;
  double tmpflt ;
  double trace ;
  int mu ;
  int a ;
  int b ;
  int vol3 ;
  int tslice ;
  complex tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 3095
  big_end_p = big_endian();
#line 3099
  gf___0 = setup_output_gauge_file();
#line 3100
  gh = gf___0->header;
#line 3103
  d_plaquette(& ssplaq, & stplaq);
#line 3104
  avgplaq = (ssplaq + stplaq) / 6.0;
#line 3105
  trace = 0.0;
#line 3106
  chksum = (u_int32type )0;
#line 3107
  i = 0;
#line 3107
  s = lattice;
#line 3107
  while (i < sites_on_node) {
#line 3108
    mu = 0;
#line 3108
    while (mu < 4) {
#line 3109
      tmp = trace_su3(& s->link[mu]);
#line 3109
      trace += tmp.real;
#line 3110
      a = 0;
#line 3110
      while (a < 2) {
#line 3110
        b = 0;
#line 3110
        while (b < 3) {
#line 3111
          tmpflt = s->link[mu].e[a][b].real;
#line 3112
          p32 = (u_int32type *)(& tmpflt);
#line 3113
          chksum += *p32;
#line 3114
          tmpflt = s->link[mu].e[a][b].imag;
#line 3115
          p32 = (u_int32type *)(& tmpflt);
#line 3116
          chksum += *p32;
#line 3110
          b ++;
        }
#line 3110
        a ++;
      }
#line 3108
      mu ++;
    }
#line 3107
    i ++;
#line 3107
    s ++;
  }
#line 3120
  g_doublesum(& trace);
#line 3121
  avgtrace = trace / (double )(volume * 12);
#line 3124
  j = 1;
#line 3124
  while (1) {
#line 3124
    tmp___0 = numnodes();
#line 3124
    if (! (j < tmp___0)) {
#line 3124
      break;
    }
#line 3125
    if (this_node == 0) {
#line 3125
      send_field((char *)(lbuf), 4, j);
    }
#line 3126
    if (this_node == j) {
#line 3127
      get_field((char *)(lbuf), 4);
#line 3128
      send_integer(0, (int *)(& chksum));
    }
#line 3130
    if (this_node == 0) {
#line 3131
      receive_integer((int *)(& utmp));
#line 3132
      chksum += utmp;
    }
#line 3124
    j ++;
  }
#line 3137
  if (this_node == 0) {
#line 3139
    printf((char const   * __restrict  )"trace = %f\n", avgtrace);
#line 3140
    printf((char const   * __restrict  )"chksum_x = %x\n", chksum);
#line 3141
    printf((char const   * __restrict  )"chksum_u = %12u\n", chksum);
#line 3142
    printf((char const   * __restrict  )"plaquette = %f\n", avgplaq);
#line 3144
    printf((char const   * __restrict  )"Writing archive format lattice to %s\n",
           filename);
#line 3146
    outfile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
#line 3147
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
#line 3148
      printf((char const   * __restrict  )"error opening output file: %s\n", filename);
#line 3149
      terminate(1);
    }
#line 3152
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"BEGIN_HEADER\n");
#line 3153
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"DATATYPE = 4D_SU3_GAUGE\n");
#line 3154
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"DIMENSION_1 = %d\n",
            nx);
#line 3155
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"DIMENSION_2 = %d\n",
            ny);
#line 3156
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"DIMENSION_3 = %d\n",
            nz);
#line 3157
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"DIMENSION_4 = %d\n",
            nt);
#line 3158
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"CHECKSUM = %x\n",
            chksum);
#line 3159
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"LINK_TRACE = %.10f\n",
            avgtrace);
#line 3160
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"PLAQUETTE = %.10f\n",
            avgplaq);
#line 3161
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"ENSEMBLE_ID = %s\n",
            ensemble_id);
#line 3162
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"SEQUENCE_NUMBER = %d\n",
            sequence_number);
#line 3164
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"MILC_INFO = -------BEGIN-------\n");
#line 3165
    write_gauge_info_item(outfile, (char *)"time_stamp", (char *)"\"%s\"", gh->time_stamp,
                          0, 0);
#line 3166
    sprintf((char * __restrict  )(sums), (char const   * __restrict  )"%x %x", gf___0->check.sum29,
            gf___0->check.sum31);
#line 3167
    write_gauge_info_item(outfile, (char *)"checksums", (char *)"\"%s\"", sums, 0,
                          0);
#line 3168
    write_gauge_info_item(outfile, (char *)"nx", (char *)"%d", (char *)(& nx), 0,
                          0);
#line 3169
    write_gauge_info_item(outfile, (char *)"ny", (char *)"%d", (char *)(& ny), 0,
                          0);
#line 3170
    write_gauge_info_item(outfile, (char *)"nz", (char *)"%d", (char *)(& nz), 0,
                          0);
#line 3171
    write_gauge_info_item(outfile, (char *)"nt", (char *)"%d", (char *)(& nt), 0,
                          0);
#line 3172
    write_appl_gauge_info(outfile);
#line 3173
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"MILC_INFO = --------END--------\n");
#line 3174
    fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"END_HEADER\n");
#line 3176
    vol3 = (nx * ny) * nz;
#line 3177
//AD    tmp___1 = calloc((size_t )(48 * vol3), sizeof(OUTPUT_TYPE ));
#line 3177
//AD    uout = (OUTPUT_TYPE *)tmp___1;
    uout = (OUTPUT_TYPE *)calloc((size_t )(48 * vol3), sizeof(OUTPUT_TYPE )); //AD
#line 3178
    if ((unsigned long )uout == (unsigned long )((void *)0)) {
#line 3179
      printf((char const   * __restrict  )"can\'t malloc uout timeslice\n");
#line 3179
      terminate(1);
    }
  }
#line 3185
  g_sync();
#line 3186
  currentnode = 0;
#line 3188
  tslice = 0;
#line 3188
  while (tslice < nt) {
#line 3189
    j = 0;
#line 3190
    z = 0;
#line 3190
    while (z < nz) {
#line 3190
      y = 0;
#line 3190
      while (y < ny) {
#line 3190
        x = 0;
#line 3190
        while (x < nx) {
#line 3191
          newnode = node_number(x, y, z, tslice);
#line 3192
          if (newnode != currentnode) {
#line 3194
            if (this_node == 0) {
#line 3194
              if (newnode != 0) {
#line 3194
                send_field((char *)(lbuf), 4, newnode);
              }
            }
#line 3195
            if (this_node == newnode) {
#line 3195
              if (newnode != 0) {
#line 3195
                get_field((char *)(lbuf), 4);
              }
            }
#line 3196
            currentnode = newnode;
          }
#line 3199
          if (this_node == 0) {
#line 3200
            if (currentnode == 0) {
#line 3201
              tmp___2 = node_index(x, y, z, tslice);
#line 3201
              s = lattice + tmp___2;
#line 3202
              mu = 0;
#line 3202
              while (mu < 4) {
#line 3203
                a = 0;
#line 3203
                while (a < 2) {
#line 3204
                  b = 0;
#line 3204
                  while (b < 3) {
#line 3205
                    *(uout + ((2 * (b + 3 * a) + 12 * mu) + 48 * j)) = s->link[mu].e[a][b].real;
#line 3207
                    *(uout + (((1 + 2 * (b + 3 * a)) + 12 * mu) + 48 * j)) = s->link[mu].e[a][b].imag;
#line 3204
                    b ++;
                  }
#line 3203
                  a ++;
                }
#line 3202
                mu ++;
              }
            } else {
#line 3214
              get_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )));
#line 3215
              mu = 0;
#line 3215
              while (mu < 4) {
#line 3216
                a = 0;
#line 3216
                while (a < 2) {
#line 3217
                  b = 0;
#line 3217
                  while (b < 3) {
#line 3218
                    *(uout + ((2 * (b + 3 * a) + 12 * mu) + 48 * j)) = lbuf[mu].e[a][b].real;
#line 3220
                    *(uout + (((1 + 2 * (b + 3 * a)) + 12 * mu) + 48 * j)) = lbuf[mu].e[a][b].imag;
#line 3217
                    b ++;
                  }
#line 3216
                  a ++;
                }
#line 3215
                mu ++;
              }
            }
#line 3226
            j ++;
          } else
#line 3229
          if (this_node == currentnode) {
#line 3230
            i = node_index(x, y, z, tslice);
#line 3231
            dir = 0;
#line 3231
            while (dir <= 3) {
#line 3231
              lbuf[dir] = (lattice + i)->link[dir];
#line 3231
              dir ++;
            }
#line 3232
            send_field((char *)(lbuf), (int )(4UL * sizeof(su3_matrix )), 0);
          }
#line 3190
          x ++;
        }
#line 3190
        y ++;
      }
#line 3190
      z ++;
    }
#line 3237
    if (this_node == 0) {
#line 3238
      if (! big_end_p) {
#line 3238
        byterevn((int32type *)uout, 48 * vol3);
      }
#line 3239
      tmp___3 = fwrite((void const   * __restrict  )uout, (unsigned long )(48 * vol3) * sizeof(OUTPUT_TYPE ),
                       (size_t )1, (FILE * __restrict  )outfile);
#line 3239
      if (tmp___3 != 1UL) {
#line 3240
        printf((char const   * __restrict  )"fwrite bombed...\n");
      }
#line 3241
      fflush(outfile);
    }
#line 3188
    tslice ++;
  }
#line 3245
  if (this_node == 0) {
#line 3246
    fclose(outfile);
#line 3247
    printf((char const   * __restrict  )"Wrote archive gauge file %s\n", filename);
#line 3248
    free((void *)uout);
  }
#line 3251
  g_sync();
#line 3252
  return (gf___0);
}
}
#line 3256 "io_lat4.c"
gauge_file *save_parallel_archive(char *filename ) 
{ 


  {
#line 3258
  printf((char const   * __restrict  )"Parallel archive saves are not implemented, yet\n");
#line 3259
  return ((gauge_file *)((void *)0));
}
}
#line 1 "make_lattice.o"
#pragma merger("0","/tmp/cil-dTE4VjJK.i","")
#line 14 "make_lattice.c"
void make_lattice(void) 
{ 
  register int i ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 20
//AD  tmp = calloc((size_t )sites_on_node, sizeof(site ));
#line 20
//AD  lattice = (site *)tmp;
  lattice = (site *)calloc((size_t )sites_on_node, sizeof(site )); //AD
#line 21
  if ((unsigned long )lattice == (unsigned long )((void *)0)) {
#line 22
    printf((char const   * __restrict  )"NODE %d: no room for lattice\n", this_node);
#line 23
    terminate(1);
  }
#line 27
  i = 0;
#line 27
  while (i < 16) {
#line 28
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(char *));
#line 28
//AD    gen_pt[i] = (char **)tmp___0;
    gen_pt[i] = (char **)calloc((size_t )sites_on_node, sizeof(char *)); //AD
#line 29
    if ((unsigned long )gen_pt[i] == (unsigned long )((void *)0)) {
#line 30
      printf((char const   * __restrict  )"NODE %d: no room for pointer vector\n",
             this_node);
#line 31
      terminate(1);
    }
#line 27
    i ++;
  }
#line 35
  t = 0;
#line 35
  while (t < nt) {
#line 35
    z = 0;
#line 35
    while (z < nz) {
#line 35
      y = 0;
#line 35
      while (y < ny) {
#line 35
        x = 0;
#line 35
        while (x < nx) {
#line 36
          tmp___1 = node_number(x, y, z, t);
#line 36
          tmp___2 = mynode();
#line 36
          if (tmp___1 == tmp___2) {
#line 37
            i = node_index(x, y, z, t);
#line 38
            (lattice + i)->x = (short )x;
#line 38
            (lattice + i)->y = (short )y;
#line 38
            (lattice + i)->z = (short )z;
#line 38
            (lattice + i)->t = (short )t;
#line 39
            (lattice + i)->index = x + nx * (y + ny * (z + nz * t));
#line 40
            if ((((x + y) + z) + t) % 2 == 0) {
#line 40
              (lattice + i)->parity = (char)2;
            } else {
#line 41
              (lattice + i)->parity = (char)1;
            }
#line 43
            initialize_prn(& (lattice + i)->site_prn, iseed, (lattice + i)->index);
          }
#line 35
          x ++;
        }
#line 35
        y ++;
      }
#line 35
      z ++;
    }
#line 35
    t ++;
  }
#line 50
//AD  tmp___3 = calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix ));
#line 50
//AD  t_longlink = (su3_matrix *)tmp___3;
  t_longlink = (su3_matrix *)calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix )); //AD
#line 51
  if ((unsigned long )t_longlink == (unsigned long )((void *)0)) {
#line 52
    printf((char const   * __restrict  )"NODE %d: no room for t_longlink\n", this_node);
#line 53
    terminate(1);
  }
#line 55
//AD  tmp___4 = calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix ));
#line 55
//AD  t_fatlink = (su3_matrix *)tmp___4;
  t_fatlink = (su3_matrix *)calloc((size_t )(sites_on_node * 4), sizeof(su3_matrix ));
#line 56
  if ((unsigned long )t_fatlink == (unsigned long )((void *)0)) {
#line 57
    printf((char const   * __restrict  )"NODE %d: no room for t_fatlink\n", this_node);
#line 58
    terminate(1);
  }
#line 61
  return;
}
}
#line 1 "path_product.o"
#pragma merger("0","/tmp/cil-t0brrGiy.i","")
#line 359 "./su3.h"
void mult_su3_na(su3_matrix *a , su3_matrix *b , su3_matrix *c ) ;
#line 378
void su3_adjoint(su3_matrix *a , su3_matrix *b ) ;
#line 64 "./generic.h"
void path_product(int *dir , int length ) ;
#line 18 "path_product.c"
void path_product(int *dir , int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  su3_matrix *tempmat2t ;
  su3_matrix *tempmat3t ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;
  register int loopend___2 ;
  register int loopend___3 ;
  register int loopend___4 ;
  register int loopend___5 ;
  register int loopend___6 ;
  register int loopend___7 ;
  register int loopend___8 ;
  register int loopend___9 ;
  register int loopend___10 ;
  register int loopend___11 ;

  {
#line 35
//AD  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 35
//AD  tempmat3t = (su3_matrix *)tmp;
  tempmat3t = (su3_matrix *)calloc((size_t )sites_on_node, sizeof(su3_matrix )); //AD
#line 36
//AD  tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 36
//AD  tempmat2t = (su3_matrix *)tmp___0;
  tempmat2t = (su3_matrix *)calloc((size_t )sites_on_node, sizeof(su3_matrix )); //AD
#line 39
  if (*(dir + 0) <= 3) {
#line 40
    mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[*(dir + 0)]) - (char *)(lattice + 0)),
                         (int )sizeof(su3_matrix ), 7 - *(dir + 0), 3, gen_pt[0]);
  } else {
#line 44
    loopend = sites_on_node;
#line 44
    i = 0;
#line 44
    s = lattice;
#line 44
    while (i < loopend) {
#line 45
      su3_adjoint(& s->link[7 - *(dir + 0)], & s->tempmat1);
#line 44
      i ++;
#line 44
      s ++;
    }
  }
#line 49
  j = 1;
#line 49
  while (j < length) {
#line 50
    if (j % 2 == 1) {
#line 51
      if (*(dir + j) <= 3) {
#line 52
        if (*(dir + (j - 1)) <= 3) {
#line 53
          wait_gather(mtag0);
#line 54
          loopend___0 = sites_on_node;
#line 54
          i = 0;
#line 54
          s = lattice;
#line 54
          while (i < loopend___0) {
#line 55
            mult_su3_nn((su3_matrix *)*(gen_pt[0] + i), & s->link[*(dir + j)], tempmat2t + i);
#line 54
            i ++;
#line 54
            s ++;
          }
#line 58
          cleanup_gather(mtag0);
        } else {
#line 61
          loopend___1 = sites_on_node;
#line 61
          i = 0;
#line 61
          s = lattice;
#line 61
          while (i < loopend___1) {
#line 62
            mult_su3_nn(& s->tempmat1, & s->link[*(dir + j)], tempmat2t + i);
#line 61
            i ++;
#line 61
            s ++;
          }
        }
#line 66
        mtag0 = start_gather_from_temp((void *)tempmat2t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      } else {
#line 71
        if (*(dir + (j - 1)) <= 3) {
#line 72
          wait_gather(mtag0);
#line 73
          loopend___2 = sites_on_node;
#line 73
          i = 0;
#line 73
          s = lattice;
#line 73
          while (i < loopend___2) {
#line 74
            su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
#line 73
            i ++;
#line 73
            s ++;
          }
#line 76
          cleanup_gather(mtag0);
#line 77
          mtag0 = start_gather_from_temp((void *)tempmat3t, (int )sizeof(su3_matrix ),
                                         7 - *(dir + j), 3, gen_pt[0]);
        } else {
#line 81
          mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), 7 - *(dir + j), 3, gen_pt[0]);
        }
#line 84
        wait_gather(mtag0);
#line 85
        loopend___3 = sites_on_node;
#line 85
        i = 0;
#line 85
        s = lattice;
#line 85
        while (i < loopend___3) {
#line 86
          mult_su3_na((su3_matrix *)*(gen_pt[0] + i), & s->link[7 - *(dir + j)], tempmat2t + i);
#line 85
          i ++;
#line 85
          s ++;
        }
#line 89
        cleanup_gather(mtag0);
      }
    } else
#line 94
    if (*(dir + j) <= 3) {
#line 95
      if (*(dir + (j - 1)) <= 3) {
#line 96
        wait_gather(mtag0);
#line 97
        loopend___4 = sites_on_node;
#line 97
        i = 0;
#line 97
        s = lattice;
#line 97
        while (i < loopend___4) {
#line 98
          mult_su3_nn((su3_matrix *)*(gen_pt[0] + i), & s->link[*(dir + j)], & s->tempmat1);
#line 97
          i ++;
#line 97
          s ++;
        }
#line 101
        cleanup_gather(mtag0);
      } else {
#line 104
        loopend___5 = sites_on_node;
#line 104
        i = 0;
#line 104
        s = lattice;
#line 104
        while (i < loopend___5) {
#line 105
          mult_su3_nn(tempmat2t + i, & s->link[*(dir + j)], & s->tempmat1);
#line 104
          i ++;
#line 104
          s ++;
        }
      }
#line 109
      mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                           (int )sizeof(su3_matrix ), 7 - *(dir + j), 3, gen_pt[0]);
    } else {
#line 114
      if (*(dir + (j - 1)) <= 3) {
#line 115
        wait_gather(mtag0);
#line 116
        loopend___6 = sites_on_node;
#line 116
        i = 0;
#line 116
        s = lattice;
#line 116
        while (i < loopend___6) {
#line 117
          su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
#line 116
          i ++;
#line 116
          s ++;
        }
#line 119
        cleanup_gather(mtag0);
#line 120
        mtag0 = start_gather_from_temp((void *)tempmat3t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      } else {
#line 124
        mtag0 = start_gather_from_temp((void *)tempmat2t, (int )sizeof(su3_matrix ),
                                       7 - *(dir + j), 3, gen_pt[0]);
      }
#line 127
      wait_gather(mtag0);
#line 128
      loopend___7 = sites_on_node;
#line 128
      i = 0;
#line 128
      s = lattice;
#line 128
      while (i < loopend___7) {
#line 129
        mult_su3_na((su3_matrix *)*(gen_pt[0] + i), & s->link[7 - *(dir + j)], & s->tempmat1);
#line 128
        i ++;
#line 128
        s ++;
      }
#line 132
      cleanup_gather(mtag0);
    }
#line 49
    j ++;
  }
#line 139
  if (length % 2 == 0) {
#line 140
    if (*(dir + (length - 1)) <= 3) {
#line 141
      wait_gather(mtag0);
#line 142
      loopend___8 = sites_on_node;
#line 142
      i = 0;
#line 142
      s = lattice;
#line 142
      while (i < loopend___8) {
#line 143
        su3mat_copy((su3_matrix *)*(gen_pt[0] + i), & s->tempmat1);
#line 142
        i ++;
#line 142
        s ++;
      }
#line 145
      cleanup_gather(mtag0);
    } else {
#line 148
      loopend___9 = sites_on_node;
#line 148
      i = 0;
#line 148
      s = lattice;
#line 148
      while (i < loopend___9) {
#line 149
        su3mat_copy(tempmat2t + i, & s->tempmat1);
#line 148
        i ++;
#line 148
        s ++;
      }
    }
  } else
#line 154
  if (*(dir + (length - 1)) <= 3) {
#line 155
    wait_gather(mtag0);
#line 156
    loopend___10 = sites_on_node;
#line 156
    i = 0;
#line 156
    s = lattice;
#line 156
    while (i < loopend___10) {
#line 157
      su3mat_copy((su3_matrix *)*(gen_pt[0] + i), tempmat3t + i);
#line 156
      i ++;
#line 156
      s ++;
    }
#line 159
    cleanup_gather(mtag0);
#line 160
    loopend___11 = sites_on_node;
#line 160
    i = 0;
#line 160
    s = lattice;
#line 160
    while (i < loopend___11) {
#line 161
      su3mat_copy(tempmat3t + i, & s->tempmat1);
#line 160
      i ++;
#line 160
      s ++;
    }
  }
#line 167
  free((void *)tempmat3t);
#line 168
  free((void *)tempmat2t);
#line 169
  return;
}
}
#line 1 "ploop3.o"
#pragma merger("0","/tmp/cil-MeN82JKg.i","")
#line 141 "./comdefs.h"
msg_tag *start_general_gather(field_offset field , int size , int *displacement ,
                              int parity , char **dest ) ;
#line 150
void wait_general_gather(msg_tag *mbuf ) ;
#line 151
void cleanup_general_gather(msg_tag *mbuf ) ;
#line 177
void g_complexsum(complex *cpt ) ;
#line 71 "./generic.h"
complex ploop(void) ;
#line 18 "ploop3.c"
complex ploop(void) 
{ 
  register int i ;
  register int t ;
  register site *st ;
  msg_tag *tag ;
  complex sum ;
  complex plp ;
  su3_matrix tmat ;
  int d[4] ;

  {
#line 27
  sum = cmplx(0.0, 0.0);
#line 28
  d[2] = 0;
#line 28
  d[1] = d[2];
#line 28
  d[0] = d[1];
#line 32
  tag = start_gather((field_offset )((char *)(& (lattice + 0)->link[3]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_matrix ), 3, 2, gen_pt[0]);
#line 34
  wait_gather(tag);
#line 35
  i = 0;
#line 35
  st = lattice;
#line 35
  while (i < even_sites_on_node) {
#line 36
    mult_su3_nn(& st->link[3], (su3_matrix *)*(gen_pt[0] + i), & st->tempmat1);
#line 35
    i ++;
#line 35
    st ++;
  }
#line 39
  cleanup_gather(tag);
#line 41
  t = 2;
#line 41
  while (t < nt) {
#line 42
    d[3] = t;
#line 43
    tag = start_general_gather((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                               (int )sizeof(su3_matrix ), d, 2, gen_pt[0]);
#line 45
    wait_general_gather(tag);
#line 46
    i = 0;
#line 46
    st = lattice;
#line 46
    while (i < even_sites_on_node) {
#line 47
      if ((int )st->t > 1) {
#line 47
        goto __Cont;
      }
#line 48
      mult_su3_nn(& st->tempmat1, (su3_matrix *)*(gen_pt[0] + i), & tmat);
#line 49
      (lattice + i)->tempmat1 = tmat;
      __Cont: /* CIL Label */ 
#line 46
      i ++;
#line 46
      st ++;
    }
#line 54
    cleanup_general_gather(tag);
#line 41
    t += 2;
  }
#line 56
  i = 0;
#line 56
  st = lattice;
#line 56
  while (i < even_sites_on_node) {
#line 57
    if ((int )st->t > 1) {
#line 57
      goto __Cont___0;
    }
#line 58
    plp = trace_su3(& st->tempmat1);
#line 60
    sum.real += plp.real;
#line 60
    sum.imag += plp.imag;
    __Cont___0: /* CIL Label */ 
#line 56
    i ++;
#line 56
    st ++;
  }
#line 68
  g_complexsum(& sum);
#line 69
  plp.real = sum.real / (double )((nx * ny) * nz);
#line 70
  plp.imag = sum.imag / (double )((nx * ny) * nz);
#line 71
  return (plp);
}
}
#line 1 "ranmom.o"
#pragma merger("0","/tmp/cil-qzsIZ0g1.i","")
#line 380 "./su3.h"
void random_anti_hermitian(anti_hermitmat *mat_antihermit , double_prn *prn_pt ) ;
#line 9 "ranmom.c"
void ranmom(void) 
{ 
  register int i ;
  register int dir ;
  register site *s ;

  {
#line 12
  i = 0;
#line 12
  s = lattice;
#line 12
  while (i < sites_on_node) {
#line 13
    dir = 0;
#line 13
    while (dir <= 3) {
#line 18
      random_anti_hermitian(& s->mom[dir], & s->site_prn);
#line 13
      dir ++;
    }
#line 12
    i ++;
#line 12
    s ++;
  }
#line 40
  return;
}
}
#line 1 "ranstuff.o"
#pragma merger("0","/tmp/cil-9LM6vII9.i","")
#line 15 "./random.h"
double myrand(double_prn *prn_pt ) ;
#line 20 "ranstuff.c"
void initialize_prn(double_prn *prn_pt , int seed , int index___0 ) 
{ 


  {
#line 22
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 23
  prn_pt->r0 = (unsigned long )((seed >> 8) & 16777215);
#line 24
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 25
  prn_pt->r1 = (unsigned long )((seed >> 8) & 16777215);
#line 26
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 27
  prn_pt->r2 = (unsigned long )((seed >> 8) & 16777215);
#line 28
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 29
  prn_pt->r3 = (unsigned long )((seed >> 8) & 16777215);
#line 30
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 31
  prn_pt->r4 = (unsigned long )((seed >> 8) & 16777215);
#line 32
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 33
  prn_pt->r5 = (unsigned long )((seed >> 8) & 16777215);
#line 34
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 35
  prn_pt->r6 = (unsigned long )((seed >> 8) & 16777215);
#line 36
  seed = (69607 + 8 * index___0) * seed + 12345;
#line 37
  prn_pt->ic_state = (unsigned long )seed;
#line 38
  prn_pt->multiplier = (unsigned long )(100005 + 8 * index___0);
#line 39
  prn_pt->addend = 12345UL;
#line 40
  prn_pt->scale = 1.0 / (double )16777216;
#line 41
  return;
}
}
#line 43 "ranstuff.c"
double myrand(double_prn *prn_pt ) 
{ 
  register int t ;
  register int s ;

  {
#line 46
  t = (int )((((prn_pt->r5 >> 7) | (prn_pt->r6 << 17)) ^ ((prn_pt->r4 >> 1) | (prn_pt->r5 << 23))) & 16777215UL);
#line 48
  prn_pt->r6 = prn_pt->r5;
#line 49
  prn_pt->r5 = prn_pt->r4;
#line 50
  prn_pt->r4 = prn_pt->r3;
#line 51
  prn_pt->r3 = prn_pt->r2;
#line 52
  prn_pt->r2 = prn_pt->r1;
#line 53
  prn_pt->r1 = prn_pt->r0;
#line 54
  prn_pt->r0 = (unsigned long )t;
#line 55
  s = (int )(prn_pt->ic_state * prn_pt->multiplier + prn_pt->addend);
#line 56
  prn_pt->ic_state = (unsigned long )s;
#line 57
  return (prn_pt->scale * (double )(t ^ ((s >> 8) & 16777215)));
}
}
#line 1 "reunitarize2.o"
#pragma merger("0","/tmp/cil-lniylRfo.i","")
#line 101 "./generic.h"
int reunit_su3(su3_matrix *c ) ;
#line 19 "reunitarize2.c"
double max_deviation  ;
#line 20 "reunitarize2.c"
double av_deviation  ;
#line 63 "reunitarize2.c"
int check_deviation(double deviation ) 
{ 


  {
#line 66
  if (max_deviation < deviation) {
#line 66
    max_deviation = deviation;
  }
#line 67
  av_deviation += deviation * deviation;
#line 69
  if (deviation > 0.0001) {
#line 70
    return (1);
  } else {
#line 72
    return (0);
  }
}
}
#line 75 "reunitarize2.c"
void reunit_report_problem_matrix(su3_matrix *mat , int i , int dir ) 
{ 
  int ii ;
  int jj ;
  union __anonunion_ifval_51___0 ifval ;
  int tmp ;

  {
#line 83
  tmp = mynode();
#line 83
  printf((char const   * __restrict  )"Unitarity problem on node %d, site %d, dir %d tolerance=%e\n",
         tmp, i, dir, 0.0001);
#line 85
  printf((char const   * __restrict  )"SU3 matrix:\n");
#line 86
  ii = 0;
#line 86
  while (ii <= 2) {
#line 87
    jj = 0;
#line 87
    while (jj <= 2) {
#line 88
      printf((char const   * __restrict  )"%f ", mat->e[ii][jj].real);
#line 89
      printf((char const   * __restrict  )"%f ", mat->e[ii][jj].imag);
#line 87
      jj ++;
    }
#line 91
    printf((char const   * __restrict  )"\n");
#line 86
    ii ++;
  }
#line 93
  printf((char const   * __restrict  )"repeat in hex:\n");
#line 94
  ii = 0;
#line 94
  while (ii <= 2) {
#line 95
    jj = 0;
#line 95
    while (jj <= 2) {
#line 96
      ifval.fval = mat->e[ii][jj].real;
#line 97
      printf((char const   * __restrict  )"%08x ", ifval.ival);
#line 98
      ifval.fval = mat->e[ii][jj].imag;
#line 99
      printf((char const   * __restrict  )"%08x ", ifval.ival);
#line 95
      jj ++;
    }
#line 101
    printf((char const   * __restrict  )"\n");
#line 94
    ii ++;
  }
#line 103
  printf((char const   * __restrict  )"  \n \n");
#line 104
  fflush(stdout);
#line 105
  return;
}
}
#line 107 "reunitarize2.c"
int reunit_su3(su3_matrix *c ) 
{ 
  register double bj0r ;
  register double bj0i ;
  register double bj1r ;
  register double bj1i ;
  register double bj2r ;
  register double bj2i ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double ar ;
  register double ai ;
  register double tr ;
  register double ti ;
  double deviation ;
  int errors ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;

  {
#line 115
  errors = 0;
#line 117
  ar = ((((c->e[0][0].real * c->e[0][0].real + c->e[0][0].imag * c->e[0][0].imag) + c->e[0][1].real * c->e[0][1].real) + c->e[0][1].imag * c->e[0][1].imag) + c->e[0][2].real * c->e[0][2].real) + c->e[0][2].imag * c->e[0][2].imag;
#line 124
  deviation = fabs(ar - 1.);
#line 125
  tmp = check_deviation(deviation);
#line 125
  errors += tmp;
#line 127
  tmp___0 = sqrt(ar);
#line 127
  ar = 1.0 / tmp___0;
#line 128
  c->e[0][0].real *= ar;
#line 129
  c->e[0][0].imag *= ar;
#line 130
  c->e[0][1].real *= ar;
#line 131
  c->e[0][1].imag *= ar;
#line 132
  c->e[0][2].real *= ar;
#line 133
  c->e[0][2].imag *= ar;
#line 136
  ar = ((((c->e[0][0].real * c->e[1][0].real + c->e[0][0].imag * c->e[1][0].imag) + c->e[0][1].real * c->e[1][1].real) + c->e[0][1].imag * c->e[1][1].imag) + c->e[0][2].real * c->e[1][2].real) + c->e[0][2].imag * c->e[1][2].imag;
#line 142
  ai = ((((c->e[0][0].real * c->e[1][0].imag - c->e[0][0].imag * c->e[1][0].real) + c->e[0][1].real * c->e[1][1].imag) - c->e[0][1].imag * c->e[1][1].real) + c->e[0][2].real * c->e[1][2].imag) - c->e[0][2].imag * c->e[1][2].real;
#line 149
  deviation = ar * ar + ai * ai;
#line 150
  tmp___1 = check_deviation(deviation);
#line 150
  errors += tmp___1;
#line 153
  c->e[1][0].real -= ar * c->e[0][0].real - ai * c->e[0][0].imag;
#line 154
  c->e[1][0].imag -= ar * c->e[0][0].imag + ai * c->e[0][0].real;
#line 155
  c->e[1][1].real -= ar * c->e[0][1].real - ai * c->e[0][1].imag;
#line 156
  c->e[1][1].imag -= ar * c->e[0][1].imag + ai * c->e[0][1].real;
#line 157
  c->e[1][2].real -= ar * c->e[0][2].real - ai * c->e[0][2].imag;
#line 158
  c->e[1][2].imag -= ar * c->e[0][2].imag + ai * c->e[0][2].real;
#line 161
  ar = ((((c->e[1][0].real * c->e[1][0].real + c->e[1][0].imag * c->e[1][0].imag) + c->e[1][1].real * c->e[1][1].real) + c->e[1][1].imag * c->e[1][1].imag) + c->e[1][2].real * c->e[1][2].real) + c->e[1][2].imag * c->e[1][2].imag;
#line 168
  deviation = fabs(ar - 1.);
#line 169
  tmp___2 = check_deviation(deviation);
#line 169
  errors += tmp___2;
#line 171
  tmp___3 = sqrt(ar);
#line 171
  ar = 1.0 / tmp___3;
#line 172
  c->e[1][0].real *= ar;
#line 173
  c->e[1][0].imag *= ar;
#line 174
  c->e[1][1].real *= ar;
#line 175
  c->e[1][1].imag *= ar;
#line 176
  c->e[1][2].real *= ar;
#line 177
  c->e[1][2].imag *= ar;
#line 180
  c0r = c->e[2][0].real;
#line 181
  c0i = c->e[2][0].imag;
#line 182
  c1r = c->e[2][1].real;
#line 183
  c1i = c->e[2][1].imag;
#line 184
  c2r = c->e[2][2].real;
#line 185
  c2i = c->e[2][2].imag;
#line 187
  bj0r = c->e[0][0].real;
#line 187
  bj0i = c->e[0][0].imag;
#line 187
  bj1r = c->e[0][1].real;
#line 187
  bj1i = c->e[0][1].imag;
#line 187
  bj2r = c->e[0][2].real;
#line 187
  bj2i = c->e[0][2].imag;
#line 187
  ar = c->e[1][2].real;
#line 187
  ai = c->e[1][2].imag;
#line 187
  tr = bj1r * ar - bj1i * ai;
#line 187
  ti = bj1r * ai + bj1i * ar;
#line 187
  ar = c->e[1][1].real;
#line 187
  ai = c->e[1][1].imag;
#line 187
  tr = (tr - bj2r * ar) + bj2i * ai;
#line 187
  ti = (ti - bj2r * ai) - bj2i * ar;
#line 187
  c->e[2][0].real = tr;
#line 187
  c->e[2][0].imag = - ti;
#line 187
  ar = c->e[1][0].real;
#line 187
  ai = c->e[1][0].imag;
#line 187
  tr = bj2r * ar - bj2i * ai;
#line 187
  ti = bj2r * ai + bj2i * ar;
#line 187
  ar = c->e[1][2].real;
#line 187
  ai = c->e[1][2].imag;
#line 187
  tr = (tr - bj0r * ar) + bj0i * ai;
#line 187
  ti = (ti - bj0r * ai) - bj0i * ar;
#line 187
  c->e[2][1].real = tr;
#line 187
  c->e[2][1].imag = - ti;
#line 187
  ar = c->e[1][1].real;
#line 187
  ai = c->e[1][1].imag;
#line 187
  tr = bj0r * ar - bj0i * ai;
#line 187
  ti = bj0r * ai + bj0i * ar;
#line 187
  ar = c->e[1][0].real;
#line 187
  ai = c->e[1][0].imag;
#line 187
  tr = (tr - bj1r * ar) + bj1i * ai;
#line 187
  ti = (ti - bj1r * ai) - bj1i * ar;
#line 187
  c->e[2][2].real = tr;
#line 187
  c->e[2][2].imag = - ti;
#line 190
  ar = (((((c0r - c->e[2][0].real) * (c0r - c->e[2][0].real) + (c0i - c->e[2][0].imag) * (c0i - c->e[2][0].imag)) + (c1r - c->e[2][1].real) * (c1r - c->e[2][1].real)) + (c1i - c->e[2][1].imag) * (c1i - c->e[2][1].imag)) + (c2r - c->e[2][2].real) * (c2r - c->e[2][2].real)) + (c2i - c->e[2][2].imag) * (c2i - c->e[2][2].imag);
#line 196
  deviation = ar;
#line 197
  tmp___4 = check_deviation(deviation);
#line 197
  errors += tmp___4;
#line 199
  return (errors);
}
}
#line 203 "reunitarize2.c"
void reunitarize(void) 
{ 
  register su3_matrix *mat ;
  register int i ;
  register int dir ;
  register site *s ;
  int errcount ;
  int errors ;
  int tmp ;

  {
#line 207
  errcount = 0;
#line 210
  max_deviation = 0.;
#line 211
  av_deviation = 0.;
#line 213
  i = 0;
#line 213
  s = lattice;
#line 213
  while (i < sites_on_node) {
#line 217
    dir = 0;
#line 217
    while (dir <= 3) {
#line 219
      mat = & s->link[dir];
#line 220
      errors = reunit_su3(mat);
#line 221
      errcount += errors;
#line 222
      if (errors) {
#line 222
        reunit_report_problem_matrix(mat, i, dir);
      }
#line 223
      if (errcount > 100) {
#line 225
        printf((char const   * __restrict  )"Unitarity error count exceeded.\n");
#line 226
        terminate(1);
      }
#line 217
      dir ++;
    }
#line 213
    i ++;
#line 213
    s ++;
  }
#line 235
  if (max_deviation > 0.0001) {
#line 237
    tmp = mynode();
#line 237
    printf((char const   * __restrict  )"reunitarize: Node %d unitarity problem, maximum deviation=%e\n",
           tmp, max_deviation);
#line 239
    errcount ++;
#line 240
    if (errcount > 100) {
#line 242
      printf((char const   * __restrict  )"Unitarity error count exceeded.\n");
#line 243
      terminate(1);
    }
  }
#line 247
  return;
}
}
#line 1 "gauge_stuff.o"
#pragma merger("0","/tmp/cil-yv88SoCn.i","")
#line 104 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 370 "./su3.h"
void scalar_mult_sub_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) ;
#line 176 "./comdefs.h"
void g_vecdoublesum(double *dpt , int ndoubles ) ;
#line 43 "./generic.h"
double imp_gauge_action(void) ;
#line 24 "gauge_stuff.c"
void printpath(int *path , int length ) ;
#line 31 "gauge_stuff.c"
char gauge_action_description[128]  ;
#line 32 "gauge_stuff.c"
int gauge_action_nloops  =    3;
#line 33 "gauge_stuff.c"
int gauge_action_nreps  =    1;
#line 34 "gauge_stuff.c"
int loop_length[3]  ;
#line 35 "gauge_stuff.c"
int loop_num[3]  ;
#line 38 "gauge_stuff.c"
int loop_ind[3][6]  ;
#line 41 "gauge_stuff.c"
int loop_table[3][16][6]  ;
#line 44 "gauge_stuff.c"
double loop_coeff[3][1]  ;
#line 47 "gauge_stuff.c"
int loop_char[16]  ;
#line 50 "gauge_stuff.c"
double loop_expect[3][1][16]  ;
#line 60
void char_num(int *dig , int *chr , int length ) ;
#line 11 "./gauge_action.h"
static int loop_ind___0[3][6]  = { {        0,        1,        7,        6, 
            -1,        -1}, 
   {        0,        0,        1,        7, 
            7,        6}, 
   {        0,        1,        2,        7, 
            6,        5}};
#line 16 "./gauge_action.h"
static int loop_length_in[3]  = {      4,      6,      6};
#line 54 "gauge_stuff.c"
void make_loop_table(void) 
{ 
  int perm[8] ;
  int pp[8] ;
  int ir[4] ;
  int length ;
  int iloop ;
  int i ;
  int j ;
  int chr ;
  int vec[6] ;
  int count ;
  int flag ;
  double tmp ;
  double tmp___0 ;

  {
#line 18 "./gauge_action.h"
  j = 0;
#line 18
  while (j < 3) {
#line 19
    loop_num[j] = 0;
#line 20
    loop_length[j] = loop_length_in[j];
#line 21
    i = 0;
#line 21
    while (i < 1) {
#line 22
      loop_coeff[j][i] = 0.0;
#line 21
      i ++;
    }
#line 18
    j ++;
  }
#line 27
  loop_coeff[0][0] = 1.0;
#line 28
  tmp = log(u0);
#line 28
  loop_coeff[1][0] = (- 1.00 / ((20.0 * u0) * u0)) * (1.00 - 0.6264 * tmp);
#line 29
  tmp___0 = log(u0);
#line 29
  loop_coeff[2][0] = ((1.00 / (u0 * u0)) * 0.04335) * tmp___0;
#line 30
  strcpy((char * __restrict  )(gauge_action_description), (char const   * __restrict  )"\"Symanzik 1x1 + 1x2 + 1x1x1 action\"");
#line 31
  if (this_node == 0) {
#line 31
    printf((char const   * __restrict  )"Symanzik 1x1 + 1x2 + 1x1x1 action\n");
  }
#line 67 "gauge_stuff.c"
  iloop = 0;
#line 67
  while (iloop < 3) {
#line 68
    length = loop_length[iloop];
#line 69
    count = 0;
#line 71
    perm[0] = 0;
#line 71
    while (perm[0] < 4) {
#line 72
      perm[1] = 0;
#line 72
      while (perm[1] < 4) {
#line 73
        perm[2] = 0;
#line 73
        while (perm[2] < 4) {
#line 74
          perm[3] = 0;
#line 74
          while (perm[3] < 4) {
#line 75
            if (perm[0] != perm[1]) {
#line 75
              if (perm[0] != perm[2]) {
#line 75
                if (perm[0] != perm[3]) {
#line 75
                  if (perm[1] != perm[2]) {
#line 75
                    if (perm[1] != perm[3]) {
#line 75
                      if (perm[2] != perm[3]) {
#line 79
                        ir[0] = 0;
#line 79
                        while (ir[0] < 2) {
#line 80
                          ir[1] = 0;
#line 80
                          while (ir[1] < 2) {
#line 81
                            ir[2] = 0;
#line 81
                            while (ir[2] < 2) {
#line 82
                              ir[3] = 0;
#line 82
                              while (ir[3] < 2) {
#line 83
                                j = 0;
#line 83
                                while (j < 4) {
#line 84
                                  pp[j] = perm[j];
#line 86
                                  if (ir[j] == 1) {
#line 86
                                    pp[j] = 7 - pp[j];
                                  }
#line 87
                                  pp[7 - j] = 7 - pp[j];
#line 83
                                  j ++;
                                }
#line 90
                                j = 0;
#line 90
                                while (j < length) {
#line 90
                                  vec[j] = pp[loop_ind___0[iloop][j]];
#line 90
                                  j ++;
                                }
#line 92
                                char_num(vec, & chr, length);
#line 93
                                flag = 0;
#line 95
                                j = 0;
#line 95
                                while (j < count) {
#line 95
                                  if (chr == loop_char[j]) {
#line 95
                                    flag = 1;
                                  }
#line 95
                                  j ++;
                                }
#line 96
                                if (flag == 0) {
#line 97
                                  loop_char[count] = chr;
#line 98
                                  j = 0;
#line 98
                                  while (j < length) {
#line 99
                                    loop_table[iloop][count][j] = vec[j];
#line 98
                                    j ++;
                                  }
#line 100
                                  count ++;
                                }
#line 103
                                if (count > 16) {
#line 104
                                  if (this_node == 0) {
#line 104
                                    printf((char const   * __restrict  )"OOPS: MAX_NUM too small\n");
                                  }
#line 105
                                  exit(0);
                                }
#line 107
                                loop_num[iloop] = count;
#line 82
                                (ir[3]) ++;
                              }
#line 81
                              (ir[2]) ++;
                            }
#line 80
                            (ir[1]) ++;
                          }
#line 79
                          (ir[0]) ++;
                        }
                      }
                    }
                  }
                }
              }
            }
#line 74
            (perm[3]) ++;
          }
#line 73
          (perm[2]) ++;
        }
#line 72
        (perm[1]) ++;
      }
#line 71
      (perm[0]) ++;
    }
#line 67
    iloop ++;
  }
#line 115
  if (this_node == 0) {
#line 115
    printf((char const   * __restrict  )"loop coefficients: nloop rep loop_coeff  multiplicity\n");
  }
#line 116
  i = 0;
#line 116
  while (i < 1) {
#line 116
    j = 0;
#line 116
    while (j < 3) {
#line 117
      if (this_node == 0) {
#line 117
        printf((char const   * __restrict  )"                    %d %d      %e     %d\n",
               j, i, loop_coeff[j][i], loop_num[j]);
      }
#line 116
      j ++;
    }
#line 116
    i ++;
  }
#line 121
  return;
}
}
#line 127 "gauge_stuff.c"
void char_num(int *dig , int *chr , int length ) 
{ 
  int j ;
  int bdig[6] ;
  int tenl ;
  int newv ;
  int old ;

  {
#line 133
  tenl = 1;
#line 134
  j = 0;
#line 134
  while (j < length - 1) {
#line 134
    tenl *= 10;
#line 134
    j ++;
  }
#line 136
  *chr = *(dig + (length - 1));
#line 137
  j = length - 2;
#line 137
  while (j >= 0) {
#line 137
    *chr = *chr * 10 + *(dig + j);
#line 137
    j --;
  }
#line 140
  old = *chr;
#line 141
  j = length - 1;
#line 141
  while (j >= 1) {
#line 142
    newv = old - tenl * *(dig + j);
#line 143
    newv = newv * 10 + *(dig + j);
#line 144
    if (newv < *chr) {
#line 144
      *chr = newv;
    }
#line 145
    old = newv;
#line 141
    j --;
  }
#line 148
  j = 0;
#line 148
  while (j < length) {
#line 148
    bdig[j] = 7 - *(dig + ((length - j) - 1));
#line 148
    j ++;
  }
#line 149
  old = bdig[length - 1];
#line 150
  j = length - 2;
#line 150
  while (j >= 0) {
#line 150
    old = old * 10 + bdig[j];
#line 150
    j --;
  }
#line 151
  if (old < *chr) {
#line 151
    *chr = old;
  }
#line 152
  j = length - 1;
#line 152
  while (j >= 1) {
#line 153
    newv = old - tenl * bdig[j];
#line 154
    newv = newv * 10 + bdig[j];
#line 155
    if (newv < *chr) {
#line 155
      *chr = newv;
    }
#line 156
    old = newv;
#line 152
    j --;
  }
#line 158
  return;
}
}
#line 160 "gauge_stuff.c"
double imp_gauge_action(void) 
{ 
  register int i ;
  int rep ;
  register site *s ;
  complex trace ;
  double g_action ;
  double action ;
  double act2 ;
  double total_action ;
  int length ;
  int ln ;
  int iloop ;

  {
#line 172
  g_action = 0.0;
#line 175
  iloop = 0;
#line 175
  while (iloop < 3) {
#line 176
    length = loop_length[iloop];
#line 178
    ln = 0;
#line 178
    while (ln < loop_num[iloop]) {
#line 180
      path_product(loop_table[iloop][ln], length);
#line 182
      i = 0;
#line 182
      s = lattice;
#line 182
      while (i < sites_on_node) {
#line 183
        trace = trace_su3(& s->tempmat1);
#line 184
        action = 3.0 - trace.real;
#line 186
        total_action = loop_coeff[iloop][0] * action;
#line 187
        act2 = action;
#line 188
        rep = 1;
#line 188
        while (rep < 1) {
#line 189
          act2 *= action;
#line 190
          total_action += loop_coeff[iloop][rep] * act2;
#line 188
          rep ++;
        }
#line 193
        g_action += total_action;
#line 182
        i ++;
#line 182
        s ++;
      }
#line 178
      ln ++;
    }
#line 175
    iloop ++;
  }
#line 199
  g_doublesum(& g_action);
#line 200
  return (g_action);
}
}
#line 205 "gauge_stuff.c"
void imp_gauge_force(double eps , field_offset mom_off ) 
{ 
  register int i ;
  register int dir ;
  register site *st ;
  su3_matrix tmat1 ;
  su3_matrix tmat2 ;
  register double eb3 ;
  register anti_hermitmat *momentum ;
  int j ;
  int k ;
  int dirs[6] ;
  int length ;
  int path_dir[6] ;
  int path_length ;
  int ln ;
  int iloop ;
  double new_term ;
  int ncount ;

  {
#line 227
  eb3 = (eps * beta) / 3.0;
#line 230
  dir = 0;
#line 230
  while (dir <= 3) {
#line 232
    i = 0;
#line 232
    st = lattice;
#line 232
    while (i < sites_on_node) {
#line 232
      j = 0;
#line 232
      while (j < 3) {
#line 232
        k = 0;
#line 232
        while (k < 3) {
#line 233
          st->staple.e[j][k] = cmplx(0.0, 0.0);
#line 232
          k ++;
        }
#line 232
        j ++;
      }
#line 232
      i ++;
#line 232
      st ++;
    }
#line 236
    ncount = 0;
#line 237
    iloop = 0;
#line 237
    while (iloop < 3) {
#line 238
      length = loop_length[iloop];
#line 239
      ln = 0;
#line 239
      while (ln < loop_num[iloop]) {
#line 243
        k = 0;
#line 243
        while (k < length) {
#line 244
          if (loop_table[iloop][ln][k] <= 3) {
#line 245
            dirs[k] = (dir + loop_table[iloop][ln][k]) % 4;
          } else {
#line 248
            dirs[k] = 7 - (dir + (7 - loop_table[iloop][ln][k])) % 4;
          }
#line 243
          k ++;
        }
#line 253
        path_length = length - 1;
#line 258
        k = 0;
#line 258
        while (k < length) {
#line 258
          if (dirs[k] == dir) {
#line 258
            goto _L;
          } else
#line 258
          if (dirs[k] == 7 - dir) {
            _L: /* CIL Label */ 
#line 259
            if (dirs[k] <= 3) {
#line 259
              j = 0;
#line 259
              while (j < path_length) {
#line 260
                path_dir[j] = dirs[((k + j) + 1) % length];
#line 259
                j ++;
              }
            }
#line 262
            if (dirs[k] > 3) {
#line 262
              j = 0;
#line 262
              while (j < path_length) {
#line 263
                path_dir[(path_length - 1) - j] = 7 - dirs[((k + j) + 1) % length];
#line 262
                j ++;
              }
            }
#line 267
            path_product(path_dir, path_length);
#line 274
            i = 0;
#line 274
            st = lattice;
#line 274
            while (i < sites_on_node) {
#line 275
              su3_adjoint(& st->tempmat1, & tmat1);
#line 277
              new_term = loop_coeff[iloop][0];
#line 293
              scalar_mult_add_su3_matrix(& st->staple, & tmat1, new_term, & st->staple);
#line 274
              i ++;
#line 274
              st ++;
            }
#line 298
            ncount ++;
          }
#line 258
          k ++;
        }
#line 239
        ln ++;
      }
#line 237
      iloop ++;
    }
#line 305
    i = 0;
#line 305
    st = lattice;
#line 305
    while (i < sites_on_node) {
#line 306
      mult_su3_na(& st->link[dir], & st->staple, & tmat1);
#line 307
      momentum = (anti_hermitmat *)((char *)st + mom_off);
#line 308
      uncompress_anti_hermitian(momentum + dir, & tmat2);
#line 309
      scalar_mult_sub_su3_matrix(& tmat2, & tmat1, eb3, & st->staple);
#line 311
      make_anti_hermitian(& st->staple, momentum + dir);
#line 305
      i ++;
#line 305
      st ++;
    }
#line 230
    dir ++;
  }
#line 318
  return;
}
}
#line 325 "gauge_stuff.c"
void g_measure(void) 
{ 
  double ss_plaquette ;
  double st_plaquette ;
  complex p_loop ;
  register int i ;
  register site *s ;
  complex trace ;
  double average[1] ;
  double action ;
  double act2 ;
  double total_action ;
  int length ;
  int ln ;
  int iloop ;
  int rep ;

  {
#line 337
  d_plaquette(& ss_plaquette, & st_plaquette);
#line 338
  if (this_node == 0) {
#line 338
    printf((char const   * __restrict  )"PLAQ:\t%f\t%f\n", ss_plaquette, st_plaquette);
  }
#line 340
  p_loop = ploop();
#line 341
  if (this_node == 0) {
#line 341
    printf((char const   * __restrict  )"P_LOOP:\t%e\t%e\n", p_loop.real, p_loop.imag);
  }
#line 344
  total_action = 0.0;
#line 345
  iloop = 0;
#line 345
  while (iloop < 3) {
#line 346
    length = loop_length[iloop];
#line 348
    ln = 0;
#line 348
    while (ln < loop_num[iloop]) {
#line 350
      path_product(loop_table[iloop][ln], length);
#line 352
      rep = 0;
#line 352
      while (rep < 1) {
#line 352
        average[rep] = 0.0;
#line 352
        rep ++;
      }
#line 353
      i = 0;
#line 353
      s = lattice;
#line 353
      while (i < sites_on_node) {
#line 354
        trace = trace_su3(& s->tempmat1);
#line 355
        average[0] += trace.real;
#line 356
        action = 3.0 - trace.real;
#line 357
        total_action += loop_coeff[iloop][0] * action;
#line 359
        act2 = action;
#line 360
        rep = 1;
#line 360
        while (rep < 1) {
#line 361
          act2 *= action;
#line 362
          average[rep] += act2;
#line 363
          total_action += loop_coeff[iloop][rep] * act2;
#line 360
          rep ++;
        }
#line 353
        i ++;
#line 353
        s ++;
      }
#line 366
      g_vecdoublesum(average, 1);
#line 368
      if (this_node == 0) {
#line 368
        printf((char const   * __restrict  )"G_LOOP:  %d  %d  %d   ", iloop, ln, length);
      }
#line 369
      rep = 0;
#line 369
      while (rep < 1) {
#line 369
        if (this_node == 0) {
#line 369
          printf((char const   * __restrict  )"\t%e", average[rep] / (double )volume);
        }
#line 369
        rep ++;
      }
#line 370
      if (this_node == 0) {
#line 370
        printf((char const   * __restrict  )"\t( ");
      }
#line 371
      i = 0;
#line 371
      while (i < length) {
#line 371
        if (this_node == 0) {
#line 371
          printf((char const   * __restrict  )"%d ", loop_table[iloop][ln][i]);
        }
#line 371
        i ++;
      }
#line 372
      if (this_node == 0) {
#line 372
        printf((char const   * __restrict  )" )\n");
      }
#line 348
      ln ++;
    }
#line 345
    iloop ++;
  }
#line 375
  g_doublesum(& total_action);
#line 376
  if (this_node == 0) {
#line 376
    printf((char const   * __restrict  )"GACTION: %e\n", total_action / (double )volume);
  }
#line 379
  if (this_node == 0) {
#line 379
    fflush(stdout);
  }
#line 381
  return;
}
}
#line 383 "gauge_stuff.c"
void printpath(int *path , int length ) 
{ 
  register int i ;

  {
#line 385
  if (this_node == 0) {
#line 385
    printf((char const   * __restrict  )"\t( ");
  }
#line 386
  i = 0;
#line 386
  while (i < length) {
#line 386
    if (this_node == 0) {
#line 386
      printf((char const   * __restrict  )"%d ", *(path + i));
    }
#line 386
    i ++;
  }
#line 387
  if (this_node == 0) {
#line 387
    printf((char const   * __restrict  )",  L = %d )\n", length);
  }
#line 388
  return;
}
}
#line 1 "grsource_imp.o"
#pragma merger("0","/tmp/cil-DwVpBmfO.i","")
#line 484 "./su3.h"
double gaussian_rand_no(double_prn *prn_pt ) ;
#line 23 "./generic_ks.h"
void scalar_mult_latvec(field_offset src , double scalar , field_offset dest , int parity ) ;
#line 25
void scalar_mult_add_latvec(field_offset src1 , field_offset src2 , double scalar ,
                            field_offset dest , int parity ) ;
#line 20 "grsource_imp.c"
void grsource_imp(field_offset dest , double mass___0 , int parity ) 
{ 
  register int i ;
  register int j ;
  register site *s ;

  {
#line 23
  i = 0;
#line 23
  s = lattice;
#line 23
  while (i < sites_on_node) {
#line 24
    j = 0;
#line 24
    while (j < 3) {
#line 26
      s->g_rand.c[j].real = gaussian_rand_no(& s->site_prn);
#line 27
      s->g_rand.c[j].imag = gaussian_rand_no(& s->site_prn);
#line 24
      j ++;
    }
#line 23
    i ++;
#line 23
    s ++;
  }
#line 35
  if (! valid_longlinks) {
#line 35
    load_longlinks();
  }
#line 36
  if (! valid_fatlinks) {
#line 36
    load_fatlinks();
  }
#line 38
  dslash_fn((field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
            dest, parity);
#line 39
  scalar_mult_latvec(dest, - 1.0, dest, parity);
#line 40
  scalar_mult_add_latvec(dest, (field_offset )((char *)(& (lattice + 0)->g_rand) - (char *)(lattice + 0)),
                         2.0 * mass___0, dest, parity);
#line 42
  return;
}
}
#line 48 "grsource_imp.c"
void checkmul_imp(field_offset src , double mass___0 ) 
{ 
  register int i ;
  register int j ;
  register site *s ;

  {
#line 51
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            3);
#line 52
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         src, 2.0 * mass___0, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         3);
#line 54
  i = 0;
#line 54
  s = lattice;
#line 54
  while (i < sites_on_node) {
#line 55
    printf((char const   * __restrict  )"Site %d %d %d %d\n", (int )s->x, (int )s->y,
           (int )s->z, (int )s->t);
#line 56
    j = 0;
#line 56
    while (j < 3) {
#line 57
      printf((char const   * __restrict  )"%d %d\t%e\t%e\t%e\n", i, j, s->g_rand.c[j].real,
             s->ttt.c[j].real, s->g_rand.c[j].real - s->ttt.c[j].real);
#line 59
      printf((char const   * __restrict  )"%d %d\t%e\t%e\t%e\n", i, j, s->g_rand.c[j].imag,
             s->ttt.c[j].imag, s->g_rand.c[j].imag - s->ttt.c[j].imag);
#line 56
      j ++;
    }
#line 62
    printf((char const   * __restrict  )"\n");
#line 54
    i ++;
#line 54
    s ++;
  }
#line 65
  return;
}
}
#line 1 "mat_invert.o"
#pragma merger("0","/tmp/cil-I0MkCnoP.i","")
#line 390 "./su3.h"
double magsq_su3vec(su3_vector *a ) ;
#line 409
void sub_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) ;
#line 413
void scalar_mult_su3_vector(su3_vector *a , double s , su3_vector *c ) ;
#line 415
void scalar_mult_add_su3_vector(su3_vector *a , su3_vector *b , double s , su3_vector *c ) ;
#line 21 "./generic_ks.h"
void clear_latvec(field_offset v , int parity ) ;
#line 111
int mat_invert_cg(field_offset src , field_offset dest , field_offset temp___0 , double mass___0 ) ;
#line 115
void check_invert(field_offset src , field_offset dest , double mass___0 , double tol ) ;
#line 22 "mat_invert.c"
int mat_invert_cg(field_offset src , field_offset dest , field_offset temp___0 , double mass___0 ) 
{ 
  int cgn ;
  double finalrsq ;

  {
#line 26
  clear_latvec(dest, 3);
#line 27
  cgn = ks_congrad(src, dest, mass___0, niter, rsqprop, 3, & finalrsq);
#line 30
  dslash_fn(dest, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            3);
#line 31
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         dest, - 2.0 * mass___0, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         3);
#line 33
  scalar_mult_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                     - 1.0, dest, 3);
#line 34
  return (cgn);
}
}
#line 61 "mat_invert.c"
int mat_invert_uml(field_offset src , field_offset dest , field_offset temp___0 ,
                   double mass___0 ) 
{ 
  int cgn ;
  double finalrsq ;
  register int i ;
  register site *s ;

  {
#line 68
  if (src == temp___0) {
#line 69
    printf((char const   * __restrict  )"BOTCH\n");
#line 69
    exit(0);
  }
#line 72
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            2);
#line 73
  scalar_mult_add_latvec((field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
                         src, - 2.0 * mass___0, temp___0, 2);
#line 75
  scalar_mult_latvec(temp___0, - 1.0, temp___0, 2);
#line 77
  cgn = ks_congrad(temp___0, dest, mass___0, niter, rsqprop, 2, & finalrsq);
#line 81
  dslash_fn(dest, (field_offset )((char *)(& (lattice + 0)->ttt) - (char *)(lattice + 0)),
            1);
#line 82
  i = even_sites_on_node;
#line 82
  s = lattice + i;
#line 82
  while (i < sites_on_node) {
#line 83
    sub_su3_vector((su3_vector *)((char *)s + src), & s->ttt, (su3_vector *)((char *)s + dest));
#line 85
    scalar_mult_su3_vector((su3_vector *)((char *)s + dest), 1.0 / (2.0 * mass___0),
                           (su3_vector *)((char *)s + dest));
#line 82
    i ++;
#line 82
    s ++;
  }
#line 88
  return (cgn);
}
}
#line 92 "mat_invert.c"
void check_invert(field_offset src , field_offset dest , double mass___0 , double tol ) 
{ 
  register int i ;
  register int k ;
  register int flag ;
  register site *s ;
  double r_diff ;
  double i_diff ;
  double sum ;
  double sum2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 98
  dslash_fn(src, (field_offset )((char *)(& (lattice + 0)->cg_p) - (char *)(lattice + 0)),
            3);
#line 99
  i = 0;
#line 99
  s = lattice;
#line 99
  while (i < sites_on_node) {
#line 100
    scalar_mult_add_su3_vector(& s->cg_p, (su3_vector *)((char *)s + src), 2.0 * mass___0,
                               & s->cg_p);
#line 99
    i ++;
#line 99
    s ++;
  }
#line 103
  sum = 0.0;
#line 103
  sum2 = sum;
#line 104
  i = 0;
#line 104
  s = lattice;
#line 104
  while (i < sites_on_node) {
#line 105
    flag = 0;
#line 105
    k = 0;
#line 105
    while (k < 3) {
#line 106
      r_diff = ((su3_vector *)((char *)s + dest))->c[k].real - s->cg_p.c[k].real;
#line 108
      i_diff = ((su3_vector *)((char *)s + dest))->c[k].imag - s->cg_p.c[k].imag;
#line 110
      tmp = fabs(r_diff);
#line 110
      if (tmp > tol) {
#line 110
        flag = 1;
      } else {
#line 110
        tmp___0 = fabs(i_diff);
#line 110
        if (tmp___0 > tol) {
#line 110
          flag = 1;
        }
      }
#line 111
      if (flag) {
#line 111
        printf((char const   * __restrict  )"%d %d  ( %.4e , %.4e )  ( %.4e , %.4e )\n",
               i, k, ((su3_vector *)((char *)s + dest))->c[k].real, ((su3_vector *)((char *)s + dest))->c[k].imag,
               s->cg_p.c[k].real, s->cg_p.c[k].imag);
      }
#line 116
      if (flag) {
#line 116
        terminate(0);
      }
#line 117
      sum += r_diff * r_diff + i_diff * i_diff;
#line 105
      k ++;
    }
#line 119
    tmp___1 = magsq_su3vec((su3_vector *)((char *)s + dest));
#line 119
    sum2 += tmp___1;
#line 104
    i ++;
#line 104
    s ++;
  }
#line 121
  g_doublesum(& sum);
#line 122
  g_doublesum(& sum2);
#line 123
  g_sync();
#line 123
  if (this_node == 0) {
#line 124
    tmp___2 = sqrt(sum / sum2);
#line 124
    printf((char const   * __restrict  )"Inversion checked, frac. error = %e\n", tmp___2);
#line 125
    fflush(stdout);
  }
#line 127
  return;
}
}
#line 1 "quark_stuff.o"
#pragma merger("0","/tmp/cil-AvOT0E4W.i","")
#line 367 "./su3.h"
void scalar_mult_su3_matrix(su3_matrix *a , double s , su3_matrix *b ) ;
#line 387
void su3_projector(su3_vector *a , su3_vector *b , su3_matrix *c ) ;
#line 395
void mult_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) ;
#line 400
void mult_adj_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) ;
#line 446
void mult_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) ;
#line 450
void mult_adj_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) ;
#line 124 "./generic_ks.h"
void eo_fermion_force_3f(double eps , int nflav1 , field_offset x1_off , int nflav2 ,
                         field_offset x2_off ) ;
#line 22 "./quark_action.h"
static int path_ind[6][7]  = { {        0,        -1,        -1,        -1, 
            -1,        -1}, 
   {        0,        0,        0,        -1, 
            -1,        -1}, 
   {        1,        0,        6,        -1, 
            -1,        -1}, 
   {        1,        2,        0,        5, 
            6,        -1}, 
   {        1,        2,        3,        0, 
            4,        5,        6}, 
   {        1,        1,        0,        6, 
            6,        -1}};
#line 30 "./quark_action.h"
static int path_length_in[6]  = {      1,      3,      3,      5, 
        7,      5};
#line 31 "./quark_action.h"
static int quark_action_npaths  =    6;
#line 32 "./quark_action.h"
static double path_coeff[6]  = {      (1.0 / 8.0 + 6.0 / 16.0) + 1.0 / 8.0,      - 1.0 / 24.0,      (- 1.0 / 8.0) * 0.5,      ((1.0 / 8.0) * 0.25) * 0.5, 
        ((- 1.0 / 8.0) * 0.125) * (1.0 / 6.0),      - 1.0 / (double )16};
#line 41 "./quark_action.h"
static char quark_action_description___0[72]  = 
#line 41
  {      (char )'\"',      (char )'O',      (char )'(',      (char )'a', 
        (char )'^',      (char )'2',      (char )')',      (char )':', 
        (char )' ',      (char )'c',      (char )'o',      (char )'u', 
        (char )'p',      (char )'l',      (char )'i',      (char )'n', 
        (char )'g',      (char )'s',      (char )'(',      (char )'p', 
        (char )'i',      (char )')',      (char )'=',      (char )'0', 
        (char )',',      (char )' ',      (char )'N',      (char )'a', 
        (char )'i',      (char )'k',      (char )' ',      (char )'t', 
        (char )'e',      (char )'r',      (char )'m',      (char )',', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'O',      (char )'(',      (char )'a',      (char )'^', 
        (char )'2',      (char )')',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'s',      (char )',',      (char )' ',      (char )'t', 
        (char )'a',      (char )'d',      (char )'p',      (char )'o', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'e',      (char )'i',      (char )'g',      (char )'h', 
        (char )'t',      (char )'s',      (char )'\"',      (char )'\000'};
#line 42 "quark_stuff.c"
void path_transport(field_offset src , field_offset dest , int parity , int *dir ,
                    int length ) ;
#line 44
void path_transport_hwv(field_offset src , field_offset dest , int parity , int *dir ,
                        int length ) ;
#line 47
void compute_gen_staple(field_offset staple , int mu , int nu , field_offset link ,
                        double coef ) ;
#line 54
void u_shift_fermion(su3_vector *src , su3_vector *dest , int dir ) ;
#line 55
void add_force_to_mom(su3_vector *back , su3_vector *forw , int dir , double coeff ) ;
#line 56
void side_link_force(int mu , int nu , double coeff , su3_vector *Path , su3_vector *Path_nu ,
                     su3_vector *Path_mu , su3_vector *Path_numu ) ;
#line 60
void u_shift_hw_fermion(half_wilson_vector *src , half_wilson_vector *dest , int dir ) ;
#line 62
void add_3f_force_to_mom(half_wilson_vector *back , half_wilson_vector *forw , int dir ,
                         double *coeff ) ;
#line 64
void side_link_3f_force(int mu , int nu , double *coeff , half_wilson_vector *Path ,
                        half_wilson_vector *Path_nu , half_wilson_vector *Path_mu ,
                        half_wilson_vector *Path_numu ) ;
#line 71 "quark_stuff.c"
int path_num[6]  ;
#line 73 "quark_stuff.c"
static double act_path_coeff[6]  ;
#line 83 "quark_stuff.c"
struct __anonstruct_q_paths_51 q_paths[688]  ;
#line 89 "quark_stuff.c"
int num_q_paths  ;
#line 90 "quark_stuff.c"
int num_basic_paths  ;
#line 92
int is_path_equal(int *path1 , int *path2 , int length ) ;
#line 93
int add_basic_path(int *basic_vec , int length , double coeff ) ;
#line 96 "quark_stuff.c"
void make_path_table(void) 
{ 
  int i ;
  int j ;
  int k ;
  double this_coeff ;

  {
#line 107
  if (this_node == 0) {
#line 107
    printf((char const   * __restrict  )"%s\n", quark_action_description___0);
  }
#line 108
  num_q_paths = 0;
#line 109
  num_basic_paths = 0;
#line 113
  if (this_node == 0) {
#line 113
    printf((char const   * __restrict  )"path coefficients: npath  path_coeff  multiplicity\n");
  }
#line 114
  j = 0;
#line 114
  while (j < quark_action_npaths) {
#line 116
    this_coeff = path_coeff[j];
#line 118
    k = 1;
#line 118
    while (k < path_length_in[j]) {
#line 118
      this_coeff /= u0;
#line 118
      k ++;
    }
#line 120
    act_path_coeff[j] = this_coeff;
#line 121
    i = add_basic_path(path_ind[j], path_length_in[j], this_coeff);
#line 123
    if (this_node == 0) {
#line 123
      printf((char const   * __restrict  )"                    %d      %e     %d\n",
             j, this_coeff, i);
    }
#line 114
    j ++;
  }
#line 126
  return;
}
}
#line 130 "quark_stuff.c"
int add_basic_path(int *basic_vec , int length , double coeff ) 
{ 
  int perm[8] ;
  int pp[8] ;
  int ir[4] ;
  int j ;
  int path_num___0 ;
  int vec[7] ;
  int flag ;

  {
#line 137
  path_num___0 = 0;
#line 143
  perm[0] = 0;
#line 143
  while (perm[0] < 4) {
#line 144
    perm[1] = 0;
#line 144
    while (perm[1] < 4) {
#line 145
      perm[2] = 0;
#line 145
      while (perm[2] < 4) {
#line 146
        perm[3] = 0;
#line 146
        while (perm[3] < 4) {
#line 147
          if (perm[0] != perm[1]) {
#line 147
            if (perm[0] != perm[2]) {
#line 147
              if (perm[0] != perm[3]) {
#line 147
                if (perm[1] != perm[2]) {
#line 147
                  if (perm[1] != perm[3]) {
#line 147
                    if (perm[2] != perm[3]) {
#line 151
                      ir[0] = 0;
#line 151
                      while (ir[0] < 2) {
#line 152
                        ir[1] = 0;
#line 152
                        while (ir[1] < 2) {
#line 153
                          ir[2] = 0;
#line 153
                          while (ir[2] < 2) {
#line 154
                            ir[3] = 0;
#line 154
                            while (ir[3] < 2) {
#line 155
                              j = 0;
#line 155
                              while (j < 4) {
#line 156
                                pp[j] = perm[j];
#line 158
                                if (ir[j] == 1) {
#line 158
                                  pp[j] = 7 - pp[j];
                                }
#line 159
                                pp[7 - j] = 7 - pp[j];
#line 155
                                j ++;
                              }
#line 162
                              j = 0;
#line 162
                              while (j < length) {
#line 162
                                vec[j] = pp[*(basic_vec + j)];
#line 162
                                j ++;
                              }
#line 163
                              j = length;
#line 163
                              while (j < 7) {
#line 163
                                vec[j] = -1;
#line 163
                                j ++;
                              }
#line 165
                              flag = 0;
#line 167
                              j = 0;
#line 167
                              while (j < num_q_paths) {
#line 168
                                flag = is_path_equal(vec, q_paths[j].dir, 7);
#line 169
                                if (flag == 1) {
#line 169
                                  break;
                                }
#line 167
                                j ++;
                              }
#line 171
                              if (flag == 0) {
#line 172
                                if (num_q_paths >= 688) {
#line 173
                                  if (this_node == 0) {
#line 173
                                    printf((char const   * __restrict  )"OOPS: MAX_NUM too small\n");
                                  }
#line 174
                                  exit(0);
                                }
#line 176
                                q_paths[num_q_paths].length = length;
#line 177
                                j = 0;
#line 177
                                while (j < 7) {
#line 177
                                  q_paths[num_q_paths].dir[j] = vec[j];
#line 177
                                  j ++;
                                }
#line 179
                                if (ir[0] == 0) {
#line 180
                                  q_paths[num_q_paths].coeff = coeff;
#line 181
                                  q_paths[num_q_paths].forwback = (double )1;
                                } else {
#line 184
                                  q_paths[num_q_paths].coeff = - coeff;
#line 185
                                  q_paths[num_q_paths].forwback = (double )-1;
                                }
#line 187
                                num_q_paths ++;
#line 188
                                path_num___0 ++;
                              }
#line 154
                              (ir[3]) ++;
                            }
#line 153
                            (ir[2]) ++;
                          }
#line 152
                          (ir[1]) ++;
                        }
#line 151
                        (ir[0]) ++;
                      }
                    }
                  }
                }
              }
            }
          }
#line 146
          (perm[3]) ++;
        }
#line 145
        (perm[2]) ++;
      }
#line 144
      (perm[1]) ++;
    }
#line 143
    (perm[0]) ++;
  }
#line 196
  num_basic_paths ++;
#line 197
  return (path_num___0);
}
}
#line 207 "quark_stuff.c"
void path_transport(field_offset src , field_offset dest , int parity , int *dir ,
                    int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  int j ;
  su3_vector *tmp_src ;
  su3_vector *tmp_dest ;
  su3_vector *tmp_work ;
  su3_vector *tmp_pt ;
  int tmp_parity ;
  int tmp_otherparity ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 217
  if (length > 0) {
#line 218
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 218
//AD    tmp_src = (su3_vector *)tmp;
    tmp_src = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 219
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 219
//AD    tmp_dest = (su3_vector *)tmp___0;
    tmp_dest = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 220
//AD    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 220
//AD    tmp_work = (su3_vector *)tmp___1;
    tmp_work = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 222
    j = length - 1;
#line 222
    while (j >= 0) {
#line 224
      if (j % 2 == 0) {
#line 225
        tmp_parity = parity;
#line 226
        switch (tmp_parity) {
        case 2: 
#line 227
        tmp_otherparity = 1;
#line 227
        break;
        case 1: 
#line 228
        tmp_otherparity = 2;
#line 228
        break;
        case 3: 
#line 229
        tmp_otherparity = 3;
#line 229
        break;
        }
      } else {
#line 233
        tmp_otherparity = parity;
#line 234
        switch (tmp_otherparity) {
        case 2: 
#line 235
        tmp_parity = 1;
#line 235
        break;
        case 1: 
#line 236
        tmp_parity = 2;
#line 236
        break;
        case 3: 
#line 237
        tmp_parity = 3;
#line 237
        break;
        }
      }
#line 241
      if (j == length - 1) {
#line 242
        if (tmp_otherparity == 1) {
#line 242
          i = even_sites_on_node;
        } else {
#line 242
          i = 0;
        }
#line 242
        s = lattice + i;
#line 242
        while (1) {
#line 242
          if (tmp_otherparity == 2) {
#line 242
            tmp___2 = even_sites_on_node;
          } else {
#line 242
            tmp___2 = sites_on_node;
          }
#line 242
          if (! (i < tmp___2)) {
#line 242
            break;
          }
#line 243
          *(tmp_src + i) = *((su3_vector *)((char *)s + src));
#line 242
          i ++;
#line 242
          s ++;
        }
      }
#line 247
      if (*(dir + j) <= 3) {
#line 248
        mtag0 = start_gather_from_temp((void *)tmp_src, (int )sizeof(su3_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
#line 250
        wait_gather(mtag0);
#line 251
        if (tmp_parity == 1) {
#line 251
          i = even_sites_on_node;
        } else {
#line 251
          i = 0;
        }
#line 251
        s = lattice + i;
#line 251
        while (1) {
#line 251
          if (tmp_parity == 2) {
#line 251
            tmp___3 = even_sites_on_node;
          } else {
#line 251
            tmp___3 = sites_on_node;
          }
#line 251
          if (! (i < tmp___3)) {
#line 251
            break;
          }
#line 252
          mult_su3_mat_vec(& s->link[*(dir + j)], (su3_vector *)*(gen_pt[0] + i),
                           tmp_dest + i);
#line 251
          i ++;
#line 251
          s ++;
        }
#line 256
        cleanup_gather(mtag0);
      } else {
#line 260
        if (tmp_otherparity == 1) {
#line 260
          i = even_sites_on_node;
        } else {
#line 260
          i = 0;
        }
#line 260
        s = lattice + i;
#line 260
        while (1) {
#line 260
          if (tmp_otherparity == 2) {
#line 260
            tmp___4 = even_sites_on_node;
          } else {
#line 260
            tmp___4 = sites_on_node;
          }
#line 260
          if (! (i < tmp___4)) {
#line 260
            break;
          }
#line 261
          mult_adj_su3_mat_vec(& s->link[7 - *(dir + j)], tmp_src + i, tmp_work + i);
#line 260
          i ++;
#line 260
          s ++;
        }
#line 264
        mtag0 = start_gather_from_temp((void *)tmp_work, (int )sizeof(su3_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
#line 266
        wait_gather(mtag0);
#line 267
        if (tmp_parity == 1) {
#line 267
          i = even_sites_on_node;
        } else {
#line 267
          i = 0;
        }
#line 267
        s = lattice + i;
#line 267
        while (1) {
#line 267
          if (tmp_parity == 2) {
#line 267
            tmp___5 = even_sites_on_node;
          } else {
#line 267
            tmp___5 = sites_on_node;
          }
#line 267
          if (! (i < tmp___5)) {
#line 267
            break;
          }
#line 268
          *(tmp_dest + i) = *((su3_vector *)*(gen_pt[0] + i));
#line 267
          i ++;
#line 267
          s ++;
        }
#line 270
        cleanup_gather(mtag0);
      }
#line 274
      tmp_pt = tmp_src;
#line 274
      tmp_src = tmp_dest;
#line 274
      tmp_dest = tmp_pt;
#line 222
      j --;
    }
#line 277
    if (parity == 1) {
#line 277
      i = even_sites_on_node;
    } else {
#line 277
      i = 0;
    }
#line 277
    s = lattice + i;
#line 277
    while (1) {
#line 277
      if (parity == 2) {
#line 277
        tmp___6 = even_sites_on_node;
      } else {
#line 277
        tmp___6 = sites_on_node;
      }
#line 277
      if (! (i < tmp___6)) {
#line 277
        break;
      }
#line 278
      *((su3_vector *)((char *)s + dest)) = *(tmp_src + i);
#line 277
      i ++;
#line 277
      s ++;
    }
#line 280
    free((void *)tmp_src);
#line 280
    free((void *)tmp_dest);
#line 280
    free((void *)tmp_work);
  } else
#line 282
  if (src != dest) {
#line 283
    if (parity == 1) {
#line 283
      i = even_sites_on_node;
    } else {
#line 283
      i = 0;
    }
#line 283
    s = lattice + i;
#line 283
    while (1) {
#line 283
      if (parity == 2) {
#line 283
        tmp___7 = even_sites_on_node;
      } else {
#line 283
        tmp___7 = sites_on_node;
      }
#line 283
      if (! (i < tmp___7)) {
#line 283
        break;
      }
#line 284
      *((su3_vector *)((char *)s + dest)) = *((su3_vector *)((char *)s + src));
#line 283
      i ++;
#line 283
      s ++;
    }
  }
#line 287
  return;
}
}
#line 290 "quark_stuff.c"
void path_transport_hwv(field_offset src , field_offset dest , int parity , int *dir ,
                        int length ) 
{ 
  register int i ;
  register site *s ;
  msg_tag *mtag0 ;
  int j ;
  half_wilson_vector *tmp_src ;
  half_wilson_vector *tmp_dest ;
  half_wilson_vector *tmp_work ;
  half_wilson_vector *tmp_pt ;
  int tmp_parity ;
  int tmp_otherparity ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 300
  if (length > 0) {
#line 301
//AD    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 301
//AD    tmp_src = (half_wilson_vector *)tmp;
    tmp_src = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 303
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 303
//AD    tmp_dest = (half_wilson_vector *)tmp___0;
    tmp_dest = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 305
//AD    tmp___1 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 305
//AD    tmp_work = (half_wilson_vector *)tmp___1;
    tmp_work = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 308
    j = length - 1;
#line 308
    while (j >= 0) {
#line 310
      if (j % 2 == 0) {
#line 311
        tmp_parity = parity;
#line 312
        switch (tmp_parity) {
        case 2: 
#line 313
        tmp_otherparity = 1;
#line 313
        break;
        case 1: 
#line 314
        tmp_otherparity = 2;
#line 314
        break;
        case 3: 
#line 315
        tmp_otherparity = 3;
#line 315
        break;
        }
      } else {
#line 319
        tmp_otherparity = parity;
#line 320
        switch (tmp_otherparity) {
        case 2: 
#line 321
        tmp_parity = 1;
#line 321
        break;
        case 1: 
#line 322
        tmp_parity = 2;
#line 322
        break;
        case 3: 
#line 323
        tmp_parity = 3;
#line 323
        break;
        }
      }
#line 327
      if (j == length - 1) {
#line 328
        if (tmp_otherparity == 1) {
#line 328
          i = even_sites_on_node;
        } else {
#line 328
          i = 0;
        }
#line 328
        s = lattice + i;
#line 328
        while (1) {
#line 328
          if (tmp_otherparity == 2) {
#line 328
            tmp___2 = even_sites_on_node;
          } else {
#line 328
            tmp___2 = sites_on_node;
          }
#line 328
          if (! (i < tmp___2)) {
#line 328
            break;
          }
#line 329
          *(tmp_src + i) = *((half_wilson_vector *)((char *)s + src));
#line 328
          i ++;
#line 328
          s ++;
        }
      }
#line 333
      if (*(dir + j) <= 3) {
#line 334
        mtag0 = start_gather_from_temp((void *)tmp_src, (int )sizeof(half_wilson_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
#line 336
        wait_gather(mtag0);
#line 337
        if (tmp_parity == 1) {
#line 337
          i = even_sites_on_node;
        } else {
#line 337
          i = 0;
        }
#line 337
        s = lattice + i;
#line 337
        while (1) {
#line 337
          if (tmp_parity == 2) {
#line 337
            tmp___3 = even_sites_on_node;
          } else {
#line 337
            tmp___3 = sites_on_node;
          }
#line 337
          if (! (i < tmp___3)) {
#line 337
            break;
          }
#line 338
          mult_su3_mat_hwvec(& s->link[*(dir + j)], (half_wilson_vector *)*(gen_pt[0] + i),
                             tmp_dest + i);
#line 337
          i ++;
#line 337
          s ++;
        }
#line 342
        cleanup_gather(mtag0);
      } else {
#line 346
        if (tmp_otherparity == 1) {
#line 346
          i = even_sites_on_node;
        } else {
#line 346
          i = 0;
        }
#line 346
        s = lattice + i;
#line 346
        while (1) {
#line 346
          if (tmp_otherparity == 2) {
#line 346
            tmp___4 = even_sites_on_node;
          } else {
#line 346
            tmp___4 = sites_on_node;
          }
#line 346
          if (! (i < tmp___4)) {
#line 346
            break;
          }
#line 347
          mult_adj_su3_mat_hwvec(& s->link[7 - *(dir + j)], tmp_src + i, tmp_work + i);
#line 346
          i ++;
#line 346
          s ++;
        }
#line 350
        mtag0 = start_gather_from_temp((void *)tmp_work, (int )sizeof(half_wilson_vector ),
                                       *(dir + j), tmp_parity, gen_pt[0]);
#line 352
        wait_gather(mtag0);
#line 353
        if (tmp_parity == 1) {
#line 353
          i = even_sites_on_node;
        } else {
#line 353
          i = 0;
        }
#line 353
        s = lattice + i;
#line 353
        while (1) {
#line 353
          if (tmp_parity == 2) {
#line 353
            tmp___5 = even_sites_on_node;
          } else {
#line 353
            tmp___5 = sites_on_node;
          }
#line 353
          if (! (i < tmp___5)) {
#line 353
            break;
          }
#line 354
          *(tmp_dest + i) = *((half_wilson_vector *)*(gen_pt[0] + i));
#line 353
          i ++;
#line 353
          s ++;
        }
#line 356
        cleanup_gather(mtag0);
      }
#line 360
      tmp_pt = tmp_src;
#line 360
      tmp_src = tmp_dest;
#line 360
      tmp_dest = tmp_pt;
#line 308
      j --;
    }
#line 363
    if (parity == 1) {
#line 363
      i = even_sites_on_node;
    } else {
#line 363
      i = 0;
    }
#line 363
    s = lattice + i;
#line 363
    while (1) {
#line 363
      if (parity == 2) {
#line 363
        tmp___6 = even_sites_on_node;
      } else {
#line 363
        tmp___6 = sites_on_node;
      }
#line 363
      if (! (i < tmp___6)) {
#line 363
        break;
      }
#line 364
      *((half_wilson_vector *)((char *)s + dest)) = *(tmp_src + i);
#line 363
      i ++;
#line 363
      s ++;
    }
#line 366
    free((void *)tmp_src);
#line 366
    free((void *)tmp_dest);
#line 366
    free((void *)tmp_work);
  } else
#line 368
  if (src != dest) {
#line 369
    if (parity == 1) {
#line 369
      i = even_sites_on_node;
    } else {
#line 369
      i = 0;
    }
#line 369
    s = lattice + i;
#line 369
    while (1) {
#line 369
      if (parity == 2) {
#line 369
        tmp___7 = even_sites_on_node;
      } else {
#line 369
        tmp___7 = sites_on_node;
      }
#line 369
      if (! (i < tmp___7)) {
#line 369
        break;
      }
#line 370
      *((half_wilson_vector *)((char *)s + dest)) = *((half_wilson_vector *)((char *)s + src));
#line 369
      i ++;
#line 369
      s ++;
    }
  }
#line 374
  return;
}
}
#line 427 "quark_stuff.c"
void load_longlinks(void) 
{ 
  register int i ;
  register site *s ;
  int ipath ;
  int dir ;
  int disp[4] ;
  register su3_matrix *long1 ;

  {
#line 438
  if (phases_in != 1) {
#line 439
    if (this_node == 0) {
#line 439
      printf((char const   * __restrict  )"BOTCH: load_longlinks needs phases in\n");
    }
#line 440
    terminate(0);
  }
#line 442
  dir = 0;
#line 442
  while (dir <= 3) {
#line 444
    i = 0;
#line 444
    s = lattice;
#line 444
    while (i < sites_on_node) {
#line 446
      long1 = t_longlink + (4 * i + dir);
#line 450
      clear_su3mat(long1);
#line 444
      i ++;
#line 444
      s ++;
    }
#line 454
    ipath = 0;
#line 454
    while (ipath < num_q_paths) {
#line 456
      i = 0;
#line 456
      while (i <= 3) {
#line 456
        disp[i] = 0;
#line 456
        i ++;
      }
#line 457
      i = 0;
#line 457
      while (i < q_paths[ipath].length) {
#line 458
        if (q_paths[ipath].dir[i] <= 3) {
#line 459
          (disp[q_paths[ipath].dir[i]]) ++;
        } else {
#line 461
          (disp[7 - q_paths[ipath].dir[i]]) --;
        }
#line 457
        i ++;
      }
#line 463
      disp[dir] += 3;
#line 463
      i = 0;
#line 463
      while (i <= 3) {
#line 463
        if (disp[i] != 0) {
#line 463
          break;
        }
#line 463
        i ++;
      }
#line 464
      if (i <= 3) {
#line 464
        goto __Cont;
      }
#line 469
      path_product(q_paths[ipath].dir, q_paths[ipath].length);
#line 470
      i = 0;
#line 470
      s = lattice;
#line 470
      while (i < sites_on_node) {
#line 471
        su3_adjoint(& s->tempmat1, & s->staple);
#line 473
        long1 = t_longlink + (4 * i + dir);
#line 477
        scalar_mult_add_su3_matrix(long1, & s->staple, - q_paths[ipath].coeff, long1);
#line 470
        i ++;
#line 470
        s ++;
      }
      __Cont: /* CIL Label */ 
#line 454
      ipath ++;
    }
#line 442
    dir ++;
  }
#line 485
  valid_longlinks = 1;
#line 490
  return;
}
}
#line 493 "quark_stuff.c"
void load_fatlinks(void) 
{ 
  register int i ;
  register site *s ;
  int dir ;
  register su3_matrix *fat1 ;
  int nu ;
  int rho ;
  int sig ;
  double one_link ;

  {
#line 510
  if (phases_in != 1) {
#line 511
    if (this_node == 0) {
#line 511
      printf((char const   * __restrict  )"BOTCH: load_fatlinks needs phases in\n");
    }
#line 512
    terminate(0);
  }
#line 564
  one_link = act_path_coeff[0] - 6.0 * act_path_coeff[5];
#line 566
  dir = 0;
#line 566
  while (dir <= 3) {
#line 567
    i = 0;
#line 567
    s = lattice;
#line 567
    while (i < sites_on_node) {
#line 570
      fat1 = t_fatlink + (4 * i + dir);
#line 574
      scalar_mult_su3_matrix(& s->link[dir], one_link, fat1);
#line 567
      i ++;
#line 567
      s ++;
    }
#line 577
    nu = 0;
#line 577
    while (nu <= 3) {
#line 577
      if (nu != dir) {
#line 579
        compute_gen_staple((field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                           dir, nu, (field_offset )((char *)(& (lattice + 0)->link[dir]) - (char *)(lattice + 0)),
                           act_path_coeff[2]);
#line 583
        compute_gen_staple(-1, dir, nu, (field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                           act_path_coeff[5]);
#line 584
        rho = 0;
#line 584
        while (rho <= 3) {
#line 584
          if (rho != dir) {
#line 584
            if (rho != nu) {
#line 586
              compute_gen_staple((field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                                 dir, rho, (field_offset )((char *)(& (lattice + 0)->staple) - (char *)(lattice + 0)),
                                 act_path_coeff[3]);
#line 588
              sig = 0;
#line 588
              while (sig <= 3) {
#line 589
                if (sig != dir) {
#line 589
                  if (sig != nu) {
#line 589
                    if (sig != rho) {
#line 591
                      compute_gen_staple(-1, dir, sig, (field_offset )((char *)(& (lattice + 0)->tempmat1) - (char *)(lattice + 0)),
                                         act_path_coeff[4]);
                    }
                  }
                }
#line 588
                sig ++;
              }
            }
          }
#line 584
          rho ++;
        }
      }
#line 577
      nu ++;
    }
#line 566
    dir ++;
  }
#line 600
  valid_fatlinks = 1;
#line 605
  return;
}
}
#line 610 "quark_stuff.c"
int is_path_equal(int *path1 , int *path2 , int length ) 
{ 
  register int i ;

  {
#line 612
  i = 0;
#line 612
  while (i < length) {
#line 612
    if (*(path1 + i) != *(path2 + i)) {
#line 612
      return (0);
    }
#line 612
    i ++;
  }
#line 613
  return (1);
}
}
#line 904 "quark_stuff.c"
void eo_fermion_force(double eps , int nflavors___0 , field_offset x_off ) 
{ 
  register int i ;
  register site *s ;
  int mu ;
  int nu ;
  int rho ;
  int sig ;
  int DirectLinks[8] ;
  double ferm_epsilon ;
  double coeff ;
  double OneLink ;
  double Lepage ;
  double Naik ;
  double FiveSt ;
  double ThreeSt ;
  double SevenSt ;
  su3_vector *tempvec[8] ;
  su3_vector *temp_x ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 923
  ferm_epsilon = (2.0 * ((double )nflavors___0 / 4.0)) * eps;
#line 926
  OneLink = act_path_coeff[0] * ferm_epsilon;
#line 927
  Naik = act_path_coeff[1] * ferm_epsilon;
#line 928
  ThreeSt = act_path_coeff[2] * ferm_epsilon;
#line 929
  FiveSt = act_path_coeff[3] * ferm_epsilon;
#line 930
  SevenSt = act_path_coeff[4] * ferm_epsilon;
#line 931
  Lepage = act_path_coeff[5] * ferm_epsilon;
#line 935
  mu = 0;
#line 935
  while (mu < 8) {
#line 936
    DirectLinks[mu] = 0;
#line 935
    mu ++;
  }
#line 939
  mu = 0;
#line 939
  while (mu < 8) {
#line 940
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 940
//AD    tempvec[mu] = (su3_vector *)tmp;
    tempvec[mu] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 939
    mu ++;
  }
#line 943
//AD  tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 943
//AD  temp_x = (su3_vector *)tmp___0;
  temp_x = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 944
  i = 0;
#line 944
  s = lattice;
#line 944
  while (i < sites_on_node) {
#line 944
    *(temp_x + i) = *((su3_vector *)((char *)s + x_off));
#line 944
    i ++;
#line 944
    s ++;
  }
#line 946
  sig = 0;
#line 946
  while (sig < 8) {
#line 948
    mu = 0;
#line 948
    while (mu < 8) {
#line 948
      if (mu != sig) {
#line 948
        if (mu != 7 - sig) {
#line 950
          u_shift_fermion(temp_x, tempvec[0], 7 - mu);
#line 951
          u_shift_fermion(tempvec[0], tempvec[7], sig);
#line 952
          if (sig <= 3) {
#line 958
            add_force_to_mom(tempvec[7], tempvec[0], sig, - ThreeSt);
          }
#line 960
          nu = 0;
#line 960
          while (nu < 8) {
#line 960
            if (nu != mu) {
#line 960
              if (nu != 7 - mu) {
#line 960
                if (nu != sig) {
#line 960
                  if (nu != 7 - sig) {
#line 963
                    u_shift_fermion(tempvec[0], tempvec[1], 7 - nu);
#line 964
                    u_shift_fermion(tempvec[1], tempvec[6], sig);
#line 965
                    if (sig <= 3) {
#line 971
                      add_force_to_mom(tempvec[6], tempvec[1], sig, FiveSt);
                    }
#line 973
                    rho = 0;
#line 973
                    while (rho < 8) {
#line 973
                      if (rho != mu) {
#line 973
                        if (rho != 7 - mu) {
#line 973
                          if (rho != nu) {
#line 973
                            if (rho != 7 - nu) {
#line 973
                              if (rho != sig) {
#line 973
                                if (rho != 7 - sig) {
#line 977
                                  u_shift_fermion(tempvec[1], tempvec[2], 7 - rho);
#line 979
                                  u_shift_fermion(tempvec[2], tempvec[3], sig);
#line 980
                                  if (sig <= 3) {
#line 986
                                    add_force_to_mom(tempvec[3], tempvec[2], sig,
                                                     - SevenSt);
                                  }
#line 989
                                  u_shift_fermion(tempvec[3], tempvec[4], rho);
#line 990
                                  side_link_force(rho, sig, SevenSt, tempvec[1], tempvec[3],
                                                  tempvec[2], tempvec[4]);
#line 992
                                  coeff = SevenSt / FiveSt;
#line 993
                                  i = 0;
#line 993
                                  s = lattice;
#line 993
                                  while (i < sites_on_node) {
#line 994
                                    scalar_mult_add_su3_vector(tempvec[6] + i, tempvec[4] + i,
                                                               coeff, tempvec[6] + i);
#line 993
                                    i ++;
#line 993
                                    s ++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
#line 973
                      rho ++;
                    }
#line 999
                    u_shift_fermion(tempvec[6], tempvec[3], nu);
#line 1000
                    side_link_force(nu, sig, - FiveSt, tempvec[0], tempvec[6], tempvec[1],
                                    tempvec[3]);
#line 1003
                    coeff = FiveSt / ThreeSt;
#line 1004
                    i = 0;
#line 1004
                    s = lattice;
#line 1004
                    while (i < sites_on_node) {
#line 1005
                      scalar_mult_add_su3_vector(tempvec[7] + i, tempvec[3] + i, coeff,
                                                 tempvec[7] + i);
#line 1004
                      i ++;
#line 1004
                      s ++;
                    }
                  }
                }
              }
            }
#line 960
            nu ++;
          }
#line 1010
          u_shift_fermion(tempvec[0], tempvec[1], 7 - mu);
#line 1011
          u_shift_fermion(tempvec[1], tempvec[6], sig);
#line 1012
          if (sig <= 3) {
#line 1018
            add_force_to_mom(tempvec[6], tempvec[1], sig, Lepage);
          }
#line 1021
          u_shift_fermion(tempvec[6], tempvec[3], mu);
#line 1022
          side_link_force(mu, sig, - Lepage, tempvec[0], tempvec[6], tempvec[1], tempvec[3]);
#line 1024
          coeff = Lepage / ThreeSt;
#line 1025
          i = 0;
#line 1025
          s = lattice;
#line 1025
          while (i < sites_on_node) {
#line 1026
            scalar_mult_add_su3_vector(tempvec[7] + i, tempvec[3] + i, coeff, tempvec[7] + i);
#line 1025
            i ++;
#line 1025
            s ++;
          }
#line 1030
          if (mu <= 3) {
#line 1031
            u_shift_fermion(tempvec[7], tempvec[3], mu);
          }
#line 1033
          side_link_force(mu, sig, ThreeSt, temp_x, tempvec[7], tempvec[0], tempvec[3]);
#line 1037
          if (! DirectLinks[mu]) {
#line 1038
            DirectLinks[mu] = 1;
#line 1039
            if (mu > 3) {
#line 1044
              add_force_to_mom(tempvec[0], temp_x, 7 - mu, OneLink);
#line 1048
              u_shift_fermion(temp_x, tempvec[4], mu);
#line 1051
              add_force_to_mom(tempvec[1], tempvec[4], 7 - mu, - Naik);
#line 1053
              u_shift_fermion(tempvec[1], tempvec[4], 7 - mu);
#line 1055
              add_force_to_mom(tempvec[4], temp_x, 7 - mu, Naik);
            } else {
#line 1059
              u_shift_fermion(temp_x, tempvec[4], mu);
#line 1062
              add_force_to_mom(tempvec[4], tempvec[1], mu, Naik);
            }
          }
        }
      }
#line 948
      mu ++;
    }
#line 946
    sig ++;
  }
#line 1070
  free((void *)temp_x);
#line 1071
  mu = 0;
#line 1071
  while (mu < 8) {
#line 1072
    free((void *)tempvec[mu]);
#line 1071
    mu ++;
  }
#line 1079
  return;
}
}
#line 1105 "quark_stuff.c"
void eo_fermion_force_3f(double eps , int nflav1 , field_offset x1_off , int nflav2 ,
                         field_offset x2_off ) 
{ 
  register int i ;
  register site *s ;
  int mu ;
  int nu ;
  int rho ;
  int sig ;
  int DirectLinks[8] ;
  double coeff[2] ;
  double ferm_epsilon ;
  double OneLink[2] ;
  double Lepage[2] ;
  double Naik[2] ;
  double FiveSt[2] ;
  double ThreeSt[2] ;
  double SevenSt[2] ;
  double mNaik[2] ;
  double mLepage[2] ;
  double mFiveSt[2] ;
  double mThreeSt[2] ;
  double mSevenSt[2] ;
  half_wilson_vector *hwvec[8] ;
  half_wilson_vector *temp_x ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1129
  ferm_epsilon = (2.0 * ((double )nflav1 / 4.0)) * eps;
#line 1130
  OneLink[0] = act_path_coeff[0] * ferm_epsilon;
#line 1131
  Naik[0] = act_path_coeff[1] * ferm_epsilon;
#line 1131
  mNaik[0] = - Naik[0];
#line 1132
  ThreeSt[0] = act_path_coeff[2] * ferm_epsilon;
#line 1132
  mThreeSt[0] = - ThreeSt[0];
#line 1133
  FiveSt[0] = act_path_coeff[3] * ferm_epsilon;
#line 1133
  mFiveSt[0] = - FiveSt[0];
#line 1134
  SevenSt[0] = act_path_coeff[4] * ferm_epsilon;
#line 1134
  mSevenSt[0] = - SevenSt[0];
#line 1135
  Lepage[0] = act_path_coeff[5] * ferm_epsilon;
#line 1135
  mLepage[0] = - Lepage[0];
#line 1137
  ferm_epsilon = (2.0 * ((double )nflav2 / 4.0)) * eps;
#line 1138
  OneLink[1] = act_path_coeff[0] * ferm_epsilon;
#line 1139
  Naik[1] = act_path_coeff[1] * ferm_epsilon;
#line 1139
  mNaik[1] = - Naik[1];
#line 1140
  ThreeSt[1] = act_path_coeff[2] * ferm_epsilon;
#line 1140
  mThreeSt[1] = - ThreeSt[1];
#line 1141
  FiveSt[1] = act_path_coeff[3] * ferm_epsilon;
#line 1141
  mFiveSt[1] = - FiveSt[1];
#line 1142
  SevenSt[1] = act_path_coeff[4] * ferm_epsilon;
#line 1142
  mSevenSt[1] = - SevenSt[1];
#line 1143
  Lepage[1] = act_path_coeff[5] * ferm_epsilon;
#line 1143
  mLepage[1] = - Lepage[1];
#line 1147
  mu = 0;
#line 1147
  while (mu < 8) {
#line 1148
    DirectLinks[mu] = 0;
#line 1147
    mu ++;
  }
#line 1151
  mu = 0;
#line 1151
  while (mu < 8) {
#line 1152
//AD    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 1152
//AD    hwvec[mu] = (half_wilson_vector *)tmp;
    hwvec[mu] = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 1151
    mu ++;
  }
#line 1156
//AD  tmp___0 = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 1156
//AD  temp_x = (half_wilson_vector *)tmp___0;
  temp_x = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 1158
  i = 0;
#line 1158
  s = lattice;
#line 1158
  while (i < sites_on_node) {
#line 1160
    (temp_x + i)->h[0] = *((su3_vector *)((char *)s + x1_off));
#line 1161
    (temp_x + i)->h[1] = *((su3_vector *)((char *)s + x2_off));
#line 1158
    i ++;
#line 1158
    s ++;
  }
#line 1164
  sig = 0;
#line 1164
  while (sig < 8) {
#line 1166
    mu = 0;
#line 1166
    while (mu < 8) {
#line 1166
      if (mu != sig) {
#line 1166
        if (mu != 7 - sig) {
#line 1168
          u_shift_hw_fermion(temp_x, hwvec[0], 7 - mu);
#line 1169
          u_shift_hw_fermion(hwvec[0], hwvec[7], sig);
#line 1170
          if (sig <= 3) {
#line 1176
            add_3f_force_to_mom(hwvec[7], hwvec[0], sig, (double *)(mThreeSt));
          }
#line 1178
          nu = 0;
#line 1178
          while (nu < 8) {
#line 1178
            if (nu != mu) {
#line 1178
              if (nu != 7 - mu) {
#line 1178
                if (nu != sig) {
#line 1178
                  if (nu != 7 - sig) {
#line 1181
                    u_shift_hw_fermion(hwvec[0], hwvec[1], 7 - nu);
#line 1182
                    u_shift_hw_fermion(hwvec[1], hwvec[6], sig);
#line 1183
                    if (sig <= 3) {
#line 1189
                      add_3f_force_to_mom(hwvec[6], hwvec[1], sig, (double *)(FiveSt));
                    }
#line 1191
                    rho = 0;
#line 1191
                    while (rho < 8) {
#line 1191
                      if (rho != mu) {
#line 1191
                        if (rho != 7 - mu) {
#line 1191
                          if (rho != nu) {
#line 1191
                            if (rho != 7 - nu) {
#line 1191
                              if (rho != sig) {
#line 1191
                                if (rho != 7 - sig) {
#line 1195
                                  u_shift_hw_fermion(hwvec[1], hwvec[2], 7 - rho);
#line 1197
                                  u_shift_hw_fermion(hwvec[2], hwvec[3], sig);
#line 1198
                                  if (sig <= 3) {
#line 1204
                                    add_3f_force_to_mom(hwvec[3], hwvec[2], sig, (double *)(mSevenSt));
                                  }
#line 1207
                                  u_shift_hw_fermion(hwvec[3], hwvec[4], rho);
#line 1208
                                  side_link_3f_force(rho, sig, (double *)(SevenSt),
                                                     hwvec[1], hwvec[3], hwvec[2],
                                                     hwvec[4]);
#line 1210
                                  coeff[0] = SevenSt[0] / FiveSt[0];
#line 1211
                                  coeff[1] = SevenSt[1] / FiveSt[1];
#line 1212
                                  i = 0;
#line 1212
                                  s = lattice;
#line 1212
                                  while (i < sites_on_node) {
#line 1214
                                    scalar_mult_add_su3_vector(& (hwvec[6] + i)->h[0],
                                                               & (hwvec[4] + i)->h[0],
                                                               coeff[0], & (hwvec[6] + i)->h[0]);
#line 1217
                                    scalar_mult_add_su3_vector(& (hwvec[6] + i)->h[1],
                                                               & (hwvec[4] + i)->h[1],
                                                               coeff[1], & (hwvec[6] + i)->h[1]);
#line 1212
                                    i ++;
#line 1212
                                    s ++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
#line 1191
                      rho ++;
                    }
#line 1224
                    u_shift_hw_fermion(hwvec[6], hwvec[3], nu);
#line 1225
                    side_link_3f_force(nu, sig, (double *)(mFiveSt), hwvec[0], hwvec[6],
                                       hwvec[1], hwvec[3]);
#line 1228
                    coeff[0] = FiveSt[0] / ThreeSt[0];
#line 1229
                    coeff[1] = FiveSt[1] / ThreeSt[1];
#line 1230
                    i = 0;
#line 1230
                    s = lattice;
#line 1230
                    while (i < sites_on_node) {
#line 1232
                      scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[0], & (hwvec[3] + i)->h[0],
                                                 coeff[0], & (hwvec[7] + i)->h[0]);
#line 1235
                      scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[1], & (hwvec[3] + i)->h[1],
                                                 coeff[1], & (hwvec[7] + i)->h[1]);
#line 1230
                      i ++;
#line 1230
                      s ++;
                    }
                  }
                }
              }
            }
#line 1178
            nu ++;
          }
#line 1243
          u_shift_hw_fermion(hwvec[0], hwvec[1], 7 - mu);
#line 1244
          u_shift_hw_fermion(hwvec[1], hwvec[6], sig);
#line 1245
          if (sig <= 3) {
#line 1251
            add_3f_force_to_mom(hwvec[6], hwvec[1], sig, (double *)(Lepage));
          }
#line 1254
          u_shift_hw_fermion(hwvec[6], hwvec[3], mu);
#line 1255
          side_link_3f_force(mu, sig, (double *)(mLepage), hwvec[0], hwvec[6], hwvec[1],
                             hwvec[3]);
#line 1257
          coeff[0] = Lepage[0] / ThreeSt[0];
#line 1258
          coeff[1] = Lepage[1] / ThreeSt[1];
#line 1259
          i = 0;
#line 1259
          s = lattice;
#line 1259
          while (i < sites_on_node) {
#line 1261
            scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[0], & (hwvec[3] + i)->h[0],
                                       coeff[0], & (hwvec[7] + i)->h[0]);
#line 1264
            scalar_mult_add_su3_vector(& (hwvec[7] + i)->h[1], & (hwvec[3] + i)->h[1],
                                       coeff[1], & (hwvec[7] + i)->h[1]);
#line 1259
            i ++;
#line 1259
            s ++;
          }
#line 1271
          if (mu <= 3) {
#line 1272
            u_shift_hw_fermion(hwvec[7], hwvec[3], mu);
          }
#line 1274
          side_link_3f_force(mu, sig, (double *)(ThreeSt), temp_x, hwvec[7], hwvec[0],
                             hwvec[3]);
#line 1278
          if (! DirectLinks[mu]) {
#line 1279
            DirectLinks[mu] = 1;
#line 1280
            if (mu > 3) {
#line 1285
              add_3f_force_to_mom(hwvec[0], temp_x, 7 - mu, (double *)(OneLink));
#line 1289
              u_shift_hw_fermion(temp_x, hwvec[4], mu);
#line 1292
              add_3f_force_to_mom(hwvec[1], hwvec[4], 7 - mu, (double *)(mNaik));
#line 1294
              u_shift_hw_fermion(hwvec[1], hwvec[4], 7 - mu);
#line 1296
              add_3f_force_to_mom(hwvec[4], temp_x, 7 - mu, (double *)(Naik));
            } else {
#line 1300
              u_shift_hw_fermion(temp_x, hwvec[4], mu);
#line 1303
              add_3f_force_to_mom(hwvec[4], hwvec[1], mu, (double *)(Naik));
            }
          }
        }
      }
#line 1166
      mu ++;
    }
#line 1164
    sig ++;
  }
#line 1311
  free((void *)temp_x);
#line 1312
  mu = 0;
#line 1312
  while (mu < 8) {
#line 1313
    free((void *)hwvec[mu]);
#line 1312
    mu ++;
  }
#line 1320
  return;
}
}
#line 1340 "quark_stuff.c"
void compute_gen_staple(field_offset staple , int mu , int nu , field_offset link ,
                        double coef ) 
{ 
  su3_matrix tmat1 ;
  su3_matrix tmat2 ;
  msg_tag *mtag0 ;
  msg_tag *mtag1 ;
  su3_matrix *tempmat ;
  register site *s ;
  register int i ;
  register su3_matrix *fat1 ;
  void *tmp ;

  {
#line 1361
  mtag0 = start_gather(link, (int )sizeof(su3_matrix ), nu, 3, gen_pt[0]);
#line 1362
  mtag1 = start_gather((field_offset )((char *)(& (lattice + 0)->link[nu]) - (char *)(lattice + 0)),
                       (int )sizeof(su3_matrix ), mu, 3, gen_pt[1]);
#line 1364
  wait_gather(mtag0);
#line 1365
  wait_gather(mtag1);
#line 1367
  if (staple != -1) {
#line 1368
    i = 0;
#line 1368
    s = lattice;
#line 1368
    while (i < sites_on_node) {
#line 1369
      mult_su3_na((su3_matrix *)*(gen_pt[0] + i), (su3_matrix *)*(gen_pt[1] + i),
                  & tmat1);
#line 1371
      mult_su3_nn(& s->link[nu], & tmat1, (su3_matrix *)((char *)s + staple));
#line 1368
      i ++;
#line 1368
      s ++;
    }
  } else {
#line 1375
    i = 0;
#line 1375
    s = lattice;
#line 1375
    while (i < sites_on_node) {
#line 1376
      mult_su3_na((su3_matrix *)*(gen_pt[0] + i), (su3_matrix *)*(gen_pt[1] + i),
                  & tmat1);
#line 1378
      mult_su3_nn(& s->link[nu], & tmat1, & tmat2);
#line 1380
      fat1 = t_fatlink + (4 * i + mu);
#line 1384
      scalar_mult_add_su3_matrix(fat1, & tmat2, coef, fat1);
#line 1375
      i ++;
#line 1375
      s ++;
    }
  }
#line 1388
  cleanup_gather(mtag0);
#line 1389
  cleanup_gather(mtag1);
#line 1392
//AD  tmp = calloc((size_t )sites_on_node, sizeof(su3_matrix ));
#line 1392
//AD  tempmat = (su3_matrix *)tmp;
  tempmat = (su3_matrix *)calloc((size_t )sites_on_node, sizeof(su3_matrix )); //AD
#line 1393
  mtag0 = start_gather((field_offset )((char *)(& (lattice + 0)->link[nu]) - (char *)(lattice + 0)),
                       (int )sizeof(su3_matrix ), mu, 3, gen_pt[0]);
#line 1395
  wait_gather(mtag0);
#line 1396
  i = 0;
#line 1396
  s = lattice;
#line 1396
  while (i < sites_on_node) {
#line 1397
    mult_su3_an(& s->link[nu], (su3_matrix *)((char *)s + link), & tmat1);
#line 1398
    mult_su3_nn(& tmat1, (su3_matrix *)*(gen_pt[0] + i), tempmat + i);
#line 1396
    i ++;
#line 1396
    s ++;
  }
#line 1400
  cleanup_gather(mtag0);
#line 1401
  mtag0 = start_gather_from_temp((void *)tempmat, (int )sizeof(su3_matrix ), 7 - nu,
                                 3, gen_pt[0]);
#line 1403
  wait_gather(mtag0);
#line 1405
  if (staple != -1) {
#line 1406
    i = 0;
#line 1406
    s = lattice;
#line 1406
    while (i < sites_on_node) {
#line 1407
      add_su3_matrix((su3_matrix *)((char *)s + staple), (su3_matrix *)*(gen_pt[0] + i),
                     (su3_matrix *)((char *)s + staple));
#line 1410
      fat1 = t_fatlink + (4 * i + mu);
#line 1414
      scalar_mult_add_su3_matrix(fat1, (su3_matrix *)((char *)s + staple), coef, fat1);
#line 1406
      i ++;
#line 1406
      s ++;
    }
  } else {
#line 1420
    i = 0;
#line 1420
    s = lattice;
#line 1420
    while (i < sites_on_node) {
#line 1422
      fat1 = t_fatlink + (4 * i + mu);
#line 1426
      scalar_mult_add_su3_matrix(fat1, (su3_matrix *)*(gen_pt[0] + i), coef, fat1);
#line 1420
      i ++;
#line 1420
      s ++;
    }
  }
#line 1432
  free((void *)tempmat);
#line 1433
  cleanup_gather(mtag0);
#line 1434
  return;
}
}
#line 1441 "quark_stuff.c"
void u_shift_fermion(su3_vector *src , su3_vector *dest , int dir ) 
{ 
  su3_vector *tmpvec ;
  msg_tag *mtag ;
  register site *s ;
  register int i ;
  void *tmp ;

  {
#line 1447
  if (dir <= 3) {
#line 1449
    mtag = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir, 3,
                                  gen_pt[0]);
#line 1451
    wait_gather(mtag);
#line 1452
    i = 0;
#line 1452
    s = lattice;
#line 1452
    while (i < sites_on_node) {
#line 1453
      mult_su3_mat_vec(& s->link[dir], (su3_vector *)*(gen_pt[0] + i), dest + i);
#line 1452
      i ++;
#line 1452
      s ++;
    }
#line 1455
    cleanup_gather(mtag);
  } else {
#line 1459
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 1459
//AD    tmpvec = (su3_vector *)tmp;
    tmpvec = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 1460
    i = 0;
#line 1460
    s = lattice;
#line 1460
    while (i < sites_on_node) {
#line 1461
      mult_adj_su3_mat_vec(& s->link[7 - dir], src + i, tmpvec + i);
#line 1460
      i ++;
#line 1460
      s ++;
    }
#line 1462
    mtag = start_gather_from_temp((void *)tmpvec, (int )sizeof(su3_vector ), dir,
                                  3, gen_pt[0]);
#line 1464
    wait_gather(mtag);
#line 1466
    i = 0;
#line 1466
    s = lattice;
#line 1466
    while (i < sites_on_node) {
#line 1467
      *(dest + i) = *((su3_vector *)*(gen_pt[0] + i));
#line 1466
      i ++;
#line 1466
      s ++;
    }
#line 1468
    cleanup_gather(mtag);
#line 1469
    free((void *)tmpvec);
  }
#line 1471
  return;
}
}
#line 1475 "quark_stuff.c"
void u_shift_hw_fermion(half_wilson_vector *src , half_wilson_vector *dest , int dir ) 
{ 
  half_wilson_vector *tmpvec ;
  msg_tag *mtag ;
  register site *s ;
  register int i ;
  void *tmp ;

  {
#line 1482
  if (dir <= 3) {
#line 1484
    mtag = start_gather_from_temp((void *)src, (int )sizeof(half_wilson_vector ),
                                  dir, 3, gen_pt[0]);
#line 1486
    wait_gather(mtag);
#line 1487
    i = 0;
#line 1487
    s = lattice;
#line 1487
    while (i < sites_on_node) {
#line 1488
      mult_su3_mat_hwvec(& s->link[dir], (half_wilson_vector *)*(gen_pt[0] + i), dest + i);
#line 1487
      i ++;
#line 1487
      s ++;
    }
#line 1490
    cleanup_gather(mtag);
  } else {
#line 1494
//AD    tmp = calloc((size_t )sites_on_node, sizeof(half_wilson_vector ));
#line 1494
//AD    tmpvec = (half_wilson_vector *)tmp;
    tmpvec = (half_wilson_vector *)calloc((size_t )sites_on_node, sizeof(half_wilson_vector )); //AD
#line 1496
    i = 0;
#line 1496
    s = lattice;
#line 1496
    while (i < sites_on_node) {
#line 1497
      mult_adj_su3_mat_hwvec(& s->link[7 - dir], src + i, tmpvec + i);
#line 1496
      i ++;
#line 1496
      s ++;
    }
#line 1498
    mtag = start_gather_from_temp((void *)tmpvec, (int )sizeof(half_wilson_vector ),
                                  dir, 3, gen_pt[0]);
#line 1500
    wait_gather(mtag);
#line 1502
    i = 0;
#line 1502
    s = lattice;
#line 1502
    while (i < sites_on_node) {
#line 1503
      *(dest + i) = *((half_wilson_vector *)*(gen_pt[0] + i));
#line 1502
      i ++;
#line 1502
      s ++;
    }
#line 1504
    cleanup_gather(mtag);
#line 1505
    free((void *)tmpvec);
  }
#line 1507
  return;
}
}
#line 1511 "quark_stuff.c"
void add_force_to_mom(su3_vector *back , su3_vector *forw , int dir , double coeff ) 
{ 
  register site *s ;
  register int i ;
  register double tmp_coeff ;
  su3_matrix tmat ;
  su3_matrix tmat2 ;

  {
#line 1518
  if (dir > 3) {
#line 1520
    dir = 7 - dir;
#line 1521
    coeff = - coeff;
  }
#line 1523
  i = 0;
#line 1523
  s = lattice;
#line 1523
  while (i < sites_on_node) {
#line 1524
    if ((int )s->parity == 1) {
#line 1525
      tmp_coeff = - coeff;
    } else {
#line 1527
      tmp_coeff = coeff;
    }
#line 1528
    uncompress_anti_hermitian(& s->mom[dir], & tmat2);
#line 1529
    su3_projector(back + i, forw + i, & tmat);
#line 1530
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff, & tmat2);
#line 1531
    make_anti_hermitian(& tmat2, & s->mom[dir]);
#line 1523
    i ++;
#line 1523
    s ++;
  }
#line 1533
  return;
}
}
#line 1537 "quark_stuff.c"
void add_3f_force_to_mom(half_wilson_vector *back , half_wilson_vector *forw , int dir ,
                         double *coeff ) 
{ 
  register site *s ;
  register int i ;
  double tmp_coeff[2] ;
  su3_matrix tmat ;
  su3_matrix tmat2 ;

  {
#line 1545
  if (dir > 3) {
#line 1547
    dir = 7 - dir;
#line 1548
    *(coeff + 0) = - *(coeff + 0);
#line 1549
    *(coeff + 1) = - *(coeff + 1);
  }
#line 1551
  i = 0;
#line 1551
  s = lattice;
#line 1551
  while (i < sites_on_node) {
#line 1552
    if ((int )s->parity == 1) {
#line 1554
      tmp_coeff[0] = - *(coeff + 0);
#line 1555
      tmp_coeff[1] = - *(coeff + 1);
    } else {
#line 1559
      tmp_coeff[0] = *(coeff + 0);
#line 1560
      tmp_coeff[1] = *(coeff + 1);
    }
#line 1562
    uncompress_anti_hermitian(& s->mom[dir], & tmat2);
#line 1563
    su3_projector(& (back + i)->h[0], & (forw + i)->h[0], & tmat);
#line 1564
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff[0], & tmat2);
#line 1565
    su3_projector(& (back + i)->h[1], & (forw + i)->h[1], & tmat);
#line 1566
    scalar_mult_add_su3_matrix(& tmat2, & tmat, tmp_coeff[1], & tmat2);
#line 1567
    make_anti_hermitian(& tmat2, & s->mom[dir]);
#line 1551
    i ++;
#line 1551
    s ++;
  }
#line 1569
  return;
}
}
#line 1579 "quark_stuff.c"
void side_link_force(int mu , int nu , double coeff , su3_vector *Path , su3_vector *Path_nu ,
                     su3_vector *Path_mu , su3_vector *Path_numu ) 
{ 


  {
#line 1582
  if (mu <= 3) {
#line 1589
    if (nu <= 3) {
#line 1590
      add_force_to_mom(Path_numu, Path, mu, coeff);
    } else {
#line 1592
      add_force_to_mom(Path, Path_numu, 7 - mu, - coeff);
    }
  } else
#line 1601
  if (nu <= 3) {
#line 1602
    add_force_to_mom(Path_nu, Path_mu, mu, - coeff);
  } else {
#line 1604
    add_force_to_mom(Path_mu, Path_nu, 7 - mu, coeff);
  }
#line 1606
  return;
}
}
#line 1610 "quark_stuff.c"
void side_link_3f_force(int mu , int nu , double *coeff , half_wilson_vector *Path ,
                        half_wilson_vector *Path_nu , half_wilson_vector *Path_mu ,
                        half_wilson_vector *Path_numu ) 
{ 
  double m_coeff[2] ;

  {
#line 1617
  m_coeff[0] = - *(coeff + 0);
#line 1618
  m_coeff[1] = - *(coeff + 1);
#line 1620
  if (mu <= 3) {
#line 1627
    if (nu <= 3) {
#line 1628
      add_3f_force_to_mom(Path_numu, Path, mu, coeff);
    } else {
#line 1630
      add_3f_force_to_mom(Path, Path_numu, 7 - mu, (double *)(m_coeff));
    }
  } else
#line 1639
  if (nu <= 3) {
#line 1640
    add_3f_force_to_mom(Path_nu, Path_mu, mu, (double *)(m_coeff));
  } else {
#line 1642
    add_3f_force_to_mom(Path_mu, Path_nu, 7 - mu, coeff);
  }
#line 1644
  return;
}
}
#line 1 "rephase.o"
#pragma merger("0","/tmp/cil-AFiC765b.i","")
#line 8 "rephase.c"
void phaseset(void) 
{ 
  register site *sit ;
  register int i ;

  {
#line 15
  i = 0;
#line 15
  sit = lattice;
#line 15
  while (i < sites_on_node) {
#line 16
    sit->phase[3] = 1.0;
#line 17
    if ((int )sit->t % 2 == 1) {
#line 17
      sit->phase[0] = - 1.0;
    } else {
#line 18
      sit->phase[0] = 1.0;
    }
#line 19
    if ((int )sit->x % 2 == 1) {
#line 19
      sit->phase[1] = - sit->phase[0];
    } else {
#line 20
      sit->phase[1] = sit->phase[0];
    }
#line 21
    if ((int )sit->y % 2 == 1) {
#line 21
      sit->phase[2] = - sit->phase[1];
    } else {
#line 22
      sit->phase[2] = sit->phase[1];
    }
#line 24
    if ((int )sit->t == nt - 1) {
#line 26
      sit->phase[3] = - sit->phase[3];
    }
#line 15
    i ++;
#line 15
    sit ++;
  }
#line 29
  return;
}
}
#line 34 "rephase.c"
void rephase(int flag ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int dir ;
  register site *s ;

  {
#line 38
  if (flag == 1) {
#line 38
    if (! (phases_in == 0)) {
#line 38
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 38
  if (flag == 0) {
#line 38
    if (! (phases_in == 1)) {
#line 38
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 39
    if (this_node == 0) {
#line 39
      printf((char const   * __restrict  )"DUMMY: you fouled up the phases\n");
    }
#line 40
    terminate(1);
  }
#line 42
  i = 0;
#line 42
  s = lattice;
#line 42
  while (i < sites_on_node) {
#line 43
    dir = 0;
#line 43
    while (dir <= 3) {
#line 44
      j = 0;
#line 44
      while (j < 3) {
#line 44
        k = 0;
#line 44
        while (k < 3) {
#line 45
          s->link[dir].e[j][k].real *= s->phase[dir];
#line 46
          s->link[dir].e[j][k].imag *= s->phase[dir];
#line 44
          k ++;
        }
#line 44
        j ++;
      }
#line 43
      dir ++;
    }
#line 42
    i ++;
#line 42
    s ++;
  }
#line 50
  phases_in = flag;
#line 51
  return;
}
}
#line 1 "cmplx.o"
#pragma merger("0","/tmp/cil-hgBrbIfy.i","")
#line 8 "cmplx.c"
complex cmplx(double x , double y ) 
{ 
  complex c ;

  {
#line 10
  c.real = x;
#line 10
  c.imag = y;
#line 11
  return (c);
}
}
#line 1 "addmat.o"
#pragma merger("0","/tmp/cil-ykgQ_V5q.i","")
#line 9 "addmat.c"
void add_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
#line 11
  i = 0;
#line 11
  while (i < 3) {
#line 11
    j = 0;
#line 11
    while (j < 3) {
#line 12
      c->e[i][j].real = a->e[i][j].real + b->e[i][j].real;
#line 12
      c->e[i][j].imag = a->e[i][j].imag + b->e[i][j].imag;
#line 11
      j ++;
    }
#line 11
    i ++;
  }
#line 14
  return;
}
}
#line 1 "addvec.o"
#pragma merger("0","/tmp/cil-uZX5PAUP.i","")
#line 408 "./su3.h"
void add_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) ;
#line 9 "addvec.c"
void add_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) 
{ 
  register int i ;

  {
#line 11
  i = 0;
#line 11
  while (i < 3) {
#line 12
    c->c[i].real = a->c[i].real + b->c[i].real;
#line 12
    c->c[i].imag = a->c[i].imag + b->c[i].imag;
#line 11
    i ++;
  }
#line 14
  return;
}
}
#line 1 "clear_mat.o"
#pragma merger("0","/tmp/cil-5ayKdvRg.i","")
#line 11 "clear_mat.c"
void clear_su3mat(su3_matrix *dest ) 
{ 
  register int i ;
  register int j ;
  double tmp ;

  {
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 13
    j = 0;
#line 13
    while (j < 3) {
#line 14
      tmp = 0.0;
#line 14
      dest->e[i][j].imag = tmp;
#line 14
      dest->e[i][j].real = tmp;
#line 13
      j ++;
    }
#line 13
    i ++;
  }
#line 16
  return;
}
}
#line 1 "clearvec.o"
#pragma merger("0","/tmp/cil-ZURcI1Np.i","")
#line 10 "clearvec.c"
void clearvec(su3_vector *v ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 11
  tmp = 0.0;
#line 11
  v->c[0].imag = tmp;
#line 11
  v->c[0].real = tmp;
#line 12
  tmp___0 = 0.0;
#line 12
  v->c[1].imag = tmp___0;
#line 12
  v->c[1].real = tmp___0;
#line 13
  tmp___1 = 0.0;
#line 13
  v->c[2].imag = tmp___1;
#line 13
  v->c[2].real = tmp___1;
#line 14
  return;
}
}
#line 1 "m_amatvec.o"
#pragma merger("0","/tmp/cil-rAj5jJkv.i","")
#line 111 "m_amatvec.c"
void mult_adj_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) 
{ 
  int i ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
#line 114
  i = 0;
#line 114
  while (i < 3) {
#line 116
    ar = a->e[0][i].real;
#line 116
    ai = a->e[0][i].imag;
#line 117
    br = b->c[0].real;
#line 117
    bi = b->c[0].imag;
#line 118
    cr = ar * br;
#line 118
    t = ai * bi;
#line 118
    cr += t;
#line 119
    ci = ar * bi;
#line 119
    t = ai * br;
#line 119
    ci -= t;
#line 121
    ar = a->e[1][i].real;
#line 121
    ai = a->e[1][i].imag;
#line 122
    br = b->c[1].real;
#line 122
    bi = b->c[1].imag;
#line 123
    t = ar * br;
#line 123
    cr += t;
#line 123
    t = ai * bi;
#line 123
    cr += t;
#line 124
    t = ar * bi;
#line 124
    ci += t;
#line 124
    t = ai * br;
#line 124
    ci -= t;
#line 126
    ar = a->e[2][i].real;
#line 126
    ai = a->e[2][i].imag;
#line 127
    br = b->c[2].real;
#line 127
    bi = b->c[2].imag;
#line 128
    t = ar * br;
#line 128
    cr += t;
#line 128
    t = ai * bi;
#line 128
    cr += t;
#line 129
    t = ar * bi;
#line 129
    ci += t;
#line 129
    t = ai * br;
#line 129
    ci -= t;
#line 131
    c->c[i].real = cr;
#line 132
    c->c[i].imag = ci;
#line 114
    i ++;
  }
#line 134
  return;
}
}
#line 1 "m_mat_an.o"
#pragma merger("0","/tmp/cil-EPmsqbNl.i","")
#line 28 "m_mat_an.c"
void mult_su3_an(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int j ;
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
#line 39
  j = 0;
#line 39
  while (j < 3) {
#line 41
    a0r = a->e[0][0].real;
#line 41
    a0i = a->e[0][0].imag;
#line 42
    b0r = b->e[0][j].real;
#line 42
    b0i = b->e[0][j].imag;
#line 43
    a1r = a->e[1][0].real;
#line 43
    a1i = a->e[1][0].imag;
#line 44
    b1r = b->e[1][j].real;
#line 44
    b1i = b->e[1][j].imag;
#line 45
    a2r = a->e[2][0].real;
#line 45
    a2i = a->e[2][0].imag;
#line 46
    b2r = b->e[2][j].real;
#line 46
    b2i = b->e[2][j].imag;
#line 48
    c->e[0][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 49
    c->e[0][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 51
    a0r = a->e[0][1].real;
#line 51
    a0i = a->e[0][1].imag;
#line 52
    b0r = b->e[0][j].real;
#line 52
    b0i = b->e[0][j].imag;
#line 53
    a1r = a->e[1][1].real;
#line 53
    a1i = a->e[1][1].imag;
#line 54
    b1r = b->e[1][j].real;
#line 54
    b1i = b->e[1][j].imag;
#line 55
    a2r = a->e[2][1].real;
#line 55
    a2i = a->e[2][1].imag;
#line 56
    b2r = b->e[2][j].real;
#line 56
    b2i = b->e[2][j].imag;
#line 58
    c->e[1][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 59
    c->e[1][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 61
    a0r = a->e[0][2].real;
#line 61
    a0i = a->e[0][2].imag;
#line 62
    b0r = b->e[0][j].real;
#line 62
    b0i = b->e[0][j].imag;
#line 63
    a1r = a->e[1][2].real;
#line 63
    a1i = a->e[1][2].imag;
#line 64
    b1r = b->e[1][j].real;
#line 64
    b1i = b->e[1][j].imag;
#line 65
    a2r = a->e[2][2].real;
#line 65
    a2i = a->e[2][2].imag;
#line 66
    b2r = b->e[2][j].real;
#line 66
    b2i = b->e[2][j].imag;
#line 68
    c->e[2][j].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 69
    c->e[2][j].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 39
    j ++;
  }
#line 72
  return;
}
}
#line 1 "m_mat_na.o"
#pragma merger("0","/tmp/cil-2LtZp4Ez.i","")
#line 28 "m_mat_na.c"
void mult_su3_na(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int i ;
  int j ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
#line 31
  i = 0;
#line 31
  while (i < 3) {
#line 31
    j = 0;
#line 31
    while (j < 3) {
#line 33
      ar = a->e[i][0].real;
#line 33
      ai = a->e[i][0].imag;
#line 34
      br = b->e[j][0].real;
#line 34
      bi = b->e[j][0].imag;
#line 35
      cr = ar * br;
#line 35
      t = ai * bi;
#line 35
      cr += t;
#line 36
      ci = ai * br;
#line 36
      t = ar * bi;
#line 36
      ci -= t;
#line 38
      ar = a->e[i][1].real;
#line 38
      ai = a->e[i][1].imag;
#line 39
      br = b->e[j][1].real;
#line 39
      bi = b->e[j][1].imag;
#line 40
      t = ar * br;
#line 40
      cr += t;
#line 40
      t = ai * bi;
#line 40
      cr += t;
#line 41
      t = ar * bi;
#line 41
      ci -= t;
#line 41
      t = ai * br;
#line 41
      ci += t;
#line 43
      ar = a->e[i][2].real;
#line 43
      ai = a->e[i][2].imag;
#line 44
      br = b->e[j][2].real;
#line 44
      bi = b->e[j][2].imag;
#line 45
      t = ar * br;
#line 45
      cr += t;
#line 45
      t = ai * bi;
#line 45
      cr += t;
#line 46
      t = ar * bi;
#line 46
      ci -= t;
#line 46
      t = ai * br;
#line 46
      ci += t;
#line 48
      c->e[i][j].real = cr;
#line 49
      c->e[i][j].imag = ci;
#line 31
      j ++;
    }
#line 31
    i ++;
  }
#line 51
  return;
}
}
#line 1 "m_mat_nn.o"
#pragma merger("0","/tmp/cil-kAtb4zUn.i","")
#line 70 "m_mat_nn.c"
void mult_su3_nn(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  int i ;
  int j ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
#line 73
  i = 0;
#line 73
  while (i < 3) {
#line 73
    j = 0;
#line 73
    while (j < 3) {
#line 75
      ar = a->e[i][0].real;
#line 75
      ai = a->e[i][0].imag;
#line 76
      br = b->e[0][j].real;
#line 76
      bi = b->e[0][j].imag;
#line 77
      cr = ar * br;
#line 77
      t = ai * bi;
#line 77
      cr -= t;
#line 78
      ci = ar * bi;
#line 78
      t = ai * br;
#line 78
      ci += t;
#line 80
      ar = a->e[i][1].real;
#line 80
      ai = a->e[i][1].imag;
#line 81
      br = b->e[1][j].real;
#line 81
      bi = b->e[1][j].imag;
#line 82
      t = ar * br;
#line 82
      cr += t;
#line 82
      t = ai * bi;
#line 82
      cr -= t;
#line 83
      t = ar * bi;
#line 83
      ci += t;
#line 83
      t = ai * br;
#line 83
      ci += t;
#line 85
      ar = a->e[i][2].real;
#line 85
      ai = a->e[i][2].imag;
#line 86
      br = b->e[2][j].real;
#line 86
      bi = b->e[2][j].imag;
#line 87
      t = ar * br;
#line 87
      cr += t;
#line 87
      t = ai * bi;
#line 87
      cr -= t;
#line 88
      t = ar * bi;
#line 88
      ci += t;
#line 88
      t = ai * br;
#line 88
      ci += t;
#line 90
      c->e[i][j].real = cr;
#line 91
      c->e[i][j].imag = ci;
#line 73
      j ++;
    }
#line 73
    i ++;
  }
#line 93
  return;
}
}
#line 1 "m_matvec.o"
#pragma merger("0","/tmp/cil-TsNVs7Iv.i","")
#line 64 "m_matvec.c"
void mult_su3_mat_vec(su3_matrix *a , su3_vector *b , su3_vector *c ) 
{ 
  int i ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
#line 67
  i = 0;
#line 67
  while (i < 3) {
#line 69
    ar = a->e[i][0].real;
#line 69
    ai = a->e[i][0].imag;
#line 70
    br = b->c[0].real;
#line 70
    bi = b->c[0].imag;
#line 71
    cr = ar * br;
#line 71
    t = ai * bi;
#line 71
    cr -= t;
#line 72
    ci = ar * bi;
#line 72
    t = ai * br;
#line 72
    ci += t;
#line 74
    ar = a->e[i][1].real;
#line 74
    ai = a->e[i][1].imag;
#line 75
    br = b->c[1].real;
#line 75
    bi = b->c[1].imag;
#line 76
    t = ar * br;
#line 76
    cr += t;
#line 76
    t = ai * bi;
#line 76
    cr -= t;
#line 77
    t = ar * bi;
#line 77
    ci += t;
#line 77
    t = ai * br;
#line 77
    ci += t;
#line 79
    ar = a->e[i][2].real;
#line 79
    ai = a->e[i][2].imag;
#line 80
    br = b->c[2].real;
#line 80
    bi = b->c[2].imag;
#line 81
    t = ar * br;
#line 81
    cr += t;
#line 81
    t = ai * bi;
#line 81
    cr -= t;
#line 82
    t = ar * bi;
#line 82
    ci += t;
#line 82
    t = ai * br;
#line 82
    ci += t;
#line 84
    c->c[i].real = cr;
#line 85
    c->c[i].imag = ci;
#line 67
    i ++;
  }
#line 87
  return;
}
}
#line 1 "make_ahmat.o"
#pragma merger("0","/tmp/cil-56OVKgq4.i","")
#line 30 "make_ahmat.c"
void make_anti_hermitian(su3_matrix *m3 , anti_hermitmat *ah3 ) 
{ 
  double temp___0 ;
  double temp2 ;

  {
#line 33
  temp___0 = m3->e[0][0].imag + m3->e[1][1].imag;
#line 35
  temp2 = temp___0 + m3->e[2][2].imag;
#line 36
  temp___0 = temp2 * 0.33333333;
#line 37
  ah3->m00im = m3->e[0][0].imag - temp___0;
#line 38
  ah3->m11im = m3->e[1][1].imag - temp___0;
#line 39
  ah3->m22im = m3->e[2][2].imag - temp___0;
#line 40
  temp___0 = m3->e[0][1].real - m3->e[1][0].real;
#line 40
  ah3->m01.real = temp___0 * 0.5;
#line 41
  temp___0 = m3->e[0][2].real - m3->e[2][0].real;
#line 41
  ah3->m02.real = temp___0 * 0.5;
#line 42
  temp___0 = m3->e[1][2].real - m3->e[2][1].real;
#line 42
  ah3->m12.real = temp___0 * 0.5;
#line 43
  temp___0 = m3->e[0][1].imag + m3->e[1][0].imag;
#line 43
  ah3->m01.imag = temp___0 * 0.5;
#line 44
  temp___0 = m3->e[0][2].imag + m3->e[2][0].imag;
#line 44
  ah3->m02.imag = temp___0 * 0.5;
#line 45
  temp___0 = m3->e[1][2].imag + m3->e[2][1].imag;
#line 45
  ah3->m12.imag = temp___0 * 0.5;
#line 47
  return;
}
}
#line 1 "rand_ahmat.o"
#pragma merger("0","/tmp/cil-GVbfjkh0.i","")
#line 14 "rand_ahmat.c"
void random_anti_hermitian(anti_hermitmat *mat_antihermit , double_prn *prn_pt ) 
{ 
  double r3 ;
  double r8 ;
  double sqrt_third ;

  {
#line 18
  sqrt_third = sqrt(1.0 / 3.0);
#line 19
  r3 = gaussian_rand_no(prn_pt);
#line 20
  r8 = gaussian_rand_no(prn_pt);
#line 21
  mat_antihermit->m00im = r3 + sqrt_third * r8;
#line 22
  mat_antihermit->m11im = - r3 + sqrt_third * r8;
#line 23
  mat_antihermit->m22im = (- 2.0 * sqrt_third) * r8;
#line 24
  mat_antihermit->m01.real = gaussian_rand_no(prn_pt);
#line 25
  mat_antihermit->m02.real = gaussian_rand_no(prn_pt);
#line 26
  mat_antihermit->m12.real = gaussian_rand_no(prn_pt);
#line 27
  mat_antihermit->m01.imag = gaussian_rand_no(prn_pt);
#line 28
  mat_antihermit->m02.imag = gaussian_rand_no(prn_pt);
#line 29
  mat_antihermit->m12.imag = gaussian_rand_no(prn_pt);
#line 31
  return;
}
}
#line 1 "realtr.o"
#pragma merger("0","/tmp/cil-Ku5MK9T9.i","")
#line 10 "realtr.c"
double realtrace_su3(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;
  register double sum ;

  {
#line 13
  sum = 0.0;
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 13
    j = 0;
#line 13
    while (j < 3) {
#line 14
      sum += a->e[i][j].real * b->e[i][j].real + a->e[i][j].imag * b->e[i][j].imag;
#line 13
      j ++;
    }
#line 13
    i ++;
  }
#line 15
  return (sum);
}
}
#line 1 "s_m_a_mat.o"
#pragma merger("0","/tmp/cil-sLfxzGaB.i","")
#line 12 "s_m_a_mat.c"
void scalar_mult_add_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
#line 17
  i = 0;
#line 17
  while (i < 3) {
#line 17
    j = 0;
#line 17
    while (j < 3) {
#line 18
      c->e[i][j].real = a->e[i][j].real + s * b->e[i][j].real;
#line 19
      c->e[i][j].imag = a->e[i][j].imag + s * b->e[i][j].imag;
#line 17
      j ++;
    }
#line 17
    i ++;
  }
#line 50
  return;
}
}
#line 1 "s_m_a_vec.o"
#pragma merger("0","/tmp/cil-EeRFQGLD.i","")
#line 13 "s_m_a_vec.c"
void scalar_mult_add_su3_vector(su3_vector *a , su3_vector *b , double s , su3_vector *c ) 
{ 
  register int i ;

  {
#line 18
  i = 0;
#line 18
  while (i < 3) {
#line 19
    c->c[i].real = a->c[i].real + s * b->c[i].real;
#line 20
    c->c[i].imag = a->c[i].imag + s * b->c[i].imag;
#line 18
    i ++;
  }
#line 37
  return;
}
}
#line 1 "s_m_s_mat.o"
#pragma merger("0","/tmp/cil-U4Mmw8zS.i","")
#line 12 "s_m_s_mat.c"
void scalar_mult_sub_su3_matrix(su3_matrix *a , su3_matrix *b , double s , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
#line 17
  i = 0;
#line 17
  while (i < 3) {
#line 17
    j = 0;
#line 17
    while (j < 3) {
#line 18
      c->e[i][j].real = a->e[i][j].real - s * b->e[i][j].real;
#line 19
      c->e[i][j].imag = a->e[i][j].imag - s * b->e[i][j].imag;
#line 17
      j ++;
    }
#line 17
    i ++;
  }
#line 50
  return;
}
}
#line 1 "s_m_vec.o"
#pragma merger("0","/tmp/cil-RMTnHIMM.i","")
#line 11 "s_m_vec.c"
void scalar_mult_su3_vector(su3_vector *a , double s , su3_vector *c ) 
{ 
  register int i ;

  {
#line 15
  i = 0;
#line 15
  while (i < 3) {
#line 16
    c->c[i].real = s * a->c[i].real;
#line 17
    c->c[i].imag = s * a->c[i].imag;
#line 15
    i ++;
  }
#line 34
  return;
}
}
#line 1 "s_m_mat.o"
#pragma merger("0","/tmp/cil-Y62nfhlX.i","")
#line 11 "s_m_mat.c"
void scalar_mult_su3_matrix(su3_matrix *a , double s , su3_matrix *b ) 
{ 
  register double ss ;

  {
#line 27
  ss = s;
#line 29
  b->e[0][0].real = ss * a->e[0][0].real;
#line 30
  b->e[0][0].imag = ss * a->e[0][0].imag;
#line 31
  b->e[0][1].real = ss * a->e[0][1].real;
#line 32
  b->e[0][1].imag = ss * a->e[0][1].imag;
#line 33
  b->e[0][2].real = ss * a->e[0][2].real;
#line 34
  b->e[0][2].imag = ss * a->e[0][2].imag;
#line 36
  b->e[1][0].real = ss * a->e[1][0].real;
#line 37
  b->e[1][0].imag = ss * a->e[1][0].imag;
#line 38
  b->e[1][1].real = ss * a->e[1][1].real;
#line 39
  b->e[1][1].imag = ss * a->e[1][1].imag;
#line 40
  b->e[1][2].real = ss * a->e[1][2].real;
#line 41
  b->e[1][2].imag = ss * a->e[1][2].imag;
#line 43
  b->e[2][0].real = ss * a->e[2][0].real;
#line 44
  b->e[2][0].imag = ss * a->e[2][0].imag;
#line 45
  b->e[2][1].real = ss * a->e[2][1].real;
#line 46
  b->e[2][1].imag = ss * a->e[2][1].imag;
#line 47
  b->e[2][2].real = ss * a->e[2][2].real;
#line 48
  b->e[2][2].imag = ss * a->e[2][2].imag;
#line 51
  return;
}
}
#line 1 "su3_adjoint.o"
#pragma merger("0","/tmp/cil-zX1fHnnN.i","")
#line 11 "su3_adjoint.c"
void su3_adjoint(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;

  {
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 13
    j = 0;
#line 13
    while (j < 3) {
#line 14
      b->e[i][j].real = a->e[j][i].real;
#line 14
      b->e[i][j].imag = - a->e[j][i].imag;
#line 13
      j ++;
    }
#line 13
    i ++;
  }
#line 16
  return;
}
}
#line 1 "su3_dot.o"
#pragma merger("0","/tmp/cil-Q8ai1ZzA.i","")
#line 10 "su3_dot.c"
complex su3_dot(su3_vector *a , su3_vector *b ) 
{ 
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;
  register complex cc ;

  {
#line 30
  ar = a->c[0].real;
#line 30
  ai = a->c[0].imag;
#line 31
  br = b->c[0].real;
#line 31
  bi = b->c[0].imag;
#line 32
  cr = ar * br + ai * bi;
#line 33
  ci = ar * bi - ai * br;
#line 35
  ar = a->c[1].real;
#line 35
  ai = a->c[1].imag;
#line 36
  br = b->c[1].real;
#line 36
  bi = b->c[1].imag;
#line 37
  cr += ar * br + ai * bi;
#line 38
  ci += ar * bi - ai * br;
#line 40
  ar = a->c[2].real;
#line 40
  ai = a->c[2].imag;
#line 41
  br = b->c[2].real;
#line 41
  bi = b->c[2].imag;
#line 42
  cr += ar * br + ai * bi;
#line 43
  ci += ar * bi - ai * br;
#line 45
  cc.real = cr;
#line 46
  cc.imag = ci;
#line 47
  return (cc);
}
}
#line 1 "su3_rdot.o"
#pragma merger("0","/tmp/cil-Qsvn1ICU.i","")
#line 389 "./su3.h"
double su3_rdot(su3_vector *a , su3_vector *b ) ;
#line 10 "su3_rdot.c"
double su3_rdot(su3_vector *a , su3_vector *b ) 
{ 
  register double temp1 ;
  register double temp2 ;

  {
#line 14
  temp2 = a->c[0].real * b->c[0].real;
#line 15
  temp1 = a->c[0].imag * b->c[0].imag;
#line 15
  temp2 += temp1;
#line 16
  temp1 = a->c[1].real * b->c[1].real;
#line 16
  temp2 += temp1;
#line 17
  temp1 = a->c[1].imag * b->c[1].imag;
#line 17
  temp2 += temp1;
#line 18
  temp1 = a->c[2].real * b->c[2].real;
#line 18
  temp2 += temp1;
#line 19
  temp1 = a->c[2].imag * b->c[2].imag;
#line 19
  temp2 += temp1;
#line 20
  return (temp2);
}
}
#line 1 "su3_proj.o"
#pragma merger("0","/tmp/cil-Qv5w4nbp.i","")
#line 38 "su3_proj.c"
void su3_projector(su3_vector *a , su3_vector *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;
  register double tmp ;
  register double tmp2 ;

  {
#line 41
  i = 0;
#line 41
  while (i < 3) {
#line 41
    j = 0;
#line 41
    while (j < 3) {
#line 42
      tmp2 = a->c[i].real * b->c[j].real;
#line 43
      tmp = a->c[i].imag * b->c[j].imag;
#line 44
      c->e[i][j].real = tmp + tmp2;
#line 45
      tmp2 = a->c[i].real * b->c[j].imag;
#line 46
      tmp = a->c[i].imag * b->c[j].real;
#line 47
      c->e[i][j].imag = tmp - tmp2;
#line 41
      j ++;
    }
#line 41
    i ++;
  }
#line 49
  return;
}
}
#line 1 "su3mat_copy.o"
#pragma merger("0","/tmp/cil-R4mN_X6C.i","")
#line 11 "su3mat_copy.c"
void su3mat_copy(su3_matrix *a , su3_matrix *b ) 
{ 
  register int i ;
  register int j ;

  {
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 13
    j = 0;
#line 13
    while (j < 3) {
#line 14
      b->e[i][j].real = a->e[i][j].real;
#line 15
      b->e[i][j].imag = a->e[i][j].imag;
#line 13
      j ++;
    }
#line 13
    i ++;
  }
#line 17
  return;
}
}
#line 1 "submat.o"
#pragma merger("0","/tmp/cil-n63jlqkM.i","")
#line 11 "submat.c"
void sub_su3_matrix(su3_matrix *a , su3_matrix *b , su3_matrix *c ) 
{ 
  register int i ;
  register int j ;

  {
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 13
    j = 0;
#line 13
    while (j < 3) {
#line 14
      c->e[i][j].real = a->e[i][j].real - b->e[i][j].real;
#line 14
      c->e[i][j].imag = a->e[i][j].imag - b->e[i][j].imag;
#line 13
      j ++;
    }
#line 13
    i ++;
  }
#line 16
  return;
}
}
#line 1 "subvec.o"
#pragma merger("0","/tmp/cil-pkiYqrhx.i","")
#line 11 "subvec.c"
void sub_su3_vector(su3_vector *a , su3_vector *b , su3_vector *c ) 
{ 
  register int i ;

  {
#line 13
  i = 0;
#line 13
  while (i < 3) {
#line 14
    c->c[i].real = a->c[i].real - b->c[i].real;
#line 14
    c->c[i].imag = a->c[i].imag - b->c[i].imag;
#line 13
    i ++;
  }
#line 16
  return;
}
}
#line 1 "trace_su3.o"
#pragma merger("0","/tmp/cil-irOfthIJ.i","")
#line 11 "trace_su3.c"
complex trace_su3(su3_matrix *a ) 
{ 
  register complex t1 ;
  register complex t2 ;

  {
#line 13
  t1.real = a->e[0][0].real + a->e[1][1].real;
#line 13
  t1.imag = a->e[0][0].imag + a->e[1][1].imag;
#line 14
  t2.real = t1.real + a->e[2][2].real;
#line 14
  t2.imag = t1.imag + a->e[2][2].imag;
#line 15
  return (t2);
}
}
#line 1 "uncmp_ahmat.o"
#pragma merger("0","/tmp/cil-sTl3EYib.i","")
#line 11 "uncmp_ahmat.c"
void uncompress_anti_hermitian(anti_hermitmat *mat_antihermit , su3_matrix *mat_su3 ) 
{ 
  double temp1 ;

  {
#line 15
  mat_su3->e[0][0].imag = mat_antihermit->m00im;
#line 16
  mat_su3->e[0][0].real = 0.;
#line 17
  mat_su3->e[1][1].imag = mat_antihermit->m11im;
#line 18
  mat_su3->e[1][1].real = 0.;
#line 19
  mat_su3->e[2][2].imag = mat_antihermit->m22im;
#line 20
  mat_su3->e[2][2].real = 0.;
#line 21
  mat_su3->e[0][1].imag = mat_antihermit->m01.imag;
#line 22
  temp1 = mat_antihermit->m01.real;
#line 23
  mat_su3->e[0][1].real = temp1;
#line 24
  mat_su3->e[1][0].real = - temp1;
#line 25
  mat_su3->e[1][0].imag = mat_antihermit->m01.imag;
#line 26
  mat_su3->e[0][2].imag = mat_antihermit->m02.imag;
#line 27
  temp1 = mat_antihermit->m02.real;
#line 28
  mat_su3->e[0][2].real = temp1;
#line 29
  mat_su3->e[2][0].real = - temp1;
#line 30
  mat_su3->e[2][0].imag = mat_antihermit->m02.imag;
#line 31
  mat_su3->e[1][2].imag = mat_antihermit->m12.imag;
#line 32
  temp1 = mat_antihermit->m12.real;
#line 33
  mat_su3->e[1][2].real = temp1;
#line 34
  mat_su3->e[2][1].real = - temp1;
#line 35
  mat_su3->e[2][1].imag = mat_antihermit->m12.imag;
#line 36
  return;
}
}
#line 1 "msq_su3vec.o"
#pragma merger("0","/tmp/cil-ASjuBzxs.i","")
#line 38 "msq_su3vec.c"
double magsq_su3vec(su3_vector *a ) 
{ 
  register double temp___0 ;
  register double sum ;

  {
#line 40
  sum = 0.0;
#line 41
  temp___0 = a->c[0].real * a->c[0].real;
#line 41
  sum += temp___0;
#line 42
  temp___0 = a->c[0].imag * a->c[0].imag;
#line 42
  sum += temp___0;
#line 43
  temp___0 = a->c[1].real * a->c[1].real;
#line 43
  sum += temp___0;
#line 44
  temp___0 = a->c[1].imag * a->c[1].imag;
#line 44
  sum += temp___0;
#line 45
  temp___0 = a->c[2].real * a->c[2].real;
#line 45
  sum += temp___0;
#line 46
  temp___0 = a->c[2].imag * a->c[2].imag;
#line 46
  sum += temp___0;
#line 47
  return (sum);
}
}
#line 1 "sub4vecs.o"
#pragma merger("0","/tmp/cil-k1nhDiZf.i","")
#line 410 "./su3.h"
void sub_four_su3_vecs(su3_vector *a , su3_vector *b1 , su3_vector *b2 , su3_vector *b3 ,
                       su3_vector *b4 ) ;
#line 24 "sub4vecs.c"
void sub_four_su3_vecs(su3_vector *a , su3_vector *b1 , su3_vector *b2 , su3_vector *b3 ,
                       su3_vector *b4 ) 
{ 


  {
#line 26
  a->c[0].real -= b1->c[0].real;
#line 26
  a->c[0].imag -= b1->c[0].imag;
#line 27
  a->c[1].real -= b1->c[1].real;
#line 27
  a->c[1].imag -= b1->c[1].imag;
#line 28
  a->c[2].real -= b1->c[2].real;
#line 28
  a->c[2].imag -= b1->c[2].imag;
#line 29
  a->c[0].real -= b2->c[0].real;
#line 29
  a->c[0].imag -= b2->c[0].imag;
#line 30
  a->c[1].real -= b2->c[1].real;
#line 30
  a->c[1].imag -= b2->c[1].imag;
#line 31
  a->c[2].real -= b2->c[2].real;
#line 31
  a->c[2].imag -= b2->c[2].imag;
#line 32
  a->c[0].real -= b3->c[0].real;
#line 32
  a->c[0].imag -= b3->c[0].imag;
#line 33
  a->c[1].real -= b3->c[1].real;
#line 33
  a->c[1].imag -= b3->c[1].imag;
#line 34
  a->c[2].real -= b3->c[2].real;
#line 34
  a->c[2].imag -= b3->c[2].imag;
#line 35
  a->c[0].real -= b4->c[0].real;
#line 35
  a->c[0].imag -= b4->c[0].imag;
#line 36
  a->c[1].real -= b4->c[1].real;
#line 36
  a->c[1].imag -= b4->c[1].imag;
#line 37
  a->c[2].real -= b4->c[2].real;
#line 37
  a->c[2].imag -= b4->c[2].imag;
#line 38
  return;
}
}
#line 1 "m_amv_4dir.o"
#pragma merger("0","/tmp/cil-3qbyYk0E.i","")
#line 401 "./su3.h"
void mult_adj_su3_mat_vec_4dir(su3_matrix *mat , su3_vector *src , su3_vector *dest ) ;
#line 25 "m_amv_4dir.c"
void mult_adj_su3_mat_vec_4dir(su3_matrix *mat , su3_vector *src , su3_vector *dest ) 
{ 
  register int n ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double br ;
  register double bi ;
  register double a0 ;
  register double a1 ;
  register double a2 ;
  register su3_matrix *a ;
  register su3_vector *b ;
  register su3_vector *c ;

  {
#line 38
  a = mat;
#line 38
  c = dest;
#line 38
  b = src;
#line 39
  n = 0;
#line 39
  while (n < 4) {
#line 41
    br = b->c[0].real;
#line 41
    bi = b->c[0].imag;
#line 42
    a0 = a->e[0][0].real;
#line 43
    a1 = a->e[0][1].real;
#line 44
    a2 = a->e[0][2].real;
#line 46
    c0r = a0 * br;
#line 47
    c1r = a1 * br;
#line 48
    c2r = a2 * br;
#line 49
    c0i = a0 * bi;
#line 50
    c1i = a1 * bi;
#line 51
    c2i = a2 * bi;
#line 53
    a0 = a->e[0][0].imag;
#line 54
    a1 = a->e[0][1].imag;
#line 55
    a2 = a->e[0][2].imag;
#line 57
    c0r += a0 * bi;
#line 58
    c1r += a1 * bi;
#line 59
    c2r += a2 * bi;
#line 60
    c0i -= a0 * br;
#line 61
    c1i -= a1 * br;
#line 62
    c2i -= a2 * br;
#line 64
    br = b->c[1].real;
#line 64
    bi = b->c[1].imag;
#line 65
    a0 = a->e[1][0].real;
#line 66
    a1 = a->e[1][1].real;
#line 67
    a2 = a->e[1][2].real;
#line 69
    c0r += a0 * br;
#line 70
    c1r += a1 * br;
#line 71
    c2r += a2 * br;
#line 72
    c0i += a0 * bi;
#line 73
    c1i += a1 * bi;
#line 74
    c2i += a2 * bi;
#line 76
    a0 = a->e[1][0].imag;
#line 77
    a1 = a->e[1][1].imag;
#line 78
    a2 = a->e[1][2].imag;
#line 80
    c0r += a0 * bi;
#line 81
    c1r += a1 * bi;
#line 82
    c2r += a2 * bi;
#line 83
    c0i -= a0 * br;
#line 84
    c1i -= a1 * br;
#line 85
    c2i -= a2 * br;
#line 87
    br = b->c[2].real;
#line 87
    bi = b->c[2].imag;
#line 88
    a0 = a->e[2][0].real;
#line 89
    a1 = a->e[2][1].real;
#line 90
    a2 = a->e[2][2].real;
#line 92
    c0r += a0 * br;
#line 93
    c1r += a1 * br;
#line 94
    c2r += a2 * br;
#line 95
    c0i += a0 * bi;
#line 96
    c1i += a1 * bi;
#line 97
    c2i += a2 * bi;
#line 99
    a0 = a->e[2][0].imag;
#line 100
    a1 = a->e[2][1].imag;
#line 101
    a2 = a->e[2][2].imag;
#line 103
    c0r += a0 * bi;
#line 104
    c1r += a1 * bi;
#line 105
    c2r += a2 * bi;
#line 106
    c0i -= a0 * br;
#line 107
    c1i -= a1 * br;
#line 108
    c2i -= a2 * br;
#line 110
    c->c[0].real = c0r;
#line 111
    c->c[0].imag = c0i;
#line 112
    c->c[1].real = c1r;
#line 113
    c->c[1].imag = c1i;
#line 114
    c->c[2].real = c2r;
#line 115
    c->c[2].imag = c2i;
#line 39
    n ++;
#line 39
    a ++;
#line 39
    c ++;
  }
#line 117
  return;
}
}
#line 1 "m_amv_4vec.o"
#pragma merger("0","/tmp/cil-3cseUHDu.i","")
#line 402 "./su3.h"
void mult_adj_su3_mat_4vec(su3_matrix *mat , su3_vector *src , su3_vector *dest0 ,
                           su3_vector *dest1 , su3_vector *dest2 , su3_vector *dest3 ) ;
#line 26 "m_amv_4vec.c"
void mult_adj_su3_mat_4vec(su3_matrix *mat , su3_vector *src , su3_vector *dest0 ,
                           su3_vector *dest1 , su3_vector *dest2 , su3_vector *dest3 ) 
{ 
  register int n ;
  register double c0r ;
  register double c0i ;
  register double c1r ;
  register double c1i ;
  register double c2r ;
  register double c2i ;
  register double br ;
  register double bi ;
  register double a0 ;
  register double a1 ;
  register double a2 ;
  register su3_matrix *a ;
  register su3_vector *b ;
  register su3_vector *c ;
  su3_vector *cc[4] ;

  {
#line 41
  cc[0] = dest0;
#line 41
  cc[1] = dest1;
#line 42
  cc[2] = dest2;
#line 42
  cc[3] = dest3;
#line 44
  a = mat;
#line 44
  c = dest0;
#line 44
  b = src;
#line 46
  n = 0;
#line 46
  while (n < 4) {
#line 47
    c = cc[n];
#line 49
    br = b->c[0].real;
#line 49
    bi = b->c[0].imag;
#line 50
    a0 = a->e[0][0].real;
#line 51
    a1 = a->e[0][1].real;
#line 52
    a2 = a->e[0][2].real;
#line 54
    c0r = a0 * br;
#line 55
    c1r = a1 * br;
#line 56
    c2r = a2 * br;
#line 57
    c0i = a0 * bi;
#line 58
    c1i = a1 * bi;
#line 59
    c2i = a2 * bi;
#line 61
    a0 = a->e[0][0].imag;
#line 62
    a1 = a->e[0][1].imag;
#line 63
    a2 = a->e[0][2].imag;
#line 65
    c0r += a0 * bi;
#line 66
    c1r += a1 * bi;
#line 67
    c2r += a2 * bi;
#line 68
    c0i -= a0 * br;
#line 69
    c1i -= a1 * br;
#line 70
    c2i -= a2 * br;
#line 72
    br = b->c[1].real;
#line 72
    bi = b->c[1].imag;
#line 73
    a0 = a->e[1][0].real;
#line 74
    a1 = a->e[1][1].real;
#line 75
    a2 = a->e[1][2].real;
#line 77
    c0r += a0 * br;
#line 78
    c1r += a1 * br;
#line 79
    c2r += a2 * br;
#line 80
    c0i += a0 * bi;
#line 81
    c1i += a1 * bi;
#line 82
    c2i += a2 * bi;
#line 84
    a0 = a->e[1][0].imag;
#line 85
    a1 = a->e[1][1].imag;
#line 86
    a2 = a->e[1][2].imag;
#line 88
    c0r += a0 * bi;
#line 89
    c1r += a1 * bi;
#line 90
    c2r += a2 * bi;
#line 91
    c0i -= a0 * br;
#line 92
    c1i -= a1 * br;
#line 93
    c2i -= a2 * br;
#line 95
    br = b->c[2].real;
#line 95
    bi = b->c[2].imag;
#line 96
    a0 = a->e[2][0].real;
#line 97
    a1 = a->e[2][1].real;
#line 98
    a2 = a->e[2][2].real;
#line 100
    c0r += a0 * br;
#line 101
    c1r += a1 * br;
#line 102
    c2r += a2 * br;
#line 103
    c0i += a0 * bi;
#line 104
    c1i += a1 * bi;
#line 105
    c2i += a2 * bi;
#line 107
    a0 = a->e[2][0].imag;
#line 108
    a1 = a->e[2][1].imag;
#line 109
    a2 = a->e[2][2].imag;
#line 111
    c0r += a0 * bi;
#line 112
    c1r += a1 * bi;
#line 113
    c2r += a2 * bi;
#line 114
    c0i -= a0 * br;
#line 115
    c1i -= a1 * br;
#line 116
    c2i -= a2 * br;
#line 118
    c->c[0].real = c0r;
#line 119
    c->c[0].imag = c0i;
#line 120
    c->c[1].real = c1r;
#line 121
    c->c[1].imag = c1i;
#line 122
    c->c[2].real = c2r;
#line 123
    c->c[2].imag = c2i;
#line 46
    n ++;
#line 46
    a ++;
  }
#line 125
  return;
}
}
#line 1 "m_mv_s_4dir.o"
#pragma merger("0","/tmp/cil-6lwnT_7j.i","")
#line 397 "./su3.h"
void mult_su3_mat_vec_sum_4dir(su3_matrix *a , su3_vector *b0 , su3_vector *b1 , su3_vector *b2 ,
                               su3_vector *b3 , su3_vector *c ) ;
#line 127 "m_mv_s_4dir.c"
void mult_su3_mat_vec_sum_4dir(su3_matrix *a , su3_vector *b0 , su3_vector *b1 , su3_vector *b2 ,
                               su3_vector *b3 , su3_vector *c ) 
{ 
  int i ;
  int n ;
  register su3_matrix *at ;
  register su3_vector *b ;
  register double t ;
  register double ar ;
  register double ai ;
  register double br ;
  register double bi ;
  register double cr ;
  register double ci ;

  {
#line 134
  i = 0;
#line 134
  while (i < 3) {
#line 135
    c->c[i].real = 0.0;
#line 136
    c->c[i].imag = 0.0;
#line 134
    i ++;
  }
#line 138
  n = 0;
#line 138
  while (n < 4) {
#line 139
    at = a + n;
#line 140
    switch (n) {
    case 0: 
#line 141
    b = b0;
#line 141
    break;
    case 1: 
#line 142
    b = b1;
#line 142
    break;
    case 2: 
#line 143
    b = b2;
#line 143
    break;
    case 3: 
#line 144
    b = b3;
#line 144
    break;
    }
#line 146
    i = 0;
#line 146
    while (i < 3) {
#line 148
      ar = at->e[i][0].real;
#line 148
      ai = at->e[i][0].imag;
#line 149
      br = b->c[0].real;
#line 149
      bi = b->c[0].imag;
#line 150
      cr = ar * br;
#line 150
      t = ai * bi;
#line 150
      cr -= t;
#line 151
      ci = ar * bi;
#line 151
      t = ai * br;
#line 151
      ci += t;
#line 153
      ar = at->e[i][1].real;
#line 153
      ai = at->e[i][1].imag;
#line 154
      br = b->c[1].real;
#line 154
      bi = b->c[1].imag;
#line 155
      t = ar * br;
#line 155
      cr += t;
#line 155
      t = ai * bi;
#line 155
      cr -= t;
#line 156
      t = ar * bi;
#line 156
      ci += t;
#line 156
      t = ai * br;
#line 156
      ci += t;
#line 158
      ar = at->e[i][2].real;
#line 158
      ai = at->e[i][2].imag;
#line 159
      br = b->c[2].real;
#line 159
      bi = b->c[2].imag;
#line 160
      t = ar * br;
#line 160
      cr += t;
#line 160
      t = ai * bi;
#line 160
      cr -= t;
#line 161
      t = ar * bi;
#line 161
      ci += t;
#line 161
      t = ai * br;
#line 161
      ci += t;
#line 163
      c->c[i].real += cr;
#line 164
      c->c[i].imag += ci;
#line 146
      i ++;
    }
#line 138
    n ++;
  }
#line 167
  return;
}
}
#line 1 "m_su2_mat_vec_n.o"
#pragma merger("0","/tmp/cil-tOef2orp.i","")
#line 10 "m_su2_mat_vec_n.c"
void mult_su2_mat_vec_elem_n(su2_matrix *u , complex *x0 , complex *x1 ) 
{ 
  complex z0 ;
  complex z1 ;
  complex t0 ;
  complex t1 ;

  {
#line 19
  t0 = *x0;
#line 19
  t1 = *x1;
#line 21
  z0.real = u->e[0][0].real * t0.real - u->e[0][0].imag * t0.imag;
#line 21
  z0.imag = u->e[0][0].real * t0.imag + u->e[0][0].imag * t0.real;
#line 22
  z1.real = u->e[0][1].real * t1.real - u->e[0][1].imag * t1.imag;
#line 22
  z1.imag = u->e[0][1].real * t1.imag + u->e[0][1].imag * t1.real;
#line 23
  x0->real = z0.real + z1.real;
#line 23
  x0->imag = z0.imag + z1.imag;
#line 24
  z0.real = u->e[1][0].real * t0.real - u->e[1][0].imag * t0.imag;
#line 24
  z0.imag = u->e[1][0].real * t0.imag + u->e[1][0].imag * t0.real;
#line 25
  z1.real = u->e[1][1].real * t1.real - u->e[1][1].imag * t1.imag;
#line 25
  z1.imag = u->e[1][1].real * t1.imag + u->e[1][1].imag * t1.real;
#line 26
  x1->real = z0.real + z1.real;
#line 26
  x1->imag = z0.imag + z1.imag;
#line 28
  return;
}
}
#line 1 "l_su2_hit_n.o"
#pragma merger("0","/tmp/cil-5jCPFz7m.i","")
#line 10 "l_su2_hit_n.c"
void left_su2_hit_n(su2_matrix *u , int p , int q , su3_matrix *link ) 
{ 
  register int m ;

  {
#line 19
  m = 0;
#line 19
  while (m < 3) {
#line 20
    mult_su2_mat_vec_elem_n(u, & link->e[p][m], & link->e[q][m]);
#line 19
    m ++;
  }
#line 22
  return;
}
}
#line 1 "r_su2_hit_a.o"
#pragma merger("0","/tmp/cil-3Ru0boWm.i","")
#line 442 "./su3.h"
void mult_su2_mat_vec_elem_a(su2_matrix *u , complex *x0 , complex *x1 ) ;
#line 10 "r_su2_hit_a.c"
void right_su2_hit_a(su2_matrix *u , int p , int q , su3_matrix *link ) 
{ 
  register int m ;

  {
#line 19
  m = 0;
#line 19
  while (m < 3) {
#line 20
    mult_su2_mat_vec_elem_a(u, & link->e[m][p], & link->e[m][q]);
#line 19
    m ++;
  }
#line 22
  return;
}
}
#line 1 "m_su2_mat_vec_a.o"
#pragma merger("0","/tmp/cil-dCpGaR0B.i","")
#line 10 "m_su2_mat_vec_a.c"
void mult_su2_mat_vec_elem_a(su2_matrix *u , complex *x0 , complex *x1 ) 
{ 
  complex z0 ;
  complex z1 ;
  complex t0 ;
  complex t1 ;

  {
#line 19
  t0 = *x0;
#line 19
  t1 = *x1;
#line 21
  z0.real = t0.real * u->e[0][0].real + t0.imag * u->e[0][0].imag;
#line 21
  z0.imag = t0.imag * u->e[0][0].real - t0.real * u->e[0][0].imag;
#line 22
  z1.real = t1.real * u->e[0][1].real + t1.imag * u->e[0][1].imag;
#line 22
  z1.imag = t1.imag * u->e[0][1].real - t1.real * u->e[0][1].imag;
#line 23
  x0->real = z0.real + z1.real;
#line 23
  x0->imag = z0.imag + z1.imag;
#line 24
  z0.real = t0.real * u->e[1][0].real + t0.imag * u->e[1][0].imag;
#line 24
  z0.imag = t0.imag * u->e[1][0].real - t0.real * u->e[1][0].imag;
#line 25
  z1.real = t1.real * u->e[1][1].real + t1.imag * u->e[1][1].imag;
#line 25
  z1.imag = t1.imag * u->e[1][1].real - t1.real * u->e[1][1].imag;
#line 26
  x1->real = z0.real + z1.real;
#line 26
  x1->imag = z0.imag + z1.imag;
#line 28
  return;
}
}
#line 1 "gaussrand.o"
#pragma merger("0","/tmp/cil-xROur8WE.i","")
#line 17 "gaussrand.c"
static int iset  =    0;
#line 18 "gaussrand.c"
static double gset  ;
#line 16 "gaussrand.c"
double gaussian_rand_no(double_prn *prn_pt ) 
{ 
  double fac ;
  double r ;
  double v1 ;
  double v2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 21
  if (iset == 0) {
#line 22
    while (1) {
#line 23
      tmp = myrand(prn_pt);
#line 23
      v1 = 2.0 * tmp - 1.0;
#line 24
      tmp___0 = myrand(prn_pt);
#line 24
      v2 = 2.0 * tmp___0 - 1.0;
#line 25
      r = v1 * v1 + v2 * v2;
#line 22
      if (! (r >= 1.0)) {
#line 22
        break;
      }
    }
#line 27
    tmp___1 = log(r);
#line 27
    fac = sqrt(- tmp___1 / r);
#line 28
    gset = v1 * fac;
#line 29
    iset = 1;
#line 30
    return (v2 * fac);
  } else {
#line 32
    iset = 0;
#line 33
    return (gset);
  }
}
}
#line 1 "byterevn.o"
#pragma merger("0","/tmp/cil-5Ax2i9t6.i","")
#line 11 "byterevn.c"
void byterevn(int32type *w , int n ) 
{ 
  register int32type old ;
  register int32type newv ;
  int j ;

  {
#line 18
  j = 0;
#line 18
  while (j < n) {
#line 20
    old = *(w + j);
#line 21
    newv = (old >> 24) & 255;
#line 22
    newv |= (old >> 8) & 65280;
#line 23
    newv |= (old << 8) & 16711680;
#line 24
    newv = (int32type )((unsigned int )newv | ((unsigned int )(old << 24) & 4278190080U));
#line 25
    *(w + j) = newv;
#line 18
    j ++;
  }
#line 27
  return;
}
}
#line 1 "m_mat_hwvec.o"
#pragma merger("0","/tmp/cil-YPoKZ2U0.i","")
#line 23 "m_mat_hwvec.c"
void mult_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) 
{ 
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
#line 36
  a0r = mat->e[0][0].real;
#line 36
  a0i = mat->e[0][0].imag;
#line 37
  b0r = src->h[0].c[0].real;
#line 37
  b0i = src->h[0].c[0].imag;
#line 38
  a1r = mat->e[0][1].real;
#line 38
  a1i = mat->e[0][1].imag;
#line 39
  b1r = src->h[0].c[1].real;
#line 39
  b1i = src->h[0].c[1].imag;
#line 40
  a2r = mat->e[0][2].real;
#line 40
  a2i = mat->e[0][2].imag;
#line 41
  b2r = src->h[0].c[2].real;
#line 41
  b2i = src->h[0].c[2].imag;
#line 43
  dest->h[0].c[0].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 44
  dest->h[0].c[0].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 46
  a0r = mat->e[1][0].real;
#line 46
  a0i = mat->e[1][0].imag;
#line 47
  b0r = src->h[0].c[0].real;
#line 47
  b0i = src->h[0].c[0].imag;
#line 48
  a1r = mat->e[1][1].real;
#line 48
  a1i = mat->e[1][1].imag;
#line 49
  b1r = src->h[0].c[1].real;
#line 49
  b1i = src->h[0].c[1].imag;
#line 50
  a2r = mat->e[1][2].real;
#line 50
  a2i = mat->e[1][2].imag;
#line 51
  b2r = src->h[0].c[2].real;
#line 51
  b2i = src->h[0].c[2].imag;
#line 53
  dest->h[0].c[1].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 54
  dest->h[0].c[1].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 56
  a0r = mat->e[2][0].real;
#line 56
  a0i = mat->e[2][0].imag;
#line 57
  b0r = src->h[0].c[0].real;
#line 57
  b0i = src->h[0].c[0].imag;
#line 58
  a1r = mat->e[2][1].real;
#line 58
  a1i = mat->e[2][1].imag;
#line 59
  b1r = src->h[0].c[1].real;
#line 59
  b1i = src->h[0].c[1].imag;
#line 60
  a2r = mat->e[2][2].real;
#line 60
  a2i = mat->e[2][2].imag;
#line 61
  b2r = src->h[0].c[2].real;
#line 61
  b2i = src->h[0].c[2].imag;
#line 63
  dest->h[0].c[2].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 64
  dest->h[0].c[2].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 68
  a0r = mat->e[0][0].real;
#line 68
  a0i = mat->e[0][0].imag;
#line 69
  b0r = src->h[1].c[0].real;
#line 69
  b0i = src->h[1].c[0].imag;
#line 70
  a1r = mat->e[0][1].real;
#line 70
  a1i = mat->e[0][1].imag;
#line 71
  b1r = src->h[1].c[1].real;
#line 71
  b1i = src->h[1].c[1].imag;
#line 72
  a2r = mat->e[0][2].real;
#line 72
  a2i = mat->e[0][2].imag;
#line 73
  b2r = src->h[1].c[2].real;
#line 73
  b2i = src->h[1].c[2].imag;
#line 75
  dest->h[1].c[0].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 76
  dest->h[1].c[0].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 78
  a0r = mat->e[1][0].real;
#line 78
  a0i = mat->e[1][0].imag;
#line 79
  b0r = src->h[1].c[0].real;
#line 79
  b0i = src->h[1].c[0].imag;
#line 80
  a1r = mat->e[1][1].real;
#line 80
  a1i = mat->e[1][1].imag;
#line 81
  b1r = src->h[1].c[1].real;
#line 81
  b1i = src->h[1].c[1].imag;
#line 82
  a2r = mat->e[1][2].real;
#line 82
  a2i = mat->e[1][2].imag;
#line 83
  b2r = src->h[1].c[2].real;
#line 83
  b2i = src->h[1].c[2].imag;
#line 85
  dest->h[1].c[1].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 86
  dest->h[1].c[1].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 88
  a0r = mat->e[2][0].real;
#line 88
  a0i = mat->e[2][0].imag;
#line 89
  b0r = src->h[1].c[0].real;
#line 89
  b0i = src->h[1].c[0].imag;
#line 90
  a1r = mat->e[2][1].real;
#line 90
  a1i = mat->e[2][1].imag;
#line 91
  b1r = src->h[1].c[1].real;
#line 91
  b1i = src->h[1].c[1].imag;
#line 92
  a2r = mat->e[2][2].real;
#line 92
  a2i = mat->e[2][2].imag;
#line 93
  b2r = src->h[1].c[2].real;
#line 93
  b2i = src->h[1].c[2].imag;
#line 95
  dest->h[1].c[2].real = ((((a0r * b0r - a0i * b0i) + a1r * b1r) - a1i * b1i) + a2r * b2r) - a2i * b2i;
#line 96
  dest->h[1].c[2].imag = ((((a0r * b0i + a0i * b0r) + a1r * b1i) + a1i * b1r) + a2r * b2i) + a2i * b2r;
#line 98
  return;
}
}
#line 1 "m_amat_hwvec.o"
#pragma merger("0","/tmp/cil-XRVOed5A.i","")
#line 21 "m_amat_hwvec.c"
void mult_adj_su3_mat_hwvec(su3_matrix *mat , half_wilson_vector *src , half_wilson_vector *dest ) 
{ 
  register double a0r ;
  register double a0i ;
  register double a1r ;
  register double a1i ;
  register double a2r ;
  register double a2i ;
  register double b0r ;
  register double b0i ;
  register double b1r ;
  register double b1i ;
  register double b2r ;
  register double b2i ;

  {
#line 34
  a0r = mat->e[0][0].real;
#line 34
  a0i = mat->e[0][0].imag;
#line 35
  b0r = src->h[0].c[0].real;
#line 35
  b0i = src->h[0].c[0].imag;
#line 36
  a1r = mat->e[1][0].real;
#line 36
  a1i = mat->e[1][0].imag;
#line 37
  b1r = src->h[0].c[1].real;
#line 37
  b1i = src->h[0].c[1].imag;
#line 38
  a2r = mat->e[2][0].real;
#line 38
  a2i = mat->e[2][0].imag;
#line 39
  b2r = src->h[0].c[2].real;
#line 39
  b2i = src->h[0].c[2].imag;
#line 41
  dest->h[0].c[0].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 42
  dest->h[0].c[0].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 44
  a0r = mat->e[0][1].real;
#line 44
  a0i = mat->e[0][1].imag;
#line 45
  b0r = src->h[0].c[0].real;
#line 45
  b0i = src->h[0].c[0].imag;
#line 46
  a1r = mat->e[1][1].real;
#line 46
  a1i = mat->e[1][1].imag;
#line 47
  b1r = src->h[0].c[1].real;
#line 47
  b1i = src->h[0].c[1].imag;
#line 48
  a2r = mat->e[2][1].real;
#line 48
  a2i = mat->e[2][1].imag;
#line 49
  b2r = src->h[0].c[2].real;
#line 49
  b2i = src->h[0].c[2].imag;
#line 51
  dest->h[0].c[1].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 52
  dest->h[0].c[1].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 54
  a0r = mat->e[0][2].real;
#line 54
  a0i = mat->e[0][2].imag;
#line 55
  b0r = src->h[0].c[0].real;
#line 55
  b0i = src->h[0].c[0].imag;
#line 56
  a1r = mat->e[1][2].real;
#line 56
  a1i = mat->e[1][2].imag;
#line 57
  b1r = src->h[0].c[1].real;
#line 57
  b1i = src->h[0].c[1].imag;
#line 58
  a2r = mat->e[2][2].real;
#line 58
  a2i = mat->e[2][2].imag;
#line 59
  b2r = src->h[0].c[2].real;
#line 59
  b2i = src->h[0].c[2].imag;
#line 61
  dest->h[0].c[2].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 62
  dest->h[0].c[2].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 67
  a0r = mat->e[0][0].real;
#line 67
  a0i = mat->e[0][0].imag;
#line 68
  b0r = src->h[1].c[0].real;
#line 68
  b0i = src->h[1].c[0].imag;
#line 69
  a1r = mat->e[1][0].real;
#line 69
  a1i = mat->e[1][0].imag;
#line 70
  b1r = src->h[1].c[1].real;
#line 70
  b1i = src->h[1].c[1].imag;
#line 71
  a2r = mat->e[2][0].real;
#line 71
  a2i = mat->e[2][0].imag;
#line 72
  b2r = src->h[1].c[2].real;
#line 72
  b2i = src->h[1].c[2].imag;
#line 74
  dest->h[1].c[0].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 75
  dest->h[1].c[0].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 77
  a0r = mat->e[0][1].real;
#line 77
  a0i = mat->e[0][1].imag;
#line 78
  b0r = src->h[1].c[0].real;
#line 78
  b0i = src->h[1].c[0].imag;
#line 79
  a1r = mat->e[1][1].real;
#line 79
  a1i = mat->e[1][1].imag;
#line 80
  b1r = src->h[1].c[1].real;
#line 80
  b1i = src->h[1].c[1].imag;
#line 81
  a2r = mat->e[2][1].real;
#line 81
  a2i = mat->e[2][1].imag;
#line 82
  b2r = src->h[1].c[2].real;
#line 82
  b2i = src->h[1].c[2].imag;
#line 84
  dest->h[1].c[1].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 85
  dest->h[1].c[1].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 87
  a0r = mat->e[0][2].real;
#line 87
  a0i = mat->e[0][2].imag;
#line 88
  b0r = src->h[1].c[0].real;
#line 88
  b0i = src->h[1].c[0].imag;
#line 89
  a1r = mat->e[1][2].real;
#line 89
  a1i = mat->e[1][2].imag;
#line 90
  b1r = src->h[1].c[1].real;
#line 90
  b1i = src->h[1].c[1].imag;
#line 91
  a2r = mat->e[2][2].real;
#line 91
  a2i = mat->e[2][2].imag;
#line 92
  b2r = src->h[1].c[2].real;
#line 92
  b2i = src->h[1].c[2].imag;
#line 94
  dest->h[1].c[2].real = ((((a0r * b0r + a0i * b0i) + a1r * b1r) + a1i * b1i) + a2r * b2r) + a2i * b2i;
#line 95
  dest->h[1].c[2].imag = ((((a0r * b0i - a0i * b0r) + a1r * b1i) - a1i * b1r) + a2r * b2i) - a2i * b2r;
#line 97
  return;
}
}
#line 1 "dslash_fn2.o"
#pragma merger("0","/tmp/cil-XcUOfOhc.i","")
#line 106 "./comdefs.h"
void restart_gather(field_offset field , int size , int index___0 , int parity , char **dest ,
                    msg_tag *mbuf ) ;
#line 127
void restart_gather_from_temp(void *field , int size , int index___0 , int parity ,
                              char **dest , msg_tag *mbuf ) ;
#line 40 "./generic_ks.h"
void cleanup_gathers(msg_tag **tags1 , msg_tag **tags2 ) ;
#line 41
void cleanup_dslash_temps(void) ;
#line 45
void dslash_fn_special(field_offset src , field_offset dest , int parity , msg_tag **tag ,
                       int start ) ;
#line 47
void dslash_fn_on_temp(su3_vector *src , su3_vector *dest , int parity ) ;
#line 48
void dslash_fn_on_temp_special(su3_vector *src , su3_vector *dest , int parity , msg_tag **tag ,
                               int start ) ;
#line 26 "dslash_fn2.c"
static su3_vector *temp[9]  ;
#line 28 "dslash_fn2.c"
static int temp_not_allocated  =    1;
#line 30 "dslash_fn2.c"
void cleanup_gathers(msg_tag **tags1 , msg_tag **tags2 ) 
{ 
  int i ;

  {
#line 34
  i = 0;
#line 34
  while (i <= 3) {
#line 35
    cleanup_gather(*(tags1 + i));
#line 36
    cleanup_gather(*(tags1 + (7 - i)));
#line 37
    cleanup_gather(*(tags2 + i));
#line 38
    cleanup_gather(*(tags2 + (7 - i)));
#line 34
    i ++;
  }
#line 41
  i = 8;
#line 41
  while (i <= 11) {
#line 42
    cleanup_gather(*(tags1 + i));
#line 43
    cleanup_gather(*(tags1 + (23 - i)));
#line 44
    cleanup_gather(*(tags2 + i));
#line 45
    cleanup_gather(*(tags2 + (23 - i)));
#line 41
    i ++;
  }
#line 47
  return;
}
}
#line 49 "dslash_fn2.c"
void cleanup_dslash_temps(void) 
{ 
  register int i ;

  {
#line 51
  if (! temp_not_allocated) {
#line 52
    i = 0;
#line 52
    while (i < 9) {
#line 53
      free((void *)temp[i]);
#line 52
      i ++;
    }
  }
#line 55
  temp_not_allocated = 1;
#line 56
  return;
}
}
#line 63 "dslash_fn2.c"
void dslash_fn(field_offset src , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  msg_tag *tag[16] ;
  register int loopend ;
  register int loopend___0 ;

  {
#line 70
  if (! valid_longlinks) {
#line 70
    load_longlinks();
  }
#line 71
  if (! valid_fatlinks) {
#line 71
    load_fatlinks();
  }
#line 72
  switch (parity) {
  case 2: 
#line 73
  otherparity = 1;
#line 73
  break;
  case 1: 
#line 74
  otherparity = 2;
#line 74
  break;
  case 3: 
#line 75
  otherparity = 3;
#line 75
  break;
  }
#line 80
  dir = 0;
#line 80
  while (dir <= 3) {
#line 81
    tag[dir] = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
#line 83
    tag[dir + 8] = start_gather(src, (int )sizeof(su3_vector ), dir + 8, parity, gen_pt[dir + 8]);
#line 80
    dir ++;
  }
#line 89
  if (otherparity == 2) {
#line 89
    loopend = even_sites_on_node;
  } else {
#line 89
    loopend = sites_on_node;
  }
#line 89
  if (otherparity == 1) {
#line 89
    i = even_sites_on_node;
  } else {
#line 89
    i = 0;
  }
#line 89
  s = lattice + i;
#line 89
  while (i < loopend) {
#line 92
    fat4 = t_fatlink + 4 * i;
#line 93
    long4 = t_longlink + 4 * i;
#line 98
    mult_adj_su3_mat_vec_4dir(fat4, (su3_vector *)((char *)s + src), s->tempvec);
#line 101
    mult_adj_su3_mat_vec_4dir(long4, (su3_vector *)((char *)s + src), s->templongvec);
#line 89
    i ++;
#line 89
    s ++;
  }
#line 106
  dir = 0;
#line 106
  while (dir <= 3) {
#line 107
    tag[7 - dir] = start_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                                (int )sizeof(su3_vector ), 7 - dir, parity, gen_pt[7 - dir]);
#line 106
    dir ++;
  }
#line 113
  dir = 8;
#line 113
  while (dir <= 11) {
#line 114
    tag[23 - dir] = start_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                                 (int )sizeof(su3_vector ), 23 - dir, parity, gen_pt[23 - dir]);
#line 113
    dir ++;
  }
#line 123
  dir = 0;
#line 123
  while (dir <= 3) {
#line 124
    wait_gather(tag[dir]);
#line 125
    wait_gather(tag[dir + 8]);
#line 123
    dir ++;
  }
#line 129
  dir = 0;
#line 129
  while (dir <= 3) {
#line 130
    wait_gather(tag[7 - dir]);
#line 129
    dir ++;
  }
#line 132
  dir = 8;
#line 132
  while (dir <= 11) {
#line 133
    wait_gather(tag[23 - dir]);
#line 132
    dir ++;
  }
#line 137
  if (parity == 2) {
#line 137
    loopend___0 = even_sites_on_node;
  } else {
#line 137
    loopend___0 = sites_on_node;
  }
#line 137
  if (parity == 1) {
#line 137
    i = even_sites_on_node;
  } else {
#line 137
    i = 0;
  }
#line 137
  s = lattice + i;
#line 137
  while (i < loopend___0) {
#line 139
    fat4 = t_fatlink + 4 * i;
#line 140
    long4 = t_longlink + 4 * i;
#line 145
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              (su3_vector *)((char *)s + dest));
#line 150
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              & s->templongv1);
#line 155
    sub_four_su3_vecs((su3_vector *)((char *)s + dest), (su3_vector *)*(gen_pt[7] + i),
                      (su3_vector *)*(gen_pt[6] + i), (su3_vector *)*(gen_pt[5] + i),
                      (su3_vector *)*(gen_pt[4] + i));
#line 160
    sub_four_su3_vecs(& s->templongv1, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
#line 166
    add_su3_vector((su3_vector *)((char *)s + dest), & s->templongv1, (su3_vector *)((char *)s + dest));
#line 137
    i ++;
#line 137
    s ++;
  }
#line 171
  dir = 0;
#line 171
  while (dir <= 3) {
#line 172
    cleanup_gather(tag[dir]);
#line 173
    cleanup_gather(tag[7 - dir]);
#line 171
    dir ++;
  }
#line 175
  dir = 8;
#line 175
  while (dir <= 11) {
#line 176
    cleanup_gather(tag[dir]);
#line 177
    cleanup_gather(tag[23 - dir]);
#line 175
    dir ++;
  }
#line 179
  return;
}
}
#line 186 "dslash_fn2.c"
void dslash_fn_special(field_offset src , field_offset dest , int parity , msg_tag **tag ,
                       int start ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  register int loopend ;
  register int loopend___0 ;

  {
#line 193
  if (! valid_longlinks) {
#line 193
    load_longlinks();
  }
#line 194
  if (! valid_fatlinks) {
#line 194
    load_fatlinks();
  }
#line 195
  switch (parity) {
  case 2: 
#line 196
  otherparity = 1;
#line 196
  break;
  case 1: 
#line 197
  otherparity = 2;
#line 197
  break;
  case 3: 
#line 198
  otherparity = 3;
#line 198
  break;
  }
#line 202
  dir = 0;
#line 202
  while (dir <= 3) {
#line 204
    if (start == 1) {
#line 204
      *(tag + dir) = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
    } else {
#line 206
      restart_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir], *(tag + dir));
    }
#line 202
    dir ++;
  }
#line 211
  dir = 8;
#line 211
  while (dir <= 11) {
#line 212
    if (start == 1) {
#line 212
      *(tag + dir) = start_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir]);
    } else {
#line 214
      restart_gather(src, (int )sizeof(su3_vector ), dir, parity, gen_pt[dir], *(tag + dir));
    }
#line 211
    dir ++;
  }
#line 219
  if (otherparity == 2) {
#line 219
    loopend = even_sites_on_node;
  } else {
#line 219
    loopend = sites_on_node;
  }
#line 219
  if (otherparity == 1) {
#line 219
    i = even_sites_on_node;
  } else {
#line 219
    i = 0;
  }
#line 219
  s = lattice + i;
#line 219
  while (i < loopend) {
#line 222
    fat4 = t_fatlink + 4 * i;
#line 223
    long4 = t_longlink + 4 * i;
#line 228
    mult_adj_su3_mat_vec_4dir(fat4, (su3_vector *)((char *)s + src), s->tempvec);
#line 231
    mult_adj_su3_mat_vec_4dir(long4, (su3_vector *)((char *)s + src), s->templongvec);
#line 219
    i ++;
#line 219
    s ++;
  }
#line 236
  dir = 0;
#line 236
  while (dir <= 3) {
#line 238
    if (start == 1) {
#line 238
      *(tag + (7 - dir)) = start_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                                        (int )sizeof(su3_vector ), 7 - dir, parity,
                                        gen_pt[7 - dir]);
    } else {
#line 240
      restart_gather((field_offset )((char *)(& (lattice + 0)->tempvec[dir]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_vector ), 7 - dir, parity, gen_pt[7 - dir],
                     *(tag + (7 - dir)));
    }
#line 236
    dir ++;
  }
#line 245
  dir = 8;
#line 245
  while (dir <= 11) {
#line 247
    if (start == 1) {
#line 247
      *(tag + (23 - dir)) = start_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                                         (int )sizeof(su3_vector ), 23 - dir, parity,
                                         gen_pt[23 - dir]);
    } else {
#line 250
      restart_gather((field_offset )((char *)(& (lattice + 0)->templongvec[dir - 8]) - (char *)(lattice + 0)),
                     (int )sizeof(su3_vector ), 23 - dir, parity, gen_pt[23 - dir],
                     *(tag + (23 - dir)));
    }
#line 245
    dir ++;
  }
#line 257
  dir = 0;
#line 257
  while (dir <= 3) {
#line 258
    wait_gather(*(tag + dir));
#line 257
    dir ++;
  }
#line 262
  dir = 8;
#line 262
  while (dir <= 11) {
#line 263
    wait_gather(*(tag + dir));
#line 262
    dir ++;
  }
#line 268
  dir = 0;
#line 268
  while (dir <= 3) {
#line 269
    wait_gather(*(tag + (7 - dir)));
#line 268
    dir ++;
  }
#line 271
  dir = 8;
#line 271
  while (dir <= 11) {
#line 272
    wait_gather(*(tag + (23 - dir)));
#line 271
    dir ++;
  }
#line 275
  if (parity == 2) {
#line 275
    loopend___0 = even_sites_on_node;
  } else {
#line 275
    loopend___0 = sites_on_node;
  }
#line 275
  if (parity == 1) {
#line 275
    i = even_sites_on_node;
  } else {
#line 275
    i = 0;
  }
#line 275
  s = lattice + i;
#line 275
  while (i < loopend___0) {
#line 278
    fat4 = t_fatlink + 4 * i;
#line 279
    long4 = t_longlink + 4 * i;
#line 284
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              (su3_vector *)((char *)s + dest));
#line 288
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              & s->templongv1);
#line 293
    sub_four_su3_vecs((su3_vector *)((char *)s + dest), (su3_vector *)*(gen_pt[7] + i),
                      (su3_vector *)*(gen_pt[6] + i), (su3_vector *)*(gen_pt[5] + i),
                      (su3_vector *)*(gen_pt[4] + i));
#line 298
    sub_four_su3_vecs(& s->templongv1, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
#line 304
    add_su3_vector((su3_vector *)((char *)s + dest), & s->templongv1, (su3_vector *)((char *)s + dest));
#line 275
    i ++;
#line 275
    s ++;
  }
#line 308
  return;
}
}
#line 310 "dslash_fn2.c"
void dslash_fn_on_temp(su3_vector *src , su3_vector *dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  msg_tag *tag[16] ;
  su3_vector *tempvec[4] ;
  su3_vector *templongvec[4] ;
  su3_vector *templongv1 ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;

  {
#line 318
  dir = 0;
#line 318
  while (dir <= 3) {
#line 320
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 320
//AD    tempvec[dir] = (su3_vector *)tmp;
    tempvec[dir] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 321
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 321
//AD    templongvec[dir] = (su3_vector *)tmp___0;
    templongvec[dir] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 318
    dir ++;
  }
#line 323
//AD  tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 323
//AD  templongv1 = (su3_vector *)tmp___1;
  templongv1 = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 325
  if (! valid_longlinks) {
#line 325
    load_longlinks();
  }
#line 326
  if (! valid_fatlinks) {
#line 326
    load_fatlinks();
  }
#line 327
  switch (parity) {
  case 2: 
#line 329
  otherparity = 1;
#line 329
  break;
  case 1: 
#line 330
  otherparity = 2;
#line 330
  break;
  case 3: 
#line 331
  otherparity = 3;
#line 331
  break;
  }
#line 336
  dir = 0;
#line 336
  while (dir <= 3) {
#line 337
    tag[dir] = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir,
                                      parity, gen_pt[dir]);
#line 339
    tag[dir + 8] = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                          dir + 8, parity, gen_pt[dir + 8]);
#line 336
    dir ++;
  }
#line 346
  if (otherparity == 2) {
#line 346
    loopend = even_sites_on_node;
  } else {
#line 346
    loopend = sites_on_node;
  }
#line 346
  if (otherparity == 1) {
#line 346
    i = even_sites_on_node;
  } else {
#line 346
    i = 0;
  }
#line 346
  s = lattice + i;
#line 346
  while (i < loopend) {
#line 349
    fat4 = t_fatlink + 4 * i;
#line 350
    long4 = t_longlink + 4 * i;
#line 355
    mult_adj_su3_mat_4vec(fat4, src + i, tempvec[0] + i, tempvec[1] + i, tempvec[2] + i,
                          tempvec[3] + i);
#line 359
    mult_adj_su3_mat_4vec(long4, src + i, templongvec[0] + i, templongvec[1] + i,
                          templongvec[2] + i, templongvec[3] + i);
#line 346
    i ++;
#line 346
    s ++;
  }
#line 365
  dir = 0;
#line 365
  while (dir <= 3) {
#line 366
    tag[7 - dir] = start_gather_from_temp((void *)tempvec[dir], (int )sizeof(su3_vector ),
                                          7 - dir, parity, gen_pt[7 - dir]);
#line 365
    dir ++;
  }
#line 371
  dir = 8;
#line 371
  while (dir <= 11) {
#line 372
    tag[23 - dir] = start_gather_from_temp((void *)templongvec[dir - 8], (int )sizeof(su3_vector ),
                                           23 - dir, parity, gen_pt[23 - dir]);
#line 371
    dir ++;
  }
#line 379
  dir = 0;
#line 379
  while (dir <= 3) {
#line 380
    wait_gather(tag[dir]);
#line 381
    wait_gather(tag[dir + 8]);
#line 379
    dir ++;
  }
#line 384
  if (parity == 2) {
#line 384
    loopend___0 = even_sites_on_node;
  } else {
#line 384
    loopend___0 = sites_on_node;
  }
#line 384
  if (parity == 1) {
#line 384
    i = even_sites_on_node;
  } else {
#line 384
    i = 0;
  }
#line 384
  s = lattice + i;
#line 384
  while (i < loopend___0) {
#line 387
    fat4 = t_fatlink + 4 * i;
#line 388
    long4 = t_longlink + 4 * i;
#line 393
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              dest + i);
#line 398
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              templongv1 + i);
#line 384
    i ++;
#line 384
    s ++;
  }
#line 406
  dir = 0;
#line 406
  while (dir <= 3) {
#line 407
    wait_gather(tag[7 - dir]);
#line 406
    dir ++;
  }
#line 409
  dir = 8;
#line 409
  while (dir <= 11) {
#line 410
    wait_gather(tag[23 - dir]);
#line 409
    dir ++;
  }
#line 413
  if (parity == 2) {
#line 413
    loopend___1 = even_sites_on_node;
  } else {
#line 413
    loopend___1 = sites_on_node;
  }
#line 413
  if (parity == 1) {
#line 413
    i = even_sites_on_node;
  } else {
#line 413
    i = 0;
  }
#line 413
  s = lattice + i;
#line 413
  while (i < loopend___1) {
#line 415
    sub_four_su3_vecs(dest + i, (su3_vector *)*(gen_pt[7] + i), (su3_vector *)*(gen_pt[6] + i),
                      (su3_vector *)*(gen_pt[5] + i), (su3_vector *)*(gen_pt[4] + i));
#line 420
    sub_four_su3_vecs(templongv1 + i, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
#line 426
    add_su3_vector(dest + i, templongv1 + i, dest + i);
#line 413
    i ++;
#line 413
    s ++;
  }
#line 430
  dir = 0;
#line 430
  while (dir <= 3) {
#line 431
    cleanup_gather(tag[dir]);
#line 432
    cleanup_gather(tag[7 - dir]);
#line 430
    dir ++;
  }
#line 435
  dir = 8;
#line 435
  while (dir <= 11) {
#line 436
    cleanup_gather(tag[dir]);
#line 437
    cleanup_gather(tag[23 - dir]);
#line 435
    dir ++;
  }
#line 440
  dir = 0;
#line 440
  while (dir <= 3) {
#line 441
    free((void *)tempvec[dir]);
#line 442
    free((void *)templongvec[dir]);
#line 440
    dir ++;
  }
#line 444
  free((void *)templongv1);
#line 445
  return;
}
}
#line 452 "dslash_fn2.c"
void dslash_fn_on_temp_special(su3_vector *src , su3_vector *dest , int parity , msg_tag **tag ,
                               int start ) 
{ 
  register int i ;
  register site *s ;
  register int dir ;
  register int otherparity ;
  register su3_matrix *fat4 ;
  register su3_matrix *long4 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register int loopend ;
  register int loopend___0 ;
  register int loopend___1 ;

  {
#line 460
  if (temp_not_allocated) {
#line 462
    dir = 0;
#line 462
    while (dir <= 3) {
#line 463
//AD      tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 463
//AD      temp[dir] = (su3_vector *)tmp;
      temp[dir] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 464
//AD      tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 464
//AD      temp[dir + 4] = (su3_vector *)tmp___0;
      temp[dir + 4] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 462
      dir ++;
    }
#line 466
//AD    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 466
//AD    temp[8] = (su3_vector *)tmp___1;
    temp[8] = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 467
    temp_not_allocated = 0;
  }
#line 471
  if (! valid_longlinks) {
#line 471
    load_longlinks();
  }
#line 472
  if (! valid_fatlinks) {
#line 472
    load_fatlinks();
  }
#line 474
  switch (parity) {
  case 2: 
#line 476
  otherparity = 1;
#line 476
  break;
  case 1: 
#line 477
  otherparity = 2;
#line 477
  break;
  case 3: 
#line 478
  otherparity = 3;
#line 478
  break;
  }
#line 483
  dir = 0;
#line 483
  while (dir <= 3) {
#line 484
    if (start == 1) {
#line 486
      *(tag + dir) = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                            dir, parity, gen_pt[dir]);
#line 488
      *(tag + (dir + 8)) = start_gather_from_temp((void *)src, (int )sizeof(su3_vector ),
                                                  dir + 8, parity, gen_pt[dir + 8]);
    } else {
#line 494
      restart_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir, parity,
                               gen_pt[dir], *(tag + dir));
#line 496
      restart_gather_from_temp((void *)src, (int )sizeof(su3_vector ), dir + 8, parity,
                               gen_pt[dir + 8], *(tag + (dir + 8)));
    }
#line 483
    dir ++;
  }
#line 503
  if (otherparity == 2) {
#line 503
    loopend = even_sites_on_node;
  } else {
#line 503
    loopend = sites_on_node;
  }
#line 503
  if (otherparity == 1) {
#line 503
    i = even_sites_on_node;
  } else {
#line 503
    i = 0;
  }
#line 503
  s = lattice + i;
#line 503
  while (i < loopend) {
#line 506
    fat4 = t_fatlink + 4 * i;
#line 507
    long4 = t_longlink + 4 * i;
#line 512
    mult_adj_su3_mat_4vec(fat4, src + i, temp[0] + i, temp[1] + i, temp[2] + i, temp[3] + i);
#line 515
    mult_adj_su3_mat_4vec(long4, src + i, temp[4] + i, temp[5] + i, temp[6] + i, temp[7] + i);
#line 503
    i ++;
#line 503
    s ++;
  }
#line 520
  dir = 0;
#line 520
  while (dir <= 3) {
#line 521
    if (start == 1) {
#line 521
      *(tag + (7 - dir)) = start_gather_from_temp((void *)temp[dir], (int )sizeof(su3_vector ),
                                                  7 - dir, parity, gen_pt[7 - dir]);
    } else {
#line 523
      restart_gather_from_temp((void *)temp[dir], (int )sizeof(su3_vector ), 7 - dir,
                               parity, gen_pt[7 - dir], *(tag + (7 - dir)));
    }
#line 520
    dir ++;
  }
#line 528
  dir = 8;
#line 528
  while (dir <= 11) {
#line 529
    if (start == 1) {
#line 529
      *(tag + (23 - dir)) = start_gather_from_temp((void *)temp[(dir - 8) + 4], (int )sizeof(su3_vector ),
                                                   23 - dir, parity, gen_pt[23 - dir]);
    } else {
#line 532
      restart_gather_from_temp((void *)temp[(dir - 8) + 4], (int )sizeof(su3_vector ),
                               23 - dir, parity, gen_pt[23 - dir], *(tag + (23 - dir)));
    }
#line 528
    dir ++;
  }
#line 540
  dir = 0;
#line 540
  while (dir <= 3) {
#line 541
    wait_gather(*(tag + dir));
#line 542
    wait_gather(*(tag + (dir + 8)));
#line 540
    dir ++;
  }
#line 545
  if (parity == 2) {
#line 545
    loopend___0 = even_sites_on_node;
  } else {
#line 545
    loopend___0 = sites_on_node;
  }
#line 545
  if (parity == 1) {
#line 545
    i = even_sites_on_node;
  } else {
#line 545
    i = 0;
  }
#line 545
  s = lattice + i;
#line 545
  while (i < loopend___0) {
#line 548
    fat4 = t_fatlink + 4 * i;
#line 549
    long4 = t_longlink + 4 * i;
#line 554
    mult_su3_mat_vec_sum_4dir(fat4, (su3_vector *)*(gen_pt[0] + i), (su3_vector *)*(gen_pt[1] + i),
                              (su3_vector *)*(gen_pt[2] + i), (su3_vector *)*(gen_pt[3] + i),
                              dest + i);
#line 559
    mult_su3_mat_vec_sum_4dir(long4, (su3_vector *)*(gen_pt[8] + i), (su3_vector *)*(gen_pt[9] + i),
                              (su3_vector *)*(gen_pt[10] + i), (su3_vector *)*(gen_pt[11] + i),
                              temp[8] + i);
#line 545
    i ++;
#line 545
    s ++;
  }
#line 567
  dir = 0;
#line 567
  while (dir <= 3) {
#line 568
    wait_gather(*(tag + (7 - dir)));
#line 567
    dir ++;
  }
#line 570
  dir = 8;
#line 570
  while (dir <= 11) {
#line 571
    wait_gather(*(tag + (23 - dir)));
#line 570
    dir ++;
  }
#line 574
  if (parity == 2) {
#line 574
    loopend___1 = even_sites_on_node;
  } else {
#line 574
    loopend___1 = sites_on_node;
  }
#line 574
  if (parity == 1) {
#line 574
    i = even_sites_on_node;
  } else {
#line 574
    i = 0;
  }
#line 574
  s = lattice + i;
#line 574
  while (i < loopend___1) {
#line 576
    sub_four_su3_vecs(dest + i, (su3_vector *)*(gen_pt[7] + i), (su3_vector *)*(gen_pt[6] + i),
                      (su3_vector *)*(gen_pt[5] + i), (su3_vector *)*(gen_pt[4] + i));
#line 581
    sub_four_su3_vecs(temp[8] + i, (su3_vector *)*(gen_pt[15] + i), (su3_vector *)*(gen_pt[14] + i),
                      (su3_vector *)*(gen_pt[13] + i), (su3_vector *)*(gen_pt[12] + i));
#line 587
    add_su3_vector(dest + i, temp[8] + i, dest + i);
#line 574
    i ++;
#line 574
    s ++;
  }
#line 590
  return;
}
}
#line 1 "d_congrad5_fn.o"
#pragma merger("0","/tmp/cil-g5s2dfUp.i","")
#line 17 "./generic_ks.h"
void copy_latvec(field_offset src , field_offset dest , int parity ) ;
#line 27
void scalar2_mult_add_su3_vector(su3_vector *a , double s1 , su3_vector *b , double s2 ,
                                 su3_vector *c ) ;
#line 30
void scalar2_mult_add_latvec(field_offset src1 , double scalar1 , field_offset src2 ,
                             double scalar2 , field_offset dest , int parity ) ;
#line 48 "d_congrad5_fn.c"
su3_vector *ttt  ;
#line 48 "d_congrad5_fn.c"
su3_vector *cg_p  ;
#line 49 "d_congrad5_fn.c"
su3_vector *resid  ;
#line 50 "d_congrad5_fn.c"
su3_vector *t_dest  ;
#line 51 "d_congrad5_fn.c"
int first_congrad  =    1;
#line 54 "d_congrad5_fn.c"
int ks_congrad(field_offset src , field_offset dest , double mass___0 , int niter___0 ,
               double rsqmin___0 , int parity , double *final_rsq_ptr ) 
{ 
  register int i ;
  register site *s ;
  int iteration ;
  double a ;
  double b ;
  double rsq ;
  double oldrsq ;
  double pkp ;
  double msq_x4 ;
  double source_norm ;
  double rsqstop ;
  int l_parity ;
  int l_otherparity ;
  msg_tag *tags1[16] ;
  msg_tag *tags2[16] ;
  int special_started ;
  double nflop ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  register int loopend ;
  double tmp___3 ;
  double tmp___4 ;
  register int loopend___0 ;
  double tmp___5 ;
  register int loopend___1 ;
  double tmp___6 ;
  register int loopend___2 ;
  register int loopend___3 ;
  register int loopend___4 ;

  {
#line 88
  nflop = (double )1187;
#line 89
  if (parity == 3) {
#line 89
    nflop *= (double )2;
  }
#line 91
  special_started = 0;
#line 93
  switch (parity) {
  case 2: 
#line 94
  l_parity = 2;
#line 94
  l_otherparity = 1;
#line 94
  break;
  case 1: 
#line 95
  l_parity = 1;
#line 95
  l_otherparity = 2;
#line 95
  break;
  case 3: 
#line 96
  l_parity = 2;
#line 96
  l_otherparity = 1;
#line 96
  break;
  }
#line 98
  msq_x4 = (4.0 * mass___0) * mass___0;
#line 99
  iteration = 0;
#line 101
  if (! valid_longlinks) {
#line 101
    load_longlinks();
  }
#line 102
  if (! valid_fatlinks) {
#line 102
    load_fatlinks();
  }
#line 108
  if (first_congrad) {
#line 109
//AD    tmp = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 109
//AD    ttt = (su3_vector *)tmp;
    ttt = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 110
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 110
//AD    cg_p = (su3_vector *)tmp___0;
    cg_p = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 111
//AD    tmp___1 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 111
//AD    resid = (su3_vector *)tmp___1;
    resid = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 112
//AD    tmp___2 = calloc((size_t )sites_on_node, sizeof(su3_vector ));
#line 112
//AD    t_dest = (su3_vector *)tmp___2;
    t_dest = (su3_vector *)calloc((size_t )sites_on_node, sizeof(su3_vector )); //AD
#line 113
    first_congrad = 0;
  }
#line 123
  i = 0;
#line 123
  s = lattice;
#line 123
  while (i < sites_on_node) {
#line 124
    *(t_dest + i) = *((su3_vector *)((char *)s + dest));
#line 123
    i ++;
#line 123
    s ++;
  }
  start: 
#line 136
  if (special_started == 1) {
#line 137
    cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
#line 138
    special_started = 0;
  }
#line 141
  source_norm = 0.0;
#line 141
  rsq = source_norm;
#line 143
  dslash_fn_on_temp_special(t_dest, ttt, l_otherparity, tags2, 1);
#line 144
  dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 1);
#line 145
  cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
#line 152
  if (l_parity == 2) {
#line 152
    loopend = even_sites_on_node;
  } else {
#line 152
    loopend = sites_on_node;
  }
#line 152
  if (l_parity == 1) {
#line 152
    i = even_sites_on_node;
  } else {
#line 152
    i = 0;
  }
#line 152
  s = lattice + i;
#line 152
  while (i < loopend) {
#line 154
    scalar_mult_add_su3_vector(ttt + i, t_dest + i, - msq_x4, ttt + i);
#line 157
    add_su3_vector((su3_vector *)((char *)s + src), ttt + i, resid + i);
#line 160
    *(cg_p + i) = *(resid + i);
#line 162
    tmp___3 = magsq_su3vec((su3_vector *)((char *)s + src));
#line 162
    source_norm += tmp___3;
#line 163
    tmp___4 = magsq_su3vec(resid + i);
#line 163
    rsq += tmp___4;
#line 152
    i ++;
#line 152
    s ++;
  }
#line 174
  g_doublesum(& source_norm);
#line 175
  g_doublesum(& rsq);
#line 177
  iteration ++;
#line 179
  total_iters ++;
#line 180
  rsqstop = rsqmin___0 * source_norm;
#line 182
  if (rsq <= rsqstop) {
#line 184
    if (parity == 3) {
#line 185
      l_parity = 1;
#line 185
      l_otherparity = 2;
#line 186
      parity = 2;
#line 187
      iteration = 0;
#line 189
      goto start;
    }
#line 191
    *final_rsq_ptr = rsq;
#line 193
    return (iteration);
  }
#line 211
  while (1) {
#line 212
    oldrsq = rsq;
#line 213
    pkp = 0.0;
#line 216
    if (special_started == 0) {
#line 218
      dslash_fn_on_temp_special(cg_p, ttt, l_otherparity, tags2, 1);
#line 219
      dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 1);
#line 226
      special_started = 1;
    } else {
#line 230
      dslash_fn_on_temp_special(cg_p, ttt, l_otherparity, tags2, 0);
#line 231
      dslash_fn_on_temp_special(ttt, ttt, l_parity, tags1, 0);
    }
#line 243
    pkp = 0.0;
#line 244
    if (l_parity == 2) {
#line 244
      loopend___0 = even_sites_on_node;
    } else {
#line 244
      loopend___0 = sites_on_node;
    }
#line 244
    if (l_parity == 1) {
#line 244
      i = even_sites_on_node;
    } else {
#line 244
      i = 0;
    }
#line 244
    s = lattice + i;
#line 244
    while (i < loopend___0) {
#line 246
      scalar_mult_add_su3_vector(ttt + i, cg_p + i, - msq_x4, ttt + i);
#line 248
      tmp___5 = su3_rdot(cg_p + i, ttt + i);
#line 248
      pkp += tmp___5;
#line 244
      i ++;
#line 244
      s ++;
    }
#line 255
    g_doublesum(& pkp);
#line 256
    iteration ++;
#line 257
    total_iters ++;
#line 259
    a = - rsq / pkp;
#line 263
    rsq = 0.0;
#line 264
    if (l_parity == 2) {
#line 264
      loopend___1 = even_sites_on_node;
    } else {
#line 264
      loopend___1 = sites_on_node;
    }
#line 264
    if (l_parity == 1) {
#line 264
      i = even_sites_on_node;
    } else {
#line 264
      i = 0;
    }
#line 264
    s = lattice + i;
#line 264
    while (i < loopend___1) {
#line 266
      scalar_mult_add_su3_vector(t_dest + i, cg_p + i, a, t_dest + i);
#line 267
      scalar_mult_add_su3_vector(resid + i, ttt + i, a, resid + i);
#line 268
      tmp___6 = magsq_su3vec(resid + i);
#line 268
      rsq += tmp___6;
#line 264
      i ++;
#line 264
      s ++;
    }
#line 276
    g_doublesum(& rsq);
#line 280
    if (rsq <= rsqstop) {
#line 283
      if (l_parity == 2) {
#line 283
        loopend___2 = even_sites_on_node;
      } else {
#line 283
        loopend___2 = sites_on_node;
      }
#line 283
      if (l_parity == 1) {
#line 283
        i = even_sites_on_node;
      } else {
#line 283
        i = 0;
      }
#line 283
      s = lattice + i;
#line 283
      while (i < loopend___2) {
#line 284
        *((su3_vector *)((char *)s + dest)) = *(t_dest + i);
#line 283
        i ++;
#line 283
        s ++;
      }
#line 288
      if (parity == 3) {
#line 289
        l_parity = 1;
#line 289
        l_otherparity = 2;
#line 290
        parity = 2;
#line 291
        iteration = 0;
#line 293
        goto start;
      }
#line 295
      *final_rsq_ptr = rsq;
#line 296
      if (special_started == 1) {
#line 297
        cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
#line 298
        special_started = 0;
      }
#line 313
      return (iteration);
    }
#line 316
    b = rsq / oldrsq;
#line 319
    if (l_parity == 2) {
#line 319
      loopend___3 = even_sites_on_node;
    } else {
#line 319
      loopend___3 = sites_on_node;
    }
#line 319
    if (l_parity == 1) {
#line 319
      i = even_sites_on_node;
    } else {
#line 319
      i = 0;
    }
#line 319
    s = lattice + i;
#line 319
    while (i < loopend___3) {
#line 320
      scalar_mult_add_su3_vector(resid + i, cg_p + i, b, cg_p + i);
#line 319
      i ++;
#line 319
      s ++;
    }
#line 211
    if (! (iteration % niter___0 != 0)) {
#line 211
      break;
    }
  }
#line 330
  if (iteration < 5 * niter___0) {
#line 332
    goto start;
  }
#line 337
  if (l_parity == 2) {
#line 337
    loopend___4 = even_sites_on_node;
  } else {
#line 337
    loopend___4 = sites_on_node;
  }
#line 337
  if (l_parity == 1) {
#line 337
    i = even_sites_on_node;
  } else {
#line 337
    i = 0;
  }
#line 337
  s = lattice + i;
#line 337
  while (i < loopend___4) {
#line 338
    *((su3_vector *)((char *)s + dest)) = *(t_dest + i);
#line 337
    i ++;
#line 337
    s ++;
  }
#line 343
  if (parity == 3) {
#line 344
    l_parity = 1;
#line 344
    l_otherparity = 2;
#line 345
    parity = 2;
#line 346
    iteration = 0;
#line 347
    goto start;
  }
#line 350
  *final_rsq_ptr = rsq;
#line 351
  if (special_started == 1) {
#line 352
    cleanup_gathers((msg_tag **)(tags1), (msg_tag **)(tags2));
#line 353
    special_started = 0;
  }
#line 355
  if (this_node == 0) {
#line 355
    printf((char const   * __restrict  )"CG not converged after %d iterations, res. = %e wanted %e\n",
           iteration, rsq, rsqstop);
  }
#line 358
  fflush(stdout);
#line 359
  return (iteration);
}
}
#line 363 "d_congrad5_fn.c"
void clear_latvec(field_offset v , int parity ) 
{ 
  register int i ;
  register int j ;
  register site *s ;
  register su3_vector *vv ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 367
  switch (parity) {
  case 2: 
#line 368
  i = 0;
#line 368
  s = lattice;
#line 368
  while (i < even_sites_on_node) {
#line 369
    vv = (su3_vector *)((char *)s + v);
#line 370
    j = 0;
#line 370
    while (j < 3) {
#line 370
      tmp = 0.0;
#line 370
      vv->c[j].imag = tmp;
#line 370
      vv->c[j].real = tmp;
#line 370
      j ++;
    }
#line 368
    i ++;
#line 368
    s ++;
  }
#line 371
  break;
  case 1: 
#line 372
  i = even_sites_on_node;
#line 372
  s = lattice + i;
#line 372
  while (i < sites_on_node) {
#line 373
    vv = (su3_vector *)((char *)s + v);
#line 374
    j = 0;
#line 374
    while (j < 3) {
#line 374
      tmp___0 = 0.0;
#line 374
      vv->c[j].imag = tmp___0;
#line 374
      vv->c[j].real = tmp___0;
#line 374
      j ++;
    }
#line 372
    i ++;
#line 372
    s ++;
  }
#line 375
  break;
  case 3: 
#line 376
  i = 0;
#line 376
  s = lattice;
#line 376
  while (i < sites_on_node) {
#line 377
    vv = (su3_vector *)((char *)s + v);
#line 378
    j = 0;
#line 378
    while (j < 3) {
#line 378
      tmp___1 = 0.0;
#line 378
      vv->c[j].imag = tmp___1;
#line 378
      vv->c[j].real = tmp___1;
#line 378
      j ++;
    }
#line 376
    i ++;
#line 376
    s ++;
  }
#line 379
  break;
  }
#line 381
  return;
}
}
#line 384 "d_congrad5_fn.c"
void copy_latvec(field_offset src , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt ;
  register su3_vector *dpt ;

  {
#line 388
  switch (parity) {
  case 2: 
#line 389
  i = 0;
#line 389
  s = lattice;
#line 389
  while (i < even_sites_on_node) {
#line 390
    s = lattice + i;
#line 391
    spt = (su3_vector *)((char *)s + src);
#line 392
    dpt = (su3_vector *)((char *)s + dest);
#line 393
    *dpt = *spt;
#line 389
    i ++;
#line 389
    s ++;
  }
#line 394
  break;
  case 1: 
#line 395
  i = even_sites_on_node;
#line 395
  s = lattice + i;
#line 395
  while (i < sites_on_node) {
#line 396
    s = lattice + i;
#line 397
    spt = (su3_vector *)((char *)s + src);
#line 398
    dpt = (su3_vector *)((char *)s + dest);
#line 399
    *dpt = *spt;
#line 395
    i ++;
#line 395
    s ++;
  }
#line 400
  break;
  case 3: 
#line 401
  i = 0;
#line 401
  s = lattice;
#line 401
  while (i < sites_on_node) {
#line 402
    s = lattice + i;
#line 403
    spt = (su3_vector *)((char *)s + src);
#line 404
    dpt = (su3_vector *)((char *)s + dest);
#line 405
    *dpt = *spt;
#line 401
    i ++;
#line 401
    s ++;
  }
#line 406
  break;
  }
#line 408
  return;
}
}
#line 411 "d_congrad5_fn.c"
void scalar_mult_add_latvec(field_offset src1 , field_offset src2 , double scalar ,
                            field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt1 ;
  register su3_vector *spt2 ;
  register su3_vector *dpt ;
  register int loopend ;

  {
#line 417
  if (parity == 2) {
#line 417
    loopend = even_sites_on_node;
  } else {
#line 417
    loopend = sites_on_node;
  }
#line 417
  if (parity == 1) {
#line 417
    i = even_sites_on_node;
  } else {
#line 417
    i = 0;
  }
#line 417
  s = lattice + i;
#line 417
  while (i < loopend) {
#line 418
    spt1 = (su3_vector *)((char *)s + src1);
#line 419
    spt2 = (su3_vector *)((char *)s + src2);
#line 420
    dpt = (su3_vector *)((char *)s + dest);
#line 421
    scalar_mult_add_su3_vector(spt1, spt2, scalar, dpt);
#line 417
    i ++;
#line 417
    s ++;
  }
#line 423
  return;
}
}
#line 426 "d_congrad5_fn.c"
void scalar2_mult_add_su3_vector(su3_vector *a , double s1 , su3_vector *b , double s2 ,
                                 su3_vector *c ) 
{ 
  register int i ;

  {
#line 429
  i = 0;
#line 429
  while (i < 3) {
#line 430
    c->c[i].real = s1 * a->c[i].real + s2 * b->c[i].real;
#line 431
    c->c[i].imag = s1 * a->c[i].imag + s2 * b->c[i].imag;
#line 429
    i ++;
  }
#line 433
  return;
}
}
#line 436 "d_congrad5_fn.c"
void scalar2_mult_add_latvec(field_offset src1 , double scalar1 , field_offset src2 ,
                             double scalar2 , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt1 ;
  register su3_vector *spt2 ;
  register su3_vector *dpt ;
  register int loopend ;

  {
#line 443
  if (parity == 2) {
#line 443
    loopend = even_sites_on_node;
  } else {
#line 443
    loopend = sites_on_node;
  }
#line 443
  if (parity == 1) {
#line 443
    i = even_sites_on_node;
  } else {
#line 443
    i = 0;
  }
#line 443
  s = lattice + i;
#line 443
  while (i < loopend) {
#line 444
    spt1 = (su3_vector *)((char *)s + src1);
#line 445
    spt2 = (su3_vector *)((char *)s + src2);
#line 446
    dpt = (su3_vector *)((char *)s + dest);
#line 447
    scalar2_mult_add_su3_vector(spt1, scalar1, spt2, scalar2, dpt);
#line 443
    i ++;
#line 443
    s ++;
  }
#line 449
  return;
}
}
#line 452 "d_congrad5_fn.c"
void scalar_mult_latvec(field_offset src , double scalar , field_offset dest , int parity ) 
{ 
  register int i ;
  register site *s ;
  register su3_vector *spt ;
  register su3_vector *dpt ;

  {
#line 458
  switch (parity) {
  case 2: 
#line 459
  i = 0;
#line 459
  s = lattice;
#line 459
  while (i < even_sites_on_node) {
#line 460
    spt = (su3_vector *)((char *)s + src);
#line 461
    dpt = (su3_vector *)((char *)s + dest);
#line 462
    scalar_mult_su3_vector(spt, scalar, dpt);
#line 459
    i ++;
#line 459
    s ++;
  }
#line 463
  break;
  case 1: 
#line 464
  i = even_sites_on_node;
#line 464
  s = lattice + i;
#line 464
  while (i < sites_on_node) {
#line 465
    spt = (su3_vector *)((char *)s + src);
#line 466
    dpt = (su3_vector *)((char *)s + dest);
#line 467
    scalar_mult_su3_vector(spt, scalar, dpt);
#line 464
    i ++;
#line 464
    s ++;
  }
#line 468
  break;
  case 3: 
#line 469
  i = 0;
#line 469
  s = lattice;
#line 469
  while (i < sites_on_node) {
#line 470
    spt = (su3_vector *)((char *)s + src);
#line 471
    dpt = (su3_vector *)((char *)s + dest);
#line 472
    scalar_mult_su3_vector(spt, scalar, dpt);
#line 469
    i ++;
#line 469
    s ++;
  }
#line 473
  break;
  }
#line 475
  return;
}
}
#line 1 "com_vanilla.o"
#pragma merger("0","/tmp/cil-BDDXrD2q.i","")
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 71 "./comdefs.h"
void start_handlers(void) ;
#line 75
void sort_eight_special(void **pt ) ;
#line 77
void neighbor_coords_special(int x , int y , int z , int t , int *dirpt , int fb ,
                             int *x2p , int *y2p , int *z2p , int *t2p ) ;
#line 91
void neighbor_coords(int x , int y , int z , int t , int dir , int *x2p , int *y2p ,
                     int *z2p , int *t2p ) ;
#line 153
char *field_pointer_at_coordinates(int field , int size , int x , int y , int z ,
                                   int t ) ;
#line 159
char *field_pointer_at_direction(field_offset field , int size , site *s , int direction ) ;
#line 167
void cleanup_field_pointer(char *buf ) ;
#line 178
void g_dcomplexsum(double_complex *cpt ) ;
#line 179
void g_veccomplexsum(complex *cpt , int ncomplex ) ;
#line 180
void g_wvectorsum(wilson_vector *wvpt ) ;
#line 184
void broadcast_double(double *dpt ) ;
#line 186
void broadcast_complex(complex *cpt ) ;
#line 187
void broadcast_dcomplex(double_complex *cpt ) ;
#line 196
void time_stamp(char *msg ) ;
#line 90 "com_vanilla.c"
int **neighbor  ;
#line 92 "com_vanilla.c"
int n_gathers  ;
#line 96 "com_vanilla.c"
void initialize_machine(int argc , char **argv ) 
{ 


  {
#line 96
  return;
}
}
#line 102 "com_vanilla.c"
void make_nn_gathers(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 114
//AD  tmp = calloc((size_t )8, sizeof(int *));
#line 114
//AD  neighbor = (int **)tmp;
  neighbor = (int **)calloc((size_t )8, sizeof(int *)); //AD
#line 115
  n_gathers = 0;
#line 117
  i = 0;
#line 117
  while (i <= 3) {
#line 118
    make_gather(& neighbor_coords_special, & i, 1, 0, 1);
#line 117
    i ++;
  }
#line 123
  sort_eight_special((void **)neighbor);
#line 124
  return;
}
}
#line 131 "com_vanilla.c"
void sort_eight_neighborlists(int index___0 ) 
{ 


  {
#line 132
  sort_eight_special((void **)(neighbor + index___0));
#line 133
  return;
}
}
#line 138 "com_vanilla.c"
void sort_eight_special(void **pt ) 
{ 
  void *tt[8] ;
  register int i ;

  {
#line 141
  i = 0;
#line 141
  while (i < 8) {
#line 141
    tt[i] = *(pt + i);
#line 141
    i ++;
  }
#line 142
  i = 0;
#line 142
  while (i <= 3) {
#line 142
    *(pt + i) = tt[2 * i];
#line 142
    *(pt + (7 - i)) = tt[2 * i + 1];
#line 142
    i ++;
  }
#line 143
  return;
}
}
#line 148 "com_vanilla.c"
void neighbor_coords_special(int x , int y , int z , int t , int *dirpt , int fb ,
                             int *x2p , int *y2p , int *z2p , int *t2p ) 
{ 
  int dir ;

  {
#line 156
  if (fb == 1) {
#line 156
    dir = *dirpt;
  } else {
#line 156
    dir = 7 - *dirpt;
  }
#line 157
  *x2p = x;
#line 157
  *y2p = y;
#line 157
  *z2p = z;
#line 157
  *t2p = t;
#line 158
  switch (dir) {
  case 0: 
#line 159
  *x2p = (x + 1) % nx;
#line 159
  break;
  case 7: 
#line 160
  *x2p = ((x + nx) - 1) % nx;
#line 160
  break;
  case 1: 
#line 161
  *y2p = (y + 1) % ny;
#line 161
  break;
  case 6: 
#line 162
  *y2p = ((y + ny) - 1) % ny;
#line 162
  break;
  case 2: 
#line 163
  *z2p = (z + 1) % nz;
#line 163
  break;
  case 5: 
#line 164
  *z2p = ((z + nz) - 1) % nz;
#line 164
  break;
  case 3: 
#line 165
  *t2p = (t + 1) % nt;
#line 165
  break;
  case 4: 
#line 166
  *t2p = ((t + nt) - 1) % nt;
#line 166
  break;
  default: 
#line 167
  printf((char const   * __restrict  )"BOTCH: bad direction\n");
#line 167
  exit(1);
  }
#line 169
  return;
}
}
#line 175 "com_vanilla.c"
int make_gather(void (*func)(int  , int  , int  , int  , int * , int  , int * , int * ,
                             int * , int * ) , int *args , int inverse , int want_even_odd ,
                int parity_conserve ) 
{ 
  register int i ;
  register int k ;
  register site *s ;
  int dir ;
  int x ;
  int y ;
  int z ;
  int t ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int x2 ;
  int y2 ;
  int z2 ;
  int t2 ;

  {
#line 204
  if (inverse == 1) {
#line 204
    n_gathers += 2;
  } else {
#line 205
    n_gathers ++;
  }
#line 206
  if (n_gathers > 32) {
#line 207
    if (this_node == 0) {
#line 207
      printf((char const   * __restrict  )"Too many gathers! change MAX_GATHERS\n");
    }
#line 208
    exit(1);
  }
#line 212
  tmp = realloc((void *)neighbor, (unsigned long )n_gathers * sizeof(int *));
#line 212
  neighbor = (int **)tmp;
#line 213
  if (inverse == 1) {
#line 214
//AD    tmp___0 = calloc((size_t )sites_on_node, sizeof(int ));
#line 214
//AD    *(neighbor + (n_gathers - 2)) = (int *)tmp___0;
    *(neighbor + (n_gathers - 2)) = (int *)calloc((size_t )sites_on_node, sizeof(int )); //AD
#line 215
    if ((unsigned long )*(neighbor + (n_gathers - 2)) == (unsigned long )((void *)0)) {
#line 216
      printf((char const   * __restrict  )"NODE %d: no room for neighbor vector\n",
             this_node);
#line 217
      terminate(1);
    }
#line 219
//AD    tmp___1 = calloc((size_t )sites_on_node, sizeof(int ));
#line 219
//AD    *(neighbor + (n_gathers - 1)) = (int *)tmp___1;
    *(neighbor + (n_gathers - 1)) = (int *)calloc((size_t )sites_on_node, sizeof(int )); //AD
#line 220
    if ((unsigned long )*(neighbor + (n_gathers - 1)) == (unsigned long )((void *)0)) {
#line 221
      printf((char const   * __restrict  )"NODE %d: no room for neighbor vector\n",
             this_node);
#line 222
      terminate(1);
    }
#line 224
    dir = n_gathers - 2;
  } else {
#line 227
//AD    tmp___2 = calloc((size_t )sites_on_node, sizeof(int ));
#line 227
//AD    *(neighbor + (n_gathers - 1)) = (int *)tmp___2;
    *(neighbor + (n_gathers - 1)) = (int *)calloc((size_t )sites_on_node, sizeof(int )); //AD
#line 228
    if ((unsigned long )*(neighbor + (n_gathers - 1)) == (unsigned long )((void *)0)) {
#line 229
      printf((char const   * __restrict  )"NODE %d: no room for neighbor vector\n",
             this_node);
#line 230
      terminate(1);
    }
#line 232
    dir = n_gathers - 1;
  }
#line 238
  i = 0;
#line 238
  s = lattice;
#line 238
  while (i < sites_on_node) {
#line 240
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, 1, & x, & y, & z,
            & t);
#line 241
    k = (((x + y) + z) + t) % 2;
#line 243
    if (x < 0) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (y < 0) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (z < 0) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (t < 0) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (x >= nx) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (y >= ny) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (z >= nz) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    } else
#line 243
    if (t >= nt) {
#line 244
      printf((char const   * __restrict  )"DUMMY! Your gather mapping does not stay in lattice\n");
#line 245
      printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
             (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 247
      terminate(1);
    }
#line 249
    if (parity_conserve == 0) {
#line 249
      if (k == 0) {
#line 249
        if ((int )s->parity == 1) {
#line 259
          printf((char const   * __restrict  )"DUMMY! Your gather mapping does not obey claimed parity\n");
#line 260
          printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
                 (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 262
          terminate(1);
        } else {
#line 249
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 249
      if (k == 1) {
#line 249
        if ((int )s->parity == 2) {
#line 259
          printf((char const   * __restrict  )"DUMMY! Your gather mapping does not obey claimed parity\n");
#line 260
          printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
                 (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 262
          terminate(1);
        } else {
#line 249
          goto _L___0;
        }
      } else {
#line 249
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 249
    if (parity_conserve == 1) {
#line 249
      if (k == 0) {
#line 249
        if ((int )s->parity == 2) {
#line 259
          printf((char const   * __restrict  )"DUMMY! Your gather mapping does not obey claimed parity\n");
#line 260
          printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
                 (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 262
          terminate(1);
        } else {
#line 249
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 249
      if (k == 1) {
#line 249
        if ((int )s->parity == 1) {
#line 259
          printf((char const   * __restrict  )"DUMMY! Your gather mapping does not obey claimed parity\n");
#line 260
          printf((char const   * __restrict  )"It mapped %d %d %d %d to %d %d %d %d\n",
                 (int )s->x, (int )s->y, (int )s->z, (int )s->t, x, y, z, t);
#line 262
          terminate(1);
        }
      }
    }
#line 264
    if (inverse == 0) {
#line 266
      (*func)(x, y, z, t, args, 1, & x2, & y2, & z2, & t2);
#line 267
      if ((int )s->x != x2) {
#line 268
        printf((char const   * __restrict  )"DUMMY! Your gather mapping is not its own inverse\n");
#line 270
        printf((char const   * __restrict  )"It\'s square mapped %d %d %d %d to %d %d %d %d\n",
               (int )s->x, (int )s->y, (int )s->z, (int )s->t, x2, y2, z2, t2);
#line 272
        terminate(1);
      } else
#line 267
      if ((int )s->y != y2) {
#line 268
        printf((char const   * __restrict  )"DUMMY! Your gather mapping is not its own inverse\n");
#line 270
        printf((char const   * __restrict  )"It\'s square mapped %d %d %d %d to %d %d %d %d\n",
               (int )s->x, (int )s->y, (int )s->z, (int )s->t, x2, y2, z2, t2);
#line 272
        terminate(1);
      } else
#line 267
      if ((int )s->z != z2) {
#line 268
        printf((char const   * __restrict  )"DUMMY! Your gather mapping is not its own inverse\n");
#line 270
        printf((char const   * __restrict  )"It\'s square mapped %d %d %d %d to %d %d %d %d\n",
               (int )s->x, (int )s->y, (int )s->z, (int )s->t, x2, y2, z2, t2);
#line 272
        terminate(1);
      } else
#line 267
      if ((int )s->t != t2) {
#line 268
        printf((char const   * __restrict  )"DUMMY! Your gather mapping is not its own inverse\n");
#line 270
        printf((char const   * __restrict  )"It\'s square mapped %d %d %d %d to %d %d %d %d\n",
               (int )s->x, (int )s->y, (int )s->z, (int )s->t, x2, y2, z2, t2);
#line 272
        terminate(1);
      }
    }
#line 238
    i ++;
#line 238
    s ++;
  }
#line 345
  i = 0;
#line 345
  s = lattice;
#line 345
  while (i < sites_on_node) {
#line 347
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, 1, & x, & y, & z,
            & t);
#line 349
    *(*(neighbor + dir) + i) = node_index(x, y, z, t);
#line 345
    i ++;
#line 345
    s ++;
  }
#line 352
  if (inverse != 1) {
#line 352
    return (dir);
  }
#line 359
  dir ++;
#line 363
  i = 0;
#line 363
  s = lattice;
#line 363
  while (i < sites_on_node) {
#line 365
    (*func)((int )s->x, (int )s->y, (int )s->z, (int )s->t, args, -1, & x, & y, & z,
            & t);
#line 368
    *(*(neighbor + dir) + i) = node_index(x, y, z, t);
#line 363
    i ++;
#line 363
    s ++;
  }
#line 371
  return (dir - 1);
}
}
#line 376 "com_vanilla.c"
void neighbor_coords(int x , int y , int z , int t , int dir , int *x2p , int *y2p ,
                     int *z2p , int *t2p ) 
{ 


  {
#line 382
  *x2p = x;
#line 382
  *y2p = y;
#line 382
  *z2p = z;
#line 382
  *t2p = t;
#line 383
  switch (dir) {
  case 0: 
#line 384
  *x2p = (x + 1) % nx;
#line 384
  break;
  case 7: 
#line 385
  *x2p = ((x + nx) - 1) % nx;
#line 385
  break;
  case 1: 
#line 386
  *y2p = (y + 1) % ny;
#line 386
  break;
  case 6: 
#line 387
  *y2p = ((y + ny) - 1) % ny;
#line 387
  break;
  case 2: 
#line 388
  *z2p = (z + 1) % nz;
#line 388
  break;
  case 5: 
#line 389
  *z2p = ((z + nz) - 1) % nz;
#line 389
  break;
  case 3: 
#line 390
  *t2p = (t + 1) % nt;
#line 390
  break;
  case 4: 
#line 391
  *t2p = ((t + nt) - 1) % nt;
#line 391
  break;
  default: 
#line 392
  printf((char const   * __restrict  )"BOTCH: bad direction\n");
#line 392
  exit(1);
  }
#line 394
  return;
}
}
#line 399 "com_vanilla.c"
void start_handlers(void) 
{ 


  {
#line 402
  return;
}
}
#line 460 "com_vanilla.c"
msg_tag *start_gather(field_offset field , int size , int index___0 , int parity ,
                      char **dest ) 
{ 
  register int j ;
  register site *s ;

  {
#line 476
  switch (parity) {
  case 2: 
#line 478
  j = 0;
#line 478
  s = lattice;
#line 478
  while (j < even_sites_on_node) {
#line 479
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
#line 478
    j ++;
#line 478
    s ++;
  }
#line 481
  break;
  case 1: 
#line 483
  j = even_sites_on_node;
#line 483
  s = lattice + j;
#line 483
  while (j < sites_on_node) {
#line 484
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
#line 483
    j ++;
#line 483
    s ++;
  }
#line 486
  break;
  case 3: 
#line 488
  j = 0;
#line 488
  s = lattice;
#line 488
  while (j < sites_on_node) {
#line 489
    *(dest + j) = (char *)(lattice + *(*(neighbor + index___0) + j)) + field;
#line 488
    j ++;
#line 488
    s ++;
  }
#line 491
  break;
  }
#line 495
  return ((msg_tag *)((void *)0));
}
}
#line 537 "com_vanilla.c"
void restart_gather(field_offset field , int size , int index___0 , int parity , char **dest ,
                    msg_tag *mbuf ) 
{ 


  {
#line 549
  return;
}
}
#line 553 "com_vanilla.c"
msg_tag *start_gather_from_temp(void *field , int size , int index___0 , int parity ,
                                char **dest ) 
{ 
  register int j ;
  register site *s ;

  {
#line 569
  switch (parity) {
  case 2: 
#line 571
  j = 0;
#line 571
  s = lattice;
#line 571
  while (j < even_sites_on_node) {
#line 572
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
#line 571
    j ++;
#line 571
    s ++;
  }
#line 574
  break;
  case 1: 
#line 576
  j = even_sites_on_node;
#line 576
  s = lattice + j;
#line 576
  while (j < sites_on_node) {
#line 577
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
#line 576
    j ++;
#line 576
    s ++;
  }
#line 579
  break;
  case 3: 
#line 581
  j = 0;
#line 581
  s = lattice;
#line 581
  while (j < sites_on_node) {
#line 582
    *(dest + j) = (char *)field + *(*(neighbor + index___0) + j) * size;
#line 581
    j ++;
#line 581
    s ++;
  }
#line 584
  break;
  }
#line 588
  return ((msg_tag *)((void *)0));
}
}
#line 630 "com_vanilla.c"
void restart_gather_from_temp(void *field , int size , int index___0 , int parity ,
                              char **dest , msg_tag *mbuf ) 
{ 


  {
#line 642
  return;
}
}
#line 644 "com_vanilla.c"
void wait_gather(msg_tag *mbuf ) 
{ 


  {
#line 645
  return;
}
}
#line 649 "com_vanilla.c"
void cleanup_gather(msg_tag *mbuf ) 
{ 


  {
#line 650
  return;
}
}
#line 685 "com_vanilla.c"
int g_gather_flag  =    0;
#line 689 "com_vanilla.c"
msg_tag *start_general_gather(field_offset field , int size , int *displacement ,
                              int parity , char **dest ) 
{ 
  register int i ;
  register site *s ;
  int tx ;
  int ty ;
  int tz ;
  int tt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 705
  if (g_gather_flag != 0) {
#line 706
    tmp = mynode();
#line 706
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: node %d, two general_gathers() at once!\n",
            tmp);
#line 708
    exit(1);
  }
#line 714
  if (parity == 1) {
#line 714
    i = even_sites_on_node;
  } else {
#line 714
    i = 0;
  }
#line 714
  s = lattice + i;
#line 714
  while (1) {
#line 714
    if (parity == 2) {
#line 714
      tmp___1 = even_sites_on_node;
    } else {
#line 714
      tmp___1 = sites_on_node;
    }
#line 714
    if (! (i < tmp___1)) {
#line 714
      break;
    }
#line 715
    if (*(displacement + 0) != 0) {
#line 715
      tx = (((int )s->x + *(displacement + 0)) + nx) % nx;
    } else {
#line 716
      tx = (int )s->x;
    }
#line 717
    if (*(displacement + 1) != 0) {
#line 717
      ty = (((int )s->y + *(displacement + 1)) + ny) % ny;
    } else {
#line 718
      ty = (int )s->y;
    }
#line 719
    if (*(displacement + 2) != 0) {
#line 719
      tz = (((int )s->z + *(displacement + 2)) + nz) % nz;
    } else {
#line 720
      tz = (int )s->z;
    }
#line 721
    if (*(displacement + 3) != 0) {
#line 721
      tt = (((int )s->t + *(displacement + 3)) + nt) % nt;
    } else {
#line 722
      tt = (int )s->t;
    }
#line 723
    tmp___0 = node_index(tx, ty, tz, tt);
#line 723
    *(dest + i) = (char *)(lattice + tmp___0) + field;
#line 714
    i ++;
#line 714
    s ++;
  }
#line 727
  g_gather_flag = 1;
#line 729
  return ((msg_tag *)((void *)0));
}
}
#line 794 "com_vanilla.c"
void wait_general_gather(msg_tag *mbuf ) 
{ 


  {
#line 795
  g_gather_flag = 0;
#line 796
  return;
}
}
#line 800 "com_vanilla.c"
void cleanup_general_gather(msg_tag *mbuf ) 
{ 


  {
#line 801
  return;
}
}
#line 819 "com_vanilla.c"
char *field_pointer_at_coordinates(int field , int size , int x , int y , int z ,
                                   int t ) 
{ 
  int index___0 ;

  {
#line 826
  index___0 = node_index(x, y, z, t);
#line 828
  return ((char *)(lattice + index___0) + field);
}
}
#line 835 "com_vanilla.c"
char *field_pointer_at_direction(field_offset field , int size , site *s , int direction ) 
{ 


  {
#line 843
  return ((char *)*(*(neighbor + direction) + (s - lattice)) + field);
}
}
#line 849 "com_vanilla.c"
void cleanup_field_pointer(char *buf ) 
{ 


  {
#line 850
  return;
}
}
#line 854 "com_vanilla.c"
void send_field(char *buf , int size , int tonode ) 
{ 


  {
#line 855
  printf((char const   * __restrict  )"BOTCH: this never happens\n");
#line 856
  return;
}
}
#line 858 "com_vanilla.c"
void get_field(char *buf , int size ) 
{ 


  {
#line 859
  printf((char const   * __restrict  )"BOTCH: this never happens\n");
#line 860
  return;
}
}
#line 866 "com_vanilla.c"
static char name[17]  = 
#line 866
  {      (char )'S',      (char )'c',      (char )'a',      (char )'l', 
        (char )'a',      (char )'r',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'c',      (char )'e', 
        (char )'s',      (char )'s',      (char )'o',      (char )'r', 
        (char )'\000'};
#line 867 "com_vanilla.c"
char *machine_type(void) 
{ 


  {
#line 868
  return (name);
}
}
#line 872 "com_vanilla.c"
int mynode(void) 
{ 


  {
#line 872
  return (0);
}
}
#line 875 "com_vanilla.c"
int numnodes(void) 
{ 


  {
#line 875
  return (1);
}
}
#line 878 "com_vanilla.c"
void g_sync(void) 
{ 


  {
#line 879
  return;
}
}
#line 882 "com_vanilla.c"
void g_floatsum(float *fpt ) 
{ 


  {
#line 883
  return;
}
}
#line 886 "com_vanilla.c"
void g_doublesum(double *dpt ) 
{ 


  {
#line 887
  return;
}
}
#line 890 "com_vanilla.c"
void g_vecdoublesum(double *dpt , int ndoubles ) 
{ 


  {
#line 891
  return;
}
}
#line 894 "com_vanilla.c"
void g_complexsum(complex *cpt ) 
{ 


  {
#line 895
  return;
}
}
#line 898 "com_vanilla.c"
void g_dcomplexsum(double_complex *cpt ) 
{ 


  {
#line 899
  return;
}
}
#line 902 "com_vanilla.c"
void g_veccomplexsum(complex *cpt , int ncomplex ) 
{ 


  {
#line 903
  return;
}
}
#line 906 "com_vanilla.c"
void g_wvectorsum(wilson_vector *wvpt ) 
{ 


  {
#line 907
  return;
}
}
#line 910 "com_vanilla.c"
void g_xor32(u_int32type *pt ) 
{ 


  {
#line 911
  return;
}
}
#line 914 "com_vanilla.c"
void g_floatmax(float *fpt ) 
{ 


  {
#line 915
  return;
}
}
#line 918 "com_vanilla.c"
void g_doublemax(double *dpt ) 
{ 


  {
#line 919
  return;
}
}
#line 922 "com_vanilla.c"
void broadcast_float(float *fpt ) 
{ 


  {
#line 923
  return;
}
}
#line 926 "com_vanilla.c"
void broadcast_double(double *dpt ) 
{ 


  {
#line 927
  return;
}
}
#line 930 "com_vanilla.c"
void broadcast_complex(complex *cpt ) 
{ 


  {
#line 931
  return;
}
}
#line 934 "com_vanilla.c"
void broadcast_dcomplex(double_complex *cpt ) 
{ 


  {
#line 935
  return;
}
}
#line 938 "com_vanilla.c"
void broadcast_bytes(char *buf , int size ) 
{ 


  {
#line 939
  return;
}
}
#line 943 "com_vanilla.c"
void send_integer(int tonode , int *address ) 
{ 


  {
#line 944
  printf((char const   * __restrict  )"BOTCH: this never happens\n");
#line 945
  return;
}
}
#line 949 "com_vanilla.c"
void receive_integer(int *address ) 
{ 


  {
#line 950
  printf((char const   * __restrict  )"BOTCH: this never happens\n");
#line 951
  return;
}
}
#line 956 "com_vanilla.c"
double dclock(void) 
{ 
  long fine ;

  {
#line 959
  fine = (long )0.;
#line 960
  return ((double )fine / 1000000.0);
}
}
#line 964 "com_vanilla.c"
void time_stamp(char *msg ) 
{ 
  time_t time_stamp___0 ;
  char *tmp ;
  int tmp___0 ;

  {
#line 967
  tmp___0 = mynode();
#line 967
  if (tmp___0 == 0) {
#line 968
    time(& time_stamp___0);
#line 969
    tmp = ctime((time_t const   *)(& time_stamp___0));
#line 969
    printf((char const   * __restrict  )"%s: %s\n", msg, tmp);
  }
#line 971
  return;
}
}
#line 974 "com_vanilla.c"
void terminate(int status ) 
{ 


  {
#line 975
  time_stamp((char *)"termination");
#line 976
  printf((char const   * __restrict  )"Termination: status = %d\n", status);
#line 977
  fflush(stdout);
#line 977
  fflush(stderr);
#line 978
  exit(status);
}
}
#line 982 "com_vanilla.c"
void normal_exit(int status ) 
{ 


  {
#line 984
  exit(status);
}
}
#line 1 "io_nonansi.o"
#pragma merger("0","/tmp/cil-7G9084az.i","")
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 356
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 28 "io_nonansi.c"
FILE *g_open(char const   *filename , char const   *mode ) 
{ 
  int fd ;
  int oflg ;
  int *fp ;
  char *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 40
  if ((int const   )*(mode + 0) == 97) {
#line 42
    printf((char const   * __restrict  )"g_open: Node %d. Append not supported in PIOFS\n",
           this_node);
#line 43
    return ((FILE *)((void *)0));
  } else
#line 46
  if ((int const   )*(mode + 0) == 119) {
#line 48
    oflg = 65;
  } else
#line 51
  if ((int const   )*(mode + 0) == 114) {
#line 53
    oflg = 0;
#line 54
    tmp = strchr(mode, '+');
#line 54
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 55
      oflg = 2;
    }
  } else {
#line 60
    printf((char const   * __restrict  )"g_open: Node %d. mode %s not recognized\n",
           this_node, mode);
#line 61
    return ((FILE *)((void *)0));
  }
#line 66
  fd = open(filename, oflg, 420);
#line 66
  if (fd == -1) {
#line 68
    tmp___0 = __errno_location();
#line 68
    printf((char const   * __restrict  )"g_open: Node %d error %d opening %s\n", this_node,
           *tmp___0, filename);
#line 70
    return ((FILE *)((void *)0));
  }
#line 79
//AD  tmp___1 = calloc((size_t )1, sizeof(int ));
#line 79
//AD  fp = (int *)tmp___1;
  fp = (int *)calloc((size_t )1, sizeof(int )); //AD
#line 80
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 82
    printf((char const   * __restrict  )"g_open: Node %d can\'t malloc fp\n", this_node);
#line 83
    fflush(stdout);
#line 83
    terminate(1);
  }
#line 86
  *fp = fd;
#line 88
  return ((FILE *)fp);
}
}
#line 91 "io_nonansi.c"
int g_seek(FILE *stream , off_t offset , int whence ) 
{ 
  int fd ;
  __off_t tmp ;

  {
#line 94
  fd = *((int *)stream);
#line 96
  tmp = lseek(fd, offset, whence);
#line 96
  return ((int )tmp);
}
}
#line 99 "io_nonansi.c"
size_t g_write(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int fd ;
  ssize_t tmp ;

  {
#line 102
  fd = *((int *)stream);
#line 104
  tmp = write(fd, ptr, (size_t )((int )(size * nmemb)));
#line 104
  return ((size_t )tmp / size);
}
}
#line 107 "io_nonansi.c"
size_t g_read(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int fd ;
  ssize_t tmp ;

  {
#line 110
  fd = *((int *)stream);
#line 112
  tmp = read(fd, ptr, (size_t )((int )(size * nmemb)));
#line 112
  return ((size_t )tmp / size);
}
}
#line 115 "io_nonansi.c"
int g_close(FILE *stream ) 
{ 
  int fd ;
  int status ;

  {
#line 118
  fd = *((int *)stream);
#line 120
  status = close(fd);
#line 121
  free((void *)stream);
#line 122
  return (status);
}
}

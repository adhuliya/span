/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 14 "./sjeng.h"
enum __anonenum_xbool_1 {
    FALSE = 0,
    TRUE = 1
} ;
#line 14 "./sjeng.h"
typedef enum __anonenum_xbool_1 xbool;
#line 95 "./sjeng.h"
struct __anonstruct_move_s_52 {
   int from ;
   int target ;
   int captured ;
   int promoted ;
   int castled ;
   int ep ;
};
#line 95 "./sjeng.h"
typedef struct __anonstruct_move_s_52 move_s;
#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 14 "ecache.c"
struct __anonstruct_ECacheType_54 {
   unsigned int stored_hash ;
   unsigned int hold_hash ;
   int score ;
};
#line 14 "ecache.c"
typedef struct __anonstruct_ECacheType_54 ECacheType;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 161 "./sjeng.h"
typedef time_t rtime_t;
#line 104 "./sjeng.h"
struct __anonstruct_move_x_53 {
   int cap_num ;
   int was_promoted ;
   int epsq ;
   int fifty ;
};
#line 104 "./sjeng.h"
typedef struct __anonstruct_move_x_53 move_x;
#line 23 "neval.c"
typedef int (*EVALFUNC)(int sq , int c );
#line 45 "proof.c"
struct node {
   unsigned char value ;
   unsigned char num_children ;
   unsigned char expanded ;
   unsigned char evaluated ;
   int proof ;
   int disproof ;
   struct node **children ;
   struct node *parent ;
   move_s move ;
};
#line 45 "proof.c"
typedef struct node node_t;
#line 13 "see.c"
struct __anonstruct_see_data_54 {
   int piece ;
   int square ;
};
#line 13 "see.c"
typedef struct __anonstruct_see_data_54 see_data;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "ttable.c"
struct __anonstruct_TType_54 {
   char Depth ;
   char OnMove ;
   char Threat ;
   char Type ;
   unsigned short Bestmove ;
   unsigned int HashKey ;
   unsigned int Hold_hash ;
   int Bound ;
};
#line 23 "ttable.c"
typedef struct __anonstruct_TType_54 TType;
#line 36 "ttable.c"
struct __anonstruct_QTType_55 {
   char OnMove ;
   char Type ;
   unsigned short Bestmove ;
   unsigned int HashKey ;
   unsigned int Hold_hash ;
   int Bound ;
};
#line 36 "ttable.c"
typedef struct __anonstruct_QTType_55 QTType;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 1 "attacks.o"
#pragma merger("0","/tmp/cil-BwyfnHhl.i","")
#line 28 "./protos.h"
xbool is_attacked(int square , int color ) ;
#line 29
xbool nk_attacked(int square , int color ) ;
#line 100
int calc_attackers(int square , int color ) ;
#line 12 "./extvars.h"
int board[144] ;
#line 18 "attacks.c"
static int const   rook_o[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
#line 19 "attacks.c"
static int const   bishop_o[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
#line 20 "attacks.c"
static int const   knight_o[8]  = 
#line 20
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 14 "attacks.c"
int calc_attackers(int square , int color ) 
{ 
  int a_sq ;
  int i ;
  int attackers ;

  {
#line 23
  attackers = 0;
#line 25
  if (board[square] == 0) {
#line 25
    return (0);
  }
#line 28
  if (color % 2) {
#line 30
    i = 0;
#line 30
    while (i < 4) {
#line 31
      a_sq = square + (int )rook_o[i];
#line 34
      if (board[a_sq] == 5) {
#line 36
        attackers ++;
#line 37
        break;
      } else {
#line 42
        while (board[a_sq] != 0) {
#line 43
          if (board[a_sq] == 7) {
#line 45
            attackers ++;
#line 46
            break;
          } else
#line 43
          if (board[a_sq] == 9) {
#line 45
            attackers ++;
#line 46
            break;
          } else
#line 48
          if (board[a_sq] != 13) {
#line 48
            break;
          }
#line 49
          a_sq += (int )rook_o[i];
        }
      }
#line 30
      i ++;
    }
#line 55
    i = 0;
#line 55
    while (i < 4) {
#line 56
      a_sq = square + (int )bishop_o[i];
#line 58
      if (board[a_sq] == 1) {
#line 58
        if (i % 2) {
#line 60
          attackers ++;
#line 61
          break;
        } else {
#line 58
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 64
      if (board[a_sq] == 5) {
#line 66
        attackers ++;
#line 67
        break;
      } else {
#line 71
        while (board[a_sq] != 0) {
#line 72
          if (board[a_sq] == 11) {
#line 74
            attackers ++;
#line 75
            break;
          } else
#line 72
          if (board[a_sq] == 9) {
#line 74
            attackers ++;
#line 75
            break;
          } else
#line 77
          if (board[a_sq] != 13) {
#line 77
            break;
          }
#line 78
          a_sq += (int )bishop_o[i];
        }
      }
#line 55
      i ++;
    }
#line 84
    i = 0;
#line 84
    while (i < 8) {
#line 85
      a_sq = square + (int )knight_o[i];
#line 86
      if (board[a_sq] == 3) {
#line 87
        attackers ++;
      }
#line 84
      i ++;
    }
  } else {
#line 98
    i = 0;
#line 98
    while (i < 4) {
#line 99
      a_sq = square + (int )rook_o[i];
#line 101
      if (board[a_sq] == 6) {
#line 103
        attackers ++;
#line 104
        break;
      } else {
#line 108
        while (board[a_sq] != 0) {
#line 109
          if (board[a_sq] == 8) {
#line 111
            attackers ++;
#line 112
            break;
          } else
#line 109
          if (board[a_sq] == 10) {
#line 111
            attackers ++;
#line 112
            break;
          }
#line 114
          if (board[a_sq] != 13) {
#line 114
            break;
          }
#line 115
          a_sq += (int )rook_o[i];
        }
      }
#line 98
      i ++;
    }
#line 121
    i = 0;
#line 121
    while (i < 4) {
#line 122
      a_sq = square + (int )bishop_o[i];
#line 124
      if (board[a_sq] == 2) {
#line 124
        if (! (i % 2)) {
#line 126
          attackers ++;
#line 127
          break;
        } else {
#line 124
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 130
      if (board[a_sq] == 6) {
#line 132
        attackers ++;
#line 133
        break;
      } else {
#line 136
        while (board[a_sq] != 0) {
#line 137
          if (board[a_sq] == 12) {
#line 139
            attackers ++;
#line 140
            break;
          } else
#line 137
          if (board[a_sq] == 10) {
#line 139
            attackers ++;
#line 140
            break;
          } else
#line 142
          if (board[a_sq] != 13) {
#line 142
            break;
          }
#line 143
          a_sq += (int )bishop_o[i];
        }
      }
#line 121
      i ++;
    }
#line 149
    i = 0;
#line 149
    while (i < 8) {
#line 150
      a_sq = square + (int )knight_o[i];
#line 151
      if (board[a_sq] == 4) {
#line 152
        attackers ++;
      }
#line 149
      i ++;
    }
  }
#line 158
  return (attackers);
}
}
#line 167 "attacks.c"
static int const   rook_o___0[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
#line 168 "attacks.c"
static int const   bishop_o___0[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
#line 169 "attacks.c"
static int const   knight_o___0[8]  = 
#line 169
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 162 "attacks.c"
xbool is_attacked(int square , int color ) 
{ 
  register int ndir ;
  register int a_sq ;
  register int basq ;
  register int i ;

  {
#line 174
  if (color & 1) {
#line 177
    i = 0;
#line 177
    while (i < 4) {
#line 178
      ndir = (int )bishop_o___0[i];
#line 179
      a_sq = square + ndir;
#line 180
      basq = board[a_sq];
#line 182
      if (basq == 1) {
#line 182
        if (i & 1) {
#line 182
          return ((xbool )1);
        }
      }
#line 184
      if (basq == 5) {
#line 184
        return ((xbool )1);
      }
#line 185
      while (basq != 0) {
#line 186
        if (basq == 11) {
#line 186
          return ((xbool )1);
        } else
#line 186
        if (basq == 9) {
#line 186
          return ((xbool )1);
        }
#line 187
        if (basq != 13) {
#line 187
          break;
        }
#line 188
        a_sq += ndir;
#line 189
        basq = board[a_sq];
      }
#line 177
      i ++;
    }
#line 193
    i = 0;
#line 193
    while (i < 8) {
#line 194
      if (board[square + (int )knight_o___0[i]] == 3) {
#line 194
        return ((xbool )1);
      }
#line 193
      i ++;
    }
#line 197
    i = 0;
#line 197
    while (i < 4) {
#line 198
      ndir = (int )rook_o___0[i];
#line 199
      a_sq = square + ndir;
#line 200
      basq = board[a_sq];
#line 202
      if (basq == 5) {
#line 202
        return ((xbool )1);
      }
#line 204
      while (basq != 0) {
#line 205
        if (basq == 7) {
#line 205
          return ((xbool )1);
        } else
#line 205
        if (basq == 9) {
#line 205
          return ((xbool )1);
        }
#line 206
        if (basq != 13) {
#line 206
          break;
        }
#line 207
        a_sq += ndir;
#line 208
        basq = board[a_sq];
      }
#line 197
      i ++;
    }
#line 213
    return ((xbool )0);
  } else {
#line 220
    i = 0;
#line 220
    while (i < 4) {
#line 221
      ndir = (int )bishop_o___0[i];
#line 222
      a_sq = square + ndir;
#line 223
      basq = board[a_sq];
#line 225
      if (basq == 2) {
#line 225
        if (! (i & 1)) {
#line 225
          return ((xbool )1);
        }
      }
#line 227
      if (basq == 6) {
#line 227
        return ((xbool )1);
      }
#line 228
      while (basq != 0) {
#line 229
        if (basq == 12) {
#line 229
          return ((xbool )1);
        } else
#line 229
        if (basq == 10) {
#line 229
          return ((xbool )1);
        }
#line 230
        if (basq != 13) {
#line 230
          break;
        }
#line 231
        a_sq += ndir;
#line 232
        basq = board[a_sq];
      }
#line 220
      i ++;
    }
#line 237
    i = 0;
#line 237
    while (i < 8) {
#line 238
      if (board[square + (int )knight_o___0[i]] == 4) {
#line 238
        return ((xbool )1);
      }
#line 237
      i ++;
    }
#line 242
    i = 0;
#line 242
    while (i < 4) {
#line 243
      ndir = (int )rook_o___0[i];
#line 244
      a_sq = square + (int )rook_o___0[i];
#line 245
      basq = board[a_sq];
#line 247
      if (basq == 6) {
#line 247
        return ((xbool )1);
      }
#line 249
      while (basq != 0) {
#line 250
        if (basq == 8) {
#line 250
          return ((xbool )1);
        } else
#line 250
        if (basq == 10) {
#line 250
          return ((xbool )1);
        }
#line 251
        if (basq != 13) {
#line 251
          break;
        }
#line 252
        a_sq += ndir;
#line 253
        basq = board[a_sq];
      }
#line 242
      i ++;
    }
#line 258
    return ((xbool )0);
  }
}
}
#line 269 "attacks.c"
static int const   rook_o___1[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
#line 270 "attacks.c"
static int const   bishop_o___1[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
#line 271 "attacks.c"
static int const   knight_o___1[8]  = 
#line 271
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 264 "attacks.c"
xbool nk_attacked(int square , int color ) 
{ 
  register int ndir ;
  register int a_sq ;
  register int basq ;
  register int i ;

  {
#line 276
  if (color & 1) {
#line 279
    i = 0;
#line 279
    while (i < 4) {
#line 280
      ndir = (int )bishop_o___1[i];
#line 281
      a_sq = square + ndir;
#line 282
      basq = board[a_sq];
#line 284
      if (basq == 1) {
#line 284
        if (i & 1) {
#line 284
          return ((xbool )1);
        }
      }
#line 286
      while (basq != 0) {
#line 287
        if (basq == 11) {
#line 287
          return ((xbool )1);
        } else
#line 287
        if (basq == 9) {
#line 287
          return ((xbool )1);
        }
#line 288
        if (basq != 13) {
#line 288
          break;
        }
#line 289
        a_sq += ndir;
#line 290
        basq = board[a_sq];
      }
#line 279
      i ++;
    }
#line 294
    i = 0;
#line 294
    while (i < 8) {
#line 295
      if (board[square + (int )knight_o___1[i]] == 3) {
#line 295
        return ((xbool )1);
      }
#line 294
      i ++;
    }
#line 298
    i = 0;
#line 298
    while (i < 4) {
#line 299
      ndir = (int )rook_o___1[i];
#line 300
      a_sq = square + ndir;
#line 301
      basq = board[a_sq];
#line 303
      while (basq != 0) {
#line 304
        if (basq == 7) {
#line 304
          return ((xbool )1);
        } else
#line 304
        if (basq == 9) {
#line 304
          return ((xbool )1);
        }
#line 305
        if (basq != 13) {
#line 305
          break;
        }
#line 306
        a_sq += ndir;
#line 307
        basq = board[a_sq];
      }
#line 298
      i ++;
    }
#line 312
    return ((xbool )0);
  } else {
#line 319
    i = 0;
#line 319
    while (i < 4) {
#line 320
      ndir = (int )bishop_o___1[i];
#line 321
      a_sq = square + ndir;
#line 322
      basq = board[a_sq];
#line 324
      if (basq == 2) {
#line 324
        if (! (i & 1)) {
#line 324
          return ((xbool )1);
        }
      }
#line 326
      while (basq != 0) {
#line 327
        if (basq == 12) {
#line 327
          return ((xbool )1);
        } else
#line 327
        if (basq == 10) {
#line 327
          return ((xbool )1);
        }
#line 328
        if (basq != 13) {
#line 328
          break;
        }
#line 329
        a_sq += ndir;
#line 330
        basq = board[a_sq];
      }
#line 319
      i ++;
    }
#line 335
    i = 0;
#line 335
    while (i < 8) {
#line 336
      if (board[square + (int )knight_o___1[i]] == 4) {
#line 336
        return ((xbool )1);
      }
#line 335
      i ++;
    }
#line 340
    i = 0;
#line 340
    while (i < 4) {
#line 341
      ndir = (int )rook_o___1[i];
#line 342
      a_sq = square + (int )rook_o___1[i];
#line 343
      basq = board[a_sq];
#line 345
      while (basq != 0) {
#line 346
        if (basq == 8) {
#line 346
          return ((xbool )1);
        } else
#line 346
        if (basq == 10) {
#line 346
          return ((xbool )1);
        }
#line 347
        if (basq != 13) {
#line 347
          break;
        }
#line 348
        a_sq += ndir;
#line 349
        basq = board[a_sq];
      }
#line 340
      i ++;
    }
#line 354
    return ((xbool )0);
  }
}
}
#line 1 "book.o"
#pragma merger("0","/tmp/cil-pLJclpDr.i","")
#line 25 "./extvars.h"
move_s dummy ;
#line 16 "book.c"
int init_book(void) 
{ 


  {
#line 18
  return (1);
}
}
#line 22 "book.c"
move_s choose_book_move(void) 
{ 


  {
#line 24
  return (dummy);
}
}
#line 1 "crazy.o"
#pragma merger("0","/tmp/cil-WUlgFZIX.i","")
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 72 "./protos.h"
void ProcessHoldings(char *str ) ;
#line 73
void addHolding(int what , int who ) ;
#line 74
void removeHolding(int what , int who ) ;
#line 75
void DropaddHolding(int what , int who ) ;
#line 76
void DropremoveHolding(int what , int who ) ;
#line 78
void printHolding(void) ;
#line 80
int SwitchColor(int piece ) ;
#line 81
int SwitchPromoted(int piece ) ;
#line 107
void reset_ecache(void) ;
#line 12 "./extvars.h"
int comp_color ;
#line 34 "./extvars.h"
int holding[2][16]  ;
#line 35 "./extvars.h"
int num_holding[2]  ;
#line 37 "./extvars.h"
int white_hand_eval  ;
#line 38 "./extvars.h"
int black_hand_eval  ;
#line 39
int hand_value[13] ;
#line 42 "./extvars.h"
int drop_piece  ;
#line 55
unsigned int zobrist[14][144] ;
#line 65 "./extvars.h"
unsigned int hold_hash  ;
#line 74
int Material ;
#line 75
int material[14] ;
#line 99
int Variant ;
#line 156 "./extvars.h"
int userealholdings  ;
#line 157 "./extvars.h"
char realholdings[255]  ;
#line 32 "crazy.c"
void ProcessHoldings(char *str ) 
{ 
  int c ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 36
  i = 0;
#line 38
  memset((void *)(holding), 0, sizeof(holding));
#line 39
  hold_hash = 3237998080U;
#line 41
  white_hand_eval = 0;
#line 42
  black_hand_eval = 0;
#line 43
  reset_ecache();
#line 45
  num_holding[0] = 0;
#line 46
  num_holding[1] = 0;
#line 48
  c = 0;
#line 48
  while (c <= 1) {
#line 50
    while (1) {
#line 50
      tmp = i;
#line 50
      i ++;
#line 50
      if (! ((int )*(str + tmp) != 91)) {
#line 50
        break;
      }
#line 51
      if ((int )*(str + i) == 0) {
#line 51
        return;
      }
    }
#line 53
    while ((int )*(str + i) != 93) {
#line 54
      tmp___0 = i;
#line 54
      i ++;
#line 54
      switch ((int )*(str + tmp___0)) {
      case 80: 
      case 112: 
#line 57
      if (c == 0) {
#line 57
        tmp___1 = 1;
      } else {
#line 57
        tmp___1 = 2;
      }
#line 57
      (holding[c][tmp___1]) ++;
#line 58
      (num_holding[c]) ++;
#line 59
      if (c == 0) {
#line 59
        tmp___2 = 1;
      } else {
#line 59
        tmp___2 = 2;
      }
#line 59
      if (c == 0) {
#line 59
        tmp___3 = 1;
      } else {
#line 59
        tmp___3 = 2;
      }
#line 59
      hold_hash ^= zobrist[tmp___2][holding[c][tmp___3]];
#line 61
      break;
      case 81: 
      case 113: 
#line 64
      if (c == 0) {
#line 64
        tmp___4 = 9;
      } else {
#line 64
        tmp___4 = 10;
      }
#line 64
      (holding[c][tmp___4]) ++;
#line 65
      (num_holding[c]) ++;
#line 66
      if (c == 0) {
#line 66
        tmp___5 = 9;
      } else {
#line 66
        tmp___5 = 10;
      }
#line 66
      if (c == 0) {
#line 66
        tmp___6 = 9;
      } else {
#line 66
        tmp___6 = 10;
      }
#line 66
      hold_hash ^= zobrist[tmp___5][holding[c][tmp___6]];
#line 68
      break;
      case 82: 
      case 114: 
#line 71
      if (c == 0) {
#line 71
        tmp___7 = 7;
      } else {
#line 71
        tmp___7 = 8;
      }
#line 71
      (holding[c][tmp___7]) ++;
#line 72
      (num_holding[c]) ++;
#line 73
      if (c == 0) {
#line 73
        tmp___8 = 7;
      } else {
#line 73
        tmp___8 = 8;
      }
#line 73
      if (c == 0) {
#line 73
        tmp___9 = 7;
      } else {
#line 73
        tmp___9 = 8;
      }
#line 73
      hold_hash ^= zobrist[tmp___8][holding[c][tmp___9]];
#line 75
      break;
      case 66: 
      case 98: 
#line 78
      if (c == 0) {
#line 78
        tmp___10 = 11;
      } else {
#line 78
        tmp___10 = 12;
      }
#line 78
      (holding[c][tmp___10]) ++;
#line 79
      (num_holding[c]) ++;
#line 80
      if (c == 0) {
#line 80
        tmp___11 = 11;
      } else {
#line 80
        tmp___11 = 12;
      }
#line 80
      if (c == 0) {
#line 80
        tmp___12 = 11;
      } else {
#line 80
        tmp___12 = 12;
      }
#line 80
      hold_hash ^= zobrist[tmp___11][holding[c][tmp___12]];
#line 82
      break;
      case 78: 
      case 110: 
#line 85
      if (c == 0) {
#line 85
        tmp___13 = 3;
      } else {
#line 85
        tmp___13 = 4;
      }
#line 85
      (holding[c][tmp___13]) ++;
#line 86
      (num_holding[c]) ++;
#line 87
      if (c == 0) {
#line 87
        tmp___14 = 3;
      } else {
#line 87
        tmp___14 = 4;
      }
#line 87
      if (c == 0) {
#line 87
        tmp___15 = 3;
      } else {
#line 87
        tmp___15 = 4;
      }
#line 87
      hold_hash ^= zobrist[tmp___14][holding[c][tmp___15]];
#line 89
      break;
      default: 
#line 91
      return;
      }
    }
#line 48
    c ++;
  }
#line 97
  if (Variant == 1) {
#line 97
    if (! userealholdings) {
#line 99
      strncpy((char * __restrict  )(realholdings), (char const   * __restrict  )str,
              (size_t )200);
#line 101
      if (comp_color == 1) {
#line 104
        if (holding[1][2] == 0) {
#line 106
          (holding[1][2]) ++;
#line 107
          (num_holding[1]) ++;
#line 108
          hold_hash ^= zobrist[2][holding[1][2]];
        }
#line 110
        if (holding[1][12] == 0) {
#line 112
          (holding[1][12]) ++;
#line 113
          (num_holding[1]) ++;
#line 114
          hold_hash ^= zobrist[2][holding[1][12]];
        }
#line 116
        if (holding[1][4] == 0) {
#line 118
          (holding[1][4]) ++;
#line 119
          (num_holding[1]) ++;
#line 120
          hold_hash ^= zobrist[4][holding[1][4]];
        }
#line 122
        if (holding[1][8] == 0) {
#line 124
          (holding[1][8]) ++;
#line 125
          (num_holding[1]) ++;
#line 126
          hold_hash ^= zobrist[4][holding[1][8]];
        }
#line 128
        if (holding[1][10] == 0) {
#line 130
          (holding[1][10]) ++;
#line 131
          (num_holding[1]) ++;
#line 132
          hold_hash ^= zobrist[4][holding[1][10]];
        }
      } else {
#line 138
        if (holding[0][9] == 0) {
#line 140
          (holding[0][9]) ++;
#line 141
          (num_holding[0]) ++;
#line 142
          hold_hash ^= zobrist[9][holding[0][9]];
        }
#line 144
        if (holding[0][7] == 0) {
#line 146
          (holding[0][7]) ++;
#line 147
          (num_holding[0]) ++;
#line 148
          hold_hash ^= zobrist[9][holding[0][7]];
        }
#line 150
        if (holding[0][11] == 0) {
#line 152
          (holding[0][11]) ++;
#line 153
          (num_holding[0]) ++;
#line 154
          hold_hash ^= zobrist[9][holding[0][11]];
        }
#line 156
        if (holding[0][3] == 0) {
#line 158
          (holding[0][3]) ++;
#line 159
          (num_holding[0]) ++;
#line 160
          hold_hash ^= zobrist[9][holding[0][3]];
        }
#line 162
        if (holding[0][1] == 0) {
#line 164
          (holding[0][1]) ++;
#line 165
          (num_holding[0]) ++;
#line 166
          hold_hash ^= zobrist[9][holding[0][1]];
        }
      }
    }
  }
#line 170
  return;
}
}
#line 172 "crazy.c"
int text_to_piece(char txt , int who ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 174
  switch ((int )txt) {
  case 80: 
  case 112: 
#line 178
  if (who == 0) {
#line 178
    tmp = 1;
  } else {
#line 178
    tmp = 2;
  }
#line 178
  return (tmp);
  case 66: 
  case 98: 
#line 181
  if (who == 0) {
#line 181
    tmp___0 = 11;
  } else {
#line 181
    tmp___0 = 12;
  }
#line 181
  return (tmp___0);
  case 78: 
  case 110: 
#line 184
  if (who == 0) {
#line 184
    tmp___1 = 3;
  } else {
#line 184
    tmp___1 = 4;
  }
#line 184
  return (tmp___1);
  case 82: 
  case 114: 
#line 187
  if (who == 0) {
#line 187
    tmp___2 = 7;
  } else {
#line 187
    tmp___2 = 8;
  }
#line 187
  return (tmp___2);
  case 81: 
  case 113: 
#line 190
  if (who == 0) {
#line 190
    tmp___3 = 9;
  } else {
#line 190
    tmp___3 = 10;
  }
#line 190
  return (tmp___3);
  }
#line 193
  return (13);
}
}
#line 196 "crazy.c"
int SwitchColor(int piece ) 
{ 
  int t[13] ;

  {
#line 198
  t[0] = 0;
#line 198
  t[1] = 2;
#line 198
  t[2] = 1;
#line 198
  t[3] = 4;
#line 198
  t[4] = 3;
#line 198
  t[5] = 0;
#line 198
  t[6] = 0;
#line 198
  t[7] = 8;
#line 198
  t[8] = 7;
#line 198
  t[9] = 10;
#line 198
  t[10] = 9;
#line 198
  t[11] = 12;
#line 198
  t[12] = 11;
#line 202
  return (t[piece]);
}
}
#line 205 "crazy.c"
int SwitchPromoted(int piece ) 
{ 
  int t[13] ;

  {
#line 207
  t[0] = 0;
#line 207
  t[1] = 2;
#line 207
  t[2] = 1;
#line 207
  t[3] = 2;
#line 207
  t[4] = 1;
#line 207
  t[5] = 0;
#line 207
  t[6] = 0;
#line 207
  t[7] = 2;
#line 207
  t[8] = 1;
#line 207
  t[9] = 2;
#line 207
  t[10] = 1;
#line 207
  t[11] = 2;
#line 207
  t[12] = 1;
#line 211
  return (t[piece]);
}
}
#line 214 "crazy.c"
void addHolding(int what , int who ) 
{ 


  {
#line 217
  if (Variant == 0) {
#line 220
    (holding[who][what]) ++;
#line 222
    (num_holding[who]) ++;
#line 224
    hold_hash ^= zobrist[what][holding[who][what]];
  }
#line 228
  if (who == 0) {
#line 229
    white_hand_eval += hand_value[what];
  } else {
#line 231
    black_hand_eval += hand_value[what];
  }
#line 233
  Material += material[what];
#line 235
  return;
}
}
#line 239 "crazy.c"
void removeHolding(int what , int who ) 
{ 


  {
#line 242
  if (Variant == 0) {
#line 248
    hold_hash ^= zobrist[what][holding[who][what]];
#line 250
    (holding[who][what]) --;
#line 252
    (num_holding[who]) --;
  }
#line 256
  if (who == 0) {
#line 257
    white_hand_eval -= hand_value[what];
  } else {
#line 259
    black_hand_eval -= hand_value[what];
  }
#line 261
  Material -= material[what];
#line 263
  return;
}
}
#line 267 "crazy.c"
void DropaddHolding(int what , int who ) 
{ 


  {
#line 269
  (holding[who][what]) ++;
#line 271
  (num_holding[who]) ++;
#line 273
  hold_hash ^= zobrist[what][holding[who][what]];
#line 275
  if (who == 0) {
#line 276
    white_hand_eval += hand_value[what];
  } else {
#line 278
    black_hand_eval += hand_value[what];
  }
#line 280
  Material += material[what];
#line 282
  return;
}
}
#line 285 "crazy.c"
void DropremoveHolding(int what , int who ) 
{ 


  {
#line 291
  hold_hash ^= zobrist[what][holding[who][what]];
#line 293
  (holding[who][what]) --;
#line 295
  (num_holding[who]) --;
#line 297
  if (who == 0) {
#line 298
    white_hand_eval -= hand_value[what];
  } else {
#line 300
    black_hand_eval -= hand_value[what];
  }
#line 302
  Material -= material[what];
#line 304
  return;
}
}
#line 307 "crazy.c"
void printHolding(void) 
{ 


  {
#line 310
  printf((char const   * __restrict  )"WP: %d WR: %d WB: %d WN: %d WQ: %d\n", holding[0][1],
         holding[0][7], holding[0][11], holding[0][3], holding[0][9]);
#line 315
  printf((char const   * __restrict  )"BP: %d BR: %d BB: %d BN: %d BQ: %d\n", holding[1][2],
         holding[1][8], holding[1][12], holding[1][4], holding[1][10]);
#line 320
  return;
}
}
#line 1 "draw.o"
#pragma merger("0","/tmp/cil-kLjs3rR_.i","")
#line 12 "./extvars.h"
int ply ;
#line 12
int fifty ;
#line 56
unsigned int hash ;
#line 159
int move_number ;
#line 160
unsigned int hash_history[600] ;
#line 70 "./protos.h"
xbool is_draw(void) ;
#line 14 "draw.c"
xbool is_draw(void) 
{ 
  int i ;
  int repeats ;
  int end ;
  int start ;

  {
#line 16
  repeats = 0;
#line 18
  if (fifty >= 4) {
#line 20
    if (move_number < ((move_number + ply) - 1) - fifty) {
#line 22
      end = ((move_number + ply) - 1) - fifty;
    } else {
#line 26
      end = move_number;
    }
#line 28
    i = (move_number + ply) - 3;
#line 28
    while (1) {
#line 28
      if (i >= 0) {
#line 28
        if (! (i >= end)) {
#line 28
          break;
        }
      } else {
#line 28
        break;
      }
#line 30
      if (hash == hash_history[i]) {
#line 32
        return ((xbool )1);
      }
#line 28
      i -= 2;
    }
  }
#line 37
  if (fifty >= 6) {
#line 39
    start = (move_number - 1) - ply % 2;
#line 40
    end = ((move_number + ply) - 1) - fifty;
#line 42
    i = start;
#line 42
    while (1) {
#line 42
      if (i >= 0) {
#line 42
        if (! (i >= end)) {
#line 42
          break;
        }
      } else {
#line 42
        break;
      }
#line 44
      if (hash == hash_history[i]) {
#line 46
        repeats ++;
      }
#line 48
      if (repeats >= 2) {
#line 50
        return ((xbool )1);
      }
#line 42
      i -= 2;
    }
  }
#line 55
  return ((xbool )0);
}
}
#line 1 "ecache.o"
#pragma merger("0","/tmp/cil-yXiRPzCx.i","")
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 89 "./protos.h"
void checkECache(int *score , int *in_cache ) ;
#line 90
void storeECache(int score ) ;
#line 130
void alloc_ecache(void) ;
#line 132
void free_ecache(void) ;
#line 58 "./extvars.h"
unsigned int ECacheProbes  ;
#line 59 "./extvars.h"
unsigned int ECacheHits  ;
#line 153
int ECacheSize ;
#line 22 "ecache.c"
ECacheType *ECache  ;
#line 27 "ecache.c"
void storeECache(int score ) 
{ 
  int ecindex ;

  {
#line 31
  ecindex = (int )(hash % (unsigned int )ECacheSize);
#line 33
  (ECache + ecindex)->stored_hash = hash;
#line 34
  (ECache + ecindex)->hold_hash = hold_hash;
#line 35
  (ECache + ecindex)->score = score;
#line 36
  return;
}
}
#line 38 "ecache.c"
void checkECache(int *score , int *in_cache ) 
{ 
  int ecindex ;

  {
#line 42
  ECacheProbes ++;
#line 44
  ecindex = (int )(hash % (unsigned int )ECacheSize);
#line 46
  if ((ECache + ecindex)->stored_hash == hash) {
#line 46
    if ((ECache + ecindex)->hold_hash == hold_hash) {
#line 50
      ECacheHits ++;
#line 52
      *in_cache = 1;
#line 53
      *score = (ECache + ecindex)->score;
    }
  }
#line 55
  return;
}
}
#line 57 "ecache.c"
void reset_ecache(void) 
{ 


  {
#line 59
  memset((void *)ECache, 0, sizeof(ECacheType ) * (unsigned long )ECacheSize);
#line 60
  return;
}
}
#line 63 "ecache.c"
void alloc_ecache(void) 
{ 
  void *tmp ;

  {
#line 65
  tmp = malloc(sizeof(ECacheType ) * (unsigned long )ECacheSize);
#line 65
  ECache = (ECacheType *)tmp;
#line 67
  if ((unsigned long )ECache == (unsigned long )((void *)0)) {
#line 69
    printf((char const   * __restrict  )"Out of memory allocating ECache.\n");
#line 70
    exit(1);
  }
#line 76
  return;
}
}
#line 79 "ecache.c"
void free_ecache(void) 
{ 


  {
#line 81
  free((void *)ECache);
#line 82
  return;
}
}
#line 1 "epd.o"
#pragma merger("0","/tmp/cil-9H99wwEt.i","")
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 16 "./protos.h"
void display_board(FILE *stream , int color ) ;
#line 21
int eval(int alpha , int beta ) ;
#line 56
void reset_piece_square(void) ;
#line 58
void rinput(char *str , int n , FILE *stream ) ;
#line 59
rtime_t rtime(void) ;
#line 63
move_s think(void) ;
#line 86
void initialize_hash(void) ;
#line 102
int interrupt(void) ;
#line 114
void run_epd_testsuite(void) ;
#line 115
void run_autotest(char *testset ) ;
#line 119
void comp_to_san(move_s move , char *str ) ;
#line 122
void clear_tt(void) ;
#line 139
void setup_epd_line(char *inbuff ) ;
#line 12 "./extvars.h"
int moved[144] ;
#line 12
int ep_square ;
#line 12
int white_to_move ;
#line 12
int wking_loc ;
#line 12
int bking_loc ;
#line 12
int white_castled ;
#line 12
int black_castled ;
#line 16
int nodes ;
#line 16
int qnodes ;
#line 23
int maxdepth ;
#line 30
int maxposdiff ;
#line 61
unsigned int TTProbes ;
#line 62
unsigned int TTHits ;
#line 63
unsigned int TTStores ;
#line 69
int book_ply ;
#line 81
unsigned int NTries ;
#line 81
unsigned int NCuts ;
#line 81
unsigned int TExt ;
#line 87
unsigned int FH ;
#line 87
unsigned int FHF ;
#line 88
unsigned int ext_check ;
#line 89
unsigned int razor_drop ;
#line 89
unsigned int razor_material ;
#line 101
int forcedwin ;
#line 116
int fixed_time ;
#line 126
int root_to_move ;
#line 31 "epd.c"
static int rankoffsets[8]  = 
#line 31 "epd.c"
  {      110,      98,      86,      74, 
        62,      50,      38,      26};
#line 14 "epd.c"
void setup_epd_line(char *inbuff ) 
{ 
  int i ;
  int rankp ;
  int rankoffset ;
  int fileoffset ;
  int j ;
  int stage ;
  int converterf ;
  int converterr ;
  int ep_file ;
  int ep_rank ;
  int norm_file ;
  int norm_rank ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 16
  i = 0;
#line 17
  rankp = 0;
#line 18
  rankoffset = 0;
#line 19
  fileoffset = 0;
#line 29
  stage = 0;
#line 34
  converterf = 'a';
#line 35
  converterr = '1';
#line 38
  memset((void *)(board), 0, sizeof(board));
#line 40
  white_castled = 0;
#line 41
  black_castled = 0;
#line 43
  book_ply = 50;
#line 45
  rankoffset = rankoffsets[0];
#line 47
  while ((int )*(inbuff + i) == 32) {
#line 47
    i ++;
  }
#line 49
  while (1) {
#line 49
    if ((int )*(inbuff + i) != 10) {
#line 49
      if (! ((int )*(inbuff + i) != 0)) {
#line 49
        break;
      }
    } else {
#line 49
      break;
    }
#line 51
    if (stage == 0) {
#line 51
      tmp___4 = __ctype_b_loc();
#line 51
      if ((int const   )*(*tmp___4 + (int )*(inbuff + i)) & 2048) {
#line 53
        j = 0;
#line 53
        while (1) {
#line 53
          tmp = atoi((char const   *)(inbuff + i));
#line 53
          if (! (j < tmp)) {
#line 53
            break;
          }
#line 54
          board[(rankoffset + j) + fileoffset] = 13;
#line 53
          j ++;
        }
#line 56
        tmp___0 = atoi((char const   *)(inbuff + i));
#line 56
        fileoffset += tmp___0;
      } else {
#line 51
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 58
    if (stage == 0) {
#line 58
      if ((int )*(inbuff + i) == 47) {
#line 60
        rankp ++;
#line 61
        rankoffset = rankoffsets[rankp];
#line 62
        fileoffset = 0;
      } else {
#line 58
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 64
    if (stage == 0) {
#line 64
      tmp___3 = __ctype_b_loc();
#line 64
      if ((int const   )*(*tmp___3 + (int )*(inbuff + i)) & 1024) {
#line 66
        switch ((int )*(inbuff + i)) {
        case 112: 
#line 68
        board[rankoffset + fileoffset] = 2;
#line 68
        break;
        case 80: 
#line 69
        board[rankoffset + fileoffset] = 1;
#line 69
        break;
        case 110: 
#line 70
        board[rankoffset + fileoffset] = 4;
#line 70
        break;
        case 78: 
#line 71
        board[rankoffset + fileoffset] = 3;
#line 71
        break;
        case 98: 
#line 72
        board[rankoffset + fileoffset] = 12;
#line 72
        break;
        case 66: 
#line 73
        board[rankoffset + fileoffset] = 11;
#line 73
        break;
        case 114: 
#line 74
        board[rankoffset + fileoffset] = 8;
#line 74
        break;
        case 82: 
#line 75
        board[rankoffset + fileoffset] = 7;
#line 75
        break;
        case 113: 
#line 76
        board[rankoffset + fileoffset] = 10;
#line 76
        break;
        case 81: 
#line 77
        board[rankoffset + fileoffset] = 9;
#line 77
        break;
        case 107: 
#line 79
        bking_loc = rankoffset + fileoffset;
#line 80
        board[bking_loc] = 6;
#line 81
        break;
        case 75: 
#line 83
        wking_loc = rankoffset + fileoffset;
#line 84
        board[wking_loc] = 5;
#line 85
        break;
        }
#line 87
        fileoffset ++;
      } else {
#line 64
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 89
    if ((int )*(inbuff + i) == 32) {
#line 91
      stage ++;
#line 93
      if (stage == 1) {
#line 96
        while ((int )*(inbuff + i) == 32) {
#line 96
          i ++;
        }
#line 98
        if ((int )*(inbuff + i) == 119) {
#line 99
          white_to_move = 1;
        } else {
#line 101
          white_to_move = 0;
        }
      } else
#line 103
      if (stage == 2) {
#line 106
        moved[30] = 1;
#line 106
        moved[33] = moved[30];
#line 106
        moved[26] = moved[33];
#line 107
        moved[117] = 1;
#line 107
        moved[114] = moved[117];
#line 107
        moved[110] = moved[114];
#line 109
        while ((int )*(inbuff + i) == 32) {
#line 109
          i ++;
        }
#line 111
        while ((int )*(inbuff + i) != 32) {
#line 113
          switch ((int )*(inbuff + i)) {
          case 45: 
#line 116
          break;
          case 75: 
#line 118
          moved[33] = 0;
#line 118
          moved[30] = moved[33];
#line 119
          break;
          case 81: 
#line 121
          moved[26] = 0;
#line 121
          moved[30] = moved[26];
#line 122
          break;
          case 107: 
#line 124
          moved[117] = 0;
#line 124
          moved[114] = moved[117];
#line 125
          break;
          case 113: 
#line 127
          moved[110] = 0;
#line 127
          moved[114] = moved[110];
#line 128
          break;
          }
#line 130
          i ++;
        }
#line 132
        i --;
      } else
#line 135
      if (stage == 3) {
#line 138
        while ((int )*(inbuff + i) == 32) {
#line 138
          i ++;
        }
#line 140
        if ((int )*(inbuff + i) == 45) {
#line 142
          ep_square = 0;
        } else {
#line 146
          tmp___1 = i;
#line 146
          i ++;
#line 146
          ep_file = (int )*(inbuff + tmp___1);
#line 147
          tmp___2 = i;
#line 147
          i ++;
#line 147
          ep_rank = (int )*(inbuff + tmp___2);
#line 149
          norm_file = ep_file - converterf;
#line 150
          norm_rank = ep_rank - converterr;
#line 152
          ep_square = (norm_rank * 12 + 26) + norm_file;
        }
      }
    }
#line 169
    i ++;
  }
#line 172
  reset_piece_square();
#line 173
  initialize_hash();
#line 175
  return;
}
}
#line 177 "epd.c"
int check_solution(char *inbuff , move_s cmove ) 
{ 
  char san[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 181
  comp_to_san(cmove, san);
#line 186
  tmp___2 = strstr((char const   *)inbuff, "bm");
#line 186
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 188
    tmp = strstr((char const   *)inbuff, (char const   *)(san));
#line 188
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 189
      return (1);
    } else {
#line 191
      return (0);
    }
  } else {
#line 193
    tmp___1 = strstr((char const   *)inbuff, "am");
#line 193
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 195
      tmp___0 = strstr((char const   *)inbuff, (char const   *)(san));
#line 195
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 196
        return (0);
      } else {
#line 198
        return (1);
      }
    } else {
#line 201
      printf((char const   * __restrict  )"No best-move or avoid-move found!");
    }
  }
#line 203
  return (0);
}
}
#line 206 "epd.c"
void run_epd_testsuite(void) 
{ 
  FILE *testsuite ;
  char readbuff[2000] ;
  char testname[4096] ;
  char tempbuff[2000] ;
  int thinktime ;
  move_s comp_move ;
  int tested ;
  int found ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 217
  tested = 0;
#line 218
  found = 0;
#line 220
  printf((char const   * __restrict  )"\nName of EPD testsuite: ");
#line 221
  rinput(testname, 256, stdin);
#line 222
  printf((char const   * __restrict  )"\nTime per move (s): ");
#line 223
  rinput(readbuff, 256, stdin);
#line 224
  tmp = atol((char const   *)(readbuff));
#line 224
  thinktime = (int )tmp;
#line 225
  printf((char const   * __restrict  )"\n");
#line 227
  thinktime *= 100;
#line 229
  testsuite = fopen((char const   * __restrict  )(testname), (char const   * __restrict  )"r");
#line 231
  while (1) {
#line 231
    tmp___3 = fgets((char * __restrict  )(readbuff), 2000, (FILE * __restrict  )testsuite);
#line 231
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 231
      break;
    }
#line 233
    tested ++;
#line 235
    setup_epd_line(readbuff);
#line 237
    if (white_to_move) {
#line 237
      root_to_move = 0;
    } else {
#line 237
      root_to_move = 1;
    }
#line 239
    clear_tt();
#line 240
    initialize_hash();
#line 242
    display_board(stdout, 1);
#line 244
    forcedwin = 0;
#line 246
    tmp___0 = interrupt();
#line 246
    if (tmp___0) {
#line 246
      rinput(tempbuff, 256, stdin);
    }
#line 248
    fixed_time = thinktime;
#line 250
    comp_move = think();
#line 253
    printf((char const   * __restrict  )"\nNodes: %i (%0.2f%% qnodes)\n", nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
#line 256
    printf((char const   * __restrict  )"ECacheProbes : %u   ECacheHits : %u   HitRate : %f%%\n",
           ECacheProbes, ECacheHits, (double )(((float )ECacheHits / ((float )ECacheProbes + (float )1)) * (float )100));
#line 260
    printf((char const   * __restrict  )"TTStores : %u TTProbes : %u   TTHits : %u   HitRate : %f%%\n",
           TTStores, TTProbes, TTHits, (double )(((float )TTHits / ((float )TTProbes + (float )1)) * (float )100));
#line 264
    printf((char const   * __restrict  )"NTries : %u  NCuts : %u  CutRate : %f%%  TExt: %u\n",
           NTries, NCuts, (double )(((float )NCuts * (float )100) / ((float )NTries + (float )1)),
           TExt);
#line 267
    printf((char const   * __restrict  )"Check extensions: %u  Razor drops : %u  Razor Material : %u\n",
           ext_check, razor_drop, razor_material);
#line 269
    printf((char const   * __restrict  )"Move ordering : %f%%\n", (double )(((float )FHF * (float )100) / (float )FH + (float )1));
#line 271
    tmp___1 = eval(-1000000, 1000000);
#line 271
    printf((char const   * __restrict  )"Material score: %d  Eval : %d  MaxPosDiff: %d\n",
           Material, tmp___1, maxposdiff);
#line 272
    printf((char const   * __restrict  )"\n");
#line 274
    if (! forcedwin) {
#line 276
      tmp___2 = check_solution(readbuff, comp_move);
#line 276
      if (tmp___2) {
#line 278
        found ++;
#line 279
        printf((char const   * __restrict  )"Solution found.\n");
      } else {
#line 283
        printf((char const   * __restrict  )"Solution not found.\n");
      }
    } else {
#line 288
      found ++;
    }
#line 291
    printf((char const   * __restrict  )"Solved: %d/%d\n", found, tested);
  }
#line 295
  printf((char const   * __restrict  )"\n");
#line 296
  return;
}
}
#line 298 "epd.c"
void run_autotest(char *testset ) 
{ 
  FILE *testsuite ;
  char readbuff[256] ;
  int searchdepth ;
  rtime_t start ;
  rtime_t end ;
  move_s comp_move ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 307
  testsuite = fopen((char const   * __restrict  )testset, (char const   * __restrict  )"r");
#line 309
  if ((unsigned long )testsuite == (unsigned long )((void *)0)) {
#line 309
    exit(1);
  }
#line 311
  start = rtime();
#line 313
  while (1) {
#line 313
    tmp___0 = fgets((char * __restrict  )(readbuff), 256, (FILE * __restrict  )testsuite);
#line 313
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 313
      break;
    }
#line 315
    setup_epd_line(readbuff);
#line 316
    if (white_to_move) {
#line 316
      root_to_move = 0;
    } else {
#line 316
      root_to_move = 1;
    }
#line 318
    clear_tt();
#line 319
    initialize_hash();
#line 321
    printf((char const   * __restrict  )"\n");
#line 322
    display_board(stdout, 1);
#line 324
    printf((char const   * __restrict  )"EPD: %s\n", readbuff);
#line 326
    tmp = fgets((char * __restrict  )(readbuff), 256, (FILE * __restrict  )testsuite);
#line 326
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 326
      exit(1);
    }
#line 327
    searchdepth = atoi((char const   *)(readbuff));
#line 329
    printf((char const   * __restrict  )"Searching to %d ply\n", searchdepth);
#line 330
    maxdepth = searchdepth;
#line 332
    fixed_time = 1000000;
#line 333
    comp_move = think();
  }
#line 336
  end = rtime();
#line 340
  fclose(testsuite);
#line 341
  exit(0);
}
}
#line 1 "eval.o"
#pragma merger("0","/tmp/cil-YDzJbcuE.i","")
#line 837 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 12 "./extvars.h"
int piece_count ;
#line 44
int pieces[62] ;
#line 74 "./extvars.h"
int Material  ;
#line 76
int zh_material[14] ;
#line 77
int std_material[14] ;
#line 78
int suicide_material[14] ;
#line 79
int losers_material[14] ;
#line 94
int const   Xrank[144] ;
#line 94
int const   Xfile[144] ;
#line 94
int const   Xdiagl[144] ;
#line 94
int const   Xdiagr[144] ;
#line 94
int const   sqcolor[144] ;
#line 95
int distance[144][144] ;
#line 96
int rookdistance[144][144] ;
#line 97
int const   upscale[64] ;
#line 139
int cfg_devscale ;
#line 145
int cfg_smarteval ;
#line 146
int cfg_attackeval ;
#line 18 "./protos.h"
int std_eval(int alpha , int beta ) ;
#line 19
int suicide_eval(void) ;
#line 20
int losers_eval(void) ;
#line 87
void initialize_eval(void) ;
#line 16 "eval.c"
int std_material[14]  = 
#line 16 "eval.c"
  {      0,      100,      -100,      310, 
        -310,      4000,      -4000,      500, 
        -500,      900,      -900,      325, 
        -325,      0};
#line 18 "eval.c"
int zh_material[14]  = 
#line 18
  {      0,      100,      -100,      210, 
        -210,      4000,      -4000,      250, 
        -250,      450,      -450,      230, 
        -230,      0};
#line 20 "eval.c"
int suicide_material[14]  = 
#line 20
  {      0,      15,      -15,      150, 
        -150,      500,      -500,      150, 
        -150,      50,      -50,      0, 
        0,      0};
#line 22 "eval.c"
int losers_material[14]  = 
#line 22
  {      0,      80,      -80,      320, 
        -320,      1000,      -1000,      350, 
        -350,      400,      -400,      270, 
        -270,      0};
#line 24 "eval.c"
int material[14]  = 
#line 24
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 26 "eval.c"
int const   Xfile[144]  = 
#line 26
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 42 "eval.c"
int const   Xrank[144]  = 
#line 42
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 58 "eval.c"
int const   Xdiagl[144]  = 
#line 58
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )11, 
        (int const   )10,      (int const   )9,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )13,      (int const   )12, 
        (int const   )11,      (int const   )10,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )14,      (int const   )13, 
        (int const   )12,      (int const   )11,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )15,      (int const   )14, 
        (int const   )13,      (int const   )12,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 74 "eval.c"
int const   Xdiagr[144]  = 
#line 74
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )15,      (int const   )14, 
        (int const   )13,      (int const   )12,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )14,      (int const   )13, 
        (int const   )12,      (int const   )11,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )13,      (int const   )12, 
        (int const   )11,      (int const   )10,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )11, 
        (int const   )10,      (int const   )9,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 90 "eval.c"
int const   sqcolor[144]  = 
#line 90
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 109 "eval.c"
int const   pcsqbishop[144]  = 
#line 109
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )-5, 
        (int const   )-10,      (int const   )-5,      (int const   )-5,      (int const   )-10, 
        (int const   )-5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )10, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )10,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )5, 
        (int const   )6,      (int const   )15,      (int const   )15,      (int const   )6, 
        (int const   )5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )3, 
        (int const   )15,      (int const   )10,      (int const   )10,      (int const   )15, 
        (int const   )3,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )3, 
        (int const   )15,      (int const   )10,      (int const   )10,      (int const   )15, 
        (int const   )3,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )5, 
        (int const   )6,      (int const   )15,      (int const   )15,      (int const   )6, 
        (int const   )5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )10, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )10,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )-5, 
        (int const   )-10,      (int const   )-5,      (int const   )-5,      (int const   )-10, 
        (int const   )-5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 123 "eval.c"
int const   black_knight[144]  = 
#line 123
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-10, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-10,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )25,      (int const   )25,      (int const   )25, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )10, 
        (int const   )25,      (int const   )20,      (int const   )25,      (int const   )25, 
        (int const   )10,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )20,      (int const   )20,      (int const   )20,      (int const   )20, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )15,      (int const   )15,      (int const   )15,      (int const   )15, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )0,      (int const   )3,      (int const   )3,      (int const   )0, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-35, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-35,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 137 "eval.c"
int const   white_knight[144]  = 
#line 137
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-35, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-35,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )0,      (int const   )3,      (int const   )3,      (int const   )0, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )15,      (int const   )15,      (int const   )15,      (int const   )15, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )20,      (int const   )20,      (int const   )20,      (int const   )20, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )10, 
        (int const   )25,      (int const   )20,      (int const   )25,      (int const   )25, 
        (int const   )10,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )25,      (int const   )25,      (int const   )25, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-10, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-10,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 151 "eval.c"
int const   white_pawn[144]  = 
#line 151
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )25, 
        (int const   )35,      (int const   )5,      (int const   )5,      (int const   )50, 
        (int const   )45,      (int const   )30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )7,      (int const   )5, 
        (int const   )5,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )14,      (int const   )14,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )10,      (int const   )20,      (int const   )20,      (int const   )10, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )27,      (int const   )27,      (int const   )18, 
        (int const   )18,      (int const   )18,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )30, 
        (int const   )30,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )30,      (int const   )25,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 167 "eval.c"
int const   black_pawn[144]  = 
#line 167
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )30,      (int const   )30, 
        (int const   )30,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )30,      (int const   )25,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )27,      (int const   )27,      (int const   )18, 
        (int const   )18,      (int const   )18,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )10,      (int const   )20,      (int const   )20,      (int const   )10, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )14,      (int const   )14,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )7,      (int const   )5, 
        (int const   )5,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )25, 
        (int const   )35,      (int const   )5,      (int const   )5,      (int const   )50, 
        (int const   )45,      (int const   )30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 184 "eval.c"
int const   white_king[144]  = 
#line 184
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-100,      (int const   )7, 
        (int const   )4,      (int const   )0,      (int const   )10,      (int const   )4, 
        (int const   )7,      (int const   )-100,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-250,      (int const   )-200, 
        (int const   )-150,      (int const   )-100,      (int const   )-100,      (int const   )-150, 
        (int const   )-200,      (int const   )-250,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-350,      (int const   )-300, 
        (int const   )-300,      (int const   )-250,      (int const   )-250,      (int const   )-300, 
        (int const   )-300,      (int const   )-350,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-400,      (int const   )-400, 
        (int const   )-400,      (int const   )-350,      (int const   )-350,      (int const   )-400, 
        (int const   )-400,      (int const   )-400,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 199 "eval.c"
int const   black_king[144]  = 
#line 199
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-400,      (int const   )-400, 
        (int const   )-400,      (int const   )-350,      (int const   )-350,      (int const   )-400, 
        (int const   )-400,      (int const   )-400,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-350,      (int const   )-300, 
        (int const   )-300,      (int const   )-250,      (int const   )-250,      (int const   )-300, 
        (int const   )-300,      (int const   )-350,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-250,      (int const   )-200, 
        (int const   )-150,      (int const   )-100,      (int const   )-100,      (int const   )-150, 
        (int const   )-200,      (int const   )-250,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-100,      (int const   )7, 
        (int const   )4,      (int const   )0,      (int const   )10,      (int const   )4, 
        (int const   )7,      (int const   )-100,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 213 "eval.c"
int const   black_queen[144]  = 
#line 213
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 228 "eval.c"
int const   white_queen[144]  = 
#line 228
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 242 "eval.c"
int const   black_rook[144]  = 
#line 242
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )15, 
        (int const   )20,      (int const   )25,      (int const   )25,      (int const   )20, 
        (int const   )15,      (int const   )10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )10, 
        (int const   )15,      (int const   )20,      (int const   )20,      (int const   )15, 
        (int const   )10,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-30,      (int const   )-30,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 258 "eval.c"
int const   white_rook[144]  = 
#line 258
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-30,      (int const   )-30,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )10, 
        (int const   )15,      (int const   )20,      (int const   )20,      (int const   )15, 
        (int const   )10,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )15, 
        (int const   )20,      (int const   )25,      (int const   )25,      (int const   )20, 
        (int const   )15,      (int const   )10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 274 "eval.c"
int const   upscale[64]  = 
#line 274
  {      (int const   )26,      (int const   )27,      (int const   )28,      (int const   )29, 
        (int const   )30,      (int const   )31,      (int const   )32,      (int const   )33, 
        (int const   )38,      (int const   )39,      (int const   )40,      (int const   )41, 
        (int const   )42,      (int const   )43,      (int const   )44,      (int const   )45, 
        (int const   )50,      (int const   )51,      (int const   )52,      (int const   )53, 
        (int const   )54,      (int const   )55,      (int const   )56,      (int const   )57, 
        (int const   )62,      (int const   )63,      (int const   )64,      (int const   )65, 
        (int const   )66,      (int const   )67,      (int const   )68,      (int const   )69, 
        (int const   )74,      (int const   )75,      (int const   )76,      (int const   )77, 
        (int const   )78,      (int const   )79,      (int const   )80,      (int const   )81, 
        (int const   )86,      (int const   )87,      (int const   )88,      (int const   )89, 
        (int const   )90,      (int const   )91,      (int const   )92,      (int const   )93, 
        (int const   )98,      (int const   )99,      (int const   )100,      (int const   )101, 
        (int const   )102,      (int const   )103,      (int const   )104,      (int const   )105, 
        (int const   )110,      (int const   )111,      (int const   )112,      (int const   )113, 
        (int const   )114,      (int const   )115,      (int const   )116,      (int const   )117};
#line 288 "eval.c"
int pre_p_tropism[9]  = 
#line 288
  {      9999,      40,      20,      10, 
        3,      1,      1,      0, 
        9999};
#line 291 "eval.c"
int pre_r_tropism[9]  = 
#line 291
  {      9999,      50,      40,      15, 
        5,      1,      1,      0, 
        9999};
#line 294 "eval.c"
int pre_n_tropism[9]  = 
#line 294
  {      9999,      50,      70,      35, 
        10,      2,      1,      0, 
        9999};
#line 297 "eval.c"
int pre_q_tropism[9]  = 
#line 297
  {      9999,      100,      60,      20, 
        5,      2,      0,      0, 
        9999};
#line 300 "eval.c"
int pre_b_tropism[9]  = 
#line 300
  {      9999,      50,      25,      15, 
        5,      2,      2,      2, 
        9999};
#line 303 "eval.c"
unsigned char p_tropism[144][144]  ;
#line 304 "eval.c"
unsigned char q_tropism[144][144]  ;
#line 305 "eval.c"
unsigned char n_tropism[144][144]  ;
#line 306 "eval.c"
unsigned char r_tropism[144][144]  ;
#line 307 "eval.c"
unsigned char b_tropism[144][144]  ;
#line 309 "eval.c"
int ksafety_scaled[15][9]  = 
#line 309
  { {        -5,        5,        10,        15, 
            50,        80,        150,        150, 
            150}, 
   {        -5,        15,        20,        25, 
            70,        150,        200,        200, 
            200}, 
   {        -5,        15,        30,        30, 
            100,        200,        300,        300, 
            300}, 
   {        -10,        20,        40,        40, 
            100,        200,        300,        300, 
            400}, 
   {        -10,        30,        50,        80, 
            150,        300,        400,        400, 
            500}, 
   {        -10,        35,        60,        100, 
            200,        250,        400,        400, 
            500}, 
   {        -10,        40,        70,        110, 
            210,        300,        500,        500, 
            600}, 
   {        -10,        45,        75,        125, 
            215,        300,        500,        600, 
            700}, 
   {        -10,        60,        90,        130, 
            240,        350,        500,        600, 
            700}, 
   {        -15,        60,        95,        145, 
            260,        350,        500,        600, 
            700}, 
   {        -15,        60,        100,        150, 
            270,        350,        500,        600, 
            700}, 
   {        -15,        60,        110,        160, 
            280,        400,        600,        700, 
            800}, 
   {        -20,        70,        115,        165, 
            290,        400,        600,        700, 
            800}, 
   {        -20,        80,        120,        170, 
            300,        450,        700,        800, 
            900}, 
   {        -20,        80,        125,        175, 
            310,        450,        700,        800, 
            900}};
#line 328 "eval.c"
void initialize_eval(void) 
{ 
  int i ;
  int j ;
  int sd ;
  int sdi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 332
  i = 0;
#line 332
  while (i < 64) {
#line 334
    j = 0;
#line 334
    while (j < 64) {
#line 336
      sd = abs((i & 7) - (j & 7));
#line 337
      sdi = abs((i >> 3) - (j >> 3));
#line 338
      rookdistance[upscale[i]][upscale[j]] = sd + sdi;
#line 339
      if (sd > sdi) {
#line 339
        distance[upscale[i]][upscale[j]] = sd;
      } else {
#line 339
        distance[upscale[i]][upscale[j]] = sdi;
      }
#line 334
      j ++;
    }
#line 332
    i ++;
  }
#line 343
  i = 0;
#line 343
  while (i < 144) {
#line 345
    j = 0;
#line 345
    while (j < 144) {
#line 347
      tmp___4 = abs((int )(Xrank[i] - Xrank[j]));
#line 347
      tmp___5 = abs((int )(Xfile[i] - Xfile[j]));
#line 347
      if (tmp___4 > tmp___5) {
#line 347
        tmp___1 = abs((int )(Xrank[i] - Xrank[j]));
#line 347
        tmp___3 = tmp___1;
      } else {
#line 347
        tmp___2 = abs((int )(Xfile[i] - Xfile[j]));
#line 347
        tmp___3 = tmp___2;
      }
#line 347
      p_tropism[i][j] = (unsigned char )pre_p_tropism[tmp___3];
#line 349
      tmp___11 = abs((int )(Xrank[i] - Xrank[j]));
#line 349
      tmp___12 = abs((int )(Xfile[i] - Xfile[j]));
#line 349
      if (tmp___11 > tmp___12) {
#line 349
        tmp___8 = abs((int )(Xrank[i] - Xrank[j]));
#line 349
        tmp___10 = tmp___8;
      } else {
#line 349
        tmp___9 = abs((int )(Xfile[i] - Xfile[j]));
#line 349
        tmp___10 = tmp___9;
      }
#line 349
      b_tropism[i][j] = (unsigned char )pre_b_tropism[tmp___10];
#line 351
      tmp___18 = abs((int )(Xrank[i] - Xrank[j]));
#line 351
      tmp___19 = abs((int )(Xfile[i] - Xfile[j]));
#line 351
      if (tmp___18 > tmp___19) {
#line 351
        tmp___15 = abs((int )(Xrank[i] - Xrank[j]));
#line 351
        tmp___17 = tmp___15;
      } else {
#line 351
        tmp___16 = abs((int )(Xfile[i] - Xfile[j]));
#line 351
        tmp___17 = tmp___16;
      }
#line 351
      n_tropism[i][j] = (unsigned char )pre_n_tropism[tmp___17];
#line 353
      tmp___25 = abs((int )(Xrank[i] - Xrank[j]));
#line 353
      tmp___26 = abs((int )(Xfile[i] - Xfile[j]));
#line 353
      if (tmp___25 > tmp___26) {
#line 353
        tmp___22 = abs((int )(Xrank[i] - Xrank[j]));
#line 353
        tmp___24 = tmp___22;
      } else {
#line 353
        tmp___23 = abs((int )(Xfile[i] - Xfile[j]));
#line 353
        tmp___24 = tmp___23;
      }
#line 353
      r_tropism[i][j] = (unsigned char )pre_r_tropism[tmp___24];
#line 355
      tmp___32 = abs((int )(Xrank[i] - Xrank[j]));
#line 355
      tmp___33 = abs((int )(Xfile[i] - Xfile[j]));
#line 355
      if (tmp___32 > tmp___33) {
#line 355
        tmp___29 = abs((int )(Xrank[i] - Xrank[j]));
#line 355
        tmp___31 = tmp___29;
      } else {
#line 355
        tmp___30 = abs((int )(Xfile[i] - Xfile[j]));
#line 355
        tmp___31 = tmp___30;
      }
#line 355
      q_tropism[i][j] = (unsigned char )pre_q_tropism[tmp___31];
#line 345
      j ++;
    }
#line 343
    i ++;
  }
#line 359
  return;
}
}
#line 361 "eval.c"
int eval(int alpha , int beta ) 
{ 
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int safety ;
  int badsquares ;
  int norm_white_hand_eval ;
  int norm_black_hand_eval ;
  int wdev_dscale ;
  int bdev_dscale ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  xbool tmp___2 ;
  unsigned int tmp___3 ;
  xbool tmp___4 ;
  unsigned int tmp___5 ;
  xbool tmp___6 ;
  unsigned int tmp___7 ;
  xbool tmp___8 ;
  unsigned int tmp___9 ;
  xbool tmp___10 ;
  unsigned int tmp___11 ;
  xbool tmp___12 ;
  unsigned int tmp___13 ;
  xbool tmp___14 ;
  unsigned int tmp___15 ;
  xbool tmp___16 ;
  unsigned int tmp___17 ;
  xbool tmp___18 ;
  unsigned int tmp___19 ;
  xbool tmp___20 ;
  unsigned int tmp___21 ;
  xbool tmp___22 ;
  unsigned int tmp___23 ;
  xbool tmp___24 ;
  unsigned int tmp___25 ;
  xbool tmp___26 ;
  unsigned int tmp___27 ;
  xbool tmp___28 ;
  unsigned int tmp___29 ;
  xbool tmp___30 ;
  unsigned int tmp___31 ;
  xbool tmp___32 ;
  unsigned int tmp___33 ;
  xbool tmp___34 ;
  unsigned int tmp___35 ;
  xbool tmp___36 ;
  unsigned int tmp___37 ;
  xbool tmp___38 ;
  unsigned int tmp___39 ;
  xbool tmp___40 ;
  unsigned int tmp___41 ;
  xbool tmp___42 ;
  unsigned int tmp___43 ;
  xbool tmp___44 ;
  unsigned int tmp___45 ;
  xbool tmp___46 ;
  unsigned int tmp___47 ;
  xbool tmp___48 ;
  unsigned int tmp___49 ;

  {
#line 366
  score = 0;
#line 372
  if (Variant == 2) {
#line 374
    tmp = std_eval(alpha, beta);
#line 374
    return (tmp);
  } else
#line 376
  if (Variant == 3) {
#line 378
    tmp___0 = suicide_eval();
#line 378
    return (tmp___0);
  } else
#line 380
  if (Variant == 4) {
#line 382
    tmp___1 = losers_eval();
#line 382
    return (tmp___1);
  }
#line 385
  in_cache = 0;
#line 387
  checkECache(& score, & in_cache);
#line 389
  if (in_cache) {
#line 391
    if (white_to_move == 1) {
#line 391
      return (score);
    }
#line 392
    return (- score);
  }
#line 397
  if (cfg_devscale) {
#line 400
    if (white_to_move != comp_color) {
#line 402
      if (white_hand_eval <= 200) {
#line 402
        if (Variant != 1) {
#line 405
          wdev_dscale = 2;
        } else {
#line 402
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 407
      if (white_hand_eval >= 700) {
#line 410
        wdev_dscale = 0;
      } else {
#line 414
        wdev_dscale = 1;
      }
    } else {
#line 418
      wdev_dscale = 0;
    }
#line 420
    if (white_to_move == comp_color) {
#line 422
      if (- black_hand_eval <= 200) {
#line 422
        if (Variant != 1) {
#line 425
          bdev_dscale = 2;
        } else {
#line 422
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 427
      if (- black_hand_eval >= 700) {
#line 430
        bdev_dscale = 0;
      } else {
#line 434
        bdev_dscale = 1;
      }
    } else {
#line 438
      bdev_dscale = 0;
    }
  } else {
#line 442
    bdev_dscale = 0;
#line 442
    wdev_dscale = bdev_dscale;
  }
#line 447
  a = 1;
#line 447
  j = 1;
#line 447
  while (a <= piece_count) {
#line 448
    i = pieces[j];
#line 450
    if (! i) {
#line 451
      goto __Cont;
    } else {
#line 453
      a ++;
    }
#line 455
    switch (board[i]) {
    case 1: 
#line 457
    score += 100;
#line 458
    score += (int )(white_pawn[i] >> wdev_dscale);
#line 459
    score += (int )p_tropism[i][bking_loc];
#line 460
    break;
    case 2: 
#line 463
    score -= 100;
#line 464
    score -= (int )(black_pawn[i] >> bdev_dscale);
#line 465
    score -= (int )p_tropism[i][wking_loc];
#line 466
    break;
    case 7: 
#line 469
    score += 250;
#line 470
    score += (int )(white_rook[i] >> wdev_dscale);
#line 471
    score += (int )r_tropism[i][bking_loc];
#line 472
    break;
    case 8: 
#line 475
    score -= 250;
#line 476
    score -= (int )(black_rook[i] >> bdev_dscale);
#line 477
    score -= (int )r_tropism[i][wking_loc];
#line 478
    break;
    case 11: 
#line 481
    score += 230;
#line 482
    score += (int )(pcsqbishop[i] >> wdev_dscale);
#line 483
    score += (int )b_tropism[i][bking_loc];
#line 484
    break;
    case 12: 
#line 487
    score -= 230;
#line 488
    score -= (int )(pcsqbishop[i] >> bdev_dscale);
#line 489
    score -= (int )b_tropism[i][wking_loc];
#line 490
    break;
    case 3: 
#line 493
    score += 210;
#line 494
    score += (int )(white_knight[i] >> wdev_dscale);
#line 495
    score += (int )n_tropism[i][bking_loc];
#line 496
    break;
    case 4: 
#line 499
    score -= 210;
#line 500
    score -= (int )(black_knight[i] >> bdev_dscale);
#line 501
    score -= (int )n_tropism[i][wking_loc];
#line 502
    break;
    case 9: 
#line 505
    score += 450;
#line 506
    score += (int )(white_queen[i] >> wdev_dscale);
#line 507
    score += (int )q_tropism[i][bking_loc];
#line 508
    break;
    case 10: 
#line 511
    score -= 450;
#line 512
    score -= (int )(black_queen[i] >> bdev_dscale);
#line 513
    score -= (int )q_tropism[i][wking_loc];
#line 514
    break;
    }
    __Cont: /* CIL Label */ 
#line 447
    j ++;
  }
#line 522
  score += (int )(white_king[wking_loc] >> bdev_dscale);
#line 523
  score -= (int )(black_king[bking_loc] >> wdev_dscale);
#line 528
  if (! white_castled) {
#line 528
    if (moved[30]) {
#line 530
      score -= 30;
    }
  }
#line 532
  if (! black_castled) {
#line 532
    if (moved[114]) {
#line 534
      score += 30;
    }
  }
#line 538
  if (! moved[41]) {
#line 538
    if (board[53] != 13) {
#line 539
      score -= 15;
    }
  }
#line 540
  if (! moved[42]) {
#line 540
    if (board[54] != 13) {
#line 541
      score -= 15;
    }
  }
#line 542
  if (! moved[101]) {
#line 542
    if (board[89] != 13) {
#line 543
      score += 15;
    }
  }
#line 544
  if (! moved[102]) {
#line 544
    if (board[90] != 13) {
#line 545
      score += 15;
    }
  }
#line 548
  if (cfg_smarteval) {
#line 553
    if (wking_loc != 30) {
#line 553
      if (wking_loc != 29) {
#line 555
        if (board[wking_loc + 11] != 1) {
#line 555
          score -= 24;
        }
#line 556
        if (board[wking_loc + 12] != 1) {
#line 556
          score -= 35;
        }
#line 557
        if (board[wking_loc + 13] != 1) {
#line 557
          score -= 24;
        }
#line 560
        if (white_castled) {
#line 562
          if (board[bking_loc - 25] == 2) {
#line 562
            score += 11;
          }
#line 563
          if (board[bking_loc - 24] == 2) {
#line 563
            score += 15;
          }
#line 564
          if (board[bking_loc - 23] == 2) {
#line 564
            score += 11;
          }
        }
      }
    }
#line 568
    if (bking_loc != 114) {
#line 568
      if (bking_loc != 113) {
#line 570
        if (board[bking_loc - 13] != 2) {
#line 570
          score += 24;
        }
#line 571
        if (board[bking_loc - 12] != 2) {
#line 571
          score += 35;
        }
#line 572
        if (board[bking_loc - 11] != 2) {
#line 572
          score += 24;
        }
#line 575
        if (black_castled) {
#line 577
          if (board[bking_loc - 25] == 2) {
#line 577
            score -= 11;
          }
#line 578
          if (board[bking_loc - 24] == 2) {
#line 578
            score -= 15;
          }
#line 579
          if (board[bking_loc - 23] == 2) {
#line 579
            score -= 11;
          }
        }
      }
    }
#line 583
    if (moved[42]) {
#line 585
      score += 30;
#line 586
      if (moved[41]) {
#line 586
        score += 25;
      }
#line 587
      if (moved[32]) {
#line 587
        score += 20;
      }
#line 588
      if (moved[27]) {
#line 588
        score += 15;
      }
#line 589
      if (moved[28]) {
#line 589
        score += 10;
      }
    }
#line 591
    if (moved[102]) {
#line 593
      score -= 30;
#line 594
      if (moved[101]) {
#line 594
        score -= 25;
      }
#line 595
      if (moved[116]) {
#line 595
        score -= 20;
      }
#line 596
      if (moved[111]) {
#line 596
        score -= 15;
      }
#line 597
      if (moved[112]) {
#line 597
        score -= 10;
      }
    }
#line 603
    if (board[44] != 1) {
#line 603
      if (board[55] == 2) {
#line 604
        score -= 30;
      } else
#line 603
      if (board[66] == 2) {
#line 604
        score -= 30;
      }
    }
#line 605
    if (board[104] != 2) {
#line 605
      if (board[91] == 1) {
#line 606
        score += 30;
      } else
#line 605
      if (board[78] == 1) {
#line 606
        score += 30;
      }
    }
#line 614
    if (board[wking_loc + 12] == 2) {
#line 614
      goto _L___1;
    } else
#line 614
    if (board[wking_loc + 12] == 12) {
      _L___1: /* CIL Label */ 
#line 616
      score -= 35;
#line 617
      if (board[wking_loc + 12] == 0) {
#line 617
        tmp___3 = 0U;
      } else {
#line 617
        tmp___2 = is_attacked(wking_loc + 12, 0);
#line 617
        tmp___3 = (unsigned int )tmp___2;
      }
#line 617
      if (tmp___3) {
#line 618
        score -= 150 >> bdev_dscale;
      }
    }
#line 620
    if (board[bking_loc - 12] == 1) {
#line 620
      goto _L___2;
    } else
#line 620
    if (board[bking_loc - 12] == 11) {
      _L___2: /* CIL Label */ 
#line 622
      score += 35;
#line 623
      if (board[bking_loc - 12] == 0) {
#line 623
        tmp___5 = 0U;
      } else {
#line 623
        tmp___4 = is_attacked(bking_loc - 12, 1);
#line 623
        tmp___5 = (unsigned int )tmp___4;
      }
#line 623
      if (tmp___5) {
#line 624
        score += 150 >> wdev_dscale;
      }
    }
#line 630
    if (board[43] == 1) {
#line 630
      goto _L___3;
    } else
#line 630
    if (board[54] == 1) {
#line 630
      goto _L___3;
    } else
#line 630
    if (board[54] == 2) {
      _L___3: /* CIL Label */ 
#line 630
      if (board[54] == 0) {
#line 630
        tmp___7 = 0U;
      } else {
#line 630
        tmp___6 = is_attacked(54, 0);
#line 630
        tmp___7 = (unsigned int )tmp___6;
      }
#line 630
      if (tmp___7) {
#line 632
        if (board[43] == 1) {
#line 632
          score += 10;
        }
#line 633
        if (board[54] == 1) {
#line 633
          score += 20;
        } else
#line 634
        if (board[54] == 2) {
#line 634
          score -= 15;
        }
      }
    }
#line 636
    if (board[103] == 2) {
#line 636
      goto _L___4;
    } else
#line 636
    if (board[90] == 2) {
#line 636
      goto _L___4;
    } else
#line 636
    if (board[90] == 1) {
      _L___4: /* CIL Label */ 
#line 636
      if (board[90] == 0) {
#line 636
        tmp___9 = 0U;
      } else {
#line 636
        tmp___8 = is_attacked(90, 1);
#line 636
        tmp___9 = (unsigned int )tmp___8;
      }
#line 636
      if (tmp___9) {
#line 638
        if (board[103] == 2) {
#line 638
          score -= 10;
        }
#line 639
        if (board[90] == 2) {
#line 639
          score -= 20;
        } else
#line 640
        if (board[90] == 1) {
#line 640
          score += 15;
        }
      }
    }
#line 645
    if (board[bking_loc] == 0) {
#line 645
      tmp___13 = 0U;
    } else {
#line 645
      tmp___12 = is_attacked(bking_loc, 1);
#line 645
      tmp___13 = (unsigned int )tmp___12;
    }
#line 645
    if (tmp___13) {
#line 646
      score += 50 >> wdev_dscale;
    } else {
#line 647
      if (board[wking_loc] == 0) {
#line 647
        tmp___11 = 0U;
      } else {
#line 647
        tmp___10 = is_attacked(wking_loc, 0);
#line 647
        tmp___11 = (unsigned int )tmp___10;
      }
#line 647
      if (tmp___11) {
#line 648
        score -= 50 >> bdev_dscale;
      }
    }
#line 653
    if (board[44] == 4) {
#line 655
      score -= 20;
#line 656
      if (board[44] == 0) {
#line 656
        tmp___15 = 0U;
      } else {
#line 656
        tmp___14 = is_attacked(44, 0);
#line 656
        tmp___15 = (unsigned int )tmp___14;
      }
#line 656
      if (tmp___15) {
#line 656
        score -= 40;
      }
#line 657
      if (board[32] == 7) {
#line 657
        score += 10;
      }
#line 658
      if (board[31] == 11) {
#line 658
        score += 10;
      }
    }
#line 660
    if (board[104] == 3) {
#line 662
      score += 20;
#line 663
      if (board[104] == 0) {
#line 663
        tmp___17 = 0U;
      } else {
#line 663
        tmp___16 = is_attacked(104, 1);
#line 663
        tmp___17 = (unsigned int )tmp___16;
      }
#line 663
      if (tmp___17) {
#line 663
        score += 40;
      }
#line 664
      if (board[116] == 8) {
#line 664
        score -= 10;
      }
#line 665
      if (board[115] == 12) {
#line 665
        score -= 10;
      }
    }
#line 671
    if (board[57] == 12) {
#line 671
      if (board[44] != 1) {
#line 673
        score -= 20;
#line 674
        if (board[44] == 4) {
#line 676
          score -= 40;
#line 677
          if (board[31] == 5) {
#line 678
            score -= 80;
          } else
#line 677
          if (board[32] == 5) {
#line 678
            score -= 80;
          } else
#line 677
          if (board[33] == 5) {
#line 678
            score -= 80;
          }
        }
      }
    }
#line 681
    if (board[93] == 11) {
#line 681
      if (board[104] != 2) {
#line 683
        score += 20;
#line 684
        if (board[104] == 3) {
#line 686
          score += 40;
#line 687
          if (board[115] == 6) {
#line 688
            score += 80;
          } else
#line 687
          if (board[116] == 6) {
#line 688
            score += 80;
          } else
#line 687
          if (board[117] == 6) {
#line 688
            score += 80;
          }
        }
      }
    }
  }
#line 693
  if (cfg_attackeval) {
#line 695
    badsquares = 0;
#line 696
    safety = 0;
#line 698
    if (board[wking_loc - 13] == 0) {
#line 698
      tmp___19 = 0U;
    } else {
#line 698
      tmp___18 = nk_attacked(wking_loc - 13, 0);
#line 698
      tmp___19 = (unsigned int )tmp___18;
    }
#line 698
    badsquares = (int )((unsigned int )badsquares + tmp___19);
#line 699
    if (board[wking_loc - 12] == 0) {
#line 699
      tmp___21 = 0U;
    } else {
#line 699
      tmp___20 = nk_attacked(wking_loc - 12, 0);
#line 699
      tmp___21 = (unsigned int )tmp___20;
    }
#line 699
    badsquares = (int )((unsigned int )badsquares + tmp___21);
#line 700
    if (board[wking_loc - 11] == 0) {
#line 700
      tmp___23 = 0U;
    } else {
#line 700
      tmp___22 = nk_attacked(wking_loc - 11, 0);
#line 700
      tmp___23 = (unsigned int )tmp___22;
    }
#line 700
    badsquares = (int )((unsigned int )badsquares + tmp___23);
#line 701
    if (board[wking_loc - 1] == 0) {
#line 701
      tmp___25 = 0U;
    } else {
#line 701
      tmp___24 = nk_attacked(wking_loc - 1, 0);
#line 701
      tmp___25 = (unsigned int )tmp___24;
    }
#line 701
    badsquares = (int )((unsigned int )badsquares + tmp___25);
#line 702
    if (board[wking_loc + 1] == 0) {
#line 702
      tmp___27 = 0U;
    } else {
#line 702
      tmp___26 = nk_attacked(wking_loc + 1, 0);
#line 702
      tmp___27 = (unsigned int )tmp___26;
    }
#line 702
    badsquares = (int )((unsigned int )badsquares + tmp___27);
#line 703
    if (board[wking_loc + 11] == 0) {
#line 703
      tmp___29 = 0U;
    } else {
#line 703
      tmp___28 = nk_attacked(wking_loc + 11, 0);
#line 703
      tmp___29 = (unsigned int )tmp___28;
    }
#line 703
    badsquares = (int )((unsigned int )badsquares + tmp___29);
#line 704
    if (board[wking_loc + 12] == 0) {
#line 704
      tmp___31 = 0U;
    } else {
#line 704
      tmp___30 = nk_attacked(wking_loc + 12, 0);
#line 704
      tmp___31 = (unsigned int )tmp___30;
    }
#line 704
    badsquares = (int )((unsigned int )badsquares + tmp___31);
#line 705
    if (board[wking_loc + 13] == 0) {
#line 705
      tmp___33 = 0U;
    } else {
#line 705
      tmp___32 = nk_attacked(wking_loc + 13, 0);
#line 705
      tmp___33 = (unsigned int )tmp___32;
    }
#line 705
    badsquares = (int )((unsigned int )badsquares + tmp___33);
#line 707
    norm_black_hand_eval = - black_hand_eval / 100;
#line 708
    if (norm_black_hand_eval > 14) {
#line 708
      norm_black_hand_eval = 14;
    } else
#line 709
    if (norm_black_hand_eval < 0) {
#line 709
      norm_black_hand_eval = 0;
    }
#line 711
    safety -= ksafety_scaled[norm_black_hand_eval][badsquares];
#line 713
    badsquares = 0;
#line 715
    if (board[bking_loc - 13] == 0) {
#line 715
      tmp___35 = 0U;
    } else {
#line 715
      tmp___34 = nk_attacked(bking_loc - 13, 1);
#line 715
      tmp___35 = (unsigned int )tmp___34;
    }
#line 715
    badsquares = (int )((unsigned int )badsquares + tmp___35);
#line 716
    if (board[bking_loc - 12] == 0) {
#line 716
      tmp___37 = 0U;
    } else {
#line 716
      tmp___36 = nk_attacked(bking_loc - 12, 1);
#line 716
      tmp___37 = (unsigned int )tmp___36;
    }
#line 716
    badsquares = (int )((unsigned int )badsquares + tmp___37);
#line 717
    if (board[bking_loc - 11] == 0) {
#line 717
      tmp___39 = 0U;
    } else {
#line 717
      tmp___38 = nk_attacked(bking_loc - 11, 1);
#line 717
      tmp___39 = (unsigned int )tmp___38;
    }
#line 717
    badsquares = (int )((unsigned int )badsquares + tmp___39);
#line 718
    if (board[bking_loc - 1] == 0) {
#line 718
      tmp___41 = 0U;
    } else {
#line 718
      tmp___40 = nk_attacked(bking_loc - 1, 1);
#line 718
      tmp___41 = (unsigned int )tmp___40;
    }
#line 718
    badsquares = (int )((unsigned int )badsquares + tmp___41);
#line 719
    if (board[bking_loc + 1] == 0) {
#line 719
      tmp___43 = 0U;
    } else {
#line 719
      tmp___42 = nk_attacked(bking_loc + 1, 1);
#line 719
      tmp___43 = (unsigned int )tmp___42;
    }
#line 719
    badsquares = (int )((unsigned int )badsquares + tmp___43);
#line 720
    if (board[bking_loc + 11] == 0) {
#line 720
      tmp___45 = 0U;
    } else {
#line 720
      tmp___44 = nk_attacked(bking_loc + 11, 1);
#line 720
      tmp___45 = (unsigned int )tmp___44;
    }
#line 720
    badsquares = (int )((unsigned int )badsquares + tmp___45);
#line 721
    if (board[bking_loc + 12] == 0) {
#line 721
      tmp___47 = 0U;
    } else {
#line 721
      tmp___46 = nk_attacked(bking_loc + 12, 1);
#line 721
      tmp___47 = (unsigned int )tmp___46;
    }
#line 721
    badsquares = (int )((unsigned int )badsquares + tmp___47);
#line 722
    if (board[bking_loc + 13] == 0) {
#line 722
      tmp___49 = 0U;
    } else {
#line 722
      tmp___48 = nk_attacked(bking_loc + 13, 1);
#line 722
      tmp___49 = (unsigned int )tmp___48;
    }
#line 722
    badsquares = (int )((unsigned int )badsquares + tmp___49);
#line 724
    norm_white_hand_eval = white_hand_eval / 100;
#line 725
    if (norm_white_hand_eval > 14) {
#line 725
      norm_white_hand_eval = 14;
    } else
#line 726
    if (norm_white_hand_eval < 0) {
#line 726
      norm_white_hand_eval = 0;
    }
#line 728
    safety += ksafety_scaled[norm_white_hand_eval][badsquares];
#line 730
    score += safety;
  }
#line 733
  score += white_hand_eval + black_hand_eval;
#line 735
  storeECache(score);
#line 738
  if (white_to_move == 1) {
#line 739
    return (score);
  } else {
#line 742
    return (- score);
  }
}
}
#line 1 "leval.o"
#pragma merger("0","/tmp/cil-Ika9ySFa.i","")
#line 14 "leval.c"
static int lcentral[144]  = 
#line 14 "leval.c"
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -15, 
        -15,      -15,      -15,      -15, 
        -15,      -20,      0,      0, 
        0,      0,      -15,      0, 
        3,      5,      5,      3, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      15,      15,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      30,      30,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      30,      30,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      15,      15,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        3,      5,      5,      3, 
        0,      -15,      0,      0, 
        0,      0,      -20,      -15, 
        -15,      -15,      -15,      -15, 
        -15,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 28 "leval.c"
static int l_bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
#line 31
  m = 0;
#line 33
  l = square - 13;
#line 33
  while (board[l] == 13) {
#line 34
    m ++;
#line 33
    l -= 13;
  }
#line 35
  l = square - 11;
#line 35
  while (board[l] == 13) {
#line 36
    m ++;
#line 35
    l -= 11;
  }
#line 37
  l = square + 11;
#line 37
  while (board[l] == 13) {
#line 38
    m ++;
#line 37
    l += 11;
  }
#line 39
  l = square + 13;
#line 39
  while (board[l] == 13) {
#line 40
    m ++;
#line 39
    l += 13;
  }
#line 42
  return (m);
}
}
#line 45 "leval.c"
static int l_rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
#line 48
  m = 0;
#line 50
  l = square - 12;
#line 50
  while (board[l] == 13) {
#line 51
    m ++;
#line 50
    l -= 12;
  }
#line 52
  l = square - 1;
#line 52
  while (board[l] == 13) {
#line 53
    m ++;
#line 52
    l --;
  }
#line 54
  l = square + 1;
#line 54
  while (board[l] == 13) {
#line 55
    m ++;
#line 54
    l ++;
  }
#line 56
  l = square + 12;
#line 56
  while (board[l] == 13) {
#line 57
    m ++;
#line 56
    l += 12;
  }
#line 59
  return (m);
}
}
#line 65
static int l_knight_mobility(int square ) ;
#line 65 "leval.c"
static int const   knight_o___2[8]  = 
#line 65
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 63 "leval.c"
static int l_knight_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
#line 66
  m = 0;
#line 68
  d = 0;
#line 68
  while (d < 8) {
#line 70
    if (board[square + (int )knight_o___2[d]] == 13) {
#line 70
      m ++;
    }
#line 68
    d ++;
  }
#line 73
  return (m);
}
}
#line 76 "leval.c"
static int l_pawn_mobility(int square ) 
{ 
  register int m ;

  {
#line 78
  m = 0;
#line 80
  if (board[square] == 1) {
#line 82
    if (board[square + 12] == 13) {
#line 82
      m ++;
    }
  } else
#line 86
  if (board[square - 12] == 13) {
#line 86
    m ++;
  }
#line 89
  return (m);
}
}
#line 94
static int l_king_mobility(int square ) ;
#line 94 "leval.c"
static int const   king_o[8]  = 
#line 94
  {      (int const   )13,      (int const   )12,      (int const   )11,      (int const   )1, 
        (int const   )-1,      (int const   )-11,      (int const   )-12,      (int const   )-13};
#line 92 "leval.c"
static int l_king_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
#line 95
  m = 0;
#line 97
  d = 0;
#line 97
  while (d < 8) {
#line 99
    if (board[square + (int )king_o[d]] == 13) {
#line 99
      m ++;
    }
#line 97
    d ++;
  }
#line 102
  return (m);
}
}
#line 106 "leval.c"
int losers_eval(void) 
{ 
  int srank ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int isolated ;
  int backwards ;
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int wp ;
  int bp ;
  int wks ;
  int bks ;
  int wpassp ;
  int bpassp ;
  int wpawns ;
  int bpawns ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 109
  srank = 0;
#line 109
  pawn_file = 0;
#line 112
  score = 0;
#line 114
  wp = 0;
#line 114
  bp = 0;
#line 115
  wks = 0;
#line 115
  bks = 0;
#line 116
  wpassp = 0;
#line 116
  bpassp = 0;
#line 117
  wpawns = 0;
#line 117
  bpawns = 0;
#line 119
  in_cache = 0;
#line 121
  checkECache(& score, & in_cache);
#line 123
  if (in_cache) {
#line 125
    if (white_to_move == 1) {
#line 125
      return (score);
    }
#line 126
    return (- score);
  }
#line 132
  memset((void *)(pawns), 0, sizeof(pawns));
#line 133
  i = 0;
#line 133
  while (i < 11) {
#line 134
    white_back_pawn[i] = 7;
#line 135
    black_back_pawn[i] = 2;
#line 133
    i ++;
  }
#line 137
  j = 1;
#line 137
  a = 1;
#line 137
  while (a <= piece_count) {
#line 138
    i = pieces[j];
#line 140
    if (! i) {
#line 141
      goto __Cont;
    } else {
#line 143
      a ++;
    }
#line 147
    pawn_file = (int )(Xfile[i] + 1);
#line 148
    srank = (int )Xrank[i];
#line 149
    if (board[i] == 1) {
#line 150
      (pawns[1][pawn_file]) ++;
#line 151
      if (srank < white_back_pawn[pawn_file]) {
#line 152
        white_back_pawn[pawn_file] = srank;
      }
    } else
#line 155
    if (board[i] == 2) {
#line 156
      (pawns[0][pawn_file]) ++;
#line 157
      if (srank > black_back_pawn[pawn_file]) {
#line 158
        black_back_pawn[pawn_file] = srank;
      }
    }
    __Cont: /* CIL Label */ 
#line 137
    j ++;
  }
#line 165
  j = 1;
#line 165
  a = 1;
#line 165
  while (a <= piece_count) {
#line 166
    i = pieces[j];
#line 168
    if (! i) {
#line 169
      goto __Cont___0;
    } else {
#line 171
      a ++;
    }
#line 173
    switch (board[i]) {
    case 1: 
#line 175
    wp ++;
#line 176
    wpawns ++;
#line 177
    score += lcentral[i];
#line 178
    tmp = l_pawn_mobility(i);
#line 178
    score += tmp << 2;
#line 179
    score += (int )((Xrank[i] - 2) * 8);
#line 180
    isolated = 0;
#line 181
    backwards = 0;
#line 184
    if (white_back_pawn[pawn_file + 1] > srank) {
#line 184
      if (white_back_pawn[pawn_file - 1] > srank) {
#line 186
        score -= 8;
#line 187
        backwards = 1;
#line 189
        if (! pawns[1][pawn_file + 1]) {
#line 189
          if (! pawns[1][pawn_file - 1]) {
#line 190
            score -= 12;
#line 191
            isolated = 1;
          }
        }
      }
    }
#line 195
    if (! pawns[0][pawn_file]) {
#line 196
      if (backwards) {
#line 196
        score -= 5;
      }
#line 197
      if (isolated) {
#line 197
        score -= 8;
      }
    }
#line 200
    if (pawns[1][pawn_file] > 1) {
#line 201
      score -= 8 * (pawns[1][pawn_file] - 1);
    }
#line 203
    if (! pawns[0][pawn_file]) {
#line 203
      if (srank >= black_back_pawn[pawn_file - 1]) {
#line 203
        if (srank >= black_back_pawn[pawn_file + 1]) {
#line 205
          score += 25 + 10 * (int )(Xrank[i] - 2);
#line 207
          if (Xrank[i] == 7) {
#line 207
            score += 50;
          }
#line 209
          wpassp ++;
#line 212
          if (Xfile[i] == 1) {
#line 213
            score += 4 + 2 * (int )(Xrank[i] - 2);
          } else
#line 212
          if (Xfile[i] == 8) {
#line 213
            score += 4 + 2 * (int )(Xrank[i] - 2);
          }
#line 216
          if (! isolated) {
#line 218
            score += 24;
          }
        }
      }
    }
#line 223
    if (! pawns[1][pawn_file - 1]) {
#line 224
      score -= 5;
    }
#line 226
    break;
    case 2: 
#line 229
    bp ++;
#line 230
    bpawns ++;
#line 231
    score -= lcentral[i];
#line 232
    tmp___0 = l_pawn_mobility(i);
#line 232
    score -= tmp___0 << 2;
#line 233
    score -= (7 - (int )Xrank[i]) * 8;
#line 234
    isolated = 0;
#line 235
    backwards = 0;
#line 242
    if (black_back_pawn[pawn_file + 1] < srank) {
#line 242
      if (black_back_pawn[pawn_file - 1] < srank) {
#line 244
        score += 8;
#line 245
        backwards = 1;
#line 247
        if (! pawns[0][pawn_file + 1]) {
#line 247
          if (! pawns[0][pawn_file - 1]) {
#line 248
            score += 12;
#line 249
            isolated = 1;
          }
        }
      }
    }
#line 253
    if (! pawns[1][pawn_file]) {
#line 254
      if (backwards) {
#line 254
        score += 5;
      }
#line 255
      if (isolated) {
#line 255
        score += 8;
      }
    }
#line 258
    if (pawns[0][pawn_file] > 1) {
#line 259
      score += 8 * (pawns[0][pawn_file] - 1);
    }
#line 261
    if (! pawns[1][pawn_file]) {
#line 261
      if (srank <= white_back_pawn[pawn_file - 1]) {
#line 261
        if (srank <= white_back_pawn[pawn_file + 1]) {
#line 263
          score -= 25 + 10 * (7 - (int )Xrank[i]);
#line 265
          if (Xrank[i] == 2) {
#line 265
            score -= 50;
          }
#line 267
          bpassp ++;
#line 270
          if (Xfile[i] == 1) {
#line 271
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          } else
#line 270
          if (Xfile[i] == 8) {
#line 271
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          }
#line 274
          if (! isolated) {
#line 276
            score -= 24;
          }
        }
      }
    }
#line 280
    if (! pawns[0][pawn_file - 1]) {
#line 281
      score += 5;
    }
#line 283
    break;
    case 7: 
#line 286
    wp ++;
#line 287
    tmp___1 = l_rook_mobility(i);
#line 287
    score += tmp___1 << 2;
#line 288
    score += lcentral[i];
#line 289
    break;
    case 8: 
#line 292
    bp ++;
#line 293
    tmp___2 = l_rook_mobility(i);
#line 293
    score -= tmp___2 << 2;
#line 294
    score -= lcentral[i];
#line 295
    break;
    case 11: 
#line 298
    wp ++;
#line 299
    tmp___3 = l_bishop_mobility(i);
#line 299
    score += tmp___3 << 2;
#line 300
    score += lcentral[i];
#line 301
    break;
    case 12: 
#line 304
    bp ++;
#line 305
    tmp___4 = l_bishop_mobility(i);
#line 305
    score -= tmp___4 << 2;
#line 306
    score -= lcentral[i];
#line 307
    break;
    case 3: 
#line 310
    wp ++;
#line 311
    score += lcentral[i] << 1;
#line 312
    tmp___5 = l_knight_mobility(i);
#line 312
    score += tmp___5 << 2;
#line 313
    break;
    case 4: 
#line 316
    bp ++;
#line 317
    score -= lcentral[i] << 1;
#line 318
    tmp___6 = l_knight_mobility(i);
#line 318
    score -= tmp___6 << 2;
#line 319
    break;
    case 9: 
#line 322
    wp ++;
#line 323
    tmp___7 = l_bishop_mobility(i);
#line 323
    score += tmp___7 << 1;
#line 324
    tmp___8 = l_rook_mobility(i);
#line 324
    score += tmp___8 << 1;
#line 325
    score += lcentral[i];
#line 326
    break;
    case 10: 
#line 329
    bp ++;
#line 330
    tmp___9 = l_bishop_mobility(i);
#line 330
    score -= tmp___9 << 1;
#line 331
    tmp___10 = l_rook_mobility(i);
#line 331
    score -= tmp___10 << 1;
#line 332
    score -= lcentral[i];
#line 333
    break;
    case 5: 
#line 337
    wks = lcentral[i] << 1;
#line 338
    tmp___11 = l_king_mobility(i);
#line 338
    score += tmp___11;
#line 339
    break;
    case 6: 
#line 343
    bks = lcentral[i] << 1;
#line 344
    tmp___12 = l_king_mobility(i);
#line 344
    score -= tmp___12;
#line 345
    break;
    }
    __Cont___0: /* CIL Label */ 
#line 165
    j ++;
  }
#line 349
  if (wp + bp > 10) {
#line 351
    score -= wks - bks;
  }
#line 354
  tmp___13 = abs(Material);
#line 354
  if (tmp___13 <= 900) {
#line 356
    score += Material;
  } else
#line 371
  if (Material > 0) {
#line 371
    if (comp_color == 1) {
#line 371
      if (! wpassp) {
#line 373
        score += 1800 - Material;
      } else {
#line 371
        goto _L___0;
      }
    } else {
#line 371
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 375
  if (Material < 0) {
#line 375
    if (comp_color == 0) {
#line 375
      if (! bpassp) {
#line 377
        score += - (1800 + Material);
      } else {
#line 381
        score += Material;
      }
    } else {
#line 381
      score += Material;
    }
  } else {
#line 381
    score += Material;
  }
#line 385
  if (! wpawns) {
#line 385
    score += 200;
  } else
#line 386
  if (! bpawns) {
#line 386
    score -= 200;
  }
#line 388
  if (! wp) {
#line 388
    score = 1000000;
  } else
#line 389
  if (! bp) {
#line 389
    score = -1000000;
  }
#line 391
  storeECache(score);
#line 394
  if (white_to_move == 1) {
#line 395
    return (score);
  } else {
#line 398
    return (- score);
  }
}
}
#line 1 "moves.o"
#pragma merger("0","/tmp/cil-PMar28Fr.i","")
#line 12 "./extvars.h"
int squares[144] ;
#line 22
xbool captures ;
#line 28
move_x path_x[300] ;
#line 45
int is_promoted[62] ;
#line 91 "./extvars.h"
unsigned int total_moves  ;
#line 92 "./extvars.h"
unsigned int total_movegens  ;
#line 100
int Giveaway ;
#line 118 "./extvars.h"
int numb_moves  ;
#line 128 "./extvars.h"
int kingcap  ;
#line 14 "./protos.h"
xbool check_legal(move_s *moves , int m , int incheck ) ;
#line 22
void gen(move_s *moves ) ;
#line 24
xbool in_check(void) ;
#line 25
xbool f_in_check(move_s *moves , int m ) ;
#line 26
int extended_in_check(void) ;
#line 31
void make(move_s *moves , int i ) ;
#line 42
void push_pawn(int target , xbool is_ep ) ;
#line 43
void push_king_castle(int Ptarget , int Pcastle_type ) ;
#line 44
void push_pawn_simple(int target ) ;
#line 45
void push_king(int target ) ;
#line 46
void push_knighT(int target ) ;
#line 48
void try_drop(int ptype ) ;
#line 51
void push_slidE(int target ) ;
#line 67
void unmake(move_s *moves , int i ) ;
#line 18 "moves.c"
static move_s *genfor  ;
#line 20 "moves.c"
xbool fcaptures  ;
#line 21 "moves.c"
int gfrom  ;
#line 25 "moves.c"
xbool check_legal(move_s *moves , int m , int incheck ) 
{ 
  int castled ;
  int from ;
  int target ;
  int l ;
  xbool tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  xbool tmp___4 ;
  xbool tmp___5 ;
  xbool tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;
  xbool tmp___9 ;
  xbool tmp___10 ;
  int tmp___11 ;
  xbool tmp___12 ;
  int tmp___13 ;
  xbool tmp___14 ;

  {
#line 31
  castled = (moves + m)->castled;
#line 32
  from = (moves + m)->from;
#line 33
  target = (moves + m)->target;
#line 36
  if (Variant == 3) {
#line 36
    return ((xbool )1);
  }
#line 39
  if (castled) {
#line 42
    if (castled == 1) {
#line 43
      tmp = is_attacked(30, 0);
#line 43
      if (tmp) {
#line 43
        return ((xbool )0);
      }
#line 44
      tmp___0 = is_attacked(31, 0);
#line 44
      if (tmp___0) {
#line 44
        return ((xbool )0);
      }
#line 45
      tmp___1 = is_attacked(32, 0);
#line 45
      if (tmp___1) {
#line 45
        return ((xbool )0);
      }
#line 46
      return ((xbool )1);
    }
#line 49
    if (castled == 2) {
#line 50
      tmp___2 = is_attacked(30, 0);
#line 50
      if (tmp___2) {
#line 50
        return ((xbool )0);
      }
#line 51
      tmp___3 = is_attacked(29, 0);
#line 51
      if (tmp___3) {
#line 51
        return ((xbool )0);
      }
#line 52
      tmp___4 = is_attacked(28, 0);
#line 52
      if (tmp___4) {
#line 52
        return ((xbool )0);
      }
#line 53
      return ((xbool )1);
    }
#line 56
    if (castled == 3) {
#line 57
      tmp___5 = is_attacked(114, 1);
#line 57
      if (tmp___5) {
#line 57
        return ((xbool )0);
      }
#line 58
      tmp___6 = is_attacked(115, 1);
#line 58
      if (tmp___6) {
#line 58
        return ((xbool )0);
      }
#line 59
      tmp___7 = is_attacked(116, 1);
#line 59
      if (tmp___7) {
#line 59
        return ((xbool )0);
      }
#line 60
      return ((xbool )1);
    }
#line 63
    if (castled == 4) {
#line 64
      tmp___8 = is_attacked(114, 1);
#line 64
      if (tmp___8) {
#line 64
        return ((xbool )0);
      }
#line 65
      tmp___9 = is_attacked(113, 1);
#line 65
      if (tmp___9) {
#line 65
        return ((xbool )0);
      }
#line 66
      tmp___10 = is_attacked(112, 1);
#line 66
      if (tmp___10) {
#line 66
        return ((xbool )0);
      }
#line 67
      return ((xbool )1);
    }
  } else
#line 78
  if (white_to_move & 1) {
#line 80
    if (! incheck) {
#line 82
      if ((moves + m)->from == 0) {
#line 82
        return ((xbool )1);
      }
#line 84
      if ((moves + m)->promoted) {
#line 84
        tmp___11 = 2;
      } else {
#line 84
        tmp___11 = board[target];
      }
#line 84
      switch (tmp___11) {
      case 2: 
#line 89
      if ((moves + m)->captured != 13) {
#line 91
        if (Xfile[from] != Xfile[bking_loc]) {
#line 91
          if (Xrank[from] != Xrank[bking_loc]) {
#line 91
            if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 91
              if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 95
                return ((xbool )1);
              }
            }
          }
        }
      } else
#line 99
      if (Xrank[from] != Xrank[bking_loc]) {
#line 99
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 99
          if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 102
            return ((xbool )1);
          }
        }
      }
#line 104
      break;
      case 4: 
#line 107
      if (Xfile[from] != Xfile[bking_loc]) {
#line 107
        if (Xrank[from] != Xrank[bking_loc]) {
#line 107
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 107
            if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 111
              return ((xbool )1);
            }
          }
        }
      }
#line 112
      break;
      case 12: 
#line 116
      if (Xfile[from] != Xfile[bking_loc]) {
#line 116
        if (Xrank[from] != Xrank[bking_loc]) {
#line 119
          if (Xdiagl[from] == Xdiagl[target]) {
#line 123
            if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 124
              return ((xbool )1);
            }
          } else
#line 128
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 129
            return ((xbool )1);
          }
        }
      }
#line 132
      break;
      case 8: 
#line 136
      if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 136
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 140
          if (Xrank[from] == Xrank[target]) {
#line 142
            if (Xfile[from] != Xfile[bking_loc]) {
#line 143
              return ((xbool )1);
            }
          } else
#line 148
          if (Xrank[from] != Xrank[bking_loc]) {
#line 149
            return ((xbool )1);
          }
        }
      }
#line 152
      break;
      case 10: 
#line 155
      if (Xfile[from] == Xfile[target]) {
#line 157
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 157
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 157
            if (Xrank[from] != Xrank[bking_loc]) {
#line 160
              return ((xbool )1);
            }
          }
        }
      } else
#line 162
      if (Xrank[from] == Xrank[target]) {
#line 164
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 164
          if (Xfile[from] != Xfile[bking_loc]) {
#line 164
            if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 167
              return ((xbool )1);
            }
          }
        }
      } else
#line 169
      if (Xdiagl[from] == Xdiagl[target]) {
#line 171
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
#line 171
          if (Xfile[from] != Xfile[bking_loc]) {
#line 171
            if (Xrank[from] != Xrank[bking_loc]) {
#line 174
              return ((xbool )1);
            }
          }
        }
      } else
#line 176
      if (Xdiagr[from] == Xdiagr[target]) {
#line 178
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
#line 178
          if (Xfile[from] != Xfile[bking_loc]) {
#line 178
            if (Xrank[from] != Xrank[bking_loc]) {
#line 181
              return ((xbool )1);
            }
          }
        }
      }
#line 183
      break;
      default: 
#line 185
      break;
      }
#line 194
      if (board[target] != 6) {
#line 196
        if (Xfile[from] == Xfile[bking_loc]) {
#line 198
          if (bking_loc > from) {
#line 200
            l = bking_loc - 12;
#line 200
            while (board[l] == 13) {
#line 200
              l -= 12;
            }
#line 201
            if (board[l] == 7) {
#line 201
              return ((xbool )0);
            } else
#line 201
            if (board[l] == 9) {
#line 201
              return ((xbool )0);
            }
          } else {
#line 205
            l = bking_loc + 12;
#line 205
            while (board[l] == 13) {
#line 205
              l += 12;
            }
#line 206
            if (board[l] == 7) {
#line 206
              return ((xbool )0);
            } else
#line 206
            if (board[l] == 9) {
#line 206
              return ((xbool )0);
            }
          }
        } else
#line 209
        if (Xrank[from] == Xrank[bking_loc]) {
#line 211
          if (bking_loc > from) {
#line 213
            l = bking_loc - 1;
#line 213
            while (board[l] == 13) {
#line 213
              l --;
            }
#line 214
            if (board[l] == 7) {
#line 214
              return ((xbool )0);
            } else
#line 214
            if (board[l] == 9) {
#line 214
              return ((xbool )0);
            }
          } else {
#line 218
            l = bking_loc + 1;
#line 218
            while (board[l] == 13) {
#line 218
              l ++;
            }
#line 219
            if (board[l] == 7) {
#line 219
              return ((xbool )0);
            } else
#line 219
            if (board[l] == 9) {
#line 219
              return ((xbool )0);
            }
          }
        } else
#line 222
        if (Xdiagl[from] == Xdiagl[bking_loc]) {
#line 224
          if (bking_loc > from) {
#line 226
            l = bking_loc - 13;
#line 226
            while (board[l] == 13) {
#line 226
              l -= 13;
            }
#line 227
            if (board[l] == 11) {
#line 227
              return ((xbool )0);
            } else
#line 227
            if (board[l] == 9) {
#line 227
              return ((xbool )0);
            }
          } else {
#line 231
            l = bking_loc + 13;
#line 231
            while (board[l] == 13) {
#line 231
              l += 13;
            }
#line 232
            if (board[l] == 11) {
#line 232
              return ((xbool )0);
            } else
#line 232
            if (board[l] == 9) {
#line 232
              return ((xbool )0);
            }
          }
        } else
#line 235
        if (Xdiagr[from] == Xdiagr[bking_loc]) {
#line 237
          if (bking_loc > from) {
#line 239
            l = bking_loc - 11;
#line 239
            while (board[l] == 13) {
#line 239
              l -= 11;
            }
#line 240
            if (board[l] == 11) {
#line 240
              return ((xbool )0);
            } else
#line 240
            if (board[l] == 9) {
#line 240
              return ((xbool )0);
            }
          } else {
#line 244
            l = bking_loc + 11;
#line 244
            while (board[l] == 13) {
#line 244
              l += 11;
            }
#line 245
            if (board[l] == 11) {
#line 245
              return ((xbool )0);
            } else
#line 245
            if (board[l] == 9) {
#line 245
              return ((xbool )0);
            }
          }
        }
#line 248
        return ((xbool )1);
      }
    }
#line 252
    tmp___12 = is_attacked(bking_loc, 1);
#line 252
    if (tmp___12) {
#line 252
      return ((xbool )0);
    } else {
#line 253
      return ((xbool )1);
    }
  } else {
#line 260
    if (! incheck) {
#line 262
      if ((moves + m)->from == 0) {
#line 262
        return ((xbool )1);
      }
#line 264
      if ((moves + m)->promoted) {
#line 264
        tmp___13 = 1;
      } else {
#line 264
        tmp___13 = board[target];
      }
#line 264
      switch (tmp___13) {
      case 1: 
#line 269
      if ((moves + m)->captured != 13) {
#line 271
        if (Xfile[from] != Xfile[wking_loc]) {
#line 271
          if (Xrank[from] != Xrank[wking_loc]) {
#line 271
            if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 271
              if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 275
                return ((xbool )1);
              }
            }
          }
        }
      } else
#line 279
      if (Xrank[from] != Xrank[wking_loc]) {
#line 279
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 279
          if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 282
            return ((xbool )1);
          }
        }
      }
#line 284
      break;
      case 3: 
#line 287
      if (Xfile[from] != Xfile[wking_loc]) {
#line 287
        if (Xrank[from] != Xrank[wking_loc]) {
#line 287
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 287
            if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 291
              return ((xbool )1);
            }
          }
        }
      }
#line 292
      break;
      case 11: 
#line 296
      if (Xfile[from] != Xfile[wking_loc]) {
#line 296
        if (Xrank[from] != Xrank[wking_loc]) {
#line 299
          if (Xdiagl[from] == Xdiagl[target]) {
#line 303
            if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 304
              return ((xbool )1);
            }
          } else
#line 308
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 309
            return ((xbool )1);
          }
        }
      }
#line 312
      break;
      case 7: 
#line 316
      if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 316
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 320
          if (Xrank[from] == Xrank[target]) {
#line 322
            if (Xfile[from] != Xfile[wking_loc]) {
#line 323
              return ((xbool )1);
            }
          } else
#line 328
          if (Xrank[from] != Xrank[wking_loc]) {
#line 329
            return ((xbool )1);
          }
        }
      }
#line 332
      break;
      case 9: 
#line 335
      if (Xfile[from] == Xfile[(moves + m)->target]) {
#line 337
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 337
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 337
            if (Xrank[from] != Xrank[wking_loc]) {
#line 340
              return ((xbool )1);
            }
          }
        }
      } else
#line 342
      if (Xrank[from] == Xrank[target]) {
#line 344
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 344
          if (Xfile[from] != Xfile[wking_loc]) {
#line 344
            if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 347
              return ((xbool )1);
            }
          }
        }
      } else
#line 349
      if (Xdiagl[from] == Xdiagl[target]) {
#line 351
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
#line 351
          if (Xfile[from] != Xfile[wking_loc]) {
#line 351
            if (Xrank[from] != Xrank[wking_loc]) {
#line 354
              return ((xbool )1);
            }
          }
        }
      } else
#line 356
      if (Xdiagr[from] == Xdiagr[target]) {
#line 358
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
#line 358
          if (Xfile[from] != Xfile[wking_loc]) {
#line 358
            if (Xrank[from] != Xrank[wking_loc]) {
#line 361
              return ((xbool )1);
            }
          }
        }
      }
#line 363
      break;
      default: 
#line 365
      break;
      }
#line 368
      if (board[target] != 5) {
#line 370
        if (Xfile[from] == Xfile[wking_loc]) {
#line 372
          if (wking_loc > from) {
#line 374
            l = wking_loc - 12;
#line 374
            while (board[l] == 13) {
#line 374
              l -= 12;
            }
#line 375
            if (board[l] == 8) {
#line 375
              return ((xbool )0);
            } else
#line 375
            if (board[l] == 10) {
#line 375
              return ((xbool )0);
            }
          } else {
#line 379
            l = wking_loc + 12;
#line 379
            while (board[l] == 13) {
#line 379
              l += 12;
            }
#line 380
            if (board[l] == 8) {
#line 380
              return ((xbool )0);
            } else
#line 380
            if (board[l] == 10) {
#line 380
              return ((xbool )0);
            }
          }
        } else
#line 383
        if (Xrank[from] == Xrank[wking_loc]) {
#line 385
          if (wking_loc > from) {
#line 387
            l = wking_loc - 1;
#line 387
            while (board[l] == 13) {
#line 387
              l --;
            }
#line 388
            if (board[l] == 8) {
#line 388
              return ((xbool )0);
            } else
#line 388
            if (board[l] == 10) {
#line 388
              return ((xbool )0);
            }
          } else {
#line 392
            l = wking_loc + 1;
#line 392
            while (board[l] == 13) {
#line 392
              l ++;
            }
#line 393
            if (board[l] == 8) {
#line 393
              return ((xbool )0);
            } else
#line 393
            if (board[l] == 10) {
#line 393
              return ((xbool )0);
            }
          }
        } else
#line 396
        if (Xdiagl[from] == Xdiagl[wking_loc]) {
#line 398
          if (wking_loc > from) {
#line 400
            l = wking_loc - 13;
#line 400
            while (board[l] == 13) {
#line 400
              l -= 13;
            }
#line 401
            if (board[l] == 12) {
#line 401
              return ((xbool )0);
            } else
#line 401
            if (board[l] == 10) {
#line 401
              return ((xbool )0);
            }
          } else {
#line 405
            l = wking_loc + 13;
#line 405
            while (board[l] == 13) {
#line 405
              l += 13;
            }
#line 406
            if (board[l] == 12) {
#line 406
              return ((xbool )0);
            } else
#line 406
            if (board[l] == 10) {
#line 406
              return ((xbool )0);
            }
          }
        } else
#line 409
        if (Xdiagr[from] == Xdiagr[wking_loc]) {
#line 411
          if (wking_loc > from) {
#line 413
            l = wking_loc - 11;
#line 413
            while (board[l] == 13) {
#line 413
              l -= 11;
            }
#line 414
            if (board[l] == 12) {
#line 414
              return ((xbool )0);
            } else
#line 414
            if (board[l] == 10) {
#line 414
              return ((xbool )0);
            }
          } else {
#line 418
            l = wking_loc + 11;
#line 418
            while (board[l] == 13) {
#line 418
              l += 11;
            }
#line 419
            if (board[l] == 12) {
#line 419
              return ((xbool )0);
            } else
#line 419
            if (board[l] == 10) {
#line 419
              return ((xbool )0);
            }
          }
        }
#line 422
        return ((xbool )1);
      }
    }
#line 426
    tmp___14 = is_attacked(wking_loc, 0);
#line 426
    if (tmp___14) {
#line 426
      return ((xbool )0);
    } else {
#line 427
      return ((xbool )1);
    }
  }
#line 431
  return ((xbool )0);
}
}
#line 439 "moves.c"
void gen(move_s *moves ) 
{ 
  int from ;
  int a ;
  int j ;
  int i ;

  {
#line 445
  kingcap = 0;
#line 447
  numb_moves = 0;
#line 448
  genfor = moves + 0;
#line 450
  if (Variant == 3) {
#line 452
    captures = (xbool )0;
#line 453
    fcaptures = (xbool )0;
  }
  restart: 
#line 459
  if (white_to_move) {
#line 460
    a = 1;
#line 460
    j = 1;
#line 460
    while (1) {
#line 460
      if (a <= piece_count) {
#line 460
        if (Variant != 3) {
#line 460
          if (! (! kingcap)) {
#line 460
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 460
        if (Variant == 3) {
#line 460
          if (! ((unsigned int )fcaptures == (unsigned int )captures)) {
#line 460
            break;
          }
        } else {
#line 460
          break;
        }
      } else {
#line 460
        break;
      }
#line 466
      i = pieces[j];
#line 468
      if (! i) {
#line 469
        goto __Cont;
      } else {
#line 471
        a ++;
      }
#line 473
      from = i;
#line 474
      gfrom = i;
#line 476
      switch (board[from]) {
      case 1: 
#line 479
      if (board[from + 12] == 13) {
#line 481
        if (Xrank[from] == 7) {
#line 481
          if (Variant != 3) {
#line 481
            if (Variant != 4) {
#line 482
              push_pawn(from + 12, (xbool )0);
            } else {
#line 481
              goto _L;
            }
          } else {
#line 481
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 484
        if (! captures) {
#line 485
          push_pawn(from + 12, (xbool )0);
#line 488
          if (Xrank[from] == 2) {
#line 488
            if (board[from + 24] == 13) {
#line 489
              push_pawn_simple(from + 24);
            }
          }
        }
      }
#line 493
      if ((board[from + 13] & 1) == 0) {
#line 493
        if (board[from + 13] != 0) {
#line 494
          push_pawn(from + 13, (xbool )0);
        }
      }
#line 496
      if ((board[from + 11] & 1) == 0) {
#line 496
        if (board[from + 11] != 0) {
#line 497
          push_pawn(from + 11, (xbool )0);
        }
      }
#line 499
      if (ep_square == from + 13) {
#line 500
        push_pawn(from + 13, (xbool )1);
      } else
#line 502
      if (ep_square == from + 11) {
#line 503
        push_pawn(from + 11, (xbool )1);
      }
#line 504
      break;
      case 3: 
#line 507
      if (board[from - 25] != 0) {
#line 507
        push_knighT(from - 25);
      }
#line 508
      if (board[from - 23] != 0) {
#line 508
        push_knighT(from - 23);
      }
#line 509
      if (board[from - 14] != 0) {
#line 509
        push_knighT(from - 14);
      }
#line 510
      if (board[from - 10] != 0) {
#line 510
        push_knighT(from - 10);
      }
#line 511
      if (board[from + 10] != 0) {
#line 511
        push_knighT(from + 10);
      }
#line 512
      if (board[from + 14] != 0) {
#line 512
        push_knighT(from + 14);
      }
#line 513
      if (board[from + 23] != 0) {
#line 513
        push_knighT(from + 23);
      }
#line 514
      if (board[from + 25] != 0) {
#line 514
        push_knighT(from + 25);
      }
#line 515
      break;
      case 11: 
#line 518
      if (board[from - 13] != 0) {
#line 518
        push_slidE(from - 13);
      }
#line 519
      if (board[from - 11] != 0) {
#line 519
        push_slidE(from - 11);
      }
#line 520
      if (board[from + 11] != 0) {
#line 520
        push_slidE(from + 11);
      }
#line 521
      if (board[from + 13] != 0) {
#line 521
        push_slidE(from + 13);
      }
#line 522
      break;
      case 7: 
#line 525
      if (board[from - 12] != 0) {
#line 525
        push_slidE(from - 12);
      }
#line 526
      if (board[from - 1] != 0) {
#line 526
        push_slidE(from - 1);
      }
#line 527
      if (board[from + 1] != 0) {
#line 527
        push_slidE(from + 1);
      }
#line 528
      if (board[from + 12] != 0) {
#line 528
        push_slidE(from + 12);
      }
#line 529
      break;
      case 9: 
#line 532
      if (board[from - 13] != 0) {
#line 532
        push_slidE(from - 13);
      }
#line 533
      if (board[from - 12] != 0) {
#line 533
        push_slidE(from - 12);
      }
#line 534
      if (board[from - 11] != 0) {
#line 534
        push_slidE(from - 11);
      }
#line 535
      if (board[from - 1] != 0) {
#line 535
        push_slidE(from - 1);
      }
#line 536
      if (board[from + 1] != 0) {
#line 536
        push_slidE(from + 1);
      }
#line 537
      if (board[from + 11] != 0) {
#line 537
        push_slidE(from + 11);
      }
#line 538
      if (board[from + 12] != 0) {
#line 538
        push_slidE(from + 12);
      }
#line 539
      if (board[from + 13] != 0) {
#line 539
        push_slidE(from + 13);
      }
#line 540
      break;
      case 5: 
#line 543
      push_king(from - 13);
#line 544
      push_king(from - 12);
#line 545
      push_king(from - 11);
#line 546
      push_king(from - 1);
#line 547
      push_king(from + 1);
#line 548
      push_king(from + 11);
#line 549
      push_king(from + 12);
#line 550
      push_king(from + 13);
#line 552
      if (from == 30) {
#line 552
        if (! moved[30]) {
#line 552
          if (! captures) {
#line 552
            if (Variant != 3) {
#line 552
              goto _L___0;
            } else
#line 552
            if (Giveaway == 1) {
              _L___0: /* CIL Label */ 
#line 554
              if (! moved[33]) {
#line 554
                if (board[33] == 7) {
#line 555
                  if (board[31] == 13) {
#line 555
                    if (board[32] == 13) {
#line 556
                      push_king_castle(from + 2, 1);
                    }
                  }
                }
              }
#line 558
              if (! moved[26]) {
#line 558
                if (board[26] == 7) {
#line 559
                  if (board[27] == 13) {
#line 559
                    if (board[28] == 13) {
#line 559
                      if (board[29] == 13) {
#line 561
                        push_king_castle(from - 2, 2);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 563
      break;
      default: 
#line 565
      break;
      }
      __Cont: /* CIL Label */ 
#line 460
      j ++;
    }
  } else {
#line 572
    a = 1;
#line 572
    j = 1;
#line 572
    while (1) {
#line 572
      if (a <= piece_count) {
#line 572
        if (Variant != 3) {
#line 572
          if (! (! kingcap)) {
#line 572
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 572
        if (Variant == 3) {
#line 572
          if (! ((unsigned int )fcaptures == (unsigned int )captures)) {
#line 572
            break;
          }
        } else {
#line 572
          break;
        }
      } else {
#line 572
        break;
      }
#line 577
      i = pieces[j];
#line 579
      if (! i) {
#line 580
        goto __Cont___0;
      } else {
#line 582
        a ++;
      }
#line 584
      from = i;
#line 585
      gfrom = i;
#line 587
      switch (board[from]) {
      case 2: 
#line 590
      if (board[from - 12] == 13) {
#line 592
        if (Xrank[from] == 2) {
#line 592
          if (Variant != 3) {
#line 592
            if (Variant != 4) {
#line 593
              push_pawn(from - 12, (xbool )0);
            } else {
#line 592
              goto _L___2;
            }
          } else {
#line 592
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 595
        if (! captures) {
#line 596
          push_pawn(from - 12, (xbool )0);
#line 599
          if (Xrank[from] == 7) {
#line 599
            if (board[from - 24] == 13) {
#line 600
              push_pawn_simple(from - 24);
            }
          }
        }
      }
#line 604
      if ((board[from - 13] & 1) == 1) {
#line 604
        if (board[from - 13] != 13) {
#line 605
          push_pawn(from - 13, (xbool )0);
        }
      }
#line 607
      if ((board[from - 11] & 1) == 1) {
#line 607
        if (board[from - 11] != 13) {
#line 608
          push_pawn(from - 11, (xbool )0);
        }
      }
#line 610
      if (ep_square == from - 13) {
#line 611
        push_pawn(from - 13, (xbool )1);
      } else
#line 613
      if (ep_square == from - 11) {
#line 614
        push_pawn(from - 11, (xbool )1);
      }
#line 615
      break;
      case 4: 
#line 618
      if (board[from - 25] != 0) {
#line 618
        push_knighT(from - 25);
      }
#line 619
      if (board[from - 23] != 0) {
#line 619
        push_knighT(from - 23);
      }
#line 620
      if (board[from - 14] != 0) {
#line 620
        push_knighT(from - 14);
      }
#line 621
      if (board[from - 10] != 0) {
#line 621
        push_knighT(from - 10);
      }
#line 622
      if (board[from + 10] != 0) {
#line 622
        push_knighT(from + 10);
      }
#line 623
      if (board[from + 14] != 0) {
#line 623
        push_knighT(from + 14);
      }
#line 624
      if (board[from + 23] != 0) {
#line 624
        push_knighT(from + 23);
      }
#line 625
      if (board[from + 25] != 0) {
#line 625
        push_knighT(from + 25);
      }
#line 626
      break;
      case 12: 
#line 629
      if (board[from - 13] != 0) {
#line 629
        push_slidE(from - 13);
      }
#line 630
      if (board[from - 11] != 0) {
#line 630
        push_slidE(from - 11);
      }
#line 631
      if (board[from + 11] != 0) {
#line 631
        push_slidE(from + 11);
      }
#line 632
      if (board[from + 13] != 0) {
#line 632
        push_slidE(from + 13);
      }
#line 633
      break;
      case 8: 
#line 636
      if (board[from - 12] != 0) {
#line 636
        push_slidE(from - 12);
      }
#line 637
      if (board[from - 1] != 0) {
#line 637
        push_slidE(from - 1);
      }
#line 638
      if (board[from + 1] != 0) {
#line 638
        push_slidE(from + 1);
      }
#line 639
      if (board[from + 12] != 0) {
#line 639
        push_slidE(from + 12);
      }
#line 640
      break;
      case 10: 
#line 643
      if (board[from - 13] != 0) {
#line 643
        push_slidE(from - 13);
      }
#line 644
      if (board[from - 12] != 0) {
#line 644
        push_slidE(from - 12);
      }
#line 645
      if (board[from - 11] != 0) {
#line 645
        push_slidE(from - 11);
      }
#line 646
      if (board[from - 1] != 0) {
#line 646
        push_slidE(from - 1);
      }
#line 647
      if (board[from + 1] != 0) {
#line 647
        push_slidE(from + 1);
      }
#line 648
      if (board[from + 11] != 0) {
#line 648
        push_slidE(from + 11);
      }
#line 649
      if (board[from + 12] != 0) {
#line 649
        push_slidE(from + 12);
      }
#line 650
      if (board[from + 13] != 0) {
#line 650
        push_slidE(from + 13);
      }
#line 651
      break;
      case 6: 
#line 654
      push_king(from - 13);
#line 655
      push_king(from - 12);
#line 656
      push_king(from - 11);
#line 657
      push_king(from - 1);
#line 658
      push_king(from + 1);
#line 659
      push_king(from + 11);
#line 660
      push_king(from + 12);
#line 661
      push_king(from + 13);
#line 663
      if (from == 114) {
#line 663
        if (! moved[114]) {
#line 663
          if (! captures) {
#line 663
            if (Variant != 3) {
#line 663
              goto _L___3;
            } else
#line 663
            if (Giveaway == 1) {
              _L___3: /* CIL Label */ 
#line 665
              if (! moved[117]) {
#line 665
                if (board[117] == 8) {
#line 666
                  if (board[115] == 13) {
#line 666
                    if (board[116] == 13) {
#line 667
                      push_king_castle(from + 2, 3);
                    }
                  }
                }
              }
#line 669
              if (! moved[110]) {
#line 669
                if (board[110] == 8) {
#line 670
                  if (board[111] == 13) {
#line 670
                    if (board[112] == 13) {
#line 670
                      if (board[113] == 13) {
#line 672
                        push_king_castle(from - 2, 4);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 674
      break;
      default: 
#line 676
      break;
      }
      __Cont___0: /* CIL Label */ 
#line 572
      j ++;
    }
  }
#line 680
  if (Variant == 0) {
#line 680
    goto _L___8;
  } else
#line 680
  if (Variant == 1) {
    _L___8: /* CIL Label */ 
#line 680
    if (! captures) {
#line 680
      if (! kingcap) {
#line 682
        if (white_to_move) {
#line 682
          if (holding[0][1]) {
#line 682
            goto _L___7;
          } else
#line 682
          if (holding[0][3]) {
#line 682
            goto _L___7;
          } else
#line 682
          if (holding[0][11]) {
#line 682
            goto _L___7;
          } else
#line 682
          if (holding[0][9]) {
#line 682
            goto _L___7;
          } else
#line 682
          if (holding[0][7]) {
            _L___7: /* CIL Label */ 
#line 687
            from = 26;
#line 687
            while (from < 118) {
#line 689
              gfrom = from;
#line 691
              switch (board[from]) {
              case 0: 
#line 694
              from += 3;
#line 695
              goto __Cont___1;
              case 13: 
#line 697
              if (holding[0][1]) {
#line 699
                if (Xrank[from] != 8) {
#line 699
                  if (Xrank[from] != 1) {
#line 701
                    try_drop(1);
                  }
                }
              }
#line 704
              if (holding[0][3]) {
#line 706
                try_drop(3);
              }
#line 708
              if (holding[0][11]) {
#line 710
                try_drop(11);
              }
#line 712
              if (holding[0][7]) {
#line 714
                try_drop(7);
              }
#line 716
              if (holding[0][9]) {
#line 718
                try_drop(9);
              }
              }
              __Cont___1: /* CIL Label */ 
#line 687
              from ++;
            }
          } else {
#line 682
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 723
        if (! white_to_move) {
#line 723
          if (holding[1][2]) {
#line 723
            goto _L___5;
          } else
#line 723
          if (holding[1][4]) {
#line 723
            goto _L___5;
          } else
#line 723
          if (holding[1][12]) {
#line 723
            goto _L___5;
          } else
#line 723
          if (holding[1][10]) {
#line 723
            goto _L___5;
          } else
#line 723
          if (holding[1][8]) {
            _L___5: /* CIL Label */ 
#line 728
            from = 26;
#line 728
            while (from < 118) {
#line 730
              gfrom = from;
#line 732
              switch (board[from]) {
              case 0: 
#line 735
              from += 3;
#line 736
              goto __Cont___2;
              case 13: 
#line 738
              if (holding[1][2]) {
#line 740
                if (Xrank[from] != 8) {
#line 740
                  if (Xrank[from] != 1) {
#line 742
                    try_drop(2);
                  }
                }
              }
#line 745
              if (holding[1][4]) {
#line 747
                try_drop(4);
              }
#line 749
              if (holding[1][12]) {
#line 751
                try_drop(12);
              }
#line 753
              if (holding[1][8]) {
#line 755
                try_drop(8);
              }
#line 757
              if (holding[1][10]) {
#line 759
                try_drop(10);
              }
              }
              __Cont___2: /* CIL Label */ 
#line 728
              from ++;
            }
          }
        }
      }
    }
  }
#line 766
  if (Variant == 3) {
#line 766
    if ((unsigned int )fcaptures == 1U) {
#line 766
      if ((unsigned int )captures == 0U) {
#line 768
        captures = (xbool )1;
#line 769
        numb_moves = 0;
#line 770
        goto restart;
      }
    }
  }
#line 773
  if (Variant == 3) {
#line 773
    kingcap = 0;
  }
#line 776
  return;
}
}
#line 779 "moves.c"
xbool in_check(void) 
{ 
  xbool tmp ;
  xbool tmp___0 ;

  {
#line 783
  if (Variant == 3) {
#line 783
    return ((xbool )0);
  }
#line 785
  if (white_to_move == 1) {
#line 786
    tmp = is_attacked(wking_loc, 0);
#line 786
    if (tmp) {
#line 787
      return ((xbool )1);
    }
  } else {
#line 791
    tmp___0 = is_attacked(bking_loc, 1);
#line 791
    if (tmp___0) {
#line 792
      return ((xbool )1);
    }
  }
#line 796
  return ((xbool )0);
}
}
#line 805 "moves.c"
static int const   knight_o___3[8]  = 
#line 805
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 800 "moves.c"
xbool f_in_check(move_s *moves , int m ) 
{ 
  int target ;
  int from ;
  int l ;
  xbool tmp ;
  xbool tmp___0 ;

  {
#line 802
  target = (moves + m)->target;
#line 803
  from = (moves + m)->from;
#line 807
  if (Variant == 3) {
#line 807
    return ((xbool )0);
  }
#line 809
  if (white_to_move == 1) {
#line 818
    switch (board[target]) {
    case 2: 
#line 821
    if (board[target - 11] == 5) {
#line 821
      return ((xbool )1);
    } else
#line 821
    if (board[target - 13] == 5) {
#line 821
      return ((xbool )1);
    }
#line 822
    break;
    case 12: 
#line 824
    if (Xdiagl[target] == Xdiagl[wking_loc]) {
#line 827
      if (wking_loc < target) {
#line 829
        l = wking_loc + 13;
#line 829
        while (board[l] == 13) {
#line 829
          l += 13;
        }
#line 830
        if (l == target) {
#line 830
          return ((xbool )1);
        }
      } else {
#line 834
        l = wking_loc - 13;
#line 834
        while (board[l] == 13) {
#line 834
          l -= 13;
        }
#line 835
        if (l == target) {
#line 835
          return ((xbool )1);
        }
      }
    } else
#line 838
    if (Xdiagr[target] == Xdiagr[wking_loc]) {
#line 840
      if (wking_loc < target) {
#line 842
        l = wking_loc + 11;
#line 842
        while (board[l] == 13) {
#line 842
          l += 11;
        }
#line 843
        if (l == target) {
#line 843
          return ((xbool )1);
        }
      } else {
#line 847
        l = wking_loc - 11;
#line 847
        while (board[l] == 13) {
#line 847
          l -= 11;
        }
#line 848
        if (l == target) {
#line 848
          return ((xbool )1);
        }
      }
    }
#line 851
    break;
    case 8: 
#line 853
    if (Xfile[target] == Xfile[wking_loc]) {
#line 855
      if (wking_loc < target) {
#line 857
        l = wking_loc + 12;
#line 857
        while (board[l] == 13) {
#line 857
          l += 12;
        }
#line 858
        if (l == target) {
#line 858
          return ((xbool )1);
        }
      } else {
#line 862
        l = wking_loc - 12;
#line 862
        while (board[l] == 13) {
#line 862
          l -= 12;
        }
#line 863
        if (l == target) {
#line 863
          return ((xbool )1);
        }
      }
    } else
#line 866
    if (Xrank[target] == Xrank[wking_loc]) {
#line 868
      if (wking_loc < target) {
#line 870
        l = wking_loc + 1;
#line 870
        while (board[l] == 13) {
#line 870
          l ++;
        }
#line 871
        if (l == target) {
#line 871
          return ((xbool )1);
        }
      } else {
#line 875
        l = wking_loc - 1;
#line 875
        while (board[l] == 13) {
#line 875
          l --;
        }
#line 876
        if (l == target) {
#line 876
          return ((xbool )1);
        }
      }
    }
#line 879
    break;
    case 4: 
#line 881
    l = 0;
#line 881
    while (l < 8) {
#line 882
      if (wking_loc + (int )knight_o___3[l] == target) {
#line 882
        return ((xbool )1);
      }
#line 881
      l ++;
    }
#line 883
    break;
    case 10: 
#line 885
    if (Xfile[target] == Xfile[wking_loc]) {
#line 887
      if (wking_loc < target) {
#line 889
        l = wking_loc + 12;
#line 889
        while (board[l] == 13) {
#line 889
          l += 12;
        }
#line 890
        if (l == target) {
#line 890
          return ((xbool )1);
        }
      } else {
#line 894
        l = wking_loc - 12;
#line 894
        while (board[l] == 13) {
#line 894
          l -= 12;
        }
#line 895
        if (l == target) {
#line 895
          return ((xbool )1);
        }
      }
    } else
#line 898
    if (Xrank[target] == Xrank[wking_loc]) {
#line 900
      if (wking_loc < target) {
#line 902
        l = wking_loc + 1;
#line 902
        while (board[l] == 13) {
#line 902
          l ++;
        }
#line 903
        if (l == target) {
#line 903
          return ((xbool )1);
        }
      } else {
#line 907
        l = wking_loc - 1;
#line 907
        while (board[l] == 13) {
#line 907
          l --;
        }
#line 908
        if (l == target) {
#line 908
          return ((xbool )1);
        }
      }
    } else
#line 911
    if (Xdiagl[target] == Xdiagl[wking_loc]) {
#line 913
      if (wking_loc < target) {
#line 915
        l = wking_loc + 13;
#line 915
        while (board[l] == 13) {
#line 915
          l += 13;
        }
#line 916
        if (l == target) {
#line 916
          return ((xbool )1);
        }
      } else {
#line 920
        l = wking_loc - 13;
#line 920
        while (board[l] == 13) {
#line 920
          l -= 13;
        }
#line 921
        if (l == target) {
#line 921
          return ((xbool )1);
        }
      }
    } else
#line 924
    if (Xdiagr[target] == Xdiagr[wking_loc]) {
#line 926
      if (wking_loc < target) {
#line 928
        l = wking_loc + 11;
#line 928
        while (board[l] == 13) {
#line 928
          l += 11;
        }
#line 929
        if (l == target) {
#line 929
          return ((xbool )1);
        }
      } else {
#line 933
        l = wking_loc - 11;
#line 933
        while (board[l] == 13) {
#line 933
          l -= 11;
        }
#line 934
        if (l == target) {
#line 934
          return ((xbool )1);
        }
      }
    }
#line 937
    break;
    case 6: 
#line 941
    if ((moves + m)->castled) {
#line 943
      tmp = is_attacked(wking_loc, 0);
#line 943
      if (tmp) {
#line 944
        return ((xbool )1);
      } else {
#line 946
        return ((xbool )0);
      }
    }
#line 948
    break;
    }
#line 952
    if (from == 0) {
#line 952
      return ((xbool )0);
    }
#line 955
    if (Xrank[from] == Xrank[wking_loc]) {
#line 957
      if (wking_loc > from) {
#line 959
        l = wking_loc - 1;
#line 959
        while (board[l] == 13) {
#line 959
          l --;
        }
#line 960
        if (board[l] == 8) {
#line 960
          return ((xbool )1);
        } else
#line 960
        if (board[l] == 10) {
#line 960
          return ((xbool )1);
        }
      } else {
#line 964
        l = wking_loc + 1;
#line 964
        while (board[l] == 13) {
#line 964
          l ++;
        }
#line 965
        if (board[l] == 8) {
#line 965
          return ((xbool )1);
        } else
#line 965
        if (board[l] == 10) {
#line 965
          return ((xbool )1);
        }
      }
    } else
#line 968
    if (Xfile[from] == Xfile[wking_loc]) {
#line 970
      if (wking_loc > from) {
#line 972
        l = wking_loc - 12;
#line 972
        while (board[l] == 13) {
#line 972
          l -= 12;
        }
#line 973
        if (board[l] == 8) {
#line 973
          return ((xbool )1);
        } else
#line 973
        if (board[l] == 10) {
#line 973
          return ((xbool )1);
        }
      } else {
#line 977
        l = wking_loc + 12;
#line 977
        while (board[l] == 13) {
#line 977
          l += 12;
        }
#line 978
        if (board[l] == 8) {
#line 978
          return ((xbool )1);
        } else
#line 978
        if (board[l] == 10) {
#line 978
          return ((xbool )1);
        }
      }
    } else
#line 981
    if (Xdiagl[from] == Xdiagl[wking_loc]) {
#line 983
      if (wking_loc > from) {
#line 985
        l = wking_loc - 13;
#line 985
        while (board[l] == 13) {
#line 985
          l -= 13;
        }
#line 986
        if (board[l] == 12) {
#line 986
          return ((xbool )1);
        } else
#line 986
        if (board[l] == 10) {
#line 986
          return ((xbool )1);
        }
      } else {
#line 990
        l = wking_loc + 13;
#line 990
        while (board[l] == 13) {
#line 990
          l += 13;
        }
#line 991
        if (board[l] == 12) {
#line 991
          return ((xbool )1);
        } else
#line 991
        if (board[l] == 10) {
#line 991
          return ((xbool )1);
        }
      }
    } else
#line 994
    if (Xdiagr[from] == Xdiagr[wking_loc]) {
#line 996
      if (wking_loc > from) {
#line 998
        l = wking_loc - 11;
#line 998
        while (board[l] == 13) {
#line 998
          l -= 11;
        }
#line 999
        if (board[l] == 12) {
#line 999
          return ((xbool )1);
        } else
#line 999
        if (board[l] == 10) {
#line 999
          return ((xbool )1);
        }
      } else {
#line 1003
        l = wking_loc + 11;
#line 1003
        while (board[l] == 13) {
#line 1003
          l += 11;
        }
#line 1004
        if (board[l] == 12) {
#line 1004
          return ((xbool )1);
        } else
#line 1004
        if (board[l] == 10) {
#line 1004
          return ((xbool )1);
        }
      }
    }
#line 1008
    return ((xbool )0);
  } else {
#line 1016
    switch (board[target]) {
    case 1: 
#line 1019
    if (board[target + 11] == 6) {
#line 1019
      return ((xbool )1);
    } else
#line 1019
    if (board[target + 13] == 6) {
#line 1019
      return ((xbool )1);
    }
#line 1020
    break;
    case 11: 
#line 1022
    if (Xdiagl[target] == Xdiagl[bking_loc]) {
#line 1025
      if (bking_loc < target) {
#line 1027
        l = bking_loc + 13;
#line 1027
        while (board[l] == 13) {
#line 1027
          l += 13;
        }
#line 1028
        if (l == target) {
#line 1028
          return ((xbool )1);
        }
      } else {
#line 1032
        l = bking_loc - 13;
#line 1032
        while (board[l] == 13) {
#line 1032
          l -= 13;
        }
#line 1033
        if (l == target) {
#line 1033
          return ((xbool )1);
        }
      }
    } else
#line 1036
    if (Xdiagr[target] == Xdiagr[bking_loc]) {
#line 1038
      if (bking_loc < target) {
#line 1040
        l = bking_loc + 11;
#line 1040
        while (board[l] == 13) {
#line 1040
          l += 11;
        }
#line 1041
        if (l == target) {
#line 1041
          return ((xbool )1);
        }
      } else {
#line 1045
        l = bking_loc - 11;
#line 1045
        while (board[l] == 13) {
#line 1045
          l -= 11;
        }
#line 1046
        if (l == target) {
#line 1046
          return ((xbool )1);
        }
      }
    }
#line 1049
    break;
    case 7: 
#line 1051
    if (Xfile[target] == Xfile[bking_loc]) {
#line 1053
      if (bking_loc < target) {
#line 1055
        l = bking_loc + 12;
#line 1055
        while (board[l] == 13) {
#line 1055
          l += 12;
        }
#line 1056
        if (l == target) {
#line 1056
          return ((xbool )1);
        }
      } else {
#line 1060
        l = bking_loc - 12;
#line 1060
        while (board[l] == 13) {
#line 1060
          l -= 12;
        }
#line 1061
        if (l == target) {
#line 1061
          return ((xbool )1);
        }
      }
    } else
#line 1064
    if (Xrank[target] == Xrank[bking_loc]) {
#line 1066
      if (bking_loc < target) {
#line 1068
        l = bking_loc + 1;
#line 1068
        while (board[l] == 13) {
#line 1068
          l ++;
        }
#line 1069
        if (l == target) {
#line 1069
          return ((xbool )1);
        }
      } else {
#line 1073
        l = bking_loc - 1;
#line 1073
        while (board[l] == 13) {
#line 1073
          l --;
        }
#line 1074
        if (l == target) {
#line 1074
          return ((xbool )1);
        }
      }
    }
#line 1077
    break;
    case 3: 
#line 1079
    l = 0;
#line 1079
    while (l < 8) {
#line 1080
      if (bking_loc + (int )knight_o___3[l] == target) {
#line 1080
        return ((xbool )1);
      }
#line 1079
      l ++;
    }
#line 1081
    break;
    case 9: 
#line 1083
    if (Xfile[target] == Xfile[bking_loc]) {
#line 1085
      if (bking_loc < target) {
#line 1087
        l = bking_loc + 12;
#line 1087
        while (board[l] == 13) {
#line 1087
          l += 12;
        }
#line 1088
        if (l == target) {
#line 1088
          return ((xbool )1);
        }
      } else {
#line 1092
        l = bking_loc - 12;
#line 1092
        while (board[l] == 13) {
#line 1092
          l -= 12;
        }
#line 1093
        if (l == target) {
#line 1093
          return ((xbool )1);
        }
      }
    } else
#line 1096
    if (Xrank[target] == Xrank[bking_loc]) {
#line 1098
      if (bking_loc < target) {
#line 1100
        l = bking_loc + 1;
#line 1100
        while (board[l] == 13) {
#line 1100
          l ++;
        }
#line 1101
        if (l == target) {
#line 1101
          return ((xbool )1);
        }
      } else {
#line 1105
        l = bking_loc - 1;
#line 1105
        while (board[l] == 13) {
#line 1105
          l --;
        }
#line 1106
        if (l == target) {
#line 1106
          return ((xbool )1);
        }
      }
    } else
#line 1109
    if (Xdiagl[target] == Xdiagl[bking_loc]) {
#line 1111
      if (bking_loc < target) {
#line 1113
        l = bking_loc + 13;
#line 1113
        while (board[l] == 13) {
#line 1113
          l += 13;
        }
#line 1114
        if (l == target) {
#line 1114
          return ((xbool )1);
        }
      } else {
#line 1118
        l = bking_loc - 13;
#line 1118
        while (board[l] == 13) {
#line 1118
          l -= 13;
        }
#line 1119
        if (l == target) {
#line 1119
          return ((xbool )1);
        }
      }
    } else
#line 1122
    if (Xdiagr[target] == Xdiagr[bking_loc]) {
#line 1124
      if (bking_loc < target) {
#line 1126
        l = bking_loc + 11;
#line 1126
        while (board[l] == 13) {
#line 1126
          l += 11;
        }
#line 1127
        if (l == target) {
#line 1127
          return ((xbool )1);
        }
      } else {
#line 1131
        l = bking_loc - 11;
#line 1131
        while (board[l] == 13) {
#line 1131
          l -= 11;
        }
#line 1132
        if (l == target) {
#line 1132
          return ((xbool )1);
        }
      }
    }
#line 1135
    break;
    case 5: 
#line 1138
    if ((moves + m)->castled) {
#line 1140
      tmp___0 = is_attacked(bking_loc, 1);
#line 1140
      if (tmp___0) {
#line 1141
        return ((xbool )1);
      } else {
#line 1143
        return ((xbool )0);
      }
    }
#line 1145
    break;
    }
#line 1148
    if (from == 0) {
#line 1148
      return ((xbool )0);
    }
#line 1151
    if (Xrank[from] == Xrank[bking_loc]) {
#line 1153
      if (bking_loc > from) {
#line 1155
        l = bking_loc - 1;
#line 1155
        while (board[l] == 13) {
#line 1155
          l --;
        }
#line 1156
        if (board[l] == 7) {
#line 1156
          return ((xbool )1);
        } else
#line 1156
        if (board[l] == 9) {
#line 1156
          return ((xbool )1);
        }
      } else {
#line 1160
        l = bking_loc + 1;
#line 1160
        while (board[l] == 13) {
#line 1160
          l ++;
        }
#line 1161
        if (board[l] == 7) {
#line 1161
          return ((xbool )1);
        } else
#line 1161
        if (board[l] == 9) {
#line 1161
          return ((xbool )1);
        }
      }
    } else
#line 1164
    if (Xfile[from] == Xfile[bking_loc]) {
#line 1166
      if (bking_loc > from) {
#line 1168
        l = bking_loc - 12;
#line 1168
        while (board[l] == 13) {
#line 1168
          l -= 12;
        }
#line 1169
        if (board[l] == 7) {
#line 1169
          return ((xbool )1);
        } else
#line 1169
        if (board[l] == 9) {
#line 1169
          return ((xbool )1);
        }
      } else {
#line 1173
        l = bking_loc + 12;
#line 1173
        while (board[l] == 13) {
#line 1173
          l += 12;
        }
#line 1174
        if (board[l] == 7) {
#line 1174
          return ((xbool )1);
        } else
#line 1174
        if (board[l] == 9) {
#line 1174
          return ((xbool )1);
        }
      }
    } else
#line 1177
    if (Xdiagl[from] == Xdiagl[bking_loc]) {
#line 1179
      if (bking_loc > from) {
#line 1181
        l = bking_loc - 13;
#line 1181
        while (board[l] == 13) {
#line 1181
          l -= 13;
        }
#line 1182
        if (board[l] == 11) {
#line 1182
          return ((xbool )1);
        } else
#line 1182
        if (board[l] == 9) {
#line 1182
          return ((xbool )1);
        }
      } else {
#line 1186
        l = bking_loc + 13;
#line 1186
        while (board[l] == 13) {
#line 1186
          l += 13;
        }
#line 1187
        if (board[l] == 11) {
#line 1187
          return ((xbool )1);
        } else
#line 1187
        if (board[l] == 9) {
#line 1187
          return ((xbool )1);
        }
      }
    } else
#line 1190
    if (Xdiagr[from] == Xdiagr[bking_loc]) {
#line 1192
      if (bking_loc > from) {
#line 1194
        l = bking_loc - 11;
#line 1194
        while (board[l] == 13) {
#line 1194
          l -= 11;
        }
#line 1195
        if (board[l] == 11) {
#line 1195
          return ((xbool )1);
        } else
#line 1195
        if (board[l] == 9) {
#line 1195
          return ((xbool )1);
        }
      } else {
#line 1199
        l = bking_loc + 11;
#line 1199
        while (board[l] == 13) {
#line 1199
          l += 11;
        }
#line 1200
        if (board[l] == 11) {
#line 1200
          return ((xbool )1);
        } else
#line 1200
        if (board[l] == 9) {
#line 1200
          return ((xbool )1);
        }
      }
    }
#line 1204
    return ((xbool )0);
  }
}
}
#line 1214 "moves.c"
static int const   knight_o___4[8]  = 
#line 1214
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 1211 "moves.c"
int extended_in_check(void) 
{ 
  register int sq ;
  xbool tmp ;
  xbool tmp___0 ;

  {
#line 1216
  if (Variant == 3) {
#line 1216
    return (0);
  }
#line 1218
  if (white_to_move == 1) {
#line 1220
    sq = board[wking_loc - 12];
#line 1221
    if (sq == 8) {
#line 1221
      return (2);
    } else
#line 1221
    if (sq == 10) {
#line 1221
      return (2);
    }
#line 1222
    sq = board[wking_loc - 1];
#line 1223
    if (sq == 8) {
#line 1223
      return (2);
    } else
#line 1223
    if (sq == 10) {
#line 1223
      return (2);
    }
#line 1224
    sq = board[wking_loc + 1];
#line 1225
    if (sq == 8) {
#line 1225
      return (2);
    } else
#line 1225
    if (sq == 10) {
#line 1225
      return (2);
    }
#line 1226
    sq = board[wking_loc + 12];
#line 1227
    if (sq == 8) {
#line 1227
      return (2);
    } else
#line 1227
    if (sq == 10) {
#line 1227
      return (2);
    }
#line 1228
    sq = board[wking_loc + 13];
#line 1229
    if (sq == 12) {
#line 1229
      return (2);
    } else
#line 1229
    if (sq == 10) {
#line 1229
      return (2);
    } else
#line 1229
    if (sq == 2) {
#line 1229
      return (2);
    }
#line 1230
    sq = board[wking_loc + 11];
#line 1231
    if (sq == 12) {
#line 1231
      return (2);
    } else
#line 1231
    if (sq == 10) {
#line 1231
      return (2);
    } else
#line 1231
    if (sq == 2) {
#line 1231
      return (2);
    }
#line 1232
    sq = board[wking_loc - 11];
#line 1233
    if (sq == 12) {
#line 1233
      return (2);
    } else
#line 1233
    if (sq == 10) {
#line 1233
      return (2);
    }
#line 1234
    sq = board[wking_loc - 13];
#line 1235
    if (sq == 12) {
#line 1235
      return (2);
    } else
#line 1235
    if (sq == 10) {
#line 1235
      return (2);
    }
#line 1236
    sq = 0;
#line 1236
    while (sq < 8) {
#line 1238
      if (board[wking_loc + (int )knight_o___4[sq]] == 4) {
#line 1238
        return (2);
      }
#line 1236
      sq ++;
    }
#line 1240
    tmp = is_attacked(wking_loc, 0);
#line 1240
    if (tmp) {
#line 1242
      if (Variant == 2) {
#line 1242
        return (2);
      } else
#line 1242
      if (Variant == 4) {
#line 1242
        return (2);
      } else {
#line 1243
        return (1);
      }
    }
  } else {
#line 1248
    sq = board[bking_loc - 12];
#line 1249
    if (sq == 7) {
#line 1249
      return (2);
    } else
#line 1249
    if (sq == 9) {
#line 1249
      return (2);
    }
#line 1250
    sq = board[bking_loc - 1];
#line 1251
    if (sq == 7) {
#line 1251
      return (2);
    } else
#line 1251
    if (sq == 9) {
#line 1251
      return (2);
    }
#line 1252
    sq = board[bking_loc + 1];
#line 1253
    if (sq == 7) {
#line 1253
      return (2);
    } else
#line 1253
    if (sq == 9) {
#line 1253
      return (2);
    }
#line 1254
    sq = board[bking_loc + 12];
#line 1255
    if (sq == 7) {
#line 1255
      return (2);
    } else
#line 1255
    if (sq == 9) {
#line 1255
      return (2);
    }
#line 1256
    sq = board[bking_loc - 13];
#line 1257
    if (sq == 11) {
#line 1257
      return (2);
    } else
#line 1257
    if (sq == 9) {
#line 1257
      return (2);
    } else
#line 1257
    if (sq == 1) {
#line 1257
      return (2);
    }
#line 1258
    sq = board[bking_loc - 11];
#line 1259
    if (sq == 11) {
#line 1259
      return (2);
    } else
#line 1259
    if (sq == 9) {
#line 1259
      return (2);
    } else
#line 1259
    if (sq == 1) {
#line 1259
      return (2);
    }
#line 1260
    sq = board[bking_loc + 11];
#line 1261
    if (sq == 11) {
#line 1261
      return (2);
    } else
#line 1261
    if (sq == 9) {
#line 1261
      return (2);
    }
#line 1262
    sq = board[bking_loc + 13];
#line 1263
    if (sq == 11) {
#line 1263
      return (2);
    } else
#line 1263
    if (sq == 9) {
#line 1263
      return (2);
    }
#line 1264
    sq = 0;
#line 1264
    while (sq < 8) {
#line 1266
      if (board[bking_loc + (int )knight_o___4[sq]] == 3) {
#line 1266
        return (2);
      }
#line 1264
      sq ++;
    }
#line 1268
    tmp___0 = is_attacked(bking_loc, 1);
#line 1268
    if (tmp___0) {
#line 1270
      if (Variant == 2) {
#line 1270
        return (2);
      } else
#line 1270
      if (Variant == 4) {
#line 1270
        return (2);
      } else {
#line 1271
        return (1);
      }
    }
  }
#line 1275
  return (0);
}
}
#line 1278 "moves.c"
void make(move_s *moves , int i ) 
{ 
  int ep ;
  int from ;
  int target ;
  int captured ;
  int promoted ;
  int castled ;
  int find_slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1285
  ep = (moves + i)->ep;
#line 1286
  from = (moves + i)->from;
#line 1287
  target = (moves + i)->target;
#line 1288
  captured = (moves + i)->captured;
#line 1289
  promoted = (moves + i)->promoted;
#line 1290
  castled = (moves + i)->castled;
#line 1297
  path_x[ply].epsq = ep_square;
#line 1299
  ep_square = 0;
#line 1302
  path_x[ply].fifty = fifty;
#line 1305
  if (board[from] == 1) {
#line 1307
    fifty = 0;
  } else
#line 1305
  if (board[from] == 2) {
#line 1307
    fifty = 0;
  } else
#line 1305
  if (board[target] != 13) {
#line 1307
    fifty = 0;
  } else {
#line 1311
    fifty ++;
  }
#line 1314
  if (from == 0) {
#line 1322
    piece_count ++;
#line 1325
    find_slot = 1;
#line 1325
    while (pieces[find_slot] != 0) {
#line 1325
      find_slot ++;
    }
#line 1329
    pieces[find_slot] = target;
#line 1331
    path_x[ply].was_promoted = is_promoted[find_slot];
#line 1332
    is_promoted[find_slot] = 0;
#line 1335
    squares[target] = find_slot;
#line 1339
    if (white_to_move) {
#line 1339
      tmp = 0;
    } else {
#line 1339
      tmp = 1;
    }
#line 1339
    DropremoveHolding(promoted, tmp);
#line 1342
    Material += material[promoted];
#line 1345
    board[target] = promoted;
#line 1347
    hash ^= zobrist[promoted][target];
#line 1349
    white_to_move ^= 1;
#line 1350
    ply ++;
#line 1352
    return;
  } else {
#line 1357
    path_x[ply].was_promoted = is_promoted[squares[target]];
#line 1361
    path_x[ply].cap_num = squares[target];
#line 1362
    pieces[squares[target]] = 0;
#line 1363
    pieces[squares[from]] = target;
#line 1364
    squares[target] = squares[from];
#line 1365
    squares[from] = 0;
#line 1368
    if (! ep) {
#line 1370
      switch (board[target]) {
      case 13: 
#line 1371
      break;
      default: 
#line 1374
      if (Variant == 1) {
#line 1374
        goto _L;
      } else
#line 1374
      if (Variant == 0) {
        _L: /* CIL Label */ 
#line 1376
        if (path_x[ply].was_promoted) {
#line 1378
          if (white_to_move) {
#line 1378
            tmp___0 = 0;
          } else {
#line 1378
            tmp___0 = 1;
          }
#line 1378
          tmp___1 = SwitchPromoted(board[target]);
#line 1378
          addHolding(tmp___1, tmp___0);
        } else {
#line 1382
          if (white_to_move) {
#line 1382
            tmp___2 = 0;
          } else {
#line 1382
            tmp___2 = 1;
          }
#line 1382
          tmp___3 = SwitchColor(board[target]);
#line 1382
          addHolding(tmp___3, tmp___2);
        }
      }
#line 1386
      Material -= material[board[target]];
#line 1389
      hash ^= zobrist[board[target]][target];
#line 1391
      piece_count --;
#line 1392
      break;
      }
    }
#line 1397
    if (board[from] == 1) {
#line 1399
      if (promoted) {
#line 1400
        board[target] = promoted;
#line 1401
        board[from] = 13;
#line 1402
        (moved[target]) ++;
#line 1403
        (moved[from]) ++;
#line 1404
        white_to_move ^= 1;
#line 1406
        is_promoted[squares[target]] = 1;
#line 1409
        hash ^= zobrist[1][from];
#line 1411
        hash ^= zobrist[promoted][target];
#line 1413
        Material -= material[1];
#line 1414
        Material += material[promoted];
#line 1416
        ply ++;
#line 1418
        return;
      }
#line 1422
      if (ep) {
#line 1425
        hash ^= zobrist[1][from];
#line 1427
        hash ^= zobrist[2][target - 12];
#line 1429
        hash ^= zobrist[1][target];
#line 1431
        Material -= material[2];
#line 1433
        board[target] = 1;
#line 1434
        board[from] = 13;
#line 1436
        addHolding(1, 0);
#line 1437
        piece_count --;
#line 1439
        board[target - 12] = 13;
#line 1440
        (moved[target]) ++;
#line 1441
        (moved[from]) ++;
#line 1442
        (moved[target - 12]) ++;
#line 1443
        white_to_move ^= 1;
#line 1444
        path_x[ply].cap_num = squares[target - 12];
#line 1446
        pieces[squares[target - 12]] = 0;
#line 1447
        squares[target - 12] = 0;
#line 1449
        ply ++;
#line 1451
        return;
      }
#line 1456
      if (target == from + 24) {
#line 1457
        ep_square = from + 12;
      }
#line 1459
      hash ^= zobrist[1][from];
#line 1460
      hash ^= zobrist[1][target];
#line 1462
      board[target] = 1;
#line 1463
      board[from] = 13;
#line 1464
      (moved[target]) ++;
#line 1465
      (moved[from]) ++;
#line 1466
      white_to_move ^= 1;
#line 1468
      ply ++;
#line 1470
      return;
    }
#line 1475
    if (board[from] == 2) {
#line 1477
      if (promoted) {
#line 1478
        board[target] = promoted;
#line 1479
        board[from] = 13;
#line 1480
        (moved[target]) ++;
#line 1481
        (moved[from]) ++;
#line 1482
        white_to_move ^= 1;
#line 1484
        is_promoted[squares[target]] = 1;
#line 1487
        hash ^= zobrist[2][from];
#line 1489
        hash ^= zobrist[promoted][target];
#line 1491
        Material -= material[2];
#line 1492
        Material += material[promoted];
#line 1494
        ply ++;
#line 1496
        return;
      }
#line 1500
      if (ep) {
#line 1503
        hash ^= zobrist[2][from];
#line 1505
        hash ^= zobrist[1][target + 12];
#line 1507
        hash ^= zobrist[2][target];
#line 1509
        Material -= material[1];
#line 1511
        board[target] = 2;
#line 1512
        board[from] = 13;
#line 1514
        addHolding(2, 1);
#line 1515
        piece_count --;
#line 1517
        board[target + 12] = 13;
#line 1518
        (moved[target]) ++;
#line 1519
        (moved[from]) ++;
#line 1520
        (moved[target + 12]) ++;
#line 1521
        white_to_move ^= 1;
#line 1522
        path_x[ply].cap_num = squares[target + 12];
#line 1523
        pieces[squares[target + 12]] = 0;
#line 1524
        squares[target + 12] = 0;
#line 1526
        ply ++;
#line 1528
        return;
      }
#line 1533
      if (target == from - 24) {
#line 1534
        ep_square = from - 12;
      }
#line 1536
      board[target] = 2;
#line 1537
      board[from] = 13;
#line 1538
      (moved[target]) ++;
#line 1539
      (moved[from]) ++;
#line 1540
      white_to_move ^= 1;
#line 1542
      hash ^= zobrist[2][from];
#line 1543
      hash ^= zobrist[2][target];
#line 1545
      ply ++;
#line 1547
      return;
    }
#line 1551
    if (board[from] != 5) {
#line 1551
      if (board[from] != 6) {
#line 1553
        hash ^= zobrist[board[from]][from];
#line 1554
        hash ^= zobrist[board[from]][target];
#line 1556
        board[target] = board[from];
#line 1557
        board[from] = 13;
#line 1558
        (moved[target]) ++;
#line 1559
        (moved[from]) ++;
#line 1560
        white_to_move ^= 1;
#line 1562
        ply ++;
#line 1564
        return;
      }
    }
#line 1569
    if (board[from] == 5) {
#line 1571
      wking_loc = target;
#line 1574
      board[target] = 5;
#line 1575
      board[from] = 13;
#line 1576
      (moved[target]) ++;
#line 1577
      (moved[from]) ++;
#line 1578
      white_to_move ^= 1;
#line 1580
      hash ^= zobrist[5][from];
#line 1581
      hash ^= zobrist[5][target];
#line 1585
      if (castled == 1) {
#line 1586
        board[33] = 13;
#line 1587
        board[31] = 7;
#line 1588
        (moved[33]) ++;
#line 1589
        (moved[31]) ++;
#line 1590
        white_castled = 1;
#line 1591
        pieces[squares[33]] = 31;
#line 1592
        squares[31] = squares[33];
#line 1593
        squares[33] = 0;
#line 1595
        hash ^= zobrist[7][33];
#line 1596
        hash ^= zobrist[7][31];
#line 1598
        ply ++;
#line 1600
        return;
      } else
#line 1604
      if (castled == 2) {
#line 1605
        board[26] = 13;
#line 1606
        board[29] = 7;
#line 1607
        (moved[26]) ++;
#line 1608
        (moved[29]) ++;
#line 1609
        white_castled = 2;
#line 1610
        pieces[squares[26]] = 29;
#line 1611
        squares[29] = squares[26];
#line 1612
        squares[26] = 0;
#line 1614
        hash ^= zobrist[7][26];
#line 1615
        hash ^= zobrist[7][29];
#line 1617
        ply ++;
#line 1619
        return;
      }
#line 1622
      ply ++;
#line 1624
      return;
    } else {
#line 1630
      bking_loc = target;
#line 1633
      board[target] = 6;
#line 1634
      board[from] = 13;
#line 1635
      (moved[target]) ++;
#line 1636
      (moved[from]) ++;
#line 1637
      white_to_move ^= 1;
#line 1639
      hash ^= zobrist[6][from];
#line 1640
      hash ^= zobrist[6][target];
#line 1644
      if (castled == 3) {
#line 1645
        board[117] = 13;
#line 1646
        board[115] = 8;
#line 1647
        (moved[117]) ++;
#line 1648
        (moved[115]) ++;
#line 1649
        black_castled = 3;
#line 1650
        pieces[squares[117]] = 115;
#line 1651
        squares[115] = squares[117];
#line 1652
        squares[117] = 0;
#line 1654
        hash ^= zobrist[8][117];
#line 1655
        hash ^= zobrist[8][115];
#line 1657
        ply ++;
#line 1659
        return;
      } else
#line 1663
      if (castled == 4) {
#line 1664
        board[110] = 13;
#line 1665
        board[113] = 8;
#line 1666
        (moved[110]) ++;
#line 1667
        (moved[113]) ++;
#line 1668
        black_castled = 4;
#line 1669
        pieces[squares[110]] = 113;
#line 1670
        squares[113] = squares[110];
#line 1671
        squares[110] = 0;
#line 1673
        hash ^= zobrist[8][110];
#line 1674
        hash ^= zobrist[8][113];
#line 1676
        ply ++;
#line 1678
        return;
      }
    }
#line 1681
    ply ++;
#line 1683
    return;
  }
}
}
#line 1687 "moves.c"
void add_move(int Ptarget , int Ppromoted ) 
{ 


  {
#line 1690
  (genfor + numb_moves)->from = gfrom;
#line 1691
  (genfor + numb_moves)->target = Ptarget;
#line 1692
  (genfor + numb_moves)->captured = 13;
#line 1693
  (genfor + numb_moves)->castled = 0;
#line 1694
  (genfor + numb_moves)->promoted = Ppromoted;
#line 1695
  (genfor + numb_moves)->ep = 0;
#line 1696
  numb_moves ++;
#line 1698
  return;
}
}
#line 1701 "moves.c"
void add_capture(int Ptarget , int Pcaptured , int Ppromoted , int Pep ) 
{ 


  {
#line 1706
  if (Variant != 3) {
#line 1706
    if (Pcaptured == 5) {
#line 1708
      kingcap = 1;
#line 1709
      return;
    } else
#line 1706
    if (Pcaptured == 6) {
#line 1708
      kingcap = 1;
#line 1709
      return;
    } else {
#line 1706
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1712
  if (Pcaptured != 13) {
#line 1712
    fcaptures = (xbool )1;
  }
#line 1714
  (genfor + numb_moves)->from = gfrom;
#line 1715
  (genfor + numb_moves)->target = Ptarget;
#line 1716
  (genfor + numb_moves)->captured = Pcaptured;
#line 1717
  (genfor + numb_moves)->castled = 0;
#line 1718
  (genfor + numb_moves)->promoted = Ppromoted;
#line 1719
  (genfor + numb_moves)->ep = Pep;
#line 1720
  numb_moves ++;
#line 1722
  return;
}
}
#line 1725 "moves.c"
void try_drop(int ptype ) 
{ 


  {
#line 1727
  (genfor + numb_moves)->from = 0;
#line 1728
  (genfor + numb_moves)->target = gfrom;
#line 1729
  (genfor + numb_moves)->captured = 13;
#line 1730
  (genfor + numb_moves)->castled = 0;
#line 1731
  (genfor + numb_moves)->promoted = ptype;
#line 1732
  (genfor + numb_moves)->ep = 0;
#line 1733
  numb_moves ++;
#line 1735
  return;
}
}
#line 1738 "moves.c"
void push_king_castle(int Ptarget , int Pcastle_type ) 
{ 


  {
#line 1740
  (genfor + numb_moves)->from = gfrom;
#line 1741
  (genfor + numb_moves)->target = Ptarget;
#line 1742
  (genfor + numb_moves)->captured = 13;
#line 1743
  (genfor + numb_moves)->castled = Pcastle_type;
#line 1744
  (genfor + numb_moves)->promoted = 0;
#line 1745
  (genfor + numb_moves)->ep = 0;
#line 1746
  numb_moves ++;
#line 1748
  return;
}
}
#line 1751 "moves.c"
void push_king(int target ) 
{ 


  {
#line 1756
  if (board[target] == 0) {
#line 1757
    return;
  }
#line 1760
  if (board[target] == 13) {
#line 1760
    if (captures) {
#line 1761
      return;
    }
  }
#line 1764
  if (board[target] == 13) {
#line 1765
    add_move(target, 0);
#line 1766
    return;
  } else
#line 1770
  if ((board[target] & 1) != (board[gfrom] & 1)) {
#line 1771
    add_capture(target, board[target], 0, 0);
#line 1772
    return;
  }
#line 1776
  return;
}
}
#line 1780 "moves.c"
void push_knighT(int target ) 
{ 


  {
#line 1785
  if (board[target] == 13) {
#line 1785
    if (captures) {
#line 1786
      return;
    }
  }
#line 1789
  if (board[target] == 13) {
#line 1790
    add_move(target, 0);
#line 1791
    return;
  } else
#line 1795
  if ((board[target] & 1) != (board[gfrom] & 1)) {
#line 1796
    add_capture(target, board[target], 0, 0);
#line 1797
    return;
  }
#line 1801
  return;
}
}
#line 1805 "moves.c"
void push_pawn(int target , xbool is_ep ) 
{ 
  int captured_piece ;

  {
#line 1812
  if (is_ep) {
#line 1813
    if (board[gfrom] == 1) {
#line 1814
      add_capture(target, 2, 0, 1);
#line 1815
      return;
    } else {
#line 1818
      add_capture(target, 1, 0, 1);
#line 1819
      return;
    }
  }
#line 1825
  captured_piece = board[target];
#line 1828
  if (board[gfrom] == 1) {
#line 1828
    if (Xrank[gfrom] == 7) {
#line 1829
      add_capture(target, captured_piece, 9, 0);
#line 1830
      add_capture(target, captured_piece, 7, 0);
#line 1831
      add_capture(target, captured_piece, 11, 0);
#line 1832
      add_capture(target, captured_piece, 3, 0);
#line 1833
      if (Variant == 3) {
#line 1834
        add_capture(target, captured_piece, 5, 0);
      }
#line 1836
      return;
    } else {
#line 1828
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1840
  if (board[gfrom] == 2) {
#line 1840
    if (Xrank[gfrom] == 2) {
#line 1841
      add_capture(target, captured_piece, 10, 0);
#line 1842
      add_capture(target, captured_piece, 8, 0);
#line 1843
      add_capture(target, captured_piece, 12, 0);
#line 1844
      add_capture(target, captured_piece, 4, 0);
#line 1845
      if (Variant == 3) {
#line 1846
        add_capture(target, captured_piece, 6, 0);
      }
#line 1848
      return;
    } else {
#line 1853
      add_capture(target, captured_piece, 0, 0);
#line 1854
      return;
    }
  } else {
#line 1853
    add_capture(target, captured_piece, 0, 0);
#line 1854
    return;
  }
}
}
#line 1858 "moves.c"
void push_pawn_simple(int target ) 
{ 


  {
#line 1862
  add_move(target, 0);
#line 1863
  return;
}
}
#line 1866 "moves.c"
void push_slidE(int target ) 
{ 
  int offset ;
  int mycolor ;

  {
#line 1875
  offset = target - gfrom;
#line 1876
  mycolor = board[gfrom] & 1;
#line 1879
  while (1) {
#line 1881
    if (board[target] == 13) {
#line 1882
      if (! captures) {
#line 1883
        add_move(target, 0);
      }
#line 1885
      target += offset;
    } else
#line 1889
    if ((board[target] & 1) != mycolor) {
#line 1890
      add_capture(target, board[target], 0, 0);
#line 1891
      break;
    } else {
#line 1896
      break;
    }
#line 1879
    if (! (board[target] != 0)) {
#line 1879
      break;
    }
  }
#line 1900
  return;
}
}
#line 1904 "moves.c"
void unmake(move_s *moves , int i ) 
{ 
  int ep ;
  int from ;
  int target ;
  int captured ;
  int promoted ;
  int castled ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1911
  ep = (moves + i)->ep;
#line 1912
  from = (moves + i)->from;
#line 1913
  target = (moves + i)->target;
#line 1914
  captured = (moves + i)->captured;
#line 1915
  promoted = (moves + i)->promoted;
#line 1916
  castled = (moves + i)->castled;
#line 1922
  ply --;
#line 1924
  ep_square = path_x[ply].epsq;
#line 1927
  fifty = path_x[ply].fifty;
#line 1929
  if (from == 0) {
#line 1938
    pieces[squares[target]] = 0;
#line 1939
    is_promoted[squares[target]] = path_x[ply].was_promoted;
#line 1942
    squares[target] = 0;
#line 1944
    piece_count --;
#line 1948
    if (white_to_move) {
#line 1948
      tmp = 1;
    } else {
#line 1948
      tmp = 0;
    }
#line 1948
    DropaddHolding(promoted, tmp);
#line 1950
    Material -= material[promoted];
#line 1953
    board[target] = captured;
#line 1955
    hash ^= zobrist[promoted][target];
#line 1957
    white_to_move ^= 1;
#line 1959
    return;
  } else {
#line 1967
    squares[from] = squares[target];
#line 1968
    squares[target] = path_x[ply].cap_num;
#line 1969
    pieces[squares[target]] = target;
#line 1970
    pieces[squares[from]] = from;
#line 1972
    is_promoted[squares[target]] = path_x[ply].was_promoted;
#line 1975
    if (! ep) {
#line 1977
      switch (captured) {
      case 13: 
#line 1978
      break;
      default: 
#line 1981
      if (Variant == 1) {
#line 1981
        goto _L;
      } else
#line 1981
      if (Variant == 0) {
        _L: /* CIL Label */ 
#line 1983
        if (is_promoted[squares[target]]) {
#line 1985
          if (white_to_move) {
#line 1985
            tmp___0 = 1;
          } else {
#line 1985
            tmp___0 = 0;
          }
#line 1985
          tmp___1 = SwitchPromoted(captured);
#line 1985
          removeHolding(tmp___1, tmp___0);
        } else {
#line 1989
          if (white_to_move) {
#line 1989
            tmp___2 = 1;
          } else {
#line 1989
            tmp___2 = 0;
          }
#line 1989
          tmp___3 = SwitchColor(captured);
#line 1989
          removeHolding(tmp___3, tmp___2);
        }
      }
#line 1993
      hash ^= zobrist[captured][target];
#line 1995
      Material += material[captured];
#line 1997
      piece_count ++;
#line 1998
      break;
      }
    }
#line 2003
    if (board[target] == 1) {
#line 2005
      if (ep) {
#line 2007
        hash ^= zobrist[1][target];
#line 2008
        hash ^= zobrist[1][from];
#line 2009
        hash ^= zobrist[2][target - 12];
#line 2011
        board[target] = 13;
#line 2012
        board[from] = 1;
#line 2014
        Material += material[2];
#line 2016
        removeHolding(1, 0);
#line 2017
        piece_count ++;
#line 2019
        board[target - 12] = 2;
#line 2020
        (moved[target]) --;
#line 2021
        (moved[from]) --;
#line 2022
        (moved[target - 12]) --;
#line 2023
        white_to_move ^= 1;
#line 2024
        squares[target - 12] = path_x[ply].cap_num;
#line 2025
        pieces[path_x[ply].cap_num] = target - 12;
#line 2026
        squares[target] = 0;
#line 2027
        return;
      }
#line 2031
      hash ^= zobrist[1][from];
#line 2032
      hash ^= zobrist[1][target];
#line 2034
      board[target] = captured;
#line 2035
      board[from] = 1;
#line 2036
      (moved[target]) --;
#line 2037
      (moved[from]) --;
#line 2038
      white_to_move ^= 1;
#line 2039
      return;
    }
#line 2044
    if (board[target] == 2) {
#line 2046
      if (ep) {
#line 2048
        hash ^= zobrist[2][target];
#line 2049
        hash ^= zobrist[2][from];
#line 2050
        hash ^= zobrist[1][target + 12];
#line 2052
        board[target] = 13;
#line 2053
        board[from] = 2;
#line 2055
        Material += material[1];
#line 2057
        removeHolding(2, 1);
#line 2058
        piece_count ++;
#line 2060
        board[target + 12] = 1;
#line 2061
        (moved[target]) --;
#line 2062
        (moved[from]) --;
#line 2063
        (moved[target + 12]) --;
#line 2064
        white_to_move ^= 1;
#line 2065
        squares[target + 12] = path_x[ply].cap_num;
#line 2066
        pieces[path_x[ply].cap_num] = target + 12;
#line 2067
        squares[target] = 0;
#line 2068
        return;
      }
#line 2071
      hash ^= zobrist[2][from];
#line 2072
      hash ^= zobrist[2][target];
#line 2075
      board[target] = captured;
#line 2076
      board[from] = 2;
#line 2077
      (moved[target]) --;
#line 2078
      (moved[from]) --;
#line 2079
      white_to_move ^= 1;
#line 2080
      return;
    }
#line 2085
    if (board[target] != 5) {
#line 2085
      if (board[target] != 6) {
#line 2085
        if (! promoted) {
#line 2086
          board[from] = board[target];
#line 2087
          board[target] = captured;
#line 2088
          (moved[target]) --;
#line 2089
          (moved[from]) --;
#line 2090
          white_to_move ^= 1;
#line 2092
          hash ^= zobrist[board[from]][target];
#line 2093
          hash ^= zobrist[board[from]][from];
#line 2095
          return;
        }
      }
    }
#line 2099
    if (promoted) {
#line 2101
      if (board[target] % 2) {
#line 2102
        board[target] = captured;
#line 2103
        board[from] = 1;
#line 2104
        (moved[target]) --;
#line 2105
        (moved[from]) --;
#line 2106
        white_to_move ^= 1;
#line 2108
        hash ^= zobrist[1][from];
#line 2109
        hash ^= zobrist[promoted][target];
#line 2111
        Material -= material[promoted];
#line 2112
        Material += material[1];
#line 2114
        return;
      }
#line 2118
      board[target] = captured;
#line 2119
      board[from] = 2;
#line 2120
      (moved[target]) --;
#line 2121
      (moved[from]) --;
#line 2122
      white_to_move ^= 1;
#line 2124
      hash ^= zobrist[2][from];
#line 2125
      hash ^= zobrist[promoted][target];
#line 2127
      Material -= material[promoted];
#line 2128
      Material += material[2];
#line 2130
      return;
    }
#line 2135
    if (board[target] == 5) {
#line 2137
      wking_loc = from;
#line 2140
      board[target] = captured;
#line 2141
      board[from] = 5;
#line 2142
      (moved[target]) --;
#line 2143
      (moved[from]) --;
#line 2144
      white_to_move ^= 1;
#line 2146
      hash ^= zobrist[5][from];
#line 2147
      hash ^= zobrist[5][target];
#line 2151
      if (castled == 1) {
#line 2152
        board[33] = 7;
#line 2153
        board[31] = 13;
#line 2154
        (moved[33]) --;
#line 2155
        (moved[31]) --;
#line 2156
        white_castled = 0;
#line 2157
        squares[33] = squares[31];
#line 2158
        squares[31] = 0;
#line 2159
        pieces[squares[33]] = 33;
#line 2161
        hash ^= zobrist[7][33];
#line 2162
        hash ^= zobrist[7][31];
#line 2164
        return;
      } else
#line 2168
      if (castled == 2) {
#line 2169
        board[26] = 7;
#line 2170
        board[29] = 13;
#line 2171
        (moved[26]) --;
#line 2172
        (moved[29]) --;
#line 2173
        white_castled = 0;
#line 2174
        squares[26] = squares[29];
#line 2175
        squares[29] = 0;
#line 2176
        pieces[squares[26]] = 26;
#line 2178
        hash ^= zobrist[7][29];
#line 2179
        hash ^= zobrist[7][26];
#line 2181
        return;
      }
#line 2184
      return;
    } else {
#line 2190
      bking_loc = from;
#line 2193
      board[target] = captured;
#line 2194
      board[from] = 6;
#line 2195
      (moved[target]) --;
#line 2196
      (moved[from]) --;
#line 2197
      white_to_move ^= 1;
#line 2199
      hash ^= zobrist[6][from];
#line 2200
      hash ^= zobrist[6][target];
#line 2204
      if (castled == 3) {
#line 2205
        board[117] = 8;
#line 2206
        board[115] = 13;
#line 2207
        (moved[117]) --;
#line 2208
        (moved[115]) --;
#line 2209
        black_castled = 0;
#line 2210
        squares[117] = squares[115];
#line 2211
        squares[115] = 0;
#line 2212
        pieces[squares[117]] = 117;
#line 2214
        hash ^= zobrist[8][117];
#line 2215
        hash ^= zobrist[8][115];
#line 2217
        return;
      } else
#line 2221
      if (castled == 4) {
#line 2222
        board[110] = 8;
#line 2223
        board[113] = 13;
#line 2224
        (moved[110]) --;
#line 2225
        (moved[113]) --;
#line 2226
        black_castled = 0;
#line 2227
        squares[110] = squares[113];
#line 2228
        squares[113] = 0;
#line 2229
        pieces[squares[110]] = 110;
#line 2231
        hash ^= zobrist[8][110];
#line 2232
        hash ^= zobrist[8][113];
#line 2234
        return;
      }
    }
  }
#line 2238
  return;
}
}
#line 1 "neval.o"
#pragma merger("0","/tmp/cil-Z6v534YW.i","")
#line 30 "./extvars.h"
int maxposdiff  ;
#line 95 "./extvars.h"
int distance[144][144]  ;
#line 96 "./extvars.h"
int rookdistance[144][144]  ;
#line 120
int phase ;
#line 34 "./protos.h"
void check_phase(void) ;
#line 15 "neval.c"
int King(int sq , int c ) ;
#line 16
int Queen(int sq , int c ) ;
#line 17
int Rook(int sq , int c ) ;
#line 18
int Bishop(int sq , int c ) ;
#line 19
int Knight(int sq , int c ) ;
#line 20
int Pawn(int sq , int c ) ;
#line 21
int ErrorIt(int sq , int c ) ;
#line 24 "neval.c"
static EVALFUNC evalRoutines[7]  = {      & ErrorIt,      & Pawn,      & Knight,      & King, 
        & Rook,      & Queen,      & Bishop};
#line 40 "neval.c"
int king_locs[2]  ;
#line 41 "neval.c"
int wmat  ;
#line 41 "neval.c"
int bmat  ;
#line 45 "neval.c"
static int sbishop[144]  = 
#line 45
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -2,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -2,      0,      0, 
        0,      0,      -2,      8, 
        5,      5,      5,      5, 
        8,      -2,      0,      0, 
        0,      0,      -2,      3, 
        3,      5,      5,      3, 
        3,      -2,      0,      0, 
        0,      0,      -2,      2, 
        5,      4,      4,      5, 
        2,      -2,      0,      0, 
        0,      0,      -2,      2, 
        5,      4,      4,      5, 
        2,      -2,      0,      0, 
        0,      0,      -2,      3, 
        3,      5,      5,      3, 
        3,      -2,      0,      0, 
        0,      0,      -2,      8, 
        5,      5,      5,      5, 
        8,      -2,      0,      0, 
        0,      0,      -2,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -2,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 59 "neval.c"
static int sknight[144]  = 
#line 59
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      -10,      0, 
        0,      3,      3,      0, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      5,      5,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      10,      10,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      10,      10,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      5,      5,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        0,      3,      3,      0, 
        0,      -10,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 73 "neval.c"
static int swhite_pawn[144]  = 
#line 73
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      1,      2, 
        3,      10,      10,      3, 
        2,      1,      0,      0, 
        0,      0,      2,      4, 
        6,      12,      12,      6, 
        4,      2,      0,      0, 
        0,      0,      3,      6, 
        9,      14,      14,      9, 
        6,      3,      0,      0, 
        0,      0,      10,      12, 
        14,      16,      16,      14, 
        12,      10,      0,      0, 
        0,      0,      20,      22, 
        24,      26,      26,      24, 
        22,      20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 87 "neval.c"
static int sblack_pawn[144]  = 
#line 87
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      20,      22, 
        24,      26,      26,      24, 
        22,      20,      0,      0, 
        0,      0,      10,      12, 
        14,      16,      16,      14, 
        12,      10,      0,      0, 
        0,      0,      3,      6, 
        9,      14,      14,      9, 
        6,      3,      0,      0, 
        0,      0,      2,      4, 
        6,      12,      12,      6, 
        4,      2,      0,      0, 
        0,      0,      1,      2, 
        3,      10,      10,      3, 
        2,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 102 "neval.c"
static int swhite_king[144]  = 
#line 102
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      2,      14, 
        0,      0,      0,      9, 
        14,      2,      0,      0, 
        0,      0,      -3,      -5, 
        -6,      -6,      -6,      -6, 
        -5,      -3,      0,      0, 
        0,      0,      -5,      -5, 
        -8,      -8,      -8,      -8, 
        -5,      -5,      0,      0, 
        0,      0,      -8,      -8, 
        -13,      -13,      -13,      -13, 
        -8,      -8,      0,      0, 
        0,      0,      -13,      -13, 
        -21,      -21,      -21,      -21, 
        -13,      -13,      0,      0, 
        0,      0,      -21,      -21, 
        -34,      -34,      -34,      -34, 
        -21,      -21,      0,      0, 
        0,      0,      -34,      -34, 
        -55,      -55,      -55,      -55, 
        -34,      -34,      0,      0, 
        0,      0,      -55,      -55, 
        -89,      -89,      -89,      -89, 
        -55,      -55,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 117 "neval.c"
static int sblack_king[144]  = 
#line 117
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -55,      -55, 
        -89,      -89,      -89,      -89, 
        -55,      -55,      0,      0, 
        0,      0,      -34,      -34, 
        -55,      -55,      -55,      -55, 
        -34,      -34,      0,      0, 
        0,      0,      -21,      -21, 
        -34,      -34,      -34,      -34, 
        -21,      -21,      0,      0, 
        0,      0,      -13,      -13, 
        -21,      -21,      -21,      -21, 
        -13,      -13,      0,      0, 
        0,      0,      -8,      -8, 
        -13,      -13,      -13,      -13, 
        -8,      -8,      0,      0, 
        0,      0,      -5,      -5, 
        -8,      -8,      -8,      -8, 
        -5,      -5,      0,      0, 
        0,      0,      -3,      -5, 
        -6,      -6,      -6,      -6, 
        -5,      -3,      0,      0, 
        0,      0,      2,      14, 
        0,      0,      0,      9, 
        14,      2,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 132 "neval.c"
static int send_king[144]  = 
#line 132
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -5,      -3, 
        -1,      0,      0,      -1, 
        -3,      -5,      0,      0, 
        0,      0,      -3,      10, 
        10,      10,      10,      10, 
        10,      -3,      0,      0, 
        0,      0,      -1,      10, 
        25,      25,      25,      25, 
        10,      -1,      0,      0, 
        0,      0,      0,      10, 
        25,      50,      50,      25, 
        10,      0,      0,      0, 
        0,      0,      0,      10, 
        25,      50,      50,      25, 
        10,      0,      0,      0, 
        0,      0,      -1,      10, 
        25,      25,      25,      25, 
        10,      -1,      0,      0, 
        0,      0,      -3,      10, 
        10,      10,      10,      10, 
        10,      -3,      0,      0, 
        0,      0,      -5,      -3, 
        -1,      0,      0,      -1, 
        -3,      -5,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 147 "neval.c"
static int const   srev_rank[9]  = 
#line 147
  {      (int const   )0,      (int const   )8,      (int const   )7,      (int const   )6, 
        (int const   )5,      (int const   )4,      (int const   )3,      (int const   )2, 
        (int const   )1};
#line 150 "neval.c"
int const   std_p_tropism[8]  = 
#line 150
  {      (int const   )9999,      (int const   )15,      (int const   )10,      (int const   )7, 
        (int const   )2,      (int const   )0,      (int const   )0,      (int const   )0};
#line 153 "neval.c"
int const   std_own_p_tropism[8]  = 
#line 153
  {      (int const   )9999,      (int const   )30,      (int const   )10,      (int const   )2, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 156 "neval.c"
int const   std_r_tropism[16]  = 
#line 156
  {      (int const   )9999,      (int const   )0,      (int const   )15,      (int const   )5, 
        (int const   )2,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 159 "neval.c"
int const   std_n_tropism[8]  = 
#line 159
  {      (int const   )9999,      (int const   )14,      (int const   )9,      (int const   )6, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0};
#line 162 "neval.c"
int const   std_q_tropism[8]  = 
#line 162
  {      (int const   )9999,      (int const   )200,      (int const   )50,      (int const   )15, 
        (int const   )3,      (int const   )2,      (int const   )1,      (int const   )0};
#line 165 "neval.c"
int const   std_b_tropism[8]  = 
#line 165
  {      (int const   )9999,      (int const   )12,      (int const   )7,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 168 "neval.c"
void check_phase(void) 
{ 
  int xnum_pieces ;
  int j ;
  int a ;
  int i ;

  {
#line 170
  xnum_pieces = 0;
#line 173
  j = 1;
#line 173
  a = 1;
#line 173
  while (a <= piece_count) {
#line 175
    i = pieces[j];
#line 177
    if (! i) {
#line 178
      goto __Cont;
    } else {
#line 180
      a ++;
    }
#line 182
    if (board[i] != 1) {
#line 182
      if (board[i] != 2) {
#line 182
        if (board[i] != 13) {
#line 182
          if (board[i] != 0) {
#line 185
            xnum_pieces ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 173
    j ++;
  }
#line 188
  if (xnum_pieces >= 12) {
#line 188
    if (! white_castled) {
#line 188
      goto _L___1;
    } else
#line 188
    if (! black_castled) {
      _L___1: /* CIL Label */ 
#line 188
      if (board[30] == 5) {
#line 194
        phase = 0;
      } else
#line 188
      if (board[114] == 6) {
#line 194
        phase = 0;
      } else {
#line 188
        goto _L___0;
      }
    } else {
#line 188
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 196
  if (xnum_pieces <= 6) {
#line 198
    phase = 2;
  } else {
#line 201
    phase = 1;
  }
#line 203
  return;
}
}
#line 210
static int bishop_mobility(int square ) ;
#line 210 "neval.c"
static int const   dir[4]  = {      (int const   )-13,      (int const   )-11,      (int const   )11,      (int const   )13};
#line 205 "neval.c"
static int bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;
  register int diridx ;

  {
#line 208
  m = 0;
#line 212
  diridx = 0;
#line 212
  while (diridx < 4) {
#line 214
    l = square + (int )dir[diridx];
#line 214
    while (board[l] == 13) {
#line 215
      m ++;
#line 214
      l += (int )dir[diridx];
    }
#line 212
    diridx ++;
  }
#line 217
  return (m);
}
}
#line 225
static int rook_mobility(int square ) ;
#line 225 "neval.c"
static int const   dir___0[4]  = {      (int const   )-1,      (int const   )1,      (int const   )12,      (int const   )-12};
#line 220 "neval.c"
static int rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;
  register int diridx ;

  {
#line 223
  m = 0;
#line 227
  diridx = 0;
#line 227
  while (diridx < 4) {
#line 229
    l = square + (int )dir___0[diridx];
#line 229
    while (board[l] == 13) {
#line 230
      m ++;
#line 229
      l += (int )dir___0[diridx];
    }
#line 227
    diridx ++;
  }
#line 232
  return (m);
}
}
#line 235 "neval.c"
int King(int sq , int c ) 
{ 
  int s ;

  {
#line 236
  s = 0;
#line 238
  if (Xfile[sq] >= 6) {
#line 238
    if ((board[sq - 1] + 1) >> 1 == 4) {
#line 238
      if (((board[sq - 1] + 1) & 1) == c) {
#line 241
        s += 2;
      }
    }
  }
#line 244
  if (Xfile[sq] >= 6) {
#line 244
    if ((board[sq + 1] + 1) >> 1 == 4) {
#line 244
      if (((board[sq + 1] + 1) & 1) == c) {
#line 247
        s += 2;
      }
    }
  }
#line 250
  if (c == 1) {
#line 251
    s = - s;
  }
#line 252
  return (s);
}
}
#line 255 "neval.c"
int Queen(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;
  int tmp___0 ;

  {
#line 256
  s = 0;
#line 258
  xside = c ^ 1;
#line 260
  s += 900;
#line 262
  s += (int )std_q_tropism[distance[sq][king_locs[xside]]];
#line 264
  tmp = rook_mobility(sq);
#line 264
  mob = tmp << 1;
#line 265
  tmp___0 = bishop_mobility(sq);
#line 265
  mob += tmp___0 << 1;
#line 267
  if (mob <= 4) {
#line 268
    if (mob == 0) {
#line 269
      mob -= 15;
    } else
#line 270
    if (mob == 2) {
#line 271
      mob -= 10;
    } else {
#line 273
      mob -= 5;
    }
  }
#line 276
  s += mob;
#line 278
  if (c == 1) {
#line 279
    s = - s;
  }
#line 280
  return (s);
}
}
#line 284 "neval.c"
static int const   square_d1[2]  = {      (int const   )29,      (int const   )113};
#line 283 "neval.c"
int Rook(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;

  {
#line 285
  s = 0;
#line 287
  xside = c ^ 1;
#line 289
  s += 500;
#line 291
  s += (int )std_r_tropism[rookdistance[sq][king_locs[xside]]];
#line 293
  tmp = rook_mobility(sq);
#line 293
  mob = tmp << 1;
#line 294
  if (mob <= 2) {
#line 294
    mob -= 5;
  }
#line 295
  s += mob;
#line 298
  if (board[sq - 1] != 13) {
#line 298
    if (board[sq + 1] != 13) {
#line 299
      s -= 5;
    }
  }
#line 303
  if (wmat != 1300) {
#line 303
    goto _L;
  } else
#line 303
  if (bmat != 1300) {
    _L: /* CIL Label */ 
#line 304
    if (sq == (int )square_d1[c]) {
#line 305
      s += 10;
#line 306
      if ((board[square_d1[c] + 1] + 1) >> 1 == 4) {
#line 306
        if (((board[square_d1[c] + 1] + 1) & 1) == c) {
#line 309
          s += 5;
        }
      }
    }
#line 312
    if (sq == (int )(square_d1[c] + 1)) {
#line 313
      s += 10;
    }
  }
#line 317
  if (c == 1) {
#line 318
    s = - s;
  }
#line 319
  return (s);
}
}
#line 322 "neval.c"
int Bishop(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;

  {
#line 323
  s = 0;
#line 325
  xside = c ^ 1;
#line 327
  s += 325;
#line 328
  s += sbishop[sq];
#line 330
  s += (int )std_b_tropism[distance[sq][king_locs[xside]]];
#line 332
  tmp = bishop_mobility(sq);
#line 332
  mob = tmp << 1;
#line 333
  if (mob <= 2) {
#line 333
    mob -= 5;
  }
#line 334
  s += mob;
#line 336
  if (c == 0) {
#line 336
    if (sq == 39) {
#line 336
      if (board[52] == 1) {
#line 339
        s -= 5;
      } else {
#line 336
        goto _L___0;
      }
    } else {
#line 336
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 336
  if (c == 1) {
#line 336
    if (sq == 99) {
#line 336
      if (board[88] == 2) {
#line 339
        s -= 5;
      }
    }
  }
#line 341
  if (c == 1) {
#line 342
    s = - s;
  }
#line 343
  return (s);
}
}
#line 346 "neval.c"
int Knight(int sq , int c ) 
{ 
  int s ;
  int xside ;

  {
#line 347
  s = 0;
#line 348
  xside = c ^ 1;
#line 350
  s += 310;
#line 351
  s += sknight[sq];
#line 353
  s += (int )std_n_tropism[distance[sq][king_locs[xside]]];
#line 355
  if (c == 1) {
#line 356
    s = - s;
  }
#line 357
  return (s);
}
}
#line 360 "neval.c"
int Pawn(int sq , int c ) 
{ 
  int s ;
  int xside ;

  {
#line 361
  s = 0;
#line 362
  xside = c ^ 1;
#line 364
  s += 100;
#line 366
  s += (int )std_p_tropism[distance[sq][king_locs[xside]]];
#line 367
  s += (int )std_own_p_tropism[distance[sq][king_locs[c]]];
#line 370
  if ((board[sq + 1] + 1) >> 1 == 1) {
#line 370
    if (((board[sq + 1] + 1) & 1) == c) {
#line 372
      s += 5;
    }
  }
#line 375
  if ((board[sq + 11] + 1) >> 1 == 1) {
#line 375
    if (((board[sq + 11] + 1) & 1) == c) {
#line 377
      s ++;
    } else {
#line 375
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 378
  if ((board[sq + 13] + 1) >> 1 == 1) {
#line 378
    if (((board[sq + 13] + 1) & 1) == c) {
#line 380
      s ++;
    }
  }
#line 382
  if (c == 1) {
#line 383
    s = - s;
  }
#line 384
  return (s);
}
}
#line 387 "neval.c"
int ErrorIt(int sq , int c ) 
{ 


  {
#line 388
  printf((char const   * __restrict  )"Illegal piece detected sq=%i c=%i\n", sq, c);
#line 389
  return (0);
}
}
#line 392 "neval.c"
int std_eval(int alpha , int beta ) 
{ 
  int i ;
  int a ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int srank ;
  int wking_pawn_file ;
  int bking_pawn_file ;
  int j ;
  int score ;
  xbool isolated ;
  xbool backwards ;
  int in_cache ;
  int wp ;
  int bp ;
  int wn ;
  int bn ;
  int wb ;
  int bb ;
  int wq ;
  int bq ;
  int wr ;
  int br ;
  int rbrook ;
  int fbrook ;
  int rwrook ;
  int fwrook ;
  int wpotential ;
  int bpotential ;
  int tmp ;
  int wksafety ;
  int bksafety ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;

  {
#line 396
  score = 0;
#line 404
  if (white_to_move) {
#line 404
    tmp___1 = Material;
  } else {
#line 404
    tmp___1 = - Material;
  }
#line 404
  if (tmp___1 - maxposdiff >= beta) {
#line 405
    if (white_to_move) {
#line 405
      tmp___0 = Material;
    } else {
#line 405
      tmp___0 = - Material;
    }
#line 405
    return (tmp___0 - maxposdiff);
  }
#line 406
  if (white_to_move) {
#line 406
    tmp___3 = Material;
  } else {
#line 406
    tmp___3 = - Material;
  }
#line 406
  if (tmp___3 + maxposdiff <= alpha) {
#line 407
    if (white_to_move) {
#line 407
      tmp___2 = Material;
    } else {
#line 407
      tmp___2 = - Material;
    }
#line 407
    return (tmp___2 + maxposdiff);
  }
#line 409
  in_cache = 0;
#line 411
  checkECache(& score, & in_cache);
#line 413
  if (in_cache) {
#line 415
    if (white_to_move == 1) {
#line 415
      return (score);
    }
#line 416
    return (- score);
  }
#line 419
  memset((void *)(pawns), 0, sizeof(pawns));
#line 420
  i = 0;
#line 420
  while (i < 11) {
#line 421
    white_back_pawn[i] = 7;
#line 422
    black_back_pawn[i] = 2;
#line 420
    i ++;
  }
#line 425
  wmat = 0;
#line 426
  bmat = 0;
#line 428
  king_locs[0] = wking_loc;
#line 429
  king_locs[1] = bking_loc;
#line 432
  j = 1;
#line 432
  a = 1;
#line 432
  while (a <= piece_count) {
#line 433
    i = pieces[j];
#line 435
    if (! i) {
#line 436
      goto __Cont;
    } else {
#line 438
      a ++;
    }
#line 442
    if ((board[i] + 1) >> 1 != 1) {
#line 442
      if ((board[i] + 1) >> 1 != 3) {
#line 444
        if (((board[i] + 1) & 1) == 0) {
#line 445
          wmat += material[board[i]];
        } else {
#line 447
          tmp___4 = abs(material[board[i]]);
#line 447
          bmat += tmp___4;
        }
      }
    }
#line 450
    if ((board[i] + 1) >> 1 == 1) {
#line 452
      pawn_file = (int )(Xfile[i] + 1);
#line 453
      srank = (int )Xrank[i];
#line 455
      if (((board[i] + 1) & 1) == 0) {
#line 457
        (pawns[1][pawn_file]) ++;
#line 458
        if (srank < white_back_pawn[pawn_file]) {
#line 459
          white_back_pawn[pawn_file] = srank;
        }
      } else {
#line 464
        (pawns[0][pawn_file]) ++;
#line 465
        if (srank > black_back_pawn[pawn_file]) {
#line 466
          black_back_pawn[pawn_file] = srank;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 432
    j ++;
  }
#line 473
  wpotential = 0;
#line 474
  bpotential = 0;
#line 475
  wksafety = 0;
#line 476
  bksafety = 0;
#line 477
  rbrook = 0;
#line 478
  fbrook = 0;
#line 479
  rwrook = 0;
#line 480
  fwrook = 0;
#line 481
  wp = 0;
#line 482
  bp = 0;
#line 483
  wb = 0;
#line 484
  bb = 0;
#line 485
  wn = 0;
#line 486
  bn = 0;
#line 487
  wr = 0;
#line 488
  br = 0;
#line 489
  wq = 0;
#line 490
  bq = 0;
#line 493
  j = 1;
#line 493
  a = 1;
#line 493
  while (a <= piece_count) {
#line 494
    i = pieces[j];
#line 495
    if (! i) {
#line 496
      goto __Cont___0;
    } else {
#line 498
      a ++;
    }
#line 500
    tmp___5 = (*(evalRoutines[(board[i] + 1) >> 1]))(i, (board[i] + 1) & 1);
#line 500
    score += tmp___5;
#line 502
    pawn_file = (int )(Xfile[i] + 1);
#line 503
    srank = (int )Xrank[i];
#line 504
    switch (board[i]) {
    case 1: 
#line 506
    isolated = (xbool )0;
#line 507
    backwards = (xbool )0;
#line 508
    score += swhite_pawn[i];
#line 509
    wp ++;
#line 512
    if (white_back_pawn[pawn_file + 1] > srank) {
#line 512
      if (white_back_pawn[pawn_file - 1] > srank) {
#line 514
        score -= 8;
#line 515
        backwards = (xbool )1;
#line 517
        if (! pawns[1][pawn_file + 1]) {
#line 517
          if (! pawns[1][pawn_file - 1]) {
#line 518
            score -= 5;
#line 519
            isolated = (xbool )1;
          }
        }
      }
    }
#line 524
    if (! pawns[0][pawn_file]) {
#line 525
      if (backwards) {
#line 525
        score -= 3;
      }
#line 526
      if (isolated) {
#line 526
        score -= 5;
      }
    }
#line 530
    if (pawns[1][pawn_file] > 1) {
#line 531
      score -= 3 * (pawns[1][pawn_file] - 1);
    }
#line 534
    if (! pawns[0][pawn_file]) {
#line 534
      if (srank >= black_back_pawn[pawn_file - 1]) {
#line 534
        if (srank >= black_back_pawn[pawn_file + 1]) {
#line 536
          score += 30 + 3 * swhite_pawn[i];
#line 538
          if (white_to_move) {
#line 542
            tmp = (110 + (int )Xfile[i]) - 1;
#line 544
            tmp___11 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
#line 544
            tmp___12 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
#line 544
            if (tmp___11 > tmp___12) {
#line 544
              tmp___8 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
#line 544
              tmp___10 = tmp___8;
            } else {
#line 544
              tmp___9 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
#line 544
              tmp___10 = tmp___9;
            }
#line 544
            tmp___13 = abs((int )(Xrank[tmp] - Xrank[i]));
#line 544
            if (tmp___10 > tmp___13) {
#line 547
              wpotential += 800;
            }
          } else {
#line 554
            tmp = (110 + (int )Xfile[i]) - 1;
#line 556
            tmp___19 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
#line 556
            tmp___20 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
#line 556
            if (tmp___19 > tmp___20) {
#line 556
              tmp___16 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
#line 556
              tmp___18 = tmp___16;
            } else {
#line 556
              tmp___17 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
#line 556
              tmp___18 = tmp___17;
            }
#line 556
            tmp___21 = abs((int )(Xrank[tmp] - Xrank[i]));
#line 556
            if (tmp___18 - 1 > tmp___21) {
#line 559
              wpotential += 800;
            }
          }
#line 564
          if (Xfile[i] == 1) {
#line 565
            score += 12 + 2 * swhite_pawn[i];
          } else
#line 564
          if (Xfile[i] == 8) {
#line 565
            score += 12 + 2 * swhite_pawn[i];
          }
#line 568
          if (! isolated) {
#line 570
            score += 12;
#line 573
            if (pawns[1][pawn_file + 1]) {
#line 575
              if (! pawns[0][pawn_file + 1]) {
#line 575
                if (white_back_pawn[pawn_file + 1] >= black_back_pawn[pawn_file + 2]) {
#line 578
                  score += 7 * (int )Xrank[i];
#line 581
                  if (Xrank[i] == 7) {
#line 581
                    if (white_back_pawn[pawn_file + 1] >= 6) {
#line 583
                      score += 50;
                    }
                  }
                }
              }
            }
#line 587
            if (pawns[1][pawn_file - 1]) {
#line 589
              if (! pawns[0][pawn_file - 1]) {
#line 589
                if (white_back_pawn[pawn_file + 1] >= black_back_pawn[pawn_file - 2]) {
#line 592
                  score += 7 * (int )Xrank[i];
#line 595
                  if (Xrank[i] == 7) {
#line 595
                    if (white_back_pawn[pawn_file - 1] >= 6) {
#line 597
                      score += 50;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 604
    if (! pawns[1][pawn_file - 1]) {
#line 605
      score -= 7;
    }
#line 607
    break;
    case 2: 
#line 610
    isolated = (xbool )0;
#line 611
    backwards = (xbool )0;
#line 612
    score -= sblack_pawn[i];
#line 613
    bp ++;
#line 617
    if (black_back_pawn[pawn_file + 1] < srank) {
#line 617
      if (black_back_pawn[pawn_file - 1] < srank) {
#line 619
        score += 8;
#line 620
        backwards = (xbool )1;
#line 622
        if (! pawns[0][pawn_file + 1]) {
#line 622
          if (! pawns[0][pawn_file - 1]) {
#line 623
            score += 5;
#line 624
            isolated = (xbool )1;
          }
        }
      }
    }
#line 629
    if (! pawns[1][pawn_file]) {
#line 630
      if (backwards) {
#line 630
        score += 3;
      }
#line 631
      if (isolated) {
#line 631
        score += 5;
      }
    }
#line 635
    if (pawns[0][pawn_file] > 1) {
#line 636
      score += 3 * (pawns[0][pawn_file] - 1);
    }
#line 639
    if (! pawns[1][pawn_file]) {
#line 639
      if (srank <= white_back_pawn[pawn_file - 1]) {
#line 639
        if (srank <= white_back_pawn[pawn_file + 1]) {
#line 641
          score -= 30 + 3 * sblack_pawn[i];
#line 643
          if (! white_to_move) {
#line 647
            tmp = (26 + (int )Xfile[i]) - 1;
#line 649
            tmp___27 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
#line 649
            tmp___28 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
#line 649
            if (tmp___27 > tmp___28) {
#line 649
              tmp___24 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
#line 649
              tmp___26 = tmp___24;
            } else {
#line 649
              tmp___25 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
#line 649
              tmp___26 = tmp___25;
            }
#line 649
            tmp___29 = abs((int )(Xrank[tmp] - Xrank[i]));
#line 649
            if (tmp___26 > tmp___29) {
#line 652
              bpotential -= 800;
            }
          } else {
#line 659
            tmp = (26 + (int )Xfile[i]) - 1;
#line 661
            tmp___35 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
#line 661
            tmp___36 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
#line 661
            if (tmp___35 > tmp___36) {
#line 661
              tmp___32 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
#line 661
              tmp___34 = tmp___32;
            } else {
#line 661
              tmp___33 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
#line 661
              tmp___34 = tmp___33;
            }
#line 661
            tmp___37 = abs((int )(Xrank[tmp] - Xrank[i]));
#line 661
            if (tmp___34 - 1 > tmp___37) {
#line 664
              bpotential -= 800;
            }
          }
#line 669
          if (Xfile[i] == 1) {
#line 670
            score -= 12 + 2 * sblack_pawn[i];
          } else
#line 669
          if (Xfile[i] == 8) {
#line 670
            score -= 12 + 2 * sblack_pawn[i];
          }
#line 673
          if (! isolated) {
#line 675
            score -= 12;
#line 678
            if (pawns[0][pawn_file + 1]) {
#line 680
              if (! pawns[1][pawn_file + 1]) {
#line 680
                if (black_back_pawn[pawn_file + 1] <= white_back_pawn[pawn_file + 2]) {
#line 683
                  score -= 7 * (9 - (int )Xrank[i]);
#line 686
                  if (Xrank[i] == 2) {
#line 686
                    if (black_back_pawn[pawn_file + 1] <= 3) {
#line 688
                      score -= 50;
                    }
                  }
                }
              }
            }
#line 692
            if (pawns[0][pawn_file - 1]) {
#line 694
              if (! pawns[1][pawn_file - 1]) {
#line 694
                if (black_back_pawn[pawn_file - 1] <= white_back_pawn[pawn_file - 2]) {
#line 697
                  score -= 7 * (9 - (int )Xrank[i]);
#line 700
                  if (Xrank[i] == 2) {
#line 700
                    if (black_back_pawn[pawn_file - 1] <= 3) {
#line 702
                      score -= 50;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 710
    if (! pawns[0][pawn_file - 1]) {
#line 711
      score += 7;
    }
#line 713
    break;
    case 7: 
#line 716
    wr ++;
#line 718
    if (wr == 1) {
#line 720
      fwrook = (int )Xfile[i];
#line 721
      rwrook = (int )Xrank[i];
    }
#line 726
    if (srank == 7) {
#line 728
      score += 25;
#line 729
      if (wr == 2) {
#line 729
        if (rwrook == 7) {
#line 731
          score += 10;
        }
      }
    }
#line 737
    if (! pawns[1][pawn_file]) {
#line 739
      score += 5;
#line 741
      if (wr == 2) {
#line 741
        if (Xfile[i] == (int const   )fwrook) {
#line 743
          score += 12;
        }
      }
#line 746
      if (! pawns[0][pawn_file]) {
#line 748
        score += 3;
      }
    }
#line 752
    break;
    case 8: 
#line 755
    br ++;
#line 756
    if (br == 1) {
#line 758
      fbrook = (int )Xfile[i];
#line 759
      rbrook = (int )Xrank[i];
    }
#line 763
    if (srank == 2) {
#line 765
      score -= 25;
#line 766
      if (wr == 2) {
#line 766
        if (rbrook == 2) {
#line 768
          score -= 10;
        }
      }
    }
#line 773
    if (! pawns[0][pawn_file]) {
#line 775
      score -= 5;
#line 777
      if (br == 2) {
#line 777
        if (Xfile[i] == (int const   )fbrook) {
#line 779
          score -= 12;
        }
      }
#line 782
      if (! pawns[1][pawn_file]) {
#line 784
        score -= 3;
      }
    }
#line 788
    break;
    case 11: 
#line 791
    wb ++;
#line 792
    break;
    case 12: 
#line 795
    bb ++;
#line 796
    break;
    case 3: 
#line 799
    wn ++;
#line 800
    break;
    case 4: 
#line 803
    bn ++;
#line 804
    break;
    case 9: 
#line 807
    wq ++;
#line 808
    break;
    case 10: 
#line 811
    bq ++;
#line 812
    break;
    case 5: 
#line 815
    if (wmat > 1300) {
#line 817
      score += swhite_king[i];
#line 821
      if (white_castled == 2) {
#line 822
        score += 15;
      } else
#line 823
      if (white_castled == 1) {
#line 824
        score += 25;
      } else
#line 825
      if (moved[30]) {
#line 826
        score -= 10;
#line 830
        if (! pawns[1][pawn_file]) {
#line 831
          score -= 15;
        }
      }
#line 837
      if (Xfile[wking_loc] != 4) {
#line 837
        if (Xfile[wking_loc] != 5) {
#line 839
          if (srank < white_back_pawn[pawn_file]) {
#line 839
            if (pawns[1][pawn_file]) {
#line 840
              score -= 9 * ((white_back_pawn[pawn_file] - srank) - 1);
            } else {
#line 842
              score -= 22;
            }
          } else {
#line 842
            score -= 22;
          }
#line 843
          if (srank < white_back_pawn[pawn_file + 1]) {
#line 843
            if (pawns[1][pawn_file + 1]) {
#line 844
              score -= 8 * ((white_back_pawn[pawn_file + 1] - srank) - 1);
            } else {
#line 846
              score -= 16;
            }
          } else {
#line 846
            score -= 16;
          }
#line 847
          if (srank < white_back_pawn[pawn_file - 1]) {
#line 847
            if (pawns[1][pawn_file - 1]) {
#line 848
              score -= 8 * ((white_back_pawn[pawn_file - 1] - srank) - 1);
            } else {
#line 850
              score -= 16;
            }
          } else {
#line 850
            score -= 16;
          }
        } else {
#line 855
          score -= 10;
        }
      } else {
#line 855
        score -= 10;
      }
    } else {
#line 860
      score += send_king[i];
    }
#line 862
    break;
    case 6: 
#line 865
    if (bmat > 1300) {
#line 867
      score -= sblack_king[i];
#line 871
      if (black_castled == 4) {
#line 872
        score -= 15;
      } else
#line 873
      if (black_castled == 3) {
#line 874
        score -= 25;
      } else
#line 875
      if (moved[114]) {
#line 876
        score += 10;
#line 880
        if (! pawns[0][pawn_file]) {
#line 881
          score += 15;
        }
      }
#line 887
      if (Xfile[bking_loc] != 4) {
#line 887
        if (Xfile[bking_loc] != 5) {
#line 889
          if (srank > black_back_pawn[pawn_file]) {
#line 889
            if (pawns[0][pawn_file]) {
#line 890
              score += 9 * (int )srev_rank[(srank - black_back_pawn[pawn_file]) - 1];
            } else {
#line 892
              score += 22;
            }
          } else {
#line 892
            score += 22;
          }
#line 893
          if (srank > black_back_pawn[pawn_file + 1]) {
#line 893
            if (pawns[0][pawn_file + 1]) {
#line 894
              score += 8 * (int )srev_rank[(srank - black_back_pawn[pawn_file + 1]) - 1];
            } else {
#line 896
              score += 16;
            }
          } else {
#line 896
            score += 16;
          }
#line 897
          if (srank > black_back_pawn[pawn_file - 1]) {
#line 897
            if (pawns[0][pawn_file - 1]) {
#line 898
              score += 8 * (int )srev_rank[(srank - black_back_pawn[pawn_file - 1]) - 1];
            } else {
#line 900
              score += 16;
            }
          } else {
#line 900
            score += 16;
          }
        } else {
#line 904
          score += 10;
        }
      } else {
#line 904
        score += 10;
      }
    } else {
#line 909
      score -= send_king[i];
    }
#line 911
    break;
    }
    __Cont___0: /* CIL Label */ 
#line 493
    j ++;
  }
#line 916
  if (wmat > 2200) {
#line 916
    goto _L;
  } else
#line 916
  if (bmat > 2200) {
    _L: /* CIL Label */ 
#line 919
    if (! moved[41]) {
#line 919
      if (board[53] != 13) {
#line 920
        score -= 5;
      }
    }
#line 921
    if (! moved[42]) {
#line 921
      if (board[54] != 13) {
#line 922
        score -= 5;
      }
    }
#line 923
    if (! moved[101]) {
#line 923
      if (board[89] != 13) {
#line 924
        score += 5;
      }
    }
#line 925
    if (! moved[102]) {
#line 925
      if (board[90] != 13) {
#line 926
        score += 5;
      }
    }
  }
#line 929
  if (wmat > 1300) {
#line 929
    goto _L___0;
  } else
#line 929
  if (bmat > 1300) {
    _L___0: /* CIL Label */ 
#line 932
    wking_pawn_file = (int )(Xfile[wking_loc] + 1);
#line 933
    bking_pawn_file = (int )(Xfile[bking_loc] + 1);
#line 937
    tmp___38 = abs(wking_pawn_file - bking_pawn_file);
#line 937
    if (tmp___38 > 2) {
#line 939
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file]] - 2);
#line 940
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file + 1]] - 2);
#line 941
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file - 1]] - 2);
#line 944
      bksafety += 3 * (white_back_pawn[bking_pawn_file] - 2);
#line 945
      bksafety += 3 * (white_back_pawn[bking_pawn_file + 1] - 2);
#line 946
      bksafety += 3 * (white_back_pawn[bking_pawn_file - 1] - 2);
#line 949
      if (! pawns[0][wking_pawn_file]) {
#line 950
        wksafety += 8;
      }
#line 951
      if (! pawns[0][wking_pawn_file + 1]) {
#line 952
        wksafety += 6;
      }
#line 953
      if (! pawns[0][wking_pawn_file - 1]) {
#line 954
        wksafety += 6;
      }
#line 957
      if (! pawns[1][bking_pawn_file]) {
#line 958
        bksafety += 8;
      }
#line 959
      if (! pawns[1][bking_pawn_file + 1]) {
#line 960
        bksafety += 6;
      }
#line 961
      if (! pawns[1][bking_pawn_file - 1]) {
#line 962
        bksafety += 6;
      }
    }
  }
#line 966
  if (bmat > 1300) {
#line 966
    if (bq) {
#line 968
      score -= wksafety;
    }
  }
#line 970
  if (wmat > 1300) {
#line 970
    if (wq) {
#line 972
      score += bksafety;
    }
  }
#line 978
  if (! wr) {
#line 978
    if (! wq) {
#line 978
      if (! wb) {
#line 978
        if (! wn) {
#line 980
          score += bpotential;
        }
      }
    }
  }
#line 983
  if (! br) {
#line 983
    if (! bq) {
#line 983
      if (! bb) {
#line 983
        if (! bn) {
#line 985
          score += wpotential;
        }
      }
    }
  }
#line 989
  if (! wp) {
#line 989
    if (! bp) {
#line 992
      if (! wr) {
#line 992
        if (! br) {
#line 992
          if (! wq) {
#line 992
            if (! bq) {
#line 994
              if (! bb) {
#line 994
                if (! wb) {
#line 998
                  if (wn < 3) {
#line 998
                    if (bn < 3) {
#line 1000
                      score = 0;
                    }
                  }
                } else {
#line 994
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
#line 1003
              if (! wn) {
#line 1003
                if (! bn) {
#line 1008
                  tmp___39 = abs(wb - bb);
#line 1008
                  if (tmp___39 < 2) {
#line 1010
                    score = 0;
                  }
                } else {
#line 1003
                  goto _L___4;
                }
              } else
              _L___4: /* CIL Label */ 
#line 1013
              if (wn < 3) {
#line 1013
                if (! wb) {
#line 1013
                  goto _L___2;
                } else {
#line 1013
                  goto _L___3;
                }
              } else
              _L___3: /* CIL Label */ 
#line 1013
              if (wb == 1) {
#line 1013
                if (! wn) {
                  _L___2: /* CIL Label */ 
#line 1016
                  if (bn < 3) {
#line 1016
                    if (! bb) {
#line 1019
                      score = 0;
                    } else {
#line 1016
                      goto _L___1;
                    }
                  } else
                  _L___1: /* CIL Label */ 
#line 1016
                  if (bb == 1) {
#line 1016
                    if (! bn) {
#line 1019
                      score = 0;
                    }
                  }
                }
              }
            } else {
#line 992
              goto _L___10;
            }
          } else {
#line 992
            goto _L___10;
          }
        } else {
#line 992
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 1023
      if (! wq) {
#line 1023
        if (! bq) {
#line 1025
          if (wr == 1) {
#line 1025
            if (br == 1) {
#line 1028
              if (wn + wb < 2) {
#line 1028
                if (bn + bb < 2) {
#line 1032
                  score = 0;
                }
              }
            } else {
#line 1025
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 1035
          if (wr == 1) {
#line 1035
            if (! br) {
#line 1040
              if (wn + wb == 0) {
#line 1040
                if (bn + bb == 1) {
#line 1042
                  score = 0;
                } else
#line 1040
                if (bn + bb == 2) {
#line 1042
                  score = 0;
                }
              }
            } else {
#line 1035
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
#line 1045
          if (br == 1) {
#line 1045
            if (! wr) {
#line 1050
              if (bn + bb == 0) {
#line 1050
                if (wn + wb == 1) {
#line 1052
                  score = 0;
                } else
#line 1050
                if (wn + wb == 2) {
#line 1052
                  score = 0;
                }
              }
            }
          }
        }
      }
    } else {
#line 989
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
#line 1060
  if (wn + wb != bn + bb) {
#line 1063
    if (wq + wr == bq + br) {
#line 1065
      if (wn + wb > bn + bb) {
#line 1068
        score += 120;
      } else {
#line 1073
        score -= 120;
      }
    } else {
#line 1076
      tmp___41 = abs((wr + wq) - (br + bq));
#line 1076
      if (tmp___41 == 1) {
#line 1080
        if (wb + wn > (bb + bn) + 1) {
#line 1083
          score += 120;
        } else
#line 1085
        if (bb + bn > (wb + wn) + 1) {
#line 1087
          score -= 120;
        }
      } else {
#line 1090
        tmp___40 = abs((wr + wq) - (br + bq));
#line 1090
        if (tmp___40 == 2) {
#line 1094
          if (wb + wn > (bb + bn) + 2) {
#line 1097
            score += 120;
          } else
#line 1099
          if (bb + bn > (wb + wn) + 2) {
#line 1101
            score -= 120;
          }
        }
      }
    }
  } else
#line 1106
  if (wq + wr == bq + br) {
#line 1108
    if (wq) {
#line 1108
      if (! bq) {
#line 1110
        score += 120;
      } else {
#line 1108
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 1112
    if (! wq) {
#line 1112
      if (bq) {
#line 1114
        score -= 120;
      }
    }
  }
#line 1119
  storeECache(score);
#line 1121
  tmp___45 = abs(Material - score);
#line 1121
  if (tmp___45 > maxposdiff) {
#line 1122
    tmp___44 = abs(Material - score);
#line 1122
    if (1000 < tmp___44) {
#line 1122
      maxposdiff = 1000;
    } else {
#line 1122
      tmp___43 = abs(Material - score);
#line 1122
      maxposdiff = tmp___43;
    }
  }
#line 1125
  if (white_to_move == 1) {
#line 1126
    return (score);
  } else {
#line 1129
    return (- score);
  }
}
}
#line 1 "partner.o"
#pragma merger("0","/tmp/cil-CFlj0n8o.i","")
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 109 "./protos.h"
void HandlePartner(char *input ) ;
#line 110
void HandlePtell(char *input ) ;
#line 111
void BegForPartner(void) ;
#line 112
void CheckBadFlow(xbool reset ) ;
#line 117
void ResetHandValue(void) ;
#line 105 "./extvars.h"
char my_partner[256] ;
#line 106
xbool have_partner ;
#line 107
xbool must_sit ;
#line 108 "./extvars.h"
int must_go  ;
#line 109
xbool go_fast ;
#line 110 "./extvars.h"
xbool piecedead  ;
#line 111 "./extvars.h"
xbool partnerdead  ;
#line 14 "partner.c"
int hand_value[13]  = 
#line 14 "partner.c"
  {      0,      100,      -100,      210, 
        -210,      0,      0,      250, 
        -250,      450,      -450,      230, 
        -230};
#line 15 "partner.c"
int std_hand_value[13]  = 
#line 15
  {      0,      100,      -100,      210, 
        -210,      0,      0,      250, 
        -250,      450,      -450,      230, 
        -230};
#line 22 "partner.c"
void ResetHandValue(void) 
{ 


  {
#line 24
  memcpy((void * __restrict  )(hand_value), (void const   * __restrict  )(std_hand_value),
         sizeof(hand_value));
#line 25
  return;
}
}
#line 27 "partner.c"
void BegForPartner(void) 
{ 


  {
#line 33
  return;
}
}
#line 36 "partner.c"
void GreetPartner(void) 
{ 


  {
#line 38
  printf((char const   * __restrict  )"tellics ptell Hello! I am Sjeng and hope you enjoy playing with me.\n");
#line 39
  printf((char const   * __restrict  )"tellics ptell For help on some commands that I understand, ptell me \'help\'\n");
#line 41
  return;
}
}
#line 44 "partner.c"
void HandlePartner(char *input ) 
{ 


  {
#line 46
  if ((int )*(input + 0) == 32) {
#line 48
    if (! have_partner) {
#line 51
      sscanf((char const   * __restrict  )(input + 1), (char const   * __restrict  )"%s",
             my_partner);
#line 52
      have_partner = (xbool )1;
#line 53
      GreetPartner();
#line 54
      printf((char const   * __restrict  )"tellics set f5 bughouse\n");
#line 55
      printf((char const   * __restrict  )"tellics unseek\n");
    }
  } else {
#line 60
    memset((void *)(my_partner), 0, sizeof(my_partner));
#line 61
    have_partner = (xbool )0;
#line 62
    BegForPartner();
#line 63
    printf((char const   * __restrict  )"tellics set f5 1=1\n");
  }
#line 65
  return;
}
}
#line 67 "partner.c"
void HandlePtell(char *input ) 
{ 
  int change ;
  char howmuch[80] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;

  {
#line 69
  change = 0;
#line 70
  howmuch[0] = (char )'i';
#line 70
  howmuch[1] = (char )'s';
#line 70
  howmuch[2] = (char )'.';
#line 70
  howmuch[3] = (char )'.';
#line 70
  howmuch[4] = (char )'.';
#line 70
  howmuch[5] = (char )'u';
#line 70
  howmuch[6] = (char )'h';
#line 70
  howmuch[7] = (char )'.';
#line 70
  howmuch[8] = (char )'.';
#line 70
  howmuch[9] = (char )'.';
#line 70
  howmuch[10] = (char )'w';
#line 70
  howmuch[11] = (char )'h';
#line 70
  howmuch[12] = (char )'a';
#line 70
  howmuch[13] = (char )'t';
#line 70
  howmuch[14] = (char )' ';
#line 70
  howmuch[15] = (char )'d';
#line 70
  howmuch[16] = (char )'i';
#line 70
  howmuch[17] = (char )'d';
#line 70
  howmuch[18] = (char )' ';
#line 70
  howmuch[19] = (char )'y';
#line 70
  howmuch[20] = (char )'o';
#line 70
  howmuch[21] = (char )'u';
#line 70
  howmuch[22] = (char )' ';
#line 70
  howmuch[23] = (char )'s';
#line 70
  howmuch[24] = (char )'a';
#line 70
  howmuch[25] = (char )'y';
#line 70
  howmuch[26] = (char )'?';
#line 70
  howmuch[27] = (char )'\n';
#line 70
  howmuch[28] = (char )'\000';
#line 70
  tmp = 29U;
#line 70
  while (! (tmp >= 80U)) {
#line 70
    howmuch[tmp] = (char)0;
#line 70
    tmp ++;
  }
#line 72
  tmp___0 = strncmp((char const   *)(input + 6), "help", (size_t )4);
#line 72
  if (! tmp___0) {
#line 74
    printf((char const   * __restrict  )"tellics ptell Commands that I understand are : sit, go, fast, slow, abort, flag, +/++/+++/-/--/---{p,n,b,r,q,d,h,trades}, x, dead, formula, help.\n");
#line 75
    return;
  }
#line 78
  if (Variant != 1) {
#line 78
    tmp___1 = strncmp((char const   *)(input + 6), "sorry", (size_t )5);
#line 78
    if (tmp___1) {
#line 80
      printf((char const   * __restrict  )"tellics ptell Sorry, but I\'m not playing a bughouse game.\n");
#line 81
      return;
    }
  }
#line 84
  tmp___61 = strncmp((char const   *)(input + 6), "sit", (size_t )3);
#line 84
  if (tmp___61) {
#line 90
    tmp___59 = strncmp((char const   *)(input + 6), "go", (size_t )2);
#line 90
    if (tmp___59) {
#line 90
      tmp___60 = strncmp((char const   *)(input + 6), "move", (size_t )4);
#line 90
      if (tmp___60) {
#line 96
        tmp___57 = strncmp((char const   *)(input + 6), "fast", (size_t )4);
#line 96
        if (tmp___57) {
#line 96
          tmp___58 = strncmp((char const   *)(input + 6), "time", (size_t )4);
#line 96
          if (tmp___58) {
#line 102
            tmp___56 = strncmp((char const   *)(input + 6), "slow", (size_t )4);
#line 102
            if (tmp___56) {
#line 108
              tmp___55 = strncmp((char const   *)(input + 6), "abort", (size_t )5);
#line 108
              if (tmp___55) {
#line 113
                tmp___54 = strncmp((char const   *)(input + 6), "flag", (size_t )4);
#line 113
                if (tmp___54) {
#line 118
                  tmp___53 = strncmp((char const   *)(input + 6), "+", (size_t )1);
#line 118
                  if (tmp___53) {
#line 273
                    tmp___52 = strncmp((char const   *)(input + 6), "-", (size_t )1);
#line 273
                    if (tmp___52) {
#line 425
                      tmp___46 = strncmp((char const   *)(input + 6), "x", (size_t )1);
#line 425
                      if (tmp___46) {
#line 425
                        tmp___47 = strstr((char const   *)(input + 6), "mate me anymore");
#line 425
                        if ((unsigned long )tmp___47 != (unsigned long )((void *)0)) {
#line 425
                          goto _L___14;
                        } else {
#line 425
                          tmp___48 = strstr((char const   *)(input + 6), "never");
#line 425
                          if ((unsigned long )tmp___48 != (unsigned long )((void *)0)) {
#line 425
                            tmp___49 = strstr((char const   *)(input + 6), "mind");
#line 425
                            if ((unsigned long )tmp___49 != (unsigned long )((void *)0)) {
#line 425
                              goto _L___14;
                            } else {
#line 425
                              goto _L___15;
                            }
                          } else {
                            _L___15: /* CIL Label */ 
#line 425
                            tmp___50 = strncmp((char const   *)(input + 6), "=", (size_t )1);
#line 425
                            if (tmp___50) {
                              _L___13: /* CIL Label */ 
#line 436
                              tmp___44 = strncmp((char const   *)(input + 6), "i\'ll have to sit...(dead)",
                                                 (size_t )25);
#line 436
                              if (tmp___44) {
#line 436
                                tmp___45 = strncmp((char const   *)(input + 6), "dead",
                                                   (size_t )4);
#line 436
                                if (tmp___45) {
#line 446
                                  tmp___43 = strncmp((char const   *)(input + 6),
                                                     "i\'ll have to sit...(piece)",
                                                     (size_t )26);
#line 446
                                  if (tmp___43) {
#line 453
                                    tmp___42 = strncmp((char const   *)(input + 6),
                                                       "sorry", (size_t )5);
#line 453
                                    if (tmp___42) {
#line 457
                                      tmp___41 = strncmp((char const   *)(input + 6),
                                                         "ok", (size_t )2);
#line 457
                                      if (tmp___41) {
#line 461
                                        tmp___39 = strncmp((char const   *)(input + 6),
                                                           "hi", (size_t )2);
#line 461
                                        if (tmp___39) {
#line 461
                                          tmp___40 = strncmp((char const   *)(input + 6),
                                                             "hello", (size_t )5);
#line 461
                                          if (tmp___40) {
#line 465
                                            tmp___38 = strstr((char const   *)(input + 6),
                                                              "formula");
#line 465
                                            if ((unsigned long )tmp___38 != (unsigned long )((void *)0)) {
#line 467
                                              printf((char const   * __restrict  )"tellics ptell Setting formula, if you are still interrupted, complain to my operator.\n");
#line 468
                                              printf((char const   * __restrict  )"tellics set f5 bughouse\n");
                                            } else {
#line 472
                                              printf((char const   * __restrict  )"tellics ptell Sorry, but I don\'t understand that command.\n");
                                            }
                                          } else {
#line 463
                                            printf((char const   * __restrict  )"tellics ptell Greetings.\n");
                                          }
                                        } else {
#line 463
                                          printf((char const   * __restrict  )"tellics ptell Greetings.\n");
                                        }
                                      } else {
#line 459
                                        return;
                                      }
                                    } else {
#line 455
                                      return;
                                    }
                                  } else {
#line 449
                                    go_fast = (xbool )1;
#line 450
                                    must_sit = (xbool )0;
#line 451
                                    piecedead = (xbool )1;
                                  }
                                } else {
#line 440
                                  go_fast = (xbool )1;
#line 441
                                  must_sit = (xbool )0;
#line 442
                                  partnerdead = (xbool )1;
                                }
                              } else {
#line 440
                                go_fast = (xbool )1;
#line 441
                                must_sit = (xbool )0;
#line 442
                                partnerdead = (xbool )1;
                              }
                            } else {
                              _L___14: /* CIL Label */ 
#line 425
                              tmp___51 = strstr((char const   *)(input + 6), "ptell me");
#line 425
                              if ((unsigned long )tmp___51 == (unsigned long )((void *)0)) {
#line 430
                                printf((char const   * __restrict  )"tellics ptell Ok, reverting to STANDARD piece values!\n");
#line 431
                                ResetHandValue();
#line 432
                                must_sit = (xbool )0;
#line 433
                                partnerdead = (xbool )0;
#line 434
                                piecedead = (xbool )0;
                              } else {
#line 425
                                goto _L___13;
                              }
                            }
                          }
                        }
                      } else {
#line 425
                        goto _L___14;
                      }
                    } else {
#line 276
                      tmp___23 = strstr((char const   *)(input + 6), "trade");
#line 276
                      if ((unsigned long )tmp___23 != (unsigned long )((void *)0)) {
#line 276
                        goto _L___6;
                      } else {
#line 276
                        tmp___24 = strstr((char const   *)(input + 6), "n");
#line 276
                        if ((unsigned long )tmp___24 == (unsigned long )((void *)0)) {
#line 276
                          tmp___25 = strstr((char const   *)(input + 6), "b");
#line 276
                          if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
#line 276
                            tmp___26 = strstr((char const   *)(input + 6), "p");
#line 276
                            if ((unsigned long )tmp___26 == (unsigned long )((void *)0)) {
#line 276
                              tmp___27 = strstr((char const   *)(input + 6), "r");
#line 276
                              if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
#line 276
                                tmp___28 = strstr((char const   *)(input + 6), "q");
#line 276
                                if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
#line 276
                                  tmp___29 = strstr((char const   *)(input + 6), "d");
#line 276
                                  if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
#line 276
                                    tmp___30 = strstr((char const   *)(input + 6),
                                                      "h");
#line 276
                                    if ((unsigned long )tmp___30 == (unsigned long )((void *)0)) {
                                      _L___6: /* CIL Label */ 
#line 286
                                      if (comp_color == 1) {
#line 288
                                        hand_value[2] -= 20;
#line 289
                                        hand_value[4] -= 50;
#line 290
                                        hand_value[12] -= 50;
#line 291
                                        hand_value[8] -= 50;
#line 292
                                        hand_value[10] -= 100;
                                      } else {
#line 296
                                        hand_value[1] += 20;
#line 297
                                        hand_value[3] += 50;
#line 298
                                        hand_value[11] += 50;
#line 299
                                        hand_value[7] += 50;
#line 300
                                        hand_value[9] += 100;
                                      }
#line 302
                                      printf((char const   * __restrict  )"tellics ptell Ok, trading is BAD\n");
                                    } else {
#line 276
                                      goto _L___12;
                                    }
                                  } else {
#line 276
                                    goto _L___12;
                                  }
                                } else {
#line 276
                                  goto _L___12;
                                }
                              } else {
#line 276
                                goto _L___12;
                              }
                            } else {
#line 276
                              goto _L___12;
                            }
                          } else {
#line 276
                            goto _L___12;
                          }
                        } else {
                          _L___12: /* CIL Label */ 
#line 305
                          tmp___22 = strstr((char const   *)(input + 6), "---");
#line 305
                          if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
#line 307
                            change = 50000;
#line 308
                            strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"mates you (ptell me \'x\' when it no longer mates you)");
                          } else {
#line 310
                            tmp___21 = strstr((char const   *)(input + 6), "--");
#line 310
                            if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
#line 312
                              change = 1000;
#line 313
                              strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"is VERY bad (ptell me \'x\' when it is no longer bad)");
                            } else {
#line 315
                              tmp___20 = strstr((char const   *)(input + 6), "-");
#line 315
                              if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 317
                                change = 150;
#line 318
                                strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"is bad (ptell me \'x\' when it is no longer bad)");
                              } else {
#line 321
                                *((int *)((void *)0)) = 0;
                              }
                            }
                          }
                        }
                      }
#line 323
                      tmp___31 = strstr((char const   *)(input + 6), "n");
#line 323
                      if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
#line 325
                        if (comp_color == 1) {
#line 326
                          hand_value[4] = std_hand_value[4] - change;
                        } else {
#line 328
                          hand_value[3] = std_hand_value[3] + change;
                        }
#line 330
                        printf((char const   * __restrict  )"tellics ptell Ok, Knight %s\n",
                               howmuch);
                      }
#line 332
                      tmp___32 = strstr((char const   *)(input + 6), "b");
#line 332
                      if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
#line 334
                        if (comp_color == 1) {
#line 335
                          hand_value[12] = std_hand_value[12] - change;
                        } else {
#line 337
                          hand_value[11] = std_hand_value[11] + change;
                        }
#line 340
                        if (comp_color == 1) {
#line 341
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
#line 343
                          hand_value[9] = std_hand_value[9] + change;
                        }
#line 345
                        printf((char const   * __restrict  )"tellics ptell Ok, Bishop %s\n",
                               howmuch);
                      }
#line 347
                      tmp___33 = strstr((char const   *)(input + 6), "r");
#line 347
                      if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
#line 349
                        if (comp_color == 1) {
#line 350
                          hand_value[8] = std_hand_value[8] - change;
                        } else {
#line 352
                          hand_value[7] = std_hand_value[7] + change;
                        }
#line 355
                        if (comp_color == 1) {
#line 356
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
#line 358
                          hand_value[9] = std_hand_value[9] + change;
                        }
#line 360
                        printf((char const   * __restrict  )"tellics ptell Ok, Rook %s\n",
                               howmuch);
                      }
#line 362
                      tmp___34 = strstr((char const   *)(input + 6), "q");
#line 362
                      if ((unsigned long )tmp___34 != (unsigned long )((void *)0)) {
#line 364
                        if (comp_color == 1) {
#line 365
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
#line 367
                          hand_value[9] = std_hand_value[9] + change;
                        }
#line 369
                        printf((char const   * __restrict  )"tellics ptell Ok, Queen %s\n",
                               howmuch);
                      }
#line 371
                      tmp___35 = strstr((char const   *)(input + 6), "p");
#line 371
                      if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
#line 373
                        if (comp_color == 1) {
#line 374
                          hand_value[2] = std_hand_value[2] - change;
                        } else {
#line 376
                          hand_value[1] = std_hand_value[1] + change;
                        }
#line 379
                        if (comp_color == 1) {
#line 381
                          hand_value[10] = std_hand_value[10] - change;
#line 382
                          hand_value[12] = std_hand_value[12] - change;
                        } else {
#line 386
                          hand_value[9] = std_hand_value[9] + change;
#line 387
                          hand_value[11] = std_hand_value[11] + change;
                        }
#line 390
                        printf((char const   * __restrict  )"tellics ptell Ok, Pawn %s\n",
                               howmuch);
                      }
#line 392
                      tmp___36 = strstr((char const   *)(input + 6), "d");
#line 392
                      if ((unsigned long )tmp___36 != (unsigned long )((void *)0)) {
#line 394
                        if (comp_color == 1) {
#line 396
                          hand_value[2] = std_hand_value[2] - change;
#line 397
                          hand_value[12] = std_hand_value[12] - change;
#line 398
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
#line 402
                          hand_value[1] = std_hand_value[1] + change;
#line 403
                          hand_value[11] = std_hand_value[11] + change;
#line 404
                          hand_value[9] = std_hand_value[9] + change;
                        }
#line 407
                        printf((char const   * __restrict  )"tellics ptell Ok, Diagonal %s\n",
                               howmuch);
                      }
#line 409
                      tmp___37 = strstr((char const   *)(input + 6), "h");
#line 409
                      if ((unsigned long )tmp___37 != (unsigned long )((void *)0)) {
#line 411
                        if (comp_color == 1) {
#line 413
                          hand_value[8] = std_hand_value[8] - change;
#line 414
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
#line 418
                          hand_value[7] = std_hand_value[7] + change;
#line 419
                          hand_value[9] = std_hand_value[9] + change;
                        }
#line 422
                        printf((char const   * __restrict  )"tellics ptell Ok, Heavy %s\n",
                               howmuch);
                      }
                    }
                  } else {
#line 121
                    tmp___5 = strstr((char const   *)(input + 6), "trade");
#line 121
                    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 121
                      goto _L;
                    } else {
#line 121
                      tmp___6 = strstr((char const   *)(input + 6), "n");
#line 121
                      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 121
                        tmp___7 = strstr((char const   *)(input + 6), "b");
#line 121
                        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 121
                          tmp___8 = strstr((char const   *)(input + 6), "p");
#line 121
                          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 121
                            tmp___9 = strstr((char const   *)(input + 6), "r");
#line 121
                            if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 121
                              tmp___10 = strstr((char const   *)(input + 6), "q");
#line 121
                              if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 121
                                tmp___11 = strstr((char const   *)(input + 6), "d");
#line 121
                                if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 121
                                  tmp___12 = strstr((char const   *)(input + 6), "h");
#line 121
                                  if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
                                    _L: /* CIL Label */ 
#line 131
                                    if (comp_color == 1) {
#line 133
                                      hand_value[1] += 25;
#line 134
                                      hand_value[3] += 50;
#line 135
                                      hand_value[11] += 50;
#line 136
                                      hand_value[7] += 50;
#line 137
                                      hand_value[9] += 100;
                                    } else {
#line 141
                                      hand_value[2] -= 25;
#line 142
                                      hand_value[4] -= 50;
#line 143
                                      hand_value[12] -= 50;
#line 144
                                      hand_value[8] -= 50;
#line 145
                                      hand_value[10] -= 100;
                                    }
#line 147
                                    printf((char const   * __restrict  )"tellics ptell Ok, trading is GOOD\n");
                                  } else {
#line 121
                                    goto _L___5;
                                  }
                                } else {
#line 121
                                  goto _L___5;
                                }
                              } else {
#line 121
                                goto _L___5;
                              }
                            } else {
#line 121
                              goto _L___5;
                            }
                          } else {
#line 121
                            goto _L___5;
                          }
                        } else {
#line 121
                          goto _L___5;
                        }
                      } else {
                        _L___5: /* CIL Label */ 
#line 150
                        tmp___4 = strstr((char const   *)(input + 6), "+++");
#line 150
                        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 152
                          change = 50000;
#line 153
                          strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"mates");
                        } else {
#line 155
                          tmp___3 = strstr((char const   *)(input + 6), "++");
#line 155
                          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 157
                            change = 1000;
#line 158
                            strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"is VERY good (ptell me \'x\' to play normal again)");
                          } else {
#line 160
                            tmp___2 = strstr((char const   *)(input + 6), "+");
#line 160
                            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 162
                              change = 150;
#line 163
                              strcpy((char * __restrict  )(howmuch), (char const   * __restrict  )"is good (ptell me \'x\' to play normal again)");
                            } else {
#line 166
                              *((int *)((void *)0)) = 0;
                            }
                          }
                        }
                      }
                    }
#line 169
                    tmp___13 = strstr((char const   *)(input + 6), "n");
#line 169
                    if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 171
                      if (comp_color == 1) {
#line 173
                        hand_value[3] = std_hand_value[3] + change;
                      } else {
#line 176
                        hand_value[4] = std_hand_value[4] - change;
                      }
#line 178
                      printf((char const   * __restrict  )"tellics ptell Ok, Knight %s\n",
                             howmuch);
                    }
#line 180
                    tmp___14 = strstr((char const   *)(input + 6), "b");
#line 180
                    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 182
                      if (comp_color == 1) {
#line 183
                        hand_value[11] = std_hand_value[11] + change;
                      } else {
#line 185
                        hand_value[12] = std_hand_value[12] - change;
                      }
#line 188
                      if (comp_color == 1) {
#line 189
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
#line 191
                        hand_value[10] = std_hand_value[10] - change;
                      }
#line 193
                      printf((char const   * __restrict  )"tellics ptell Ok, Bishop %s\n",
                             howmuch);
                    }
#line 195
                    tmp___15 = strstr((char const   *)(input + 6), "r");
#line 195
                    if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 197
                      if (comp_color == 1) {
#line 198
                        hand_value[7] = std_hand_value[7] + change;
                      } else {
#line 200
                        hand_value[8] = std_hand_value[8] - change;
                      }
#line 203
                      if (comp_color == 1) {
#line 204
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
#line 206
                        hand_value[10] = std_hand_value[10] - change;
                      }
#line 208
                      printf((char const   * __restrict  )"tellics ptell Ok, Rook %s\n",
                             howmuch);
                    }
#line 210
                    tmp___16 = strstr((char const   *)(input + 6), "q");
#line 210
                    if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 212
                      if (comp_color == 1) {
#line 213
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
#line 215
                        hand_value[10] = std_hand_value[10] - change;
                      }
#line 217
                      printf((char const   * __restrict  )"tellics ptell Ok, Queen %s\n",
                             howmuch);
                    }
#line 219
                    tmp___17 = strstr((char const   *)(input + 6), "p");
#line 219
                    if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 221
                      if (comp_color == 1) {
#line 222
                        hand_value[1] = std_hand_value[1] + change;
                      } else {
#line 224
                        hand_value[2] = std_hand_value[2] - change;
                      }
#line 227
                      if (comp_color == 1) {
#line 229
                        hand_value[9] = std_hand_value[9] + change;
#line 230
                        hand_value[11] = std_hand_value[11] + change;
                      } else {
#line 234
                        hand_value[10] = std_hand_value[10] - change;
#line 235
                        hand_value[12] = std_hand_value[12] - change;
                      }
#line 238
                      printf((char const   * __restrict  )"tellics ptell Ok, Pawn %s\n",
                             howmuch);
                    }
#line 240
                    tmp___18 = strstr((char const   *)(input + 6), "d");
#line 240
                    if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
#line 242
                      if (comp_color == 1) {
#line 244
                        hand_value[1] = std_hand_value[1] + change;
#line 245
                        hand_value[11] = std_hand_value[11] + change;
#line 246
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
#line 250
                        hand_value[2] = std_hand_value[2] - change;
#line 251
                        hand_value[12] = std_hand_value[12] - change;
#line 252
                        hand_value[10] = std_hand_value[10] - change;
                      }
#line 255
                      printf((char const   * __restrict  )"tellics ptell Ok, Diagonal %s\n",
                             howmuch);
                    }
#line 257
                    tmp___19 = strstr((char const   *)(input + 6), "h");
#line 257
                    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
#line 259
                      if (comp_color == 1) {
#line 261
                        hand_value[7] = std_hand_value[7] + change;
#line 262
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
#line 266
                        hand_value[8] = std_hand_value[8] - change;
#line 267
                        hand_value[10] = std_hand_value[10] - change;
                      }
#line 270
                      printf((char const   * __restrict  )"tellics ptell Ok, Heavy %s\n",
                             howmuch);
                    }
                  }
                } else {
#line 115
                  printf((char const   * __restrict  )"tellics ptell Flagging...\n");
#line 116
                  printf((char const   * __restrict  )"tellics flag\n");
                }
              } else {
#line 110
                printf((char const   * __restrict  )"tellics ptell Requesting abort...\n");
#line 111
                printf((char const   * __restrict  )"tellics abort\n");
              }
            } else {
#line 104
              printf((char const   * __restrict  )"tellics ptell Ok, moving normally.\n");
#line 105
              go_fast = (xbool )0;
#line 106
              must_sit = (xbool )0;
            }
          } else {
#line 98
            printf((char const   * __restrict  )"tellics ptell Ok, I\'m going FAST!\n");
#line 99
            go_fast = (xbool )1;
#line 100
            must_sit = (xbool )0;
          }
        } else {
#line 98
          printf((char const   * __restrict  )"tellics ptell Ok, I\'m going FAST!\n");
#line 99
          go_fast = (xbool )1;
#line 100
          must_sit = (xbool )0;
        }
      } else {
#line 92
        printf((char const   * __restrict  )"tellics ptell Ok, I\'m moving.\n");
#line 93
        must_sit = (xbool )0;
#line 94
        must_go = 4;
      }
    } else {
#line 92
      printf((char const   * __restrict  )"tellics ptell Ok, I\'m moving.\n");
#line 93
      must_sit = (xbool )0;
#line 94
      must_go = 4;
    }
  } else {
#line 86
    printf((char const   * __restrict  )"tellics ptell Ok, I sit next move. Tell me when to go.\n");
#line 87
    must_sit = (xbool )1;
#line 88
    must_go = 0;
  }
#line 474
  return;
}
}
#line 494 "partner.c"
static int pawnmated  =    0;
#line 494 "partner.c"
static int knightmated  =    0;
#line 494 "partner.c"
static int bishopmated  =    0;
#line 494 "partner.c"
static int rookmated  =    0;
#line 494 "partner.c"
static int queenmated  =    0;
#line 479 "partner.c"
void CheckBadFlow(xbool reset ) 
{ 
  move_s hismoves[512] ;
  move_s ourmoves[512] ;
  int his_num_moves ;
  int our_num_moves ;
  int j ;
  int i ;
  int ic ;
  int icc ;
  xbool othermove ;
  int pawnmates ;
  int knightmates ;
  int bishopmates ;
  int rookmates ;
  int queenmates ;
  xbool pawnwarn ;
  xbool knightwarn ;
  xbool bishopwarn ;
  xbool rookwarn ;
  xbool queenwarn ;
  xbool tmp ;
  int tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;
  xbool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  xbool tmp___13 ;
  xbool tmp___14 ;
  xbool tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  xbool tmp___19 ;
  xbool tmp___20 ;
  xbool tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  xbool tmp___25 ;
  xbool tmp___26 ;
  xbool tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 485
  othermove = (xbool )0;
#line 487
  pawnmates = 0;
#line 487
  knightmates = 0;
#line 487
  bishopmates = 0;
#line 487
  rookmates = 0;
#line 487
  queenmates = 0;
#line 501
  pawnwarn = (xbool )0;
#line 501
  knightwarn = (xbool )0;
#line 501
  bishopwarn = (xbool )0;
#line 501
  rookwarn = (xbool )0;
#line 501
  queenwarn = (xbool )0;
#line 508
  if (reset) {
#line 510
    pawnmated = 0;
#line 511
    knightmated = 0;
#line 512
    bishopmated = 0;
#line 513
    rookmated = 0;
#line 514
    queenmated = 0;
#line 515
    return;
  }
#line 518
  tmp = in_check();
#line 518
  ic = (int )tmp;
#line 520
  if (white_to_move) {
#line 520
    tmp___5 = 1;
  } else {
#line 520
    tmp___5 = 2;
  }
#line 520
  if (! holding[! white_to_move][tmp___5]) {
#line 523
    if (white_to_move) {
#line 523
      tmp___0 = 1;
    } else {
#line 523
      tmp___0 = 2;
    }
#line 523
    DropaddHolding(tmp___0, ! white_to_move);
#line 525
    gen(& hismoves[0]);
#line 526
    his_num_moves = numb_moves;
#line 528
    i = 0;
#line 528
    while (1) {
#line 528
      if (i < his_num_moves) {
#line 528
        if (! (pawnmates == 0)) {
#line 528
          break;
        }
      } else {
#line 528
        break;
      }
#line 530
      make(& hismoves[0], i);
#line 532
      tmp___3 = check_legal(& hismoves[0], i, ic);
#line 532
      if (tmp___3) {
#line 534
        pawnmates = 3;
#line 536
        tmp___1 = in_check();
#line 536
        icc = (int )tmp___1;
#line 538
        gen(& ourmoves[0]);
#line 539
        our_num_moves = numb_moves;
#line 541
        j = 0;
#line 541
        while (1) {
#line 541
          if (j < our_num_moves) {
#line 541
            if (! (pawnmates != 0)) {
#line 541
              break;
            }
          } else {
#line 541
            break;
          }
#line 544
          make(& ourmoves[0], j);
#line 546
          tmp___2 = check_legal(& ourmoves[0], j, icc);
#line 546
          if (tmp___2) {
#line 547
            pawnmates = 0;
          }
#line 549
          unmake(& ourmoves[0], j);
#line 541
          j ++;
        }
      }
#line 553
      unmake(& hismoves[0], i);
#line 528
      i ++;
    }
#line 555
    if (white_to_move) {
#line 555
      tmp___4 = 1;
    } else {
#line 555
      tmp___4 = 2;
    }
#line 555
    DropremoveHolding(tmp___4, ! white_to_move);
  }
#line 558
  if (white_to_move) {
#line 558
    tmp___11 = 3;
  } else {
#line 558
    tmp___11 = 4;
  }
#line 558
  if (! holding[! white_to_move][tmp___11]) {
#line 561
    if (white_to_move) {
#line 561
      tmp___6 = 3;
    } else {
#line 561
      tmp___6 = 4;
    }
#line 561
    DropaddHolding(tmp___6, ! white_to_move);
#line 563
    gen(& hismoves[0]);
#line 564
    his_num_moves = numb_moves;
#line 566
    i = 0;
#line 566
    while (1) {
#line 566
      if (i < his_num_moves) {
#line 566
        if (! (knightmates == 0)) {
#line 566
          break;
        }
      } else {
#line 566
        break;
      }
#line 569
      make(& hismoves[0], i);
#line 571
      tmp___9 = check_legal(& hismoves[0], i, ic);
#line 571
      if (tmp___9) {
#line 573
        knightmates = 3;
#line 575
        tmp___7 = in_check();
#line 575
        icc = (int )tmp___7;
#line 577
        gen(& ourmoves[0]);
#line 578
        our_num_moves = numb_moves;
#line 580
        j = 0;
#line 580
        while (1) {
#line 580
          if (j < our_num_moves) {
#line 580
            if (! (knightmates != 0)) {
#line 580
              break;
            }
          } else {
#line 580
            break;
          }
#line 582
          make(& ourmoves[0], j);
#line 584
          tmp___8 = check_legal(& ourmoves[0], j, icc);
#line 584
          if (tmp___8) {
#line 585
            knightmates = 0;
          }
#line 587
          unmake(& ourmoves[0], j);
#line 580
          j ++;
        }
      }
#line 590
      unmake(& hismoves[0], i);
#line 566
      i ++;
    }
#line 592
    if (white_to_move) {
#line 592
      tmp___10 = 3;
    } else {
#line 592
      tmp___10 = 4;
    }
#line 592
    DropremoveHolding(tmp___10, ! white_to_move);
  }
#line 595
  if (white_to_move) {
#line 595
    tmp___17 = 11;
  } else {
#line 595
    tmp___17 = 12;
  }
#line 595
  if (! holding[! white_to_move][tmp___17]) {
#line 598
    if (white_to_move) {
#line 598
      tmp___12 = 11;
    } else {
#line 598
      tmp___12 = 12;
    }
#line 598
    DropaddHolding(tmp___12, ! white_to_move);
#line 600
    gen(& hismoves[0]);
#line 601
    his_num_moves = numb_moves;
#line 603
    i = 0;
#line 603
    while (1) {
#line 603
      if (i < his_num_moves) {
#line 603
        if (! (bishopmates == 0)) {
#line 603
          break;
        }
      } else {
#line 603
        break;
      }
#line 605
      make(& hismoves[0], i);
#line 607
      tmp___15 = check_legal(& hismoves[0], i, ic);
#line 607
      if (tmp___15) {
#line 609
        bishopmates = 3;
#line 611
        tmp___13 = in_check();
#line 611
        icc = (int )tmp___13;
#line 613
        gen(& ourmoves[0]);
#line 614
        our_num_moves = numb_moves;
#line 616
        j = 0;
#line 616
        while (1) {
#line 616
          if (j < our_num_moves) {
#line 616
            if (! (bishopmates != 0)) {
#line 616
              break;
            }
          } else {
#line 616
            break;
          }
#line 618
          make(& ourmoves[0], j);
#line 620
          tmp___14 = check_legal(& ourmoves[0], j, icc);
#line 620
          if (tmp___14) {
#line 621
            bishopmates = 0;
          }
#line 623
          unmake(& ourmoves[0], j);
#line 616
          j ++;
        }
      }
#line 626
      unmake(& hismoves[0], i);
#line 603
      i ++;
    }
#line 628
    if (white_to_move) {
#line 628
      tmp___16 = 11;
    } else {
#line 628
      tmp___16 = 12;
    }
#line 628
    DropremoveHolding(tmp___16, ! white_to_move);
  }
#line 631
  if (white_to_move) {
#line 631
    tmp___23 = 7;
  } else {
#line 631
    tmp___23 = 8;
  }
#line 631
  if (! holding[! white_to_move][tmp___23]) {
#line 634
    if (white_to_move) {
#line 634
      tmp___18 = 7;
    } else {
#line 634
      tmp___18 = 8;
    }
#line 634
    DropaddHolding(tmp___18, ! white_to_move);
#line 636
    gen(& hismoves[0]);
#line 637
    his_num_moves = numb_moves;
#line 639
    i = 0;
#line 639
    while (1) {
#line 639
      if (i < his_num_moves) {
#line 639
        if (! (rookmates == 0)) {
#line 639
          break;
        }
      } else {
#line 639
        break;
      }
#line 641
      make(& hismoves[0], i);
#line 643
      tmp___21 = check_legal(& hismoves[0], i, ic);
#line 643
      if (tmp___21) {
#line 645
        rookmates = 3;
#line 647
        tmp___19 = in_check();
#line 647
        icc = (int )tmp___19;
#line 649
        gen(& ourmoves[0]);
#line 650
        our_num_moves = numb_moves;
#line 652
        j = 0;
#line 652
        while (1) {
#line 652
          if (j < our_num_moves) {
#line 652
            if (! (rookmates != 0)) {
#line 652
              break;
            }
          } else {
#line 652
            break;
          }
#line 654
          make(& ourmoves[0], j);
#line 656
          tmp___20 = check_legal(& ourmoves[0], j, icc);
#line 656
          if (tmp___20) {
#line 657
            rookmates = 0;
          }
#line 659
          unmake(& ourmoves[0], j);
#line 652
          j ++;
        }
      }
#line 662
      unmake(& hismoves[0], i);
#line 639
      i ++;
    }
#line 664
    if (white_to_move) {
#line 664
      tmp___22 = 7;
    } else {
#line 664
      tmp___22 = 8;
    }
#line 664
    DropremoveHolding(tmp___22, ! white_to_move);
  }
#line 667
  if (white_to_move) {
#line 667
    tmp___29 = 9;
  } else {
#line 667
    tmp___29 = 10;
  }
#line 667
  if (! holding[! white_to_move][tmp___29]) {
#line 670
    if (white_to_move) {
#line 670
      tmp___24 = 9;
    } else {
#line 670
      tmp___24 = 10;
    }
#line 670
    DropaddHolding(tmp___24, ! white_to_move);
#line 672
    gen(& hismoves[0]);
#line 673
    his_num_moves = numb_moves;
#line 675
    i = 0;
#line 675
    while (1) {
#line 675
      if (i < his_num_moves) {
#line 675
        if (! (queenmates == 0)) {
#line 675
          break;
        }
      } else {
#line 675
        break;
      }
#line 677
      make(& hismoves[0], i);
#line 679
      tmp___27 = check_legal(& hismoves[0], i, ic);
#line 679
      if (tmp___27) {
#line 681
        queenmates = 3;
#line 683
        tmp___25 = in_check();
#line 683
        icc = (int )tmp___25;
#line 685
        gen(& ourmoves[0]);
#line 686
        our_num_moves = numb_moves;
#line 688
        j = 0;
#line 688
        while (1) {
#line 688
          if (j < our_num_moves) {
#line 688
            if (! (queenmates != 0)) {
#line 688
              break;
            }
          } else {
#line 688
            break;
          }
#line 690
          make(& ourmoves[0], j);
#line 692
          tmp___26 = check_legal(& ourmoves[0], j, icc);
#line 692
          if (tmp___26) {
#line 693
            queenmates = 0;
          }
#line 695
          unmake(& ourmoves[0], j);
#line 688
          j ++;
        }
      }
#line 698
      unmake(& hismoves[0], i);
#line 675
      i ++;
    }
#line 700
    if (white_to_move) {
#line 700
      tmp___28 = 9;
    } else {
#line 700
      tmp___28 = 10;
    }
#line 700
    DropremoveHolding(tmp___28, ! white_to_move);
  }
#line 706
  if (pawnmates != pawnmated) {
#line 708
    if (pawnmates == 3) {
#line 709
      pawnwarn = (xbool )1;
    } else
#line 710
    if (pawnmates == 0) {
#line 710
      if (pawnmated == 0) {
#line 712
        printf((char const   * __restrict  )"tellics ptell p doesn\'t mate me anymore\n");
#line 713
        othermove = (xbool )1;
      }
    }
  }
#line 717
  if (knightmates != knightmated) {
#line 719
    if (knightmates == 3) {
#line 720
      knightwarn = (xbool )1;
    } else
#line 721
    if (knightmates == 0) {
#line 721
      if (knightmated == 0) {
#line 723
        printf((char const   * __restrict  )"tellics ptell n doesn\'t mate me anymore\n");
#line 724
        othermove = (xbool )1;
      }
    }
  }
#line 728
  if (bishopmates != bishopmated) {
#line 730
    if (bishopmates == 3) {
#line 731
      bishopwarn = (xbool )1;
    } else
#line 732
    if (bishopmates == 0) {
#line 732
      if (bishopmated == 0) {
#line 734
        printf((char const   * __restrict  )"tellics ptell b doesn\'t mate me anymore\n");
#line 735
        othermove = (xbool )1;
      }
    }
  }
#line 738
  if (rookmates != rookmated) {
#line 740
    if (rookmates == 3) {
#line 741
      rookwarn = (xbool )1;
    } else
#line 742
    if (rookmates == 0) {
#line 742
      if (rookmated == 0) {
#line 744
        printf((char const   * __restrict  )"tellics ptell r doesn\'t mate me anymore\n");
#line 745
        othermove = (xbool )1;
      }
    }
  }
#line 748
  if (queenmates != queenmated) {
#line 750
    if (queenmates == 3) {
#line 751
      queenwarn = (xbool )1;
    } else
#line 752
    if (queenmates == 0) {
#line 752
      if (queenmated == 0) {
#line 754
        printf((char const   * __restrict  )"tellics ptell q doesn\'t mate me anymore\n");
#line 755
        othermove = (xbool )1;
      }
    }
  }
#line 759
  if (pawnwarn) {
#line 760
    printf((char const   * __restrict  )"tellics ptell ---p\n");
  }
#line 761
  if (knightwarn) {
#line 762
    printf((char const   * __restrict  )"tellics ptell ---n\n");
  }
#line 763
  if (bishopwarn) {
#line 764
    printf((char const   * __restrict  )"tellics ptell ---b\n");
  }
#line 765
  if (rookwarn) {
#line 766
    printf((char const   * __restrict  )"tellics ptell ---r\n");
  }
#line 767
  if (queenwarn) {
#line 768
    printf((char const   * __restrict  )"tellics ptell ---q\n");
  }
#line 773
  if (piecedead) {
#line 773
    if (othermove) {
#line 775
      piecedead = (xbool )0;
#line 776
      printf((char const   * __restrict  )"tellics ptell x\n");
#line 777
      printf((char const   * __restrict  )"tellics ptell go\n");
#line 778
      go_fast = (xbool )0;
    }
  }
#line 781
  if (pawnmates) {
#line 781
    pawnmated = pawnmates;
  } else {
#line 781
    pawnmated --;
  }
#line 782
  if (bishopmates) {
#line 782
    bishopmated = bishopmates;
  } else {
#line 782
    bishopmated --;
  }
#line 783
  if (rookmates) {
#line 783
    rookmated = rookmates;
  } else {
#line 783
    rookmated --;
  }
#line 784
  if (queenmates) {
#line 784
    queenmated = queenmates;
  } else {
#line 784
    queenmated --;
  }
#line 785
  if (knightmates) {
#line 785
    knightmated = knightmates;
  } else {
#line 785
    knightmated --;
  }
#line 787
  return;
}
}
#line 1 "proof.o"
#pragma merger("0","/tmp/cil-umsqfEeU.i","")
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 12 "./extvars.h"
int result ;
#line 22
xbool post ;
#line 23
int xb_mode ;
#line 101 "./extvars.h"
int forcedwin  ;
#line 130 "./extvars.h"
int pn_time  ;
#line 131 "./extvars.h"
move_s pn_move  ;
#line 132 "./extvars.h"
move_s pn_saver  ;
#line 133 "./extvars.h"
xbool kibitzed  ;
#line 134 "./extvars.h"
int rootlosers[300]  ;
#line 135 "./extvars.h"
int alllosers  ;
#line 136
int s_threat ;
#line 152
int PBSize ;
#line 15 "./protos.h"
void comp_to_coord(move_s move , char *str ) ;
#line 54
int rdifftime(rtime_t end , rtime_t start ) ;
#line 92
void StoreTT(int score , int alpha , int beta , int best , int threat , int depth ) ;
#line 125
move_s proofnumbercheck(move_s compmove ) ;
#line 126
void proofnumbersearch(void) ;
#line 127
void proofnumberscan(void) ;
#line 28 "proof.c"
int nodecount  ;
#line 29 "proof.c"
int nodecount2  ;
#line 30 "proof.c"
int pn2  ;
#line 31 "proof.c"
int frees  ;
#line 32 "proof.c"
int iters  ;
#line 33 "proof.c"
int forwards  ;
#line 34 "proof.c"
int maxply  ;
#line 59
void pn2_eval(node_t *root ) ;
#line 60
void suicide_pn_eval(node_t *this ) ;
#line 61
void std_pn_eval(node_t *this ) ;
#line 62
void losers_pn_eval(node_t *this ) ;
#line 64 "proof.c"
unsigned char *membuff  ;
#line 65 "proof.c"
int bufftop  =    0;
#line 67 "proof.c"
void *Xmalloc(int size ) 
{ 
  int oldtop ;

  {
#line 69
  oldtop = bufftop;
#line 71
  bufftop += size;
#line 73
  return ((void *)(membuff + oldtop));
}
}
#line 76 "proof.c"
void Xfree(void) 
{ 


  {
#line 78
  bufftop = 0;
#line 79
  return;
}
}
#line 81 "proof.c"
void freenodes(node_t *node ) 
{ 
  int i ;

  {
#line 85
  if (! node) {
#line 86
    return;
  }
#line 88
  if (node->children) {
#line 90
    if ((int )node->num_children > 0) {
#line 92
      i = 0;
#line 92
      while (i < (int )node->num_children) {
#line 94
        if ((unsigned long )*(node->children + i) != (unsigned long )((struct node *)0)) {
#line 96
          freenodes(*(node->children + i));
        }
#line 92
        i ++;
      }
#line 99
      free((void *)node->children);
    }
  }
#line 103
  free((void *)node);
#line 104
  return;
}
}
#line 106 "proof.c"
void pn_eval(node_t *this ) 
{ 


  {
#line 108
  if (Variant == 3) {
#line 110
    suicide_pn_eval(this);
  } else
#line 112
  if (Variant == 4) {
#line 114
    losers_pn_eval(this);
  } else {
#line 118
    std_pn_eval(this);
  }
#line 120
  return;
}
}
#line 122 "proof.c"
void std_pn_eval(node_t *this ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int mate ;
  int i ;
  xbool tmp ;
  int tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;

  {
#line 129
  this->evaluated = (unsigned char)1;
#line 133
  if (white_to_move) {
#line 133
    tmp___1 = is_attacked(wking_loc, 0);
#line 133
    if (tmp___1) {
#line 133
      goto _L;
    } else {
#line 133
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 133
  if (! white_to_move) {
#line 133
    tmp___2 = is_attacked(bking_loc, 1);
#line 133
    if (tmp___2) {
      _L: /* CIL Label */ 
#line 137
      num_moves = 0;
#line 138
      gen(& moves[0]);
#line 139
      num_moves = numb_moves;
#line 141
      mate = 1;
#line 143
      i = 0;
#line 143
      while (i < num_moves) {
#line 145
        make(& moves[0], i);
#line 148
        tmp = check_legal(& moves[0], i, 1);
#line 148
        if (tmp) {
#line 150
          mate = 0;
#line 151
          unmake(& moves[0], i);
#line 152
          break;
        }
#line 155
        unmake(& moves[0], i);
#line 143
        i ++;
      }
#line 158
      if (mate == 1) {
#line 161
        if (white_to_move) {
#line 161
          tmp___0 = 0;
        } else {
#line 161
          tmp___0 = 1;
        }
#line 161
        if (tmp___0 == root_to_move) {
#line 164
          this->value = (unsigned char)0;
        } else {
#line 168
          this->value = (unsigned char)1;
        }
      } else {
#line 173
        this->value = (unsigned char)2;
      }
    } else {
#line 178
      this->value = (unsigned char)2;
    }
  } else {
#line 178
    this->value = (unsigned char)2;
  }
#line 183
  return;
}
}
#line 185 "proof.c"
void suicide_pn_eval(node_t *this ) 
{ 
  int j ;
  int a ;
  int i ;
  int wp ;
  int bp ;

  {
#line 188
  wp = 0;
#line 188
  bp = 0;
#line 190
  this->evaluated = (unsigned char)1;
#line 192
  j = 1;
#line 192
  a = 1;
#line 192
  while (a <= piece_count) {
#line 194
    i = pieces[j];
#line 196
    if (! i) {
#line 197
      goto __Cont;
    } else {
#line 199
      a ++;
    }
#line 201
    switch (board[i]) {
    case 3: 
    case 9: 
    case 5: 
    case 7: 
    case 11: 
    case 1: 
#line 208
    wp ++;
#line 208
    break;
    case 4: 
    case 10: 
    case 6: 
    case 8: 
    case 12: 
    case 2: 
#line 214
    bp ++;
#line 214
    break;
    }
#line 217
    if (wp) {
#line 217
      if (bp) {
#line 217
        break;
      }
    }
    __Cont: /* CIL Label */ 
#line 192
    j ++;
  }
#line 220
  if (! wp) {
#line 224
    if (! root_to_move) {
#line 227
      this->value = (unsigned char)1;
    } else {
#line 231
      this->value = (unsigned char)0;
    }
  } else
#line 234
  if (! bp) {
#line 237
    if (! root_to_move) {
#line 240
      this->value = (unsigned char)0;
    } else {
#line 244
      this->value = (unsigned char)1;
    }
  } else {
#line 249
    this->value = (unsigned char)2;
  }
#line 251
  return;
}
}
#line 253 "proof.c"
void losers_pn_eval(node_t *this ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int mate ;
  int i ;
  int j ;
  int a ;
  int wp ;
  int bp ;
  xbool tmp ;
  xbool tmp___0 ;
  int tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;

  {
#line 260
  wp = 0;
#line 260
  bp = 0;
#line 262
  this->evaluated = (unsigned char)1;
#line 266
  j = 1;
#line 266
  a = 1;
#line 266
  while (a <= piece_count) {
#line 268
    i = pieces[j];
#line 270
    if (! i) {
#line 271
      goto __Cont;
    } else {
#line 273
      a ++;
    }
#line 275
    switch (board[i]) {
    case 3: 
    case 9: 
    case 7: 
    case 11: 
    case 1: 
#line 281
    wp ++;
#line 281
    break;
    case 4: 
    case 10: 
    case 8: 
    case 12: 
    case 2: 
#line 286
    bp ++;
#line 286
    break;
    }
#line 289
    if (wp) {
#line 289
      if (bp) {
#line 289
        break;
      }
    }
    __Cont: /* CIL Label */ 
#line 266
    j ++;
  }
#line 293
  if (! wp) {
#line 296
    if (! root_to_move) {
#line 299
      this->value = (unsigned char)1;
    } else {
#line 303
      this->value = (unsigned char)0;
    }
#line 305
    return;
  } else
#line 307
  if (! bp) {
#line 309
    if (root_to_move) {
#line 312
      this->value = (unsigned char)1;
    } else {
#line 316
      this->value = (unsigned char)0;
    }
#line 318
    return;
  }
#line 321
  if (white_to_move) {
#line 321
    tmp___2 = is_attacked(wking_loc, 0);
#line 321
    if (tmp___2) {
#line 321
      goto _L;
    } else {
#line 321
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 321
  if (! white_to_move) {
#line 321
    tmp___3 = is_attacked(bking_loc, 1);
#line 321
    if (tmp___3) {
      _L: /* CIL Label */ 
#line 325
      captures = (xbool )1;
#line 327
      num_moves = 0;
#line 328
      gen(& moves[0]);
#line 329
      num_moves = numb_moves;
#line 330
      captures = (xbool )0;
#line 332
      mate = 1;
#line 334
      i = 0;
#line 334
      while (i < num_moves) {
#line 336
        make(& moves[0], i);
#line 339
        tmp = check_legal(& moves[0], i, 1);
#line 339
        if (tmp) {
#line 341
          mate = 0;
#line 342
          unmake(& moves[0], i);
#line 343
          break;
        }
#line 346
        unmake(& moves[0], i);
#line 334
        i ++;
      }
#line 349
      if (mate == 1) {
#line 352
        captures = (xbool )0;
#line 353
        num_moves = 0;
#line 354
        gen(& moves[0]);
#line 355
        num_moves = numb_moves;
#line 357
        i = 0;
#line 357
        while (i < num_moves) {
#line 359
          make(& moves[0], i);
#line 362
          tmp___0 = check_legal(& moves[0], i, 1);
#line 362
          if (tmp___0) {
#line 364
            mate = 0;
#line 365
            unmake(& moves[0], i);
#line 366
            break;
          }
#line 369
          unmake(& moves[0], i);
#line 357
          i ++;
        }
      }
#line 373
      if (mate == 1) {
#line 376
        if (white_to_move) {
#line 376
          tmp___1 = 0;
        } else {
#line 376
          tmp___1 = 1;
        }
#line 376
        if (tmp___1 == root_to_move) {
#line 379
          this->value = (unsigned char)1;
        } else {
#line 383
          this->value = (unsigned char)0;
        }
      } else {
#line 388
        this->value = (unsigned char)2;
      }
    } else {
#line 393
      this->value = (unsigned char)2;
    }
  } else {
#line 393
    this->value = (unsigned char)2;
  }
#line 398
  return;
}
}
#line 401 "proof.c"
node_t *select_most_proving(node_t *node ) 
{ 
  int i ;
  node_t *tnode ;
  int tmp ;

  {
#line 406
  tnode = node;
#line 408
  while (tnode->expanded) {
#line 410
    if (white_to_move) {
#line 410
      tmp = 0;
    } else {
#line 410
      tmp = 1;
    }
#line 410
    if (tmp == root_to_move) {
#line 412
      i = 0;
#line 414
      while ((*(tnode->children + i))->proof != tnode->proof) {
#line 416
        i ++;
      }
    } else {
#line 421
      i = 0;
#line 423
      while ((*(tnode->children + i))->disproof != tnode->disproof) {
#line 425
        i ++;
      }
    }
#line 429
    tnode = *(tnode->children + i);
#line 431
    hash_history[(move_number + ply) - 1] = hash;
#line 433
    make(& tnode->move, 0);
#line 435
    if (ply > maxply) {
#line 436
      maxply = ply;
    }
  }
#line 440
  return (tnode);
}
}
#line 444 "proof.c"
void set_proof_and_disproof_numbers(node_t *node ) 
{ 
  int proof ;
  int disproof ;
  int i ;
  move_s moves[512] ;
  int l ;
  int num_moves ;
  int ic ;
  int tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  xbool tmp___4 ;
  xbool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 453
  if (node->expanded) {
#line 455
    if (white_to_move) {
#line 455
      tmp = 0;
    } else {
#line 455
      tmp = 1;
    }
#line 455
    if (tmp != root_to_move) {
#line 457
      proof = 0;
#line 458
      disproof = 100000000;
#line 460
      i = 0;
#line 460
      while (i < (int )node->num_children) {
#line 462
        proof += (*(node->children + i))->proof;
#line 464
        if (proof > 100000000) {
#line 465
          proof = 100000000;
        }
#line 467
        if ((*(node->children + i))->disproof < disproof) {
#line 469
          disproof = (*(node->children + i))->disproof;
        }
#line 460
        i ++;
      }
#line 473
      if (proof == 0) {
#line 475
        forwards ++;
#line 476
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 473
      if (disproof == 100000000) {
#line 475
        forwards ++;
#line 476
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 478
      if (disproof == 0) {
#line 480
        forwards ++;
#line 481
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 478
      if (proof == 100000000) {
#line 480
        forwards ++;
#line 481
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      }
    } else {
#line 486
      disproof = 0;
#line 487
      proof = 100000000;
#line 489
      i = 0;
#line 489
      while (i < (int )node->num_children) {
#line 492
        disproof += (*(node->children + i))->disproof;
#line 494
        if (disproof > 100000000) {
#line 495
          disproof = 100000000;
        }
#line 497
        if ((*(node->children + i))->proof < proof) {
#line 499
          proof = (*(node->children + i))->proof;
        }
#line 489
        i ++;
      }
#line 503
      if (proof == 0) {
#line 505
        forwards ++;
#line 506
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 503
      if (disproof == 100000000) {
#line 505
        forwards ++;
#line 506
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 508
      if (disproof == 0) {
#line 510
        forwards ++;
#line 511
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      } else
#line 508
      if (proof == 100000000) {
#line 510
        forwards ++;
#line 511
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      }
    }
#line 515
    hash_history[(move_number + ply) - 1] = hash;
#line 517
    node->proof = proof;
#line 518
    node->disproof = disproof;
  } else
#line 521
  if (node->evaluated) {
#line 523
    if ((int )node->value == 2) {
#line 526
      hash_history[(move_number + ply) - 1] = hash;
#line 528
      tmp___0 = is_draw();
#line 528
      if (tmp___0) {
#line 530
        node->proof = 50000;
#line 531
        node->disproof = 50000;
#line 532
        return;
      } else
#line 528
      if (ply > 200) {
#line 530
        node->proof = 50000;
#line 531
        node->disproof = 50000;
#line 532
        return;
      }
#line 537
      if (Variant != 4) {
#line 539
        num_moves = 0;
#line 540
        gen(& moves[0]);
#line 541
        num_moves = numb_moves;
#line 543
        tmp___1 = in_check();
#line 543
        ic = (int )tmp___1;
#line 545
        if (Variant != 3) {
#line 547
          l = 0;
#line 549
          i = 0;
#line 549
          while (i < num_moves) {
#line 551
            make(& moves[0], i);
#line 553
            tmp___2 = check_legal(& moves[0], i, ic);
#line 553
            if (tmp___2) {
#line 555
              l ++;
            }
#line 557
            unmake(& moves[0], i);
#line 549
            i ++;
          }
        } else {
#line 562
          l = numb_moves;
        }
      } else {
#line 569
        l = 0;
#line 570
        captures = (xbool )1;
#line 571
        num_moves = 0;
#line 572
        gen(& moves[0]);
#line 573
        num_moves = numb_moves;
#line 574
        captures = (xbool )0;
#line 576
        tmp___3 = in_check();
#line 576
        ic = (int )tmp___3;
#line 578
        if (num_moves) {
#line 580
          i = 0;
#line 580
          while (i < num_moves) {
#line 582
            make(& moves[0], i);
#line 584
            tmp___4 = check_legal(& moves[0], i, ic);
#line 584
            if (tmp___4) {
#line 586
              l ++;
            }
#line 588
            unmake(& moves[0], i);
#line 580
            i ++;
          }
        }
#line 594
        if (! l) {
#line 596
          captures = (xbool )0;
#line 597
          num_moves = 0;
#line 598
          gen(& moves[0]);
#line 599
          num_moves = numb_moves;
#line 601
          i = 0;
#line 601
          while (i < num_moves) {
#line 603
            make(& moves[0], i);
#line 605
            tmp___5 = check_legal(& moves[0], i, ic);
#line 605
            if (tmp___5) {
#line 607
              l ++;
            }
#line 609
            unmake(& moves[0], i);
#line 601
            i ++;
          }
        }
      }
#line 614
      if (l == 0) {
#line 617
        node->proof = 1;
#line 618
        node->disproof = 1;
      } else {
#line 620
        if (white_to_move) {
#line 620
          tmp___6 = 0;
        } else {
#line 620
          tmp___6 = 1;
        }
#line 620
        if (tmp___6 == root_to_move) {
#line 622
          if (Variant != 3) {
#line 622
            if (Variant != 4) {
#line 624
              node->proof = 1 + ply / 50;
#line 625
              node->disproof = l + ply / 50;
            } else {
#line 622
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 629
          if (Variant == 4) {
#line 633
            if (phase == 2) {
#line 635
              node->proof = 1 + ply / 30;
#line 636
              node->disproof = l + ply / 30;
            } else {
#line 640
              node->proof = 1 + ply / 80;
#line 641
              node->disproof = l + ply / 80;
            }
          } else {
#line 646
            node->proof = 1 + ply / 150;
#line 647
            node->disproof = l + ply / 150;
          }
        } else
#line 653
        if (Variant != 3) {
#line 653
          if (Variant != 4) {
#line 655
            node->proof = l + ply / 50;
#line 656
            node->disproof = 1 + ply / 50;
          } else {
#line 653
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 660
        if (Variant == 4) {
#line 662
          if (phase == 2) {
#line 664
            node->proof = l + ply / 30;
#line 665
            node->disproof = 1 + ply / 30;
          } else {
#line 670
            node->proof = l + ply / 80;
#line 671
            node->disproof = 1 + ply / 80;
          }
        } else {
#line 676
          node->proof = l + ply / 150;
#line 677
          node->disproof = 1 + ply / 150;
        }
      }
    } else
#line 684
    if ((int )node->value == 0) {
#line 686
      node->proof = 100000000;
#line 687
      node->disproof = 0;
    } else
#line 689
    if ((int )node->value == 1) {
#line 691
      node->proof = 0;
#line 692
      node->disproof = 100000000;
    } else
#line 694
    if ((int )node->value == 3) {
#line 697
      node->proof = 50000;
#line 698
      node->disproof = 50000;
    }
  } else {
#line 703
    tmp___7 = 1;
#line 703
    node->disproof = tmp___7;
#line 703
    node->proof = tmp___7;
  }
#line 705
  return;
}
}
#line 707 "proof.c"
void develop_node(node_t *node ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int i ;
  int l ;
  node_t *newnode ;
  int leg ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  xbool tmp___4 ;
  int tmp___5 ;

  {
#line 726
  tmp = in_check();
#line 726
  ic = (int )tmp;
#line 728
  if (Variant != 4) {
#line 730
    num_moves = 0;
#line 731
    gen(& moves[0]);
#line 732
    num_moves = numb_moves;
  } else {
#line 736
    captures = (xbool )1;
#line 737
    leg = 0;
#line 738
    num_moves = 0;
#line 740
    gen(& moves[0]);
#line 741
    num_moves = numb_moves;
#line 742
    captures = (xbool )0;
#line 744
    i = 0;
#line 744
    while (i < num_moves) {
#line 746
      make(& moves[0], i);
#line 749
      tmp___0 = check_legal(& moves[0], i, ic);
#line 749
      if (tmp___0) {
#line 751
        leg = 1;
#line 752
        unmake(& moves[0], i);
#line 753
        break;
      }
#line 756
      unmake(& moves[0], i);
#line 744
      i ++;
    }
#line 759
    if (leg == 0) {
#line 761
      captures = (xbool )0;
#line 762
      num_moves = 0;
#line 763
      gen(& moves[0]);
#line 764
      num_moves = numb_moves;
    }
  }
#line 771
  tmp___1 = Xmalloc((int )((unsigned long )num_moves * sizeof(node_t **)));
#line 771
  node->children = (node_t **)tmp___1;
#line 777
  l = 0;
#line 779
  i = 0;
#line 779
  while (i < num_moves) {
#line 781
    hash_history[(move_number + ply) - 1] = hash;
#line 783
    make(& moves[0], i);
#line 786
    tmp___4 = check_legal(& moves[0], i, ic);
#line 786
    if (tmp___4) {
#line 791
      tmp___2 = Xmalloc((int )sizeof(node_t ));
#line 791
      newnode = (node_t *)tmp___2;
#line 796
      newnode->value = (unsigned char)0;
#line 806
      tmp___3 = 1;
#line 806
      newnode->disproof = tmp___3;
#line 806
      newnode->proof = tmp___3;
#line 811
      newnode->num_children = (unsigned char)0;
#line 812
      newnode->parent = node;
#line 813
      newnode->evaluated = (unsigned char)0;
#line 814
      newnode->expanded = (unsigned char)0;
#line 815
      newnode->move = moves[i];
#line 822
      *(node->children + l) = newnode;
#line 824
      l ++;
#line 830
      pn_eval(newnode);
#line 834
      set_proof_and_disproof_numbers(newnode);
#line 836
      unmake(& moves[0], i);
    } else {
#line 840
      unmake(& moves[0], i);
    }
#line 779
    i ++;
  }
#line 843
  node->expanded = (unsigned char)1;
#line 844
  node->num_children = (unsigned char )l;
#line 852
  if ((int )node->num_children == 0) {
#line 854
    node->expanded = (unsigned char)0;
#line 855
    node->evaluated = (unsigned char)1;
#line 856
    if (Variant != 3) {
#line 856
      if (Variant != 4) {
#line 858
        node->value = (unsigned char)3;
      } else {
#line 856
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 862
      if (white_to_move) {
#line 862
        tmp___5 = 0;
      } else {
#line 862
        tmp___5 = 1;
      }
#line 862
      if (tmp___5 == root_to_move) {
#line 864
        node->value = (unsigned char)1;
      } else {
#line 868
        node->value = (unsigned char)0;
      }
    }
  }
#line 878
  nodecount += num_moves;
#line 880
  frees += num_moves;
#line 886
  return;
}
}
#line 888 "proof.c"
void update_ancestors(node_t *node ) 
{ 
  node_t *tnode ;
  node_t *prevnode ;

  {
#line 892
  tnode = node;
#line 893
  prevnode = node;
#line 895
  while ((unsigned long )tnode != (unsigned long )((node_t *)0)) {
#line 897
    set_proof_and_disproof_numbers(tnode);
#line 899
    prevnode = tnode;
#line 901
    if (tnode->move.target != 0) {
#line 903
      unmake(& tnode->move, 0);
    }
#line 906
    tnode = tnode->parent;
  }
#line 909
  if (prevnode->move.target != 0) {
#line 911
    make(& prevnode->move, 0);
  }
#line 914
  return;
}
}
#line 918 "proof.c"
void pn2_eval(node_t *root ) 
{ 
  node_t *mostproving ;
  node_t *currentnode ;
  node_t *oldparent ;

  {
#line 928
  nodecount2 = 0;
#line 929
  pn2 = 1;
#line 931
  oldparent = root->parent;
#line 932
  root->parent = (struct node *)0;
#line 934
  pn_eval(root);
#line 936
  set_proof_and_disproof_numbers(root);
#line 938
  currentnode = root;
#line 940
  while (1) {
#line 940
    if (root->proof != 0) {
#line 940
      if (root->disproof != 0) {
#line 940
        if (! (nodecount2 < nodecount)) {
#line 940
          break;
        }
      } else {
#line 940
        break;
      }
    } else {
#line 940
      break;
    }
#line 942
    mostproving = select_most_proving(root);
#line 943
    develop_node(mostproving);
#line 944
    update_ancestors(mostproving);
  }
#line 947
  root->expanded = (unsigned char)0;
#line 948
  root->num_children = (unsigned char)0;
#line 950
  root->parent = oldparent;
#line 952
  pn2 = 0;
#line 954
  return;
}
}
#line 956 "proof.c"
void proofnumberscan(void) 
{ 
  move_s moves[512] ;
  int islegal[512] ;
  int nodesspent[512] ;
  int i ;
  int l ;
  int legal ;
  int num_moves ;
  rtime_t xstart_time ;
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  int leastlooked ;
  int leastlooked_l ;
  int leastlooked_i ;
  int losers ;
  int xnodecount ;
  int firsts ;
  int alternates ;
  char output[8] ;
  int ic ;
  float bdp ;
  int altlosers ;
  void *tmp ;
  void *tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  rtime_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 967
  leastlooked_l = 0;
#line 967
  leastlooked_i = 0;
#line 976
  xstart_time = rtime();
#line 978
//AD  tmp = calloc((size_t )PBSize, sizeof(node_t ));
#line 978
//AD  membuff = (unsigned char *)tmp;
  membuff = (unsigned char *)calloc((size_t )PBSize, sizeof(node_t )); //AD
#line 980
//AD  tmp___0 = calloc((size_t )1, sizeof(node_t ));
#line 980
//AD  root = (node_t *)tmp___0;
  root = (node_t *)calloc((size_t )1, sizeof(node_t )); //AD
#line 982
  gen(& moves[0]);
#line 983
  num_moves = numb_moves;
#line 985
  alllosers = 0;
#line 986
  memset((void *)(rootlosers), 0, sizeof(rootlosers));
#line 987
  memset((void *)(nodesspent), 0, sizeof(nodesspent));
#line 989
  pn_move = dummy;
#line 991
  legal = 0;
#line 993
  tmp___1 = in_check();
#line 993
  ic = (int )tmp___1;
#line 995
  i = 0;
#line 995
  while (i < num_moves) {
#line 997
    make(& moves[0], i);
#line 1000
    tmp___2 = check_legal(& moves[0], i, ic);
#line 1000
    if (tmp___2) {
#line 1002
      legal ++;
#line 1003
      islegal[i] = 1;
    } else {
#line 1007
      islegal[i] = 0;
    }
#line 1010
    unmake(& moves[0], i);
#line 995
    i ++;
  }
#line 1013
  if (legal == 0) {
#line 1015
    Xfree();
#line 1016
    free((void *)membuff);
#line 1017
    free((void *)root);
#line 1018
    return;
  }
#line 1021
  losers = 0;
#line 1023
  nodecount = 1;
#line 1024
  iters = 0;
#line 1025
  maxply = 0;
#line 1026
  forwards = 0;
#line 1027
  firsts = 0;
#line 1028
  alternates = 0;
#line 1029
  hash_history[(move_number + ply) - 1] = hash;
#line 1030
  if (white_to_move) {
#line 1030
    root_to_move = 0;
  } else {
#line 1030
    root_to_move = 1;
  }
#line 1032
  pn_eval(root);
#line 1034
  if ((int )root->value == 1) {
#line 1036
    Xfree();
#line 1037
    free((void *)membuff);
#line 1038
    free((void *)root);
#line 1039
    pn_move = dummy;
#line 1040
    return;
  } else
#line 1034
  if ((int )root->value == 0) {
#line 1036
    Xfree();
#line 1037
    free((void *)membuff);
#line 1038
    free((void *)root);
#line 1039
    pn_move = dummy;
#line 1040
    return;
  }
#line 1043
  set_proof_and_disproof_numbers(root);
#line 1045
  while (1) {
#line 1045
    tmp___3 = rtime();
#line 1045
    tmp___4 = rdifftime(tmp___3, xstart_time);
#line 1045
    if (tmp___4 < pn_time) {
#line 1045
      tmp___5 = interrupt();
#line 1045
      if (tmp___5) {
#line 1045
        break;
      } else
#line 1045
      if ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t )) {
#line 1045
        if (root->proof != 0) {
#line 1045
          if (! (root->disproof != 0)) {
#line 1045
            break;
          }
        } else {
#line 1045
          break;
        }
      } else {
#line 1045
        break;
      }
    } else {
#line 1045
      break;
    }
#line 1050
    iters ++;
#line 1051
    xnodecount = nodecount;
#line 1053
    if (nodecount % 100 < 66) {
#line 1055
      firsts ++;
#line 1058
      currentnode = root;
#line 1060
      mostproving = select_most_proving(currentnode);
#line 1061
      develop_node(mostproving);
#line 1062
      update_ancestors(mostproving);
#line 1065
      i = 0;
#line 1066
      while ((*(root->children + i))->proof != root->proof) {
#line 1066
        i ++;
      }
#line 1068
      nodesspent[i] += nodecount - xnodecount;
#line 1070
      if (root->proof == 0) {
#line 1070
        if (root->disproof == 100000000) {
#line 1072
          forcedwin = 1;
#line 1074
          if (! kibitzed) {
#line 1076
            kibitzed = (xbool )1;
#line 1077
            printf((char const   * __restrict  )"tellics kibitz Forced win!\n");
          }
#line 1080
          pn_move = (*(root->children + i))->move;
        } else {
#line 1070
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1083
      if (root->disproof == 0) {
#line 1083
        if (root->proof == 100000000) {
#line 1085
          pn_move = dummy;
#line 1086
          losers ++;
        }
      }
    } else {
#line 1092
      alternates ++;
#line 1094
      leastlooked = 100000000;
#line 1095
      l = 0;
#line 1097
      i = 0;
#line 1097
      while (i < num_moves) {
#line 1099
        if (nodesspent[i] < leastlooked) {
#line 1099
          if (islegal[i]) {
#line 1099
            if (! rootlosers[i]) {
#line 1101
              leastlooked = nodesspent[i];
#line 1102
              leastlooked_i = i;
#line 1103
              leastlooked_l = l;
            }
          }
        }
#line 1105
        if (islegal[i]) {
#line 1105
          l ++;
        }
#line 1097
        i ++;
      }
#line 1108
      if (leastlooked == 100000000) {
#line 1111
        nodecount += 30;
#line 1112
        continue;
      }
#line 1115
      make(& moves[0], leastlooked_i);
#line 1117
      currentnode = *(root->children + leastlooked_l);
#line 1119
      mostproving = select_most_proving(currentnode);
#line 1120
      develop_node(mostproving);
#line 1121
      update_ancestors(mostproving);
#line 1123
      nodesspent[leastlooked_i] += nodecount - xnodecount;
#line 1127
      if ((*(root->children + leastlooked_l))->proof == 0) {
#line 1127
        if ((*(root->children + leastlooked_l))->disproof == 100000000) {
#line 1131
          forcedwin = 1;
#line 1133
          if (! kibitzed) {
#line 1135
            kibitzed = (xbool )1;
#line 1136
            printf((char const   * __restrict  )"tellics kibitz Forced win! (alt)\n");
          }
#line 1139
          pn_move = (*(root->children + leastlooked_l))->move;
        } else {
#line 1127
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1141
      if ((*(root->children + leastlooked_l))->disproof == 0) {
#line 1141
        if ((*(root->children + leastlooked_l))->proof == 100000000) {
#line 1145
          rootlosers[leastlooked_i] = 1;
#line 1146
          losers ++;
        }
      }
    }
  }
#line 1151
  l = 0;
#line 1152
  bdp = (float )-1;
#line 1153
  altlosers = 0;
#line 1155
  if (root->expanded) {
#line 1157
    i = 0;
#line 1157
    while (i < num_moves) {
#line 1159
      if (islegal[i]) {
#line 1161
        comp_to_san(moves[i], output);
#line 1166
        if ((*(root->children + l))->proof != 0) {
#line 1168
          if ((float )(*(root->children + l))->disproof / (float )(*(root->children + l))->proof > bdp) {
#line 1170
            bdp = (float )(*(root->children + l))->disproof / (float )(*(root->children + l))->proof;
#line 1171
            pn_move = (*(root->children + l))->move;
          }
#line 1173
          if ((*(root->children + l))->disproof == 0) {
#line 1173
            if ((*(root->children + l))->proof == 100000000) {
#line 1175
              altlosers ++;
            }
          }
        } else {
#line 1180
          forcedwin = 1;
#line 1181
          pn_move = (*(root->children + l))->move;
#line 1182
          bdp = (float )100000000;
        }
#line 1184
        l ++;
      }
#line 1157
      i ++;
    }
  }
#line 1189
  comp_to_san(pn_move, output);
#line 1191
  if (xb_mode) {
#line 1191
    if (post) {
#line 1192
      printf((char const   * __restrict  )"tellics whisper proof %d, disproof %d, %d losers, highest depth %d, primary %d, secondary %d\n",
             root->proof, root->disproof, altlosers, maxply, firsts, alternates);
    }
  }
#line 1208
  if (altlosers == legal - 1) {
#line 1210
    printf((char const   * __restrict  )"tellics whisper Forced reply\n");
#line 1212
    i = 0;
#line 1212
    while (i < num_moves) {
#line 1214
      if (! rootlosers[i]) {
#line 1214
        if (islegal[i]) {
#line 1218
          forcedwin = 1;
#line 1219
          pn_move = moves[i];
#line 1220
          break;
        }
      }
#line 1212
      i ++;
    }
  }
#line 1225
  if (altlosers == legal) {
#line 1227
    alllosers = 1;
  }
#line 1230
  Xfree();
#line 1231
  free((void *)membuff);
#line 1232
  free((void *)root);
#line 1234
  return;
}
}
#line 1239 "proof.c"
void proofnumbersearch(void) 
{ 
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  rtime_t xstart_time ;
  char output[8192] ;
  char PV[8192] ;
  int i ;
  float bdp ;
  int oldply ;
  void *tmp ;
  void *tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  rtime_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1252
  nodecount = 1;
#line 1253
  iters = 0;
#line 1254
  frees = 0;
#line 1255
  ply = 1;
#line 1256
  maxply = 0;
#line 1257
  forwards = 0;
#line 1258
  hash_history[(move_number + ply) - 1] = hash;
#line 1259
  if (white_to_move) {
#line 1259
    root_to_move = 0;
  } else {
#line 1259
    root_to_move = 1;
  }
#line 1263
  xstart_time = rtime();
#line 1265
//AD  tmp = calloc((size_t )1, sizeof(node_t ));
#line 1265
//AD  root = (node_t *)tmp;
  root = (node_t *)calloc((size_t )1, sizeof(node_t )); //AD
#line 1267
//AD  tmp___0 = calloc((size_t )PBSize, sizeof(node_t ));
#line 1267
//AD  membuff = (unsigned char *)tmp___0;
  membuff = (unsigned char *) calloc((size_t )PBSize, sizeof(node_t )); //AD
#line 1269
  pn_eval(root);
#line 1271
  if ((int )root->value == 0) {
#line 1273
    pn_move = dummy;
#line 1274
    Xfree();
#line 1275
    free((void *)root);
#line 1276
    free((void *)membuff);
#line 1277
    return;
  }
#line 1280
  set_proof_and_disproof_numbers(root);
#line 1282
  currentnode = root;
#line 1284
  while (1) {
#line 1284
    if (root->proof != 0) {
#line 1284
      if (root->disproof != 0) {
#line 1284
        if (! ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t ))) {
#line 1284
          break;
        }
      } else {
#line 1284
        break;
      }
    } else {
#line 1284
      break;
    }
#line 1287
    mostproving = select_most_proving(currentnode);
#line 1288
    develop_node(mostproving);
#line 1289
    update_ancestors(mostproving);
#line 1291
    iters ++;
#line 1296
    if (iters % 32 == 0) {
#line 1346
      tmp___1 = rtime();
#line 1346
      tmp___2 = rdifftime(tmp___1, xstart_time);
#line 1346
      if (tmp___2 > pn_time) {
#line 1346
        tmp___3 = interrupt();
#line 1346
        if (! tmp___3) {
#line 1347
          break;
        }
      }
    }
  }
#line 1351
  printf((char const   * __restrict  )"P: %d D: %d N: %d S: %d Mem: %2.2fM Iters: %d MaxDepth: %d\n",
         root->proof, root->disproof, nodecount, frees, (double )((float )((unsigned long )nodecount * sizeof(node_t )) / (float )1048576),
         iters, maxply);
#line 1353
  if (xb_mode) {
#line 1353
    if (post) {
#line 1354
      printf((char const   * __restrict  )"tellics whisper proof %d, disproof %d, %d nodes, %d forwards, %d iters, highest depth %d\n",
             root->proof, root->disproof, nodecount, forwards, iters, maxply);
    }
  }
#line 1356
  if (! xb_mode) {
#line 1357
    tmp___4 = rtime();
#line 1357
    tmp___5 = rdifftime(tmp___4, xstart_time);
#line 1357
    printf((char const   * __restrict  )"Time : %f\n", (double )((float )tmp___5) / 100.);
  }
#line 1359
  while ((unsigned long )currentnode != (unsigned long )root) {
#line 1361
    unmake(& currentnode->move, 0);
#line 1362
    currentnode = currentnode->parent;
  }
#line 1365
  if (root->proof == 0) {
#line 1367
    root->value = (unsigned char)1;
#line 1369
    printf((char const   * __restrict  )"This position is WON.\n");
#line 1370
    printf((char const   * __restrict  )"PV: ");
#line 1372
    memset((void *)(output), 0, sizeof(output));
#line 1373
    memset((void *)(PV), 0, sizeof(PV));
#line 1375
    ply = 1;
#line 1377
    while (currentnode->expanded) {
#line 1379
      if (white_to_move) {
#line 1379
        tmp___6 = 0;
      } else {
#line 1379
        tmp___6 = 1;
      }
#line 1379
      if (tmp___6 == root_to_move) {
#line 1381
        i = 0;
#line 1382
        while ((*(currentnode->children + i))->proof != currentnode->proof) {
#line 1384
          i ++;
        }
      } else {
#line 1389
        i = 0;
#line 1390
        while ((*(currentnode->children + i))->disproof != currentnode->disproof) {
#line 1392
          i ++;
        }
      }
#line 1396
      currentnode = *(currentnode->children + i);
#line 1398
      comp_to_coord(currentnode->move, output);
#line 1399
      printf((char const   * __restrict  )"%s ", output);
#line 1400
      strcat((char * __restrict  )(PV), (char const   * __restrict  )(output));
#line 1401
      strcat((char * __restrict  )(PV), (char const   * __restrict  )" ");
#line 1403
      make(& currentnode->move, 0);
#line 1405
      if (ply == 1) {
#line 1406
        pn_move = currentnode->move;
      }
#line 1408
      forcedwin = 1;
    }
#line 1411
    oldply = ply;
#line 1413
    while ((unsigned long )currentnode != (unsigned long )root) {
#line 1415
      unmake(& currentnode->move, 0);
#line 1416
      currentnode = currentnode->parent;
    }
#line 1419
    if (! kibitzed) {
#line 1419
      if (xb_mode) {
#line 1419
        if (post) {
#line 1421
          kibitzed = (xbool )1;
#line 1422
          printf((char const   * __restrict  )"\ntellics kibitz Forced win in %d moves.\n",
                 oldply / 2);
        }
      }
    }
#line 1425
    if (oldply == 1) {
#line 1425
      if (root->proof == 0) {
#line 1425
        goto _L;
      } else
#line 1425
      if (root->disproof == 0) {
        _L: /* CIL Label */ 
#line 1427
        if (root_to_move == 0) {
#line 1429
          printf((char const   * __restrict  )"\n1-0 {White mates}\n");
#line 1430
          result = 3;
        } else {
#line 1434
          printf((char const   * __restrict  )"\n0-1 {Black mates}\n");
#line 1435
          result = 2;
        }
      }
    }
#line 1439
    printf((char const   * __restrict  )"\n");
  } else
#line 1441
  if (root->disproof == 0) {
#line 1443
    root->value = (unsigned char)0;
#line 1444
    printf((char const   * __restrict  )"This position is LOST.\n");
#line 1446
    pn_move = dummy;
  } else {
#line 1450
    root->value = (unsigned char)2;
#line 1451
    printf((char const   * __restrict  )"This position is UNKNOWN.\n");
#line 1453
    pn_move = dummy;
  }
#line 1457
  bdp = (float )-1;
#line 1459
  i = 0;
#line 1459
  while (i < (int )root->num_children) {
#line 1461
    if ((*(root->children + i))->proof != 0) {
#line 1463
      if ((float )(*(root->children + i))->disproof / (float )(*(root->children + i))->proof > bdp) {
#line 1465
        bdp = (float )(*(root->children + i))->disproof / (float )(*(root->children + i))->proof;
#line 1466
        pn_move = (*(root->children + i))->move;
      }
    } else {
#line 1471
      pn_move = (*(root->children + i))->move;
#line 1472
      break;
    }
#line 1459
    i ++;
  }
#line 1476
  pn_saver = pn_move;
#line 1478
  free((void *)root);
#line 1479
  Xfree();
#line 1480
  free((void *)membuff);
#line 1484
  return;
}
}
#line 1487 "proof.c"
move_s proofnumbercheck(move_s compmove ) 
{ 
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  rtime_t xstart_time ;
  move_s resmove ;
  void *tmp ;
  void *tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;

  {
#line 1495
  if (piece_count <= 3) {
#line 1495
    if (Variant == 3) {
#line 1497
      return (compmove);
    }
  }
#line 1500
  nodecount = 0;
#line 1501
  iters = 0;
#line 1502
  frees = 0;
#line 1503
  ply = 1;
#line 1504
  maxply = 0;
#line 1507
  make(& compmove, 0);
#line 1509
  hash_history[(move_number + ply) - 1] = hash;
#line 1511
  if (white_to_move) {
#line 1511
    root_to_move = 0;
  } else {
#line 1511
    root_to_move = 1;
  }
#line 1515
  xstart_time = rtime();
#line 1517
//AD  tmp = calloc((size_t )1, sizeof(node_t ));
#line 1517
//AD  root = (node_t *)tmp;
  root = (node_t *)calloc((size_t )1, sizeof(node_t )); //AD
#line 1519
//AD  tmp___0 = calloc((size_t )PBSize, sizeof(node_t ));
#line 1519
//AD  membuff = (unsigned char *)tmp___0;
  membuff = (unsigned char *)calloc((size_t )PBSize, sizeof(node_t )); //AD
#line 1521
  pn_eval(root);
#line 1523
  set_proof_and_disproof_numbers(root);
#line 1525
  currentnode = root;
#line 1527
  while (1) {
#line 1527
    if (root->proof != 0) {
#line 1527
      if (root->disproof != 0) {
#line 1527
        if (! ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t ))) {
#line 1527
          break;
        }
      } else {
#line 1527
        break;
      }
    } else {
#line 1527
      break;
    }
#line 1530
    mostproving = select_most_proving(currentnode);
#line 1531
    develop_node(mostproving);
#line 1532
    update_ancestors(mostproving);
#line 1534
    iters ++;
#line 1536
    if (iters % 32 == 0) {
#line 1539
      tmp___1 = rtime();
#line 1539
      tmp___2 = rdifftime(tmp___1, xstart_time);
#line 1539
      if (tmp___2 > pn_time) {
#line 1540
        break;
      }
    }
  }
#line 1544
  printf((char const   * __restrict  )"P: %d D: %d N: %d S: %d Mem: %2.2fM Iters: %d\n",
         root->proof, root->disproof, nodecount, frees, (double )((float )((unsigned long )nodecount * sizeof(node_t )) / (float )1048576),
         iters);
#line 1546
  while ((unsigned long )currentnode != (unsigned long )root) {
#line 1548
    unmake(& currentnode->move, 0);
#line 1549
    currentnode = currentnode->parent;
  }
#line 1552
  unmake(& compmove, 0);
#line 1554
  if (root->proof == 0) {
#line 1557
    root->value = (unsigned char)1;
#line 1560
    resmove = pn_move;
#line 1562
    s_threat = 1;
  } else
#line 1564
  if (root->disproof == 0) {
#line 1568
    root->value = (unsigned char)0;
#line 1569
    resmove = compmove;
  } else {
#line 1574
    root->value = (unsigned char)2;
#line 1575
    resmove = compmove;
  }
#line 1579
  Xfree();
#line 1580
  free((void *)root);
#line 1581
  free((void *)membuff);
#line 1585
  return (resmove);
}
}
#line 1 "rcfile.o"
#pragma merger("0","/tmp/cil-j6swoiAU.i","")
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "./protos.h"
void alloc_hash(void) ;
#line 133
void read_rcfile(void) ;
#line 138 "./extvars.h"
int cfg_booklearn  ;
#line 139 "./extvars.h"
int cfg_devscale  ;
#line 140 "./extvars.h"
int cfg_razordrop  ;
#line 141 "./extvars.h"
int cfg_cutdrop  ;
#line 142 "./extvars.h"
int cfg_futprune  ;
#line 143 "./extvars.h"
int cfg_onerep  ;
#line 144 "./extvars.h"
int cfg_recap  ;
#line 145 "./extvars.h"
int cfg_smarteval  ;
#line 146 "./extvars.h"
int cfg_attackeval  ;
#line 147 "./extvars.h"
float cfg_scalefac  ;
#line 148 "./extvars.h"
int cfg_ksafety[15][9]  ;
#line 149 "./extvars.h"
int cfg_tropism[5][7]  ;
#line 150 "./extvars.h"
int havercfile  ;
#line 151 "./extvars.h"
int TTSize  ;
#line 152 "./extvars.h"
int PBSize  ;
#line 153 "./extvars.h"
int ECacheSize  ;
#line 166
char setcode[30] ;
#line 14 "rcfile.c"
FILE *rcfile  ;
#line 15 "rcfile.c"
char line[256]  ;
#line 35 "rcfile.c"
void read_rcfile(void) 
{ 
  unsigned int setc ;

  {
#line 39
  TTSize = 3000000;
#line 40
  ECacheSize = 1000000;
#line 41
  PBSize = 200000;
#line 43
  cfg_devscale = 1;
#line 44
  cfg_scalefac = (float )1.0;
#line 45
  cfg_razordrop = 1;
#line 46
  cfg_cutdrop = 0;
#line 47
  cfg_futprune = 1;
#line 48
  cfg_smarteval = 1;
#line 49
  cfg_attackeval = 0;
#line 50
  cfg_onerep = 1;
#line 51
  cfg_recap = 0;
#line 53
  havercfile = 0;
#line 55
  setc = (unsigned int )(((((((havercfile + (cfg_devscale << 1)) + (1 << 2)) + (cfg_razordrop << 3)) + (cfg_cutdrop << 4)) + (cfg_futprune << 5)) + (cfg_smarteval << 6)) + (cfg_attackeval << 7));
#line 65
  sprintf((char * __restrict  )(setcode), (char const   * __restrict  )"%u", setc);
#line 67
  initialize_eval();
#line 68
  alloc_hash();
#line 69
  alloc_ecache();
#line 71
  return;
}
}
#line 1 "search.o"
#pragma merger("0","/tmp/cil-_y25m5EB.i","")
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 12 "./extvars.h"
int pv_length[300] ;
#line 12
int i_depth ;
#line 16
int raw_nodes ;
#line 16
int killer_scores[300] ;
#line 16
int killer_scores2[300] ;
#line 16
int killer_scores3[300] ;
#line 16
int moves_to_tc ;
#line 16
int inc ;
#line 16
int time_left ;
#line 16
int time_cushion ;
#line 16
int time_for_move ;
#line 16
int cur_score ;
#line 20
unsigned int history_h[144][144] ;
#line 22
xbool searching_pv ;
#line 22
xbool time_exit ;
#line 22
xbool time_failure ;
#line 25
move_s pv[300][300] ;
#line 25
move_s killer1[300] ;
#line 25
move_s killer2[300] ;
#line 25
move_s killer3[300] ;
#line 29
move_s path[300] ;
#line 32
rtime_t start_time ;
#line 85
xbool is_pondering ;
#line 87 "./extvars.h"
unsigned int FH  ;
#line 87 "./extvars.h"
unsigned int FHF  ;
#line 87
unsigned int PVS ;
#line 87
unsigned int FULL ;
#line 87
unsigned int PVSF ;
#line 88 "./extvars.h"
unsigned int ext_recap  ;
#line 88 "./extvars.h"
unsigned int ext_onerep  ;
#line 89 "./extvars.h"
unsigned int razor_drop  ;
#line 89 "./extvars.h"
unsigned int razor_material  ;
#line 103
xbool is_analyzing ;
#line 112 "./extvars.h"
int tradefreely  ;
#line 114 "./extvars.h"
char true_i_depth  ;
#line 122 "./extvars.h"
int bestmovenum  ;
#line 124 "./extvars.h"
int ugly_ep_hack  ;
#line 136 "./extvars.h"
int s_threat  ;
#line 162 "./extvars.h"
int moveleft  ;
#line 163 "./extvars.h"
int movetotal  ;
#line 164 "./extvars.h"
char searching_move[20]  ;
#line 13 "./protos.h"
int allocate_time(void) ;
#line 32
void order_moves(move_s *moves , int *move_ordering , int *see_values , int num_moves ,
                 int best ) ;
#line 35
void perft(int depth ) ;
#line 37
void post_thinking(int score ) ;
#line 38
void post_fl_thinking(int score , move_s *failmove ) ;
#line 39
void post_fh_thinking(int score , move_s *failmove ) ;
#line 40
void post_fail_thinking(int score , move_s *failmove ) ;
#line 41
void print_move(move_s *moves , int m , FILE *stream ) ;
#line 52
int qsearch(int alpha , int beta , int depth ) ;
#line 55
xbool remove_one(int *marker , int *move_ordering , int num_moves ) ;
#line 60
int search(int alpha , int beta , int depth , int is_null ) ;
#line 61
move_s search_root(int originalalpha , int originalbeta , int depth ) ;
#line 65
void tree(int depth , int indent , FILE *output , char *disp_b ) ;
#line 93
void QStoreTT(int score , int alpha , int beta , int best ) ;
#line 94
int ProbeTT(int *score , int beta , int *best , int *threat , int *donull , int depth ) ;
#line 95
int QProbeTT(int *score , int *best ) ;
#line 120
void stringize_pv(char *str ) ;
#line 141
int see(int color , int square , int from ) ;
#line 16 "search.c"
unsigned int drop_cuts  ;
#line 24 "search.c"
char postpv[256]  ;
#line 30 "search.c"
int legals  ;
#line 32 "search.c"
int failed  ;
#line 33 "search.c"
int extendedtime  ;
#line 39 "search.c"
unsigned int rootnodecount[512]  ;
#line 41 "search.c"
xbool checks[300]  ;
#line 42 "search.c"
xbool recaps[300]  ;
#line 43 "search.c"
xbool singular[300]  ;
#line 55 "search.c"
void order_moves(move_s *moves , int *move_ordering , int *see_values , int num_moves ,
                 int best ) 
{ 
  int promoted ;
  int captured ;
  int i ;
  int from ;
  int target ;
  int seev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 63
  if (searching_pv) {
#line 64
    searching_pv = (xbool )0;
#line 65
    i = 0;
#line 65
    while (i < num_moves) {
#line 66
      from = (moves + i)->from;
#line 67
      target = (moves + i)->target;
#line 68
      promoted = (moves + i)->promoted;
#line 69
      captured = (moves + i)->captured;
#line 73
      if (captured != 13) {
#line 76
        tmp___2 = abs(material[captured]);
#line 76
        tmp___3 = abs(material[board[from]]);
#line 76
        if (tmp___2 + 15 >= tmp___3) {
#line 78
          tmp = abs(material[captured]);
#line 78
          tmp___0 = abs(material[board[from]]);
#line 78
          *(see_values + i) = tmp - (tmp___0 >> 4);
#line 79
          *(move_ordering + i) = 50000000 + *(see_values + i);
        } else {
#line 83
          if (white_to_move) {
#line 83
            tmp___1 = 0;
          } else {
#line 83
            tmp___1 = 1;
          }
#line 83
          seev = see(tmp___1, target, from);
#line 85
          if (seev >= -50) {
#line 86
            *(move_ordering + i) = 50000000 + seev;
          } else {
#line 88
            *(move_ordering + i) = seev;
          }
#line 90
          *(see_values + i) = seev;
        }
      } else {
#line 94
        *(move_ordering + i) = 0;
      }
#line 97
      if (from == pv[1][ply].from) {
#line 97
        if (target == pv[1][ply].target) {
#line 97
          if (promoted == pv[1][ply].promoted) {
#line 101
            searching_pv = (xbool )1;
#line 102
            *(move_ordering + i) = 100000000;
#line 104
            if (captured != 13) {
#line 107
              tmp___7 = abs(material[captured]);
#line 107
              tmp___8 = abs(material[board[from]]);
#line 107
              if (tmp___7 + 15 >= tmp___8) {
#line 109
                tmp___4 = abs(material[captured]);
#line 109
                tmp___5 = abs(material[board[from]]);
#line 109
                *(see_values + i) = tmp___4 - (tmp___5 >> 4);
              } else {
#line 113
                if (white_to_move) {
#line 113
                  tmp___6 = 0;
                } else {
#line 113
                  tmp___6 = 1;
                }
#line 113
                seev = see(tmp___6, target, from);
#line 114
                *(see_values + i) = seev;
              }
            }
          } else {
#line 97
            goto _L___7;
          }
        } else {
#line 97
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 118
      if (best != -1) {
#line 118
        if (best != -2) {
#line 118
          if (i == best) {
#line 120
            *(move_ordering + i) = 100000000;
#line 122
            if (captured != 13) {
#line 125
              tmp___12 = abs(material[captured]);
#line 125
              tmp___13 = abs(material[board[from]]);
#line 125
              if (tmp___12 + 15 >= tmp___13) {
#line 127
                tmp___9 = abs(material[captured]);
#line 127
                tmp___10 = abs(material[board[from]]);
#line 127
                *(see_values + i) = tmp___9 - (tmp___10 >> 4);
              } else {
#line 131
                if (white_to_move) {
#line 131
                  tmp___11 = 0;
                } else {
#line 131
                  tmp___11 = 1;
                }
#line 131
                seev = see(tmp___11, target, from);
#line 132
                *(see_values + i) = seev;
              }
            }
          } else {
#line 118
            goto _L___5;
          }
        } else {
#line 118
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 136
      if (best == -2) {
#line 139
        if (from == pv[ply + 1][ply + 1].from) {
#line 139
          if (target == pv[ply + 1][ply + 1].target) {
#line 139
            if (promoted == pv[ply + 1][ply + 1].promoted) {
#line 143
              *(move_ordering + i) = 100000000;
#line 145
              if (captured != 13) {
#line 148
                tmp___17 = abs(material[captured]);
#line 148
                tmp___18 = abs(material[board[from]]);
#line 148
                if (tmp___17 + 15 >= tmp___18) {
#line 150
                  tmp___14 = abs(material[captured]);
#line 150
                  tmp___15 = abs(material[board[from]]);
#line 150
                  *(see_values + i) = tmp___14 - (tmp___15 >> 4);
                } else {
#line 154
                  if (white_to_move) {
#line 154
                    tmp___16 = 0;
                  } else {
#line 154
                    tmp___16 = 1;
                  }
#line 154
                  seev = see(tmp___16, target, from);
#line 155
                  *(see_values + i) = seev;
                }
              }
            }
          }
        }
      } else
#line 166
      if (ply != 1) {
#line 166
        goto _L___3;
      } else
#line 166
      if (i_depth < 2) {
        _L___3: /* CIL Label */ 
#line 169
        *(move_ordering + i) = (int )((unsigned int )*(move_ordering + i) + history_h[from][target]);
#line 172
        if (from == killer1[ply].from) {
#line 172
          if (target == killer1[ply].target) {
#line 172
            if (promoted == killer1[ply].promoted) {
#line 174
              *(move_ordering + i) += 25000000;
            } else {
#line 172
              goto _L___2;
            }
          } else {
#line 172
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 175
        if (from == killer2[ply].from) {
#line 175
          if (target == killer2[ply].target) {
#line 175
            if (promoted == killer2[ply].promoted) {
#line 177
              *(move_ordering + i) += 20000000;
            } else {
#line 175
              goto _L___0;
            }
          } else {
#line 175
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 178
        if (from == killer3[ply].from) {
#line 178
          if (target == killer3[ply].target) {
#line 178
            if (promoted == killer3[ply].promoted) {
#line 180
              *(move_ordering + i) += 15000000;
            }
          }
        }
      } else
#line 184
      if (nodes / 100 > 100000000) {
#line 186
        *(move_ordering + i) = (int )(rootnodecount[i] / 1000U);
      } else {
#line 190
        *(move_ordering + i) = (int )(rootnodecount[i] / 100U);
      }
#line 65
      i ++;
    }
  } else {
#line 199
    i = 0;
#line 199
    while (i < num_moves) {
#line 200
      from = (moves + i)->from;
#line 201
      target = (moves + i)->target;
#line 202
      promoted = (moves + i)->promoted;
#line 203
      captured = (moves + i)->captured;
#line 207
      if (best != -1) {
#line 207
        if (i == best) {
#line 209
          *(move_ordering + i) = 100000000;
#line 212
          if (captured != 13) {
#line 215
            tmp___22 = abs(material[captured]);
#line 215
            tmp___23 = abs(material[board[from]]);
#line 215
            if (tmp___22 + 15 >= tmp___23) {
#line 217
              tmp___19 = abs(material[captured]);
#line 217
              tmp___20 = abs(material[board[from]]);
#line 217
              *(see_values + i) = tmp___19 - (tmp___20 >> 4);
            } else {
#line 221
              if (white_to_move) {
#line 221
                tmp___21 = 0;
              } else {
#line 221
                tmp___21 = 1;
              }
#line 221
              seev = see(tmp___21, target, from);
#line 222
              *(see_values + i) = seev;
            }
          }
        } else {
#line 207
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 227
      if (best == -2) {
#line 230
        if (from == pv[ply + 1][ply + 1].from) {
#line 230
          if (target == pv[ply + 1][ply + 1].target) {
#line 230
            if (promoted == pv[ply + 1][ply + 1].promoted) {
#line 234
              *(move_ordering + i) = 100000000;
#line 236
              if (captured != 13) {
#line 239
                tmp___27 = abs(material[captured]);
#line 239
                tmp___28 = abs(material[board[from]]);
#line 239
                if (tmp___27 + 15 >= tmp___28) {
#line 241
                  tmp___24 = abs(material[captured]);
#line 241
                  tmp___25 = abs(material[board[from]]);
#line 241
                  *(see_values + i) = tmp___24 - (tmp___25 >> 4);
                } else {
#line 245
                  if (white_to_move) {
#line 245
                    tmp___26 = 0;
                  } else {
#line 245
                    tmp___26 = 1;
                  }
#line 245
                  seev = see(tmp___26, target, from);
#line 246
                  *(see_values + i) = seev;
                }
              }
            }
          }
        }
      } else
#line 251
      if (captured != 13) {
#line 254
        tmp___32 = abs(material[captured]);
#line 254
        tmp___33 = abs(material[board[from]]);
#line 254
        if (tmp___32 + 15 >= tmp___33) {
#line 256
          tmp___29 = abs(material[captured]);
#line 256
          tmp___30 = abs(material[board[from]]);
#line 256
          *(see_values + i) = tmp___29 - (tmp___30 >> 4);
#line 257
          *(move_ordering + i) = 50000000 + *(see_values + i);
        } else {
#line 261
          if (white_to_move) {
#line 261
            tmp___31 = 0;
          } else {
#line 261
            tmp___31 = 1;
          }
#line 261
          seev = see(tmp___31, target, from);
#line 263
          if (seev >= -50) {
#line 264
            *(move_ordering + i) = 50000000 + seev;
          } else {
#line 266
            *(move_ordering + i) = seev;
          }
#line 268
          *(see_values + i) = seev;
        }
      } else {
#line 272
        *(move_ordering + i) = 0;
      }
#line 277
      *(move_ordering + i) = (int )((unsigned int )*(move_ordering + i) + history_h[from][target]);
#line 280
      if (from == killer1[ply].from) {
#line 280
        if (target == killer1[ply].target) {
#line 280
          if (promoted == killer1[ply].promoted) {
#line 282
            *(move_ordering + i) += 25000000;
          } else {
#line 280
            goto _L___12;
          }
        } else {
#line 280
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 283
      if (from == killer2[ply].from) {
#line 283
        if (target == killer2[ply].target) {
#line 283
          if (promoted == killer2[ply].promoted) {
#line 285
            *(move_ordering + i) += 20000000;
          } else {
#line 283
            goto _L___10;
          }
        } else {
#line 283
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 286
      if (from == killer3[ply].from) {
#line 286
        if (target == killer3[ply].target) {
#line 286
          if (promoted == killer3[ply].promoted) {
#line 288
            *(move_ordering + i) += 15000000;
          }
        }
      }
#line 199
      i ++;
    }
  }
#line 292
  return;
}
}
#line 294 "search.c"
void perft(int depth ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;

  {
#line 300
  num_moves = 0;
#line 303
  if (! depth) {
#line 304
    raw_nodes ++;
#line 305
    return;
  }
#line 309
  gen(& moves[0]);
#line 310
  num_moves = numb_moves;
#line 312
  tmp = in_check();
#line 312
  ic = (int )tmp;
#line 315
  i = 0;
#line 315
  while (i < num_moves) {
#line 316
    make(& moves[0], i);
#line 319
    tmp___0 = check_legal(& moves[0], i, ic);
#line 319
    if (tmp___0) {
#line 322
      perft(depth - 1);
    }
#line 326
    unmake(& moves[0], i);
#line 315
    i ++;
  }
#line 330
  return;
}
}
#line 333 "search.c"
int qsearch(int alpha , int beta , int depth ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int score ;
  int standpat ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool legal_move ;
  xbool no_moves ;
  int sbest ;
  int best_score ;
  int best ;
  int delta ;
  int bound ;
  int originalalpha ;
  int oldtime ;
  int seev ;
  int tmp ;
  int tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  xbool tmp___6 ;

  {
#line 340
  score = -1000000;
#line 343
  no_moves = (xbool )1;
#line 349
  pv_length[ply] = ply;
#line 352
  if (! (nodes & ((1 << 16) - 1))) {
#line 354
    tmp___3 = interrupt();
#line 354
    if (tmp___3) {
#line 356
      time_exit = (xbool )1;
#line 357
      return (0);
    } else {
#line 359
      tmp___1 = rtime();
#line 359
      tmp___2 = rdifftime(tmp___1, start_time);
#line 359
      if (tmp___2 >= time_for_move) {
#line 359
        if (i_depth > 1) {
#line 361
          if (failed == 1) {
#line 361
            if (! extendedtime) {
#line 361
              if (! fixed_time) {
#line 361
                if (! go_fast) {
#line 361
                  if (Variant != 1) {
#line 361
                    if (time_for_move * 4 > 1000) {
#line 361
                      tmp___0 = time_for_move * 4;
                    } else {
#line 361
                      tmp___0 = 1000;
                    }
#line 361
                    if (time_left > tmp___0) {
#line 367
                      extendedtime = 1;
#line 368
                      oldtime = time_for_move;
#line 369
                      tmp = allocate_time();
#line 369
                      time_for_move += tmp;
#line 370
                      printf((char const   * __restrict  )"Extended from %d to %d, time left %d\n",
                             oldtime, time_for_move, time_left);
                    } else {
#line 376
                      time_exit = (xbool )1;
#line 377
                      return (0);
                    }
                  } else {
#line 376
                    time_exit = (xbool )1;
#line 377
                    return (0);
                  }
                } else {
#line 376
                  time_exit = (xbool )1;
#line 377
                  return (0);
                }
              } else {
#line 376
                time_exit = (xbool )1;
#line 377
                return (0);
              }
            } else {
#line 376
              time_exit = (xbool )1;
#line 377
              return (0);
            }
          } else {
#line 376
            time_exit = (xbool )1;
#line 377
            return (0);
          }
        }
      }
    }
  }
#line 383
  if (depth <= 0) {
#line 385
    score = eval(alpha, beta);
#line 386
    return (score);
  } else
#line 383
  if (ply >= 300) {
#line 385
    score = eval(alpha, beta);
#line 386
    return (score);
  }
#line 389
  qnodes ++;
#line 390
  nodes ++;
#line 392
  originalalpha = alpha;
#line 394
  tmp___4 = QProbeTT(& bound, & best);
#line 394
  switch (tmp___4) {
  case 3: 
#line 397
  return (bound);
#line 398
  break;
  case 1: 
#line 400
  if (bound <= alpha) {
#line 401
    return (bound);
  }
#line 402
  break;
  case 2: 
#line 404
  if (bound >= beta) {
#line 405
    return (bound);
  }
#line 406
  break;
  case 0: 
#line 408
  break;
  case 4: 
#line 410
  best = -1;
#line 411
  break;
  }
#line 414
  standpat = eval(alpha, beta);
#line 416
  if (standpat >= beta) {
#line 418
    QStoreTT(standpat, originalalpha, beta, 500);
#line 419
    return (standpat);
  } else
#line 421
  if (standpat > alpha) {
#line 422
    alpha = standpat;
  }
#line 425
  sbest = -1;
#line 426
  best_score = -1000000;
#line 427
  num_moves = 0;
#line 430
  gen(& moves[0]);
#line 431
  num_moves = numb_moves;
#line 433
  if (kingcap) {
#line 433
    return (50000);
  }
#line 435
  delta = (alpha - 150) - standpat;
#line 437
  order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, best);
#line 440
  while (1) {
#line 440
    tmp___6 = remove_one(& i, & move_ordering[0], num_moves);
#line 440
    if (! tmp___6) {
#line 440
      break;
    }
#line 442
    legal_move = (xbool )0;
#line 444
    if (! moves[i].promoted) {
#line 446
      seev = see_values[i];
#line 448
      if (seev < delta) {
#line 449
        continue;
      } else
#line 448
      if (seev < 0) {
#line 449
        continue;
      }
    }
#line 452
    make(& moves[0], i);
#line 454
    tmp___5 = qsearch(- beta, - alpha, depth - 1);
#line 454
    score = - tmp___5;
#line 456
    if (score != -50000) {
#line 458
      legal_move = (xbool )1;
#line 459
      no_moves = (xbool )0;
    }
#line 462
    unmake(& moves[0], i);
#line 464
    if (score > best_score) {
#line 464
      if (legal_move) {
#line 466
        best_score = score;
      }
    }
#line 470
    if (score > alpha) {
#line 470
      if (legal_move) {
#line 475
        best = i;
#line 478
        if (score >= beta) {
#line 480
          QStoreTT(score, originalalpha, beta, i);
#line 481
          return (score);
        }
#line 484
        alpha = score;
#line 487
        pv[ply][ply] = moves[i];
#line 488
        j = ply + 1;
#line 488
        while (j < pv_length[ply + 1]) {
#line 489
          pv[ply][j] = pv[ply + 1][j];
#line 488
          j ++;
        }
#line 490
        pv_length[ply] = pv_length[ply + 1];
      }
    }
  }
#line 499
  QStoreTT(alpha, originalalpha, beta, best);
#line 500
  return (alpha);
}
}
#line 504 "search.c"
xbool remove_one(int *marker , int *move_ordering , int num_moves ) 
{ 
  int i ;
  int best ;

  {
#line 510
  best = -1000000;
#line 512
  *marker = -1000000;
#line 514
  i = 0;
#line 514
  while (i < num_moves) {
#line 515
    if (*(move_ordering + i) > best) {
#line 516
      *marker = i;
#line 517
      best = *(move_ordering + i);
    }
#line 514
    i ++;
  }
#line 521
  if (*marker > -1000000) {
#line 522
    *(move_ordering + *marker) = -1000000;
#line 523
    return ((xbool )1);
  } else {
#line 526
    return ((xbool )0);
  }
}
}
#line 549 "search.c"
static int const   rc_index[14]  = 
#line 549
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )5,      (int const   )5,      (int const   )3, 
        (int const   )3,      (int const   )4,      (int const   )4,      (int const   )2, 
        (int const   )2,      (int const   )0};
#line 531 "search.c"
int search(int alpha , int beta , int depth , int is_null ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int score ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool no_moves ;
  xbool legal_move ;
  int bound ;
  int threat ;
  int donull ;
  int best ;
  int sbest ;
  int best_score ;
  int old_ep ;
  xbool incheck ;
  xbool first ;
  int extend ;
  int fscore ;
  int fmax ;
  int selective ;
  move_s kswap ;
  int ksswap ;
  int originalalpha ;
  int afterincheck ;
  int legalmoves ;
  int dropcut ;
  int oldtime ;
  int tmp ;
  int tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  xbool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  xbool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  xbool tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  xbool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  xbool tmp___30 ;
  xbool tmp___31 ;
  xbool tmp___32 ;

  {
#line 537
  score = -1000000;
#line 551
  nodes ++;
#line 554
  if (! (nodes & ((1 << 16) - 1))) {
#line 555
    tmp___3 = interrupt();
#line 555
    if (tmp___3) {
#line 557
      time_exit = (xbool )1;
#line 558
      return (0);
    } else {
#line 560
      tmp___1 = rtime();
#line 560
      tmp___2 = rdifftime(tmp___1, start_time);
#line 560
      if (tmp___2 >= time_for_move) {
#line 560
        if (i_depth > 1) {
#line 562
          if (failed == 1) {
#line 562
            if (! extendedtime) {
#line 562
              if (! fixed_time) {
#line 562
                if (! go_fast) {
#line 562
                  if (Variant != 1) {
#line 562
                    if (time_for_move * 4 > 1000) {
#line 562
                      tmp___0 = time_for_move * 4;
                    } else {
#line 562
                      tmp___0 = 1000;
                    }
#line 562
                    if (time_left > tmp___0) {
#line 568
                      extendedtime = 1;
#line 569
                      oldtime = time_for_move;
#line 570
                      tmp = allocate_time();
#line 570
                      time_for_move += tmp;
#line 571
                      printf((char const   * __restrict  )"Extended from %d to %d, time left %d\n",
                             oldtime, time_for_move, time_left);
                    } else {
#line 577
                      time_exit = (xbool )1;
#line 578
                      return (0);
                    }
                  } else {
#line 577
                    time_exit = (xbool )1;
#line 578
                    return (0);
                  }
                } else {
#line 577
                  time_exit = (xbool )1;
#line 578
                  return (0);
                }
              } else {
#line 577
                time_exit = (xbool )1;
#line 578
                return (0);
              }
            } else {
#line 577
              time_exit = (xbool )1;
#line 578
              return (0);
            }
          } else {
#line 577
            time_exit = (xbool )1;
#line 578
            return (0);
          }
        }
      }
    }
  }
#line 583
  originalalpha = alpha;
#line 584
  fmax = -1000000;
#line 586
  threat = 0;
#line 587
  extend = 0;
#line 589
  pv_length[ply] = ply;
#line 591
  tmp___4 = is_draw();
#line 591
  if (tmp___4) {
#line 593
    return (0);
  }
#line 596
  incheck = checks[ply];
#line 597
  singular[ply] = (xbool )0;
#line 598
  recaps[ply] = (xbool )0;
#line 601
  if (ply < 300) {
#line 601
    if (incheck) {
#line 601
      if (ply <= i_depth * 2) {
#line 603
        depth ++;
#line 604
        ext_check ++;
#line 605
        extend ++;
      } else
#line 601
      if (depth == 0) {
#line 603
        depth ++;
#line 604
        ext_check ++;
#line 605
        extend ++;
      } else {
#line 601
        goto _L___0;
      }
    } else {
#line 601
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 607
  if (ply < 300) {
#line 607
    if (ply > 2) {
#line 607
      if (ply <= i_depth * 2) {
#line 607
        if (! recaps[ply - 2]) {
#line 607
          if (cfg_recap) {
#line 607
            if (path[ply - 1].captured != 13) {
#line 607
              if (rc_index[path[ply - 1].captured] == rc_index[path[ply - 2].captured]) {
#line 613
                depth ++;
#line 614
                ext_recap ++;
#line 615
                extend ++;
#line 616
                recaps[ply] = (xbool )1;
              }
            }
          }
        }
      }
    }
  }
#line 620
  if (depth <= 0) {
#line 620
    goto _L___2;
  } else
#line 620
  if (ply >= 300) {
    _L___2: /* CIL Label */ 
#line 622
    if (Variant != 3) {
#line 622
      if (Variant != 4) {
#line 624
        captures = (xbool )1;
#line 625
        score = qsearch(alpha, beta, 300 - ply);
#line 626
        captures = (xbool )0;
#line 627
        return (score);
      } else {
#line 622
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 631
    if (Variant == 3) {
#line 633
      tmp___5 = suicide_eval();
#line 633
      return (tmp___5);
    } else
#line 636
    if (Variant == 4) {
#line 638
      i = losers_eval();
#line 640
      tmp___7 = abs(i);
#line 640
      if (tmp___7 == 1000000) {
#line 642
        if (i > 0) {
#line 642
          tmp___6 = 1000000 - ply;
        } else {
#line 642
          tmp___6 = -1000000 + ply;
        }
#line 642
        return (tmp___6);
      } else {
#line 646
        return (i);
      }
    }
  }
#line 652
  num_moves = 0;
#line 653
  no_moves = (xbool )1;
#line 655
  tmp___8 = ProbeTT(& bound, beta, & best, & threat, & donull, depth);
#line 655
  switch (tmp___8) {
  case 3: 
#line 658
  return (bound);
#line 659
  break;
  case 1: 
#line 661
  if (bound <= alpha) {
#line 662
    return (bound);
  }
#line 663
  break;
  case 2: 
#line 665
  if (bound >= beta) {
#line 666
    return (bound);
  }
#line 667
  break;
  case 0: 
#line 669
  break;
  case 4: 
#line 671
  best = -1;
#line 672
  threat = 0;
#line 673
  break;
  }
#line 676
  if (best == 500) {
#line 676
    best = -1;
  }
#line 678
  sbest = -1;
#line 679
  best_score = -1000000;
#line 681
  old_ep = ep_square;
#line 683
  legalmoves = 0;
#line 685
  if (Variant == 4) {
#line 687
    i = losers_eval();
#line 689
    tmp___10 = abs(i);
#line 689
    if (tmp___10 == 1000000) {
#line 691
      if (i > 0) {
#line 691
        tmp___9 = i - ply;
      } else {
#line 691
        tmp___9 = i + ply;
      }
#line 691
      return (tmp___9);
    }
#line 694
    captures = (xbool )1;
#line 695
    gen(& moves[0]);
#line 696
    num_moves = numb_moves;
#line 697
    captures = (xbool )0;
#line 699
    if (num_moves) {
#line 701
      i = 0;
#line 701
      while (i < num_moves) {
#line 703
        make(& moves[0], i);
#line 704
        tmp___11 = check_legal(& moves[0], i, (int )incheck);
#line 704
        if (tmp___11) {
#line 706
          legalmoves ++;
        }
#line 708
        unmake(& moves[0], i);
#line 701
        i ++;
      }
    }
#line 711
    if (! legalmoves) {
#line 713
      captures = (xbool )0;
#line 714
      gen(& moves[0]);
#line 715
      num_moves = numb_moves;
    }
#line 718
    legalmoves = 0;
  }
#line 721
  if (is_null == 0) {
#line 721
    if (phase != 2) {
#line 721
      goto _L___11;
    } else
#line 721
    if (phase == 2) {
#line 721
      if (depth <= 6) {
        _L___11: /* CIL Label */ 
#line 721
        if (! incheck) {
#line 721
          if (donull) {
#line 721
            if (! searching_pv) {
#line 721
              if (threat == 0) {
#line 721
                if (Variant != 3) {
#line 721
                  if (Variant != 4) {
#line 721
                    goto _L___4;
                  } else {
#line 721
                    goto _L___5;
                  }
                } else
                _L___5: /* CIL Label */ 
#line 721
                if (Variant == 4) {
#line 721
                  if (moves[0].captured == 13) {
                    _L___4: /* CIL Label */ 
#line 729
                    ep_square = 0;
#line 730
                    white_to_move ^= 1;
#line 731
                    ply ++;
#line 732
                    fifty ++;
#line 733
                    hash ^= 3735928559U;
#line 736
                    if (Variant != 2) {
#line 736
                      if (Variant != 4) {
#line 737
                        if (depth > 3) {
#line 737
                          tmp___12 = (depth - 2) - 1;
                        } else {
#line 737
                          tmp___12 = (depth - 1) - 1;
                        }
#line 737
                        tmp___13 = search(- beta, - beta + 1, tmp___12, 1);
#line 737
                        score = - tmp___13;
                      } else {
#line 739
                        tmp___14 = search(- beta, - beta + 1, (depth - 3) - 1, 1);
#line 739
                        score = - tmp___14;
                      }
                    } else {
#line 739
                      tmp___14 = search(- beta, - beta + 1, (depth - 3) - 1, 1);
#line 739
                      score = - tmp___14;
                    }
#line 741
                    hash ^= 3735928559U;
#line 742
                    fifty --;
#line 743
                    ply --;
#line 744
                    white_to_move ^= 1;
#line 745
                    ep_square = old_ep;
#line 747
                    if (time_exit) {
#line 747
                      return (0);
                    }
#line 749
                    NTries ++;
#line 751
                    if (score >= beta) {
#line 754
                      NCuts ++;
#line 756
                      StoreTT(score, alpha, beta, 500, 0, depth);
#line 758
                      return (score);
                    } else
#line 760
                    if (score < -999900) {
#line 762
                      threat = 1;
#line 763
                      TExt ++;
#line 764
                      depth ++;
#line 765
                      extend ++;
#line 766
                      ext_onerep ++;
                    }
                  } else {
#line 721
                    goto _L___10;
                  }
                } else {
#line 721
                  goto _L___10;
                }
              } else {
#line 721
                goto _L___10;
              }
            } else {
#line 721
              goto _L___10;
            }
          } else {
#line 721
            goto _L___10;
          }
        } else {
#line 721
          goto _L___10;
        }
      } else {
#line 721
        goto _L___10;
      }
    } else {
#line 721
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 769
  if (threat == 1) {
#line 771
    TExt ++;
#line 772
    depth ++;
#line 773
    extend ++;
#line 774
    ext_onerep ++;
  }
#line 777
  score = -1000000;
#line 779
  if (Variant != 4) {
#line 782
    gen(& moves[0]);
#line 783
    num_moves = numb_moves;
  }
#line 787
  if (cfg_onerep) {
#line 787
    if (incheck) {
#line 789
      if (num_moves) {
#line 791
        i = 0;
#line 791
        while (1) {
#line 791
          if (i < num_moves) {
#line 791
            if (! (legalmoves < 2)) {
#line 791
              break;
            }
          } else {
#line 791
            break;
          }
#line 793
          make(& moves[0], i);
#line 794
          tmp___15 = check_legal(& moves[0], i, (int )incheck);
#line 794
          if (tmp___15) {
#line 796
            legalmoves ++;
          }
#line 798
          unmake(& moves[0], i);
#line 791
          i ++;
        }
      }
    }
  }
#line 803
  if (ply < 300) {
#line 805
    if (Variant == 3) {
#line 805
      if (num_moves == 1) {
#line 806
        depth ++;
#line 807
        ext_onerep ++;
#line 808
        singular[ply] = (xbool )1;
      } else {
#line 805
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 810
    if (legalmoves == 1) {
#line 810
      if (! singular[ply - 2]) {
#line 811
        depth ++;
#line 812
        ext_onerep ++;
#line 813
        singular[ply] = (xbool )1;
      }
    }
  }
#line 817
  first = (xbool )1;
#line 818
  selective = 0;
#line 820
  if (phase != 2) {
#line 820
    if (Variant != 3) {
#line 820
      if (cfg_futprune) {
#line 823
        if (white_to_move) {
#line 823
          tmp___16 = Material;
        } else {
#line 823
          tmp___16 = - Material;
        }
#line 823
        fscore = tmp___16 + 900;
#line 825
        if (! extend) {
#line 825
          if (depth == 3) {
#line 825
            if (fscore <= alpha) {
#line 826
              depth = 2;
            }
          }
        }
#line 828
        if (white_to_move) {
#line 828
          tmp___17 = Material;
        } else {
#line 828
          tmp___17 = - Material;
        }
#line 828
        fscore = tmp___17 + 500;
#line 830
        if (! extend) {
#line 830
          if (depth == 2) {
#line 830
            if (fscore <= alpha) {
#line 832
              selective = 1;
#line 833
              fmax = fscore;
#line 833
              best_score = fmax;
            }
          }
        }
#line 836
        if (white_to_move) {
#line 836
          tmp___18 = Material;
        } else {
#line 836
          tmp___18 = - Material;
        }
#line 836
        if (Variant == 2) {
#line 836
          tmp___19 = 150;
        } else {
#line 836
          tmp___19 = 200;
        }
#line 836
        fscore = tmp___18 + tmp___19;
#line 838
        if (! extend) {
#line 838
          if (depth == 1) {
#line 838
            if (fscore <= alpha) {
#line 840
              selective = 1;
#line 841
              fmax = fscore;
#line 841
              best_score = fmax;
            }
          }
        }
      }
    }
  }
#line 845
  if (num_moves > 0) {
#line 847
    order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, best);
#line 850
    while (1) {
#line 850
      tmp___31 = remove_one(& i, & move_ordering[0], num_moves);
#line 850
      if (! tmp___31) {
#line 850
        break;
      }
#line 852
      make(& moves[0], i);
#line 854
      legal_move = (xbool )0;
#line 856
      hash_history[(move_number + ply) - 1] = hash;
#line 857
      path[ply - 1] = moves[i];
#line 859
      extend = 0;
#line 863
      tmp___30 = check_legal(& moves[0], i, (int )incheck);
#line 863
      if (tmp___30) {
#line 865
        tmp___20 = f_in_check(& moves[0], i);
#line 865
        afterincheck = (int )tmp___20;
#line 866
        checks[ply] = (xbool )afterincheck;
#line 868
        if (! afterincheck) {
#line 868
          if (Variant == 2) {
#line 868
            goto _L___14;
          } else
#line 868
          if (Variant == 3) {
#line 868
            goto _L___14;
          } else
#line 868
          if (Variant == 4) {
            _L___14: /* CIL Label */ 
#line 868
            if (depth < 3) {
#line 868
              if (board[moves[i].target] == 1) {
#line 868
                if (Xrank[moves[i].target] >= 6) {
#line 874
                  extend ++;
                } else {
#line 868
                  goto _L___13;
                }
              } else
              _L___13: /* CIL Label */ 
#line 868
              if (board[moves[i].target] == 2) {
#line 868
                if (Xrank[moves[i].target] <= 3) {
#line 874
                  extend ++;
                }
              }
            }
          }
        }
#line 877
        dropcut = 0;
#line 880
        if (moves[i].from == 0) {
#line 880
          if (depth > 1) {
#line 880
            if (afterincheck == 0) {
#line 880
              if ((unsigned int )incheck == 0U) {
#line 880
                if (! searching_pv) {
#line 880
                  if (cfg_razordrop) {
#line 887
                    razor_drop ++;
#line 887
                    extend --;
                  } else {
#line 880
                    goto _L___19;
                  }
                } else {
#line 880
                  goto _L___19;
                }
              } else {
#line 880
                goto _L___19;
              }
            } else {
#line 880
              goto _L___19;
            }
          } else {
#line 880
            goto _L___19;
          }
        } else
        _L___19: /* CIL Label */ 
#line 890
        if (moves[i].from == 0) {
#line 890
          if (depth == 1) {
#line 890
            if ((unsigned int )incheck == 0U) {
#line 890
              if (cfg_cutdrop) {
#line 892
                if (white_to_move) {
#line 894
                  tmp___21 = calc_attackers(moves[i].target, 1);
#line 894
                  tmp___22 = calc_attackers(moves[i].target, 0);
#line 894
                  dropcut = tmp___21 - tmp___22 > 0;
#line 896
                  if (dropcut) {
#line 896
                    drop_cuts ++;
                  }
                } else {
#line 900
                  tmp___23 = calc_attackers(moves[i].target, 0);
#line 900
                  tmp___24 = calc_attackers(moves[i].target, 1);
#line 900
                  dropcut = tmp___23 - tmp___24 > 0;
#line 902
                  if (dropcut) {
#line 902
                    drop_cuts ++;
                  }
                }
              }
            }
          }
        }
#line 908
        if (! dropcut) {
#line 908
          if (! selective) {
#line 908
            goto _L___20;
          } else
#line 908
          if (afterincheck != 0) {
#line 908
            goto _L___20;
          } else {
#line 908
            tmp___28 = abs(material[moves[i].captured]);
#line 908
            if (Variant == 2) {
#line 908
              tmp___29 = 1;
            } else
#line 908
            if (Variant == 4) {
#line 908
              tmp___29 = 1;
            } else {
#line 908
              tmp___29 = 2;
            }
#line 908
            if (fmax + tmp___28 * tmp___29 > alpha) {
#line 908
              goto _L___20;
            } else
#line 908
            if (moves[i].promoted) {
              _L___20: /* CIL Label */ 
#line 914
              if ((unsigned int )first == 1U) {
#line 916
                tmp___25 = search(- beta, - alpha, (depth + extend) - 1, 0);
#line 916
                score = - tmp___25;
#line 917
                FULL ++;
              } else {
#line 921
                tmp___26 = search(- alpha - 1, - alpha, (depth + extend) - 1, 0);
#line 921
                score = - tmp___26;
#line 922
                PVS ++;
#line 924
                if (score > best_score) {
#line 924
                  if (! time_exit) {
#line 924
                    if (score != -50000) {
#line 926
                      if (score > alpha) {
#line 926
                        if (score < beta) {
#line 928
                          tmp___27 = search(- beta, - alpha, (depth + extend) - 1,
                                            0);
#line 928
                          score = - tmp___27;
#line 929
                          PVSF ++;
#line 931
                          if (score > best_score) {
#line 931
                            best_score = score;
                          }
                        } else {
#line 934
                          best_score = score;
                        }
                      } else {
#line 934
                        best_score = score;
                      }
                    }
                  }
                }
              }
#line 938
              legal_move = (xbool )1;
            } else {
#line 942
              razor_material ++;
            }
          }
        } else {
#line 942
          razor_material ++;
        }
#line 945
        legalmoves ++;
#line 946
        no_moves = (xbool )0;
      }
#line 949
      if (score > best_score) {
#line 949
        if (legal_move) {
#line 951
          best_score = score;
        }
      }
#line 954
      unmake(& moves[0], i);
#line 957
      if (time_exit) {
#line 957
        return (0);
      }
#line 960
      if (score > alpha) {
#line 960
        if (legal_move) {
#line 963
          if (score >= beta) {
#line 966
            (history_h[moves[i].from][moves[i].target]) ++;
#line 968
            if (moves[i].captured == 13) {
#line 972
              if (moves[i].from == killer1[ply].from) {
#line 972
                if (moves[i].target == killer1[ply].target) {
#line 972
                  if (moves[i].promoted == killer1[ply].promoted) {
#line 975
                    (killer_scores[ply]) ++;
                  } else {
#line 972
                    goto _L___24;
                  }
                } else {
#line 972
                  goto _L___24;
                }
              } else
              _L___24: /* CIL Label */ 
#line 977
              if (moves[i].from == killer2[ply].from) {
#line 977
                if (moves[i].target == killer2[ply].target) {
#line 977
                  if (moves[i].promoted == killer2[ply].promoted) {
#line 980
                    (killer_scores2[ply]) ++;
#line 982
                    if (killer_scores2[ply] > killer_scores[ply]) {
#line 984
                      kswap = killer1[ply];
#line 985
                      killer1[ply] = killer2[ply];
#line 986
                      killer2[ply] = kswap;
#line 987
                      ksswap = killer_scores[ply];
#line 988
                      killer_scores[ply] = killer_scores2[ply];
#line 989
                      killer_scores2[ply] = ksswap;
                    }
                  } else {
#line 977
                    goto _L___22;
                  }
                } else {
#line 977
                  goto _L___22;
                }
              } else
              _L___22: /* CIL Label */ 
#line 993
              if (moves[i].from == killer3[ply].from) {
#line 993
                if (moves[i].target == killer3[ply].target) {
#line 993
                  if (moves[i].promoted == killer3[ply].promoted) {
#line 997
                    (killer_scores3[ply]) ++;
#line 999
                    if (killer_scores3[ply] > killer_scores2[ply]) {
#line 1001
                      kswap = killer2[ply];
#line 1002
                      killer2[ply] = killer3[ply];
#line 1003
                      killer3[ply] = kswap;
#line 1004
                      ksswap = killer_scores2[ply];
#line 1005
                      killer_scores2[ply] = killer_scores3[ply];
#line 1006
                      killer_scores3[ply] = ksswap;
                    }
                  } else {
#line 1012
                    killer_scores3[ply] = 1;
#line 1013
                    killer3[ply] = moves[i];
                  }
                } else {
#line 1012
                  killer_scores3[ply] = 1;
#line 1013
                  killer3[ply] = moves[i];
                }
              } else {
#line 1012
                killer_scores3[ply] = 1;
#line 1013
                killer3[ply] = moves[i];
              }
            }
#line 1017
            if ((unsigned int )first == 1U) {
#line 1017
              FHF ++;
            }
#line 1019
            FH ++;
#line 1021
            StoreTT(score, originalalpha, beta, i, threat, depth);
#line 1023
            return (score);
          }
#line 1026
          alpha = score;
#line 1028
          sbest = i;
#line 1031
          pv[ply][ply] = moves[i];
#line 1032
          j = ply + 1;
#line 1032
          while (j < pv_length[ply + 1]) {
#line 1033
            pv[ply][j] = pv[ply + 1][j];
#line 1032
            j ++;
          }
#line 1034
          pv_length[ply] = pv_length[ply + 1];
        }
      }
#line 1037
      if (legal_move) {
#line 1038
        first = (xbool )0;
      }
    }
  } else {
#line 1045
    StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
#line 1046
    return (1000000 - ply);
  }
#line 1050
  if (no_moves) {
#line 1052
    if (Variant != 4) {
#line 1052
      if (Variant != 3) {
#line 1054
        tmp___32 = in_check();
#line 1054
        if (tmp___32) {
#line 1056
          StoreTT(-1000000 + ply, originalalpha, beta, 0, threat, depth);
#line 1057
          return (-1000000 + ply);
        } else {
#line 1061
          StoreTT(0, originalalpha, beta, 0, threat, depth);
#line 1062
          return (0);
        }
      } else {
#line 1067
        StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
#line 1068
        return (1000000 - ply);
      }
    } else {
#line 1067
      StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
#line 1068
      return (1000000 - ply);
    }
  } else
#line 1073
  if (fifty > 100) {
#line 1075
    return (0);
  }
#line 1079
  if (sbest == -1) {
#line 1079
    sbest = 500;
  }
#line 1081
  if (best_score <= originalalpha) {
#line 1083
    if (! selective) {
#line 1084
      StoreTT(best_score, originalalpha, beta, sbest, threat, depth);
    }
  } else
#line 1088
  if (! selective) {
#line 1089
    StoreTT(best_score, originalalpha, beta, sbest, threat, depth);
  } else {
#line 1091
    StoreTT(best_score, -1000000, -1000000, sbest, threat, depth);
  }
#line 1094
  return (best_score);
}
}
#line 1099 "search.c"
move_s search_root(int originalalpha , int originalbeta , int depth ) 
{ 
  move_s moves[512] ;
  move_s best_move ;
  int num_moves ;
  int i ;
  int j ;
  int root_score ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool no_moves ;
  xbool legal_move ;
  xbool first ;
  int alpha ;
  int beta ;
  move_s kswap ;
  int ksswap ;
  int incheck ;
  int mc ;
  int oldnodecount ;
  xbool tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  xbool tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;

  {
#line 1103
  best_move = dummy;
#line 1105
  root_score = -1000000;
#line 1111
  mc = 0;
#line 1114
  alpha = originalalpha;
#line 1115
  beta = originalbeta;
#line 1117
  num_moves = 0;
#line 1118
  no_moves = (xbool )1;
#line 1119
  ply = 1;
#line 1120
  searching_pv = (xbool )1;
#line 1121
  time_exit = (xbool )0;
#line 1122
  time_failure = (xbool )0;
#line 1123
  first = (xbool )1;
#line 1124
  cur_score = -1000000;
#line 1125
  nodes ++;
#line 1128
  tmp = is_draw();
#line 1128
  if (tmp) {
#line 1130
    result = 5;
#line 1131
    cur_score = 0;
#line 1132
    pv_length[ply] = 0;
#line 1133
    return (dummy);
  }
#line 1136
  pv_length[ply] = ply;
#line 1137
  hash_history[(move_number + ply) - 1] = hash;
#line 1141
  tmp___0 = in_check();
#line 1141
  incheck = (int )tmp___0;
#line 1143
  if (incheck) {
#line 1145
    ext_check ++;
#line 1146
    depth ++;
  }
#line 1149
  checks[ply] = (xbool )incheck;
#line 1150
  recaps[ply] = (xbool )0;
#line 1151
  singular[ply] = (xbool )0;
#line 1153
  if (Variant == 4) {
#line 1155
    legals = 0;
#line 1156
    captures = (xbool )1;
#line 1157
    gen(& moves[0]);
#line 1158
    num_moves = numb_moves;
#line 1159
    captures = (xbool )0;
#line 1161
    if (num_moves) {
#line 1163
      i = 0;
#line 1163
      while (i < num_moves) {
#line 1165
        make(& moves[0], i);
#line 1166
        tmp___1 = check_legal(& moves[0], i, incheck);
#line 1166
        if (tmp___1) {
#line 1168
          legals ++;
        }
#line 1170
        unmake(& moves[0], i);
#line 1163
        i ++;
      }
    }
#line 1174
    if (! legals) {
#line 1176
      captures = (xbool )0;
#line 1177
      gen(& moves[0]);
#line 1178
      num_moves = numb_moves;
#line 1180
      i = 0;
#line 1180
      while (i < num_moves) {
#line 1182
        make(& moves[0], i);
#line 1183
        tmp___2 = check_legal(& moves[0], i, incheck);
#line 1183
        if (tmp___2) {
#line 1185
          legals ++;
        }
#line 1187
        unmake(& moves[0], i);
#line 1180
        i ++;
      }
    }
  } else {
#line 1195
    gen(& moves[0]);
#line 1196
    num_moves = numb_moves;
  }
#line 1199
  movetotal = legals;
#line 1201
  order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, -1);
#line 1204
  while (1) {
#line 1204
    tmp___7 = remove_one(& i, & move_ordering[0], num_moves);
#line 1204
    if (! tmp___7) {
#line 1204
      break;
    }
#line 1206
    if (! alllosers) {
#line 1206
      if (rootlosers[i]) {
#line 1206
        if (Variant == 4) {
#line 1206
          continue;
        } else
#line 1206
        if (Variant == 3) {
#line 1206
          continue;
        }
      }
    }
#line 1208
    make(& moves[0], i);
#line 1209
    legal_move = (xbool )0;
#line 1211
    hash_history[(move_number + ply) - 1] = hash;
#line 1212
    path[ply - 1] = moves[i];
#line 1214
    oldnodecount = nodes;
#line 1217
    tmp___6 = check_legal(& moves[0], i, incheck);
#line 1217
    if (tmp___6) {
#line 1219
      unmake(& moves[0], i);
#line 1220
      mc ++;
#line 1221
      moveleft = movetotal - mc;
#line 1222
      comp_to_san(moves[i], searching_move);
#line 1223
      make(& moves[0], i);
#line 1225
      checks[ply] = f_in_check(& moves[0], i);
#line 1226
      recaps[ply] = (xbool )0;
#line 1227
      singular[ply] = (xbool )0;
#line 1229
      if ((unsigned int )first == 1U) {
#line 1229
        goto _L___0;
      } else
#line 1229
      if (i_depth < 2) {
        _L___0: /* CIL Label */ 
#line 1231
        tmp___3 = search(- beta, - alpha, depth - 1, 0);
#line 1231
        root_score = - tmp___3;
#line 1233
        if (! time_exit) {
#line 1233
          if (post) {
#line 1233
            goto _L;
          } else
#line 1233
          if (! xb_mode) {
            _L: /* CIL Label */ 
#line 1233
            if (i_depth >= 2) {
#line 1235
              if (root_score >= beta) {
#line 1237
                post_fh_thinking(root_score, & moves[i]);
              } else
#line 1239
              if (root_score <= alpha) {
#line 1241
                failed = 1;
#line 1243
                post_fl_thinking(root_score, & moves[i]);
              } else {
#line 1248
                pv[ply - 1][ply - 1] = moves[i];
#line 1249
                j = ply;
#line 1249
                while (j < pv_length[ply]) {
#line 1250
                  pv[ply - 1][j] = pv[ply][j];
#line 1249
                  j ++;
                }
#line 1251
                pv_length[ply - 1] = pv_length[ply];
#line 1253
                post_thinking(root_score);
              }
#line 1256
              if (root_score > cur_score) {
#line 1256
                if (! time_exit) {
#line 1258
                  cur_score = root_score;
#line 1259
                  bestmovenum = i;
#line 1260
                  best_move = moves[i];
                }
              }
            }
          }
        }
      } else {
#line 1267
        tmp___4 = search(- alpha - 1, - alpha, depth - 1, 0);
#line 1267
        root_score = - tmp___4;
#line 1269
        if (root_score > alpha) {
#line 1269
          if (root_score < beta) {
#line 1269
            if (! time_exit) {
#line 1271
              post_fail_thinking(root_score, & moves[i]);
#line 1273
              tmp___5 = search(- beta, - alpha, depth - 1, 0);
#line 1273
              root_score = - tmp___5;
#line 1275
              if (root_score > alpha) {
#line 1275
                if (! time_exit) {
#line 1277
                  failed = 0;
#line 1279
                  cur_score = root_score;
#line 1280
                  bestmovenum = i;
#line 1281
                  best_move = moves[i];
#line 1283
                  if (root_score < beta) {
#line 1283
                    if (i_depth >= 2) {
#line 1286
                      pv[ply - 1][ply - 1] = moves[i];
#line 1287
                      j = ply;
#line 1287
                      while (j < pv_length[ply]) {
#line 1288
                        pv[ply - 1][j] = pv[ply][j];
#line 1287
                        j ++;
                      }
#line 1289
                      pv_length[ply - 1] = pv_length[ply];
                    }
                  }
                }
              }
            }
          }
        }
#line 1294
        if (root_score >= beta) {
#line 1294
          if (! time_exit) {
#line 1295
            post_fh_thinking(root_score, & moves[i]);
          }
        }
      }
#line 1298
      if (root_score > cur_score) {
#line 1298
        if (! time_exit) {
#line 1300
          cur_score = root_score;
#line 1301
          bestmovenum = i;
#line 1302
          best_move = moves[i];
        }
      }
#line 1309
      if (time_exit) {
#line 1309
        if (cur_score == -1000000) {
#line 1311
          if (no_moves) {
#line 1312
            time_failure = (xbool )1;
          }
        }
      }
#line 1315
      no_moves = (xbool )0;
#line 1316
      legal_move = (xbool )1;
    }
#line 1320
    unmake(& moves[0], i);
#line 1323
    if (time_exit) {
#line 1324
      return (best_move);
    }
#line 1327
    if (root_score > alpha) {
#line 1327
      if (legal_move) {
#line 1331
        if (moves[i].from == killer1[ply].from) {
#line 1331
          if (moves[i].target == killer1[ply].target) {
#line 1331
            if (moves[i].promoted == killer1[ply].promoted) {
#line 1334
              (killer_scores[ply]) ++;
            } else {
#line 1331
              goto _L___4;
            }
          } else {
#line 1331
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 1336
        if (moves[i].from == killer2[ply].from) {
#line 1336
          if (moves[i].target == killer2[ply].target) {
#line 1336
            if (moves[i].promoted == killer2[ply].promoted) {
#line 1339
              (killer_scores2[ply]) ++;
#line 1341
              if (killer_scores2[ply] > killer_scores[ply]) {
#line 1343
                kswap = killer1[ply];
#line 1344
                killer1[ply] = killer2[ply];
#line 1345
                killer2[ply] = kswap;
#line 1346
                ksswap = killer_scores[ply];
#line 1347
                killer_scores[ply] = killer_scores2[ply];
#line 1348
                killer_scores2[ply] = ksswap;
              }
            } else {
#line 1336
              goto _L___2;
            }
          } else {
#line 1336
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1351
        if (moves[i].from == killer3[ply].from) {
#line 1351
          if (moves[i].target == killer3[ply].target) {
#line 1351
            if (moves[i].promoted == killer3[ply].promoted) {
#line 1354
              (killer_scores3[ply]) ++;
#line 1356
              if (killer_scores3[ply] > killer_scores2[ply]) {
#line 1358
                kswap = killer2[ply];
#line 1359
                killer2[ply] = killer3[ply];
#line 1360
                killer3[ply] = kswap;
#line 1361
                ksswap = killer_scores2[ply];
#line 1362
                killer_scores2[ply] = killer_scores3[ply];
#line 1363
                killer_scores3[ply] = ksswap;
              }
            } else {
#line 1369
              killer_scores3[ply] = 1;
#line 1370
              killer3[ply] = moves[i];
            }
          } else {
#line 1369
            killer_scores3[ply] = 1;
#line 1370
            killer3[ply] = moves[i];
          }
        } else {
#line 1369
          killer_scores3[ply] = 1;
#line 1370
          killer3[ply] = moves[i];
        }
#line 1374
        (history_h[moves[i].from][moves[i].target]) ++;
#line 1376
        alpha = root_score;
#line 1377
        best_move = moves[i];
#line 1378
        bestmovenum = i;
#line 1379
        cur_score = alpha;
#line 1382
        pv[ply][ply] = moves[i];
#line 1383
        j = ply + 1;
#line 1383
        while (j < pv_length[ply + 1]) {
#line 1384
          pv[ply][j] = pv[ply + 1][j];
#line 1383
          j ++;
        }
#line 1385
        pv_length[ply] = pv_length[ply + 1];
#line 1387
        if (cur_score >= beta) {
#line 1387
          return (best_move);
        }
#line 1390
        if (post) {
#line 1390
          if (i_depth >= 2) {
#line 1391
            post_thinking(alpha);
          }
        }
      }
    }
#line 1394
    if (legal_move) {
#line 1395
      first = (xbool )0;
    }
#line 1397
    rootnodecount[i] = (unsigned int )(nodes - oldnodecount);
  }
#line 1401
  if (no_moves) {
#line 1401
    if (! is_pondering) {
#line 1403
      if (Variant != 3) {
#line 1403
        if (Variant != 4) {
#line 1405
          tmp___8 = in_check();
#line 1405
          if (tmp___8) {
#line 1406
            if (white_to_move == 1) {
#line 1407
              result = 2;
            } else {
#line 1410
              result = 3;
            }
          } else {
#line 1414
            result = 1;
          }
        } else {
#line 1403
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1419
      if (white_to_move == 1) {
#line 1420
        result = 3;
      } else {
#line 1423
        result = 2;
      }
    } else {
#line 1401
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1427
  if (! is_pondering) {
#line 1430
    if (fifty > 100) {
#line 1432
      result = 4;
#line 1433
      cur_score = 0;
#line 1434
      pv_length[ply] = 0;
#line 1435
      return (dummy);
    }
  }
#line 1439
  return (best_move);
}
}
#line 1444 "search.c"
move_s think(void) 
{ 
  move_s comp_move ;
  move_s temp_move ;
  move_s old_move ;
  int i ;
  int j ;
  int k ;
  int elapsed ;
  int temp_score ;
  int true_score ;
  int alpha ;
  int beta ;
  int tmptmp ;
  int rs ;
  move_s moves[512] ;
  int l ;
  int lastlegal ;
  int ic ;
  int pn_restart ;
  int num_moves ;
  char output[8] ;
  int tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  rtime_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  rtime_t tmp___7 ;

  {
#line 1449
  k = 0;
#line 1450
  temp_score = 0;
#line 1455
  lastlegal = 0;
#line 1460
  userealholdings = 0;
#line 1461
  pn_restart = 0;
  restart: 
#line 1463
  nodes = 0;
#line 1464
  qnodes = 0;
#line 1465
  ply = 1;
#line 1467
  ECacheProbes = 0U;
#line 1468
  ECacheHits = 0U;
#line 1469
  TTProbes = 0U;
#line 1470
  TTHits = 0U;
#line 1471
  TTStores = 0U;
#line 1472
  NCuts = 0U;
#line 1473
  NTries = 0U;
#line 1474
  TExt = 0U;
#line 1475
  FH = 0U;
#line 1476
  FHF = 0U;
#line 1477
  PVS = 0U;
#line 1478
  FULL = 0U;
#line 1479
  PVSF = 0U;
#line 1480
  ext_check = 0U;
#line 1481
  ext_recap = 0U;
#line 1482
  ext_onerep = 0U;
#line 1483
  razor_drop = 0U;
#line 1484
  razor_material = 0U;
#line 1485
  drop_cuts = 0U;
#line 1486
  rs = 0;
#line 1487
  extendedtime = 0;
#line 1488
  forcedwin = 0;
#line 1489
  maxposdiff = 200;
#line 1491
  true_i_depth = (char)0;
#line 1492
  bestmovenum = -1;
#line 1496
  tmp = interrupt();
#line 1496
  if (tmp) {
#line 1496
    if (is_analyzing) {
#line 1496
      return (dummy);
    } else
#line 1496
    if (is_pondering) {
#line 1496
      return (dummy);
    }
  }
#line 1499
  start_time = rtime();
#line 1502
  legals = 0;
#line 1504
  if (Variant == 4) {
#line 1504
    captures = (xbool )1;
  } else {
#line 1505
    captures = (xbool )0;
  }
#line 1506
  gen(& moves[0]);
#line 1507
  num_moves = numb_moves;
#line 1509
  tmp___0 = in_check();
#line 1509
  ic = (int )tmp___0;
#line 1511
  l = 0;
#line 1511
  while (l < numb_moves) {
#line 1513
    make(& moves[0], l);
#line 1514
    tmp___1 = check_legal(& moves[0], l, ic);
#line 1514
    if (tmp___1) {
#line 1516
      legals ++;
#line 1517
      lastlegal = l;
    }
#line 1519
    unmake(& moves[0], l);
#line 1511
    l ++;
  }
#line 1522
  if (Variant == 4) {
#line 1522
    if (legals == 0) {
#line 1524
      captures = (xbool )0;
#line 1525
      num_moves = 0;
#line 1526
      gen(& moves[0]);
#line 1527
      num_moves = numb_moves;
#line 1529
      l = 0;
#line 1529
      while (l < numb_moves) {
#line 1531
        make(& moves[0], l);
#line 1532
        tmp___2 = check_legal(& moves[0], l, ic);
#line 1532
        if (tmp___2) {
#line 1534
          legals ++;
#line 1535
          lastlegal = l;
        }
#line 1537
        unmake(& moves[0], l);
#line 1529
        l ++;
      }
    }
  }
#line 1541
  if (Variant != 1) {
#line 1541
    if (! is_pondering) {
#line 1543
      if (legals == 1) {
#line 1545
        time_cushion += inc * 100;
#line 1546
        return (moves[lastlegal]);
      }
    }
  }
#line 1551
  check_phase();
#line 1553
  switch (phase) {
  case 0: 
#line 1556
  printf((char const   * __restrict  )"Opening phase.\n");
#line 1557
  break;
  case 1: 
#line 1559
  printf((char const   * __restrict  )"Middlegame phase.\n");
#line 1560
  break;
  case 2: 
#line 1562
  printf((char const   * __restrict  )"Endgame phase.\n");
#line 1563
  break;
  }
#line 1568
  if (! is_pondering) {
#line 1570
    if (! fixed_time) {
#line 1572
      if (go_fast) {
#line 1574
        tmptmp = allocate_time();
#line 1576
        if (tmptmp > 40) {
#line 1578
          time_for_move = 40;
        } else {
#line 1582
          time_for_move = tmptmp;
        }
      } else {
#line 1587
        time_for_move = allocate_time();
      }
    } else {
#line 1592
      time_for_move = fixed_time;
    }
  } else {
#line 1597
    time_for_move = 999999;
  }
#line 1600
  if (pn_restart) {
#line 1600
    time_for_move = (int )((double )((float )time_for_move * (float )2) / ((double )((float )pn_restart) + 1.0));
  }
#line 1603
  printf((char const   * __restrict  )"Time for move : %d\n", time_for_move);
#line 1605
  if (! pn_restart) {
#line 1608
    clear_tt();
#line 1609
    reset_ecache();
#line 1610
    memset((void *)(rootlosers), 0, sizeof(rootlosers));
  }
#line 1613
  if (! pn_restart) {
#line 1613
    if (! is_pondering) {
#line 1613
      if (Variant == 3) {
#line 1613
        goto _L___1;
      } else
#line 1613
      if (Variant == 4) {
        _L___1: /* CIL Label */ 
#line 1613
        if (piece_count > 3) {
#line 1616
          pn_time = (int )(((double )((float )time_for_move) * 1.0) / 3.0);
#line 1617
          proofnumberscan();
        } else
#line 1613
        if (Variant != 3) {
#line 1616
          pn_time = (int )(((double )((float )time_for_move) * 1.0) / 3.0);
#line 1617
          proofnumberscan();
        } else {
#line 1613
          goto _L___2;
        }
      } else {
#line 1613
        goto _L___2;
      }
    } else {
#line 1613
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1619
  if (! pn_restart) {
#line 1620
    pn_move = dummy;
  }
#line 1622
  if (result) {
#line 1622
    if (pn_move.target == dummy.target) {
#line 1623
      return (pn_move);
    }
  }
#line 1625
  if (forcedwin) {
#line 1625
    goto _L___6;
  } else
#line 1625
  if (result) {
    _L___6: /* CIL Label */ 
#line 1625
    if (pn_move.target != dummy.target) {
#line 1625
      if (! is_analyzing) {
#line 1628
        comp_move = pn_move;
      } else {
#line 1625
        goto _L___5;
      }
    } else {
#line 1625
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 1633
    i = 0;
#line 1633
    while (i < 300) {
#line 1634
      j = 0;
#line 1634
      while (j < 300) {
#line 1635
        pv[i][j] = dummy;
#line 1634
        j ++;
      }
#line 1633
      i ++;
    }
#line 1638
    memset((void *)(history_h), 0, sizeof(history_h));
#line 1641
    i = 0;
#line 1641
    while (i < 300) {
#line 1642
      killer_scores[i] = 0;
#line 1643
      killer_scores2[i] = 0;
#line 1644
      killer_scores3[i] = 0;
#line 1645
      killer1[i] = dummy;
#line 1646
      killer2[i] = dummy;
#line 1647
      killer3[i] = dummy;
#line 1641
      i ++;
    }
#line 1650
    memset((void *)(rootnodecount), 0, sizeof(rootnodecount));
#line 1652
    temp_score = 0;
#line 1653
    cur_score = 0;
#line 1654
    true_score = 0;
#line 1656
    i_depth = 1;
#line 1656
    while (i_depth <= maxdepth) {
#line 1660
      tmp___3 = rtime();
#line 1660
      elapsed = rdifftime(tmp___3, start_time);
#line 1661
      if ((double )elapsed > ((double )time_for_move * 2.1) / 3.0) {
#line 1661
        if (i_depth > 2) {
#line 1662
          break;
        }
      }
#line 1664
      failed = 0;
#line 1666
      if (Variant == 2) {
#line 1666
        tmp___4 = 35;
      } else {
#line 1666
        tmp___4 = 100;
      }
#line 1666
      alpha = temp_score - tmp___4;
#line 1667
      if (Variant == 2) {
#line 1667
        tmp___5 = 35;
      } else {
#line 1667
        tmp___5 = 100;
      }
#line 1667
      beta = temp_score + tmp___5;
#line 1669
      temp_move = search_root(alpha, beta, i_depth);
#line 1671
      if (result) {
#line 1671
        break;
      }
#line 1673
      if (cur_score <= alpha) {
#line 1673
        failed = 1;
      } else {
#line 1674
        failed = 0;
      }
#line 1676
      if (cur_score <= alpha) {
#line 1676
        if (! time_exit) {
#line 1678
          rs ++;
#line 1680
          temp_move = search_root(-1000000, 1000000, i_depth);
#line 1681
          if (! time_exit) {
#line 1681
            failed = 0;
          }
        } else {
#line 1676
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1684
      if (cur_score >= beta) {
#line 1684
        if (! time_exit) {
#line 1686
          comp_move = temp_move;
#line 1687
          temp_score = cur_score;
#line 1689
          rs ++;
#line 1691
          temp_move = search_root(-1000000, 1000000, i_depth);
#line 1692
          if (! time_exit) {
#line 1692
            failed = 0;
          }
        }
      }
#line 1697
      tmp___6 = interrupt();
#line 1697
      if (tmp___6) {
#line 1697
        if (i_depth > 1) {
#line 1699
          if (is_pondering) {
#line 1700
            return (dummy);
          } else
#line 1701
          if (! go_fast) {
#line 1702
            break;
          }
        }
      }
#line 1707
      if (! time_failure) {
#line 1707
        if (! failed) {
#line 1712
          if (cur_score == -1000000) {
#line 1712
            return (dummy);
          }
#line 1714
          comp_move = temp_move;
#line 1715
          temp_score = cur_score;
#line 1717
          stringize_pv(postpv);
#line 1719
          if (! time_exit) {
#line 1721
            true_i_depth = (char )i_depth;
          }
#line 1724
          if (i_depth >= 2) {
#line 1725
            post_thinking(cur_score);
          }
#line 1727
          if (temp_score > 900000) {
#line 1727
            if (1000000 - cur_score < i_depth) {
#line 1729
              break;
            }
          }
        }
      }
#line 1733
      if (time_exit) {
#line 1733
        break;
      }
#line 1738
      j = 0;
#line 1738
      while (j < 300) {
#line 1739
        killer_scores[j] = 0;
#line 1740
        killer_scores2[j] = 0;
#line 1741
        killer_scores3[j] = 0;
#line 1738
        j ++;
      }
#line 1656
      i_depth ++;
    }
  }
#line 1748
  if (! forcedwin) {
#line 1751
    old_move = comp_move;
#line 1753
    if (Variant == 4) {
#line 1753
      goto _L___7;
    } else
#line 1753
    if (Variant == 3) {
      _L___7: /* CIL Label */ 
#line 1753
      if (! result) {
#line 1753
        if (! alllosers) {
#line 1753
          if (! is_pondering) {
#line 1755
            s_threat = 0;
#line 1757
            comp_move = proofnumbercheck(comp_move);
#line 1759
            if (pn_restart < 10) {
#line 1759
              if (s_threat) {
#line 1762
                pn_restart ++;
#line 1765
                i = 0;
#line 1765
                while (i < num_moves) {
#line 1767
                  if (moves[i].from == old_move.from) {
#line 1767
                    if (moves[i].target == old_move.target) {
#line 1767
                      if (moves[i].promoted == old_move.promoted) {
#line 1770
                        rootlosers[i] = 1;
#line 1771
                        break;
                      }
                    }
                  }
#line 1765
                  i ++;
                }
#line 1774
                j = 0;
#line 1774
                while (j < num_moves) {
#line 1776
                  if (rootlosers[j]) {
#line 1776
                    k ++;
                  }
#line 1774
                  j ++;
                }
#line 1779
                if (k == legals) {
#line 1779
                  alllosers = 1;
                }
#line 1781
                goto restart;
              }
            }
          }
        }
      }
    }
  }
#line 1786
  if (alllosers) {
#line 1786
    comp_move = old_move;
  }
#line 1788
  if (pn_restart != 0) {
#line 1788
    if (xb_mode) {
#line 1790
      comp_to_san(comp_move, output);
#line 1791
      printf((char const   * __restrict  )"tellics whisper %d restart(s), ended up with %s\n",
             pn_restart, output);
#line 1792
      result = 0;
    }
  }
#line 1794
  tmp___7 = rtime();
#line 1794
  elapsed = rdifftime(tmp___7, start_time);
#line 1797
  time_left -= elapsed;
#line 1800
  if (moves_to_tc) {
#line 1800
    if (! is_pondering) {
#line 1801
      time_cushion += (time_for_move - elapsed) + inc;
    }
  }
#line 1805
  if (temp_score == 999998) {
#line 1805
    if (! is_pondering) {
#line 1807
      if (white_to_move == 1) {
#line 1809
        result = 3;
      } else {
#line 1813
        result = 2;
      }
    } else {
#line 1805
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 1816
  if (temp_score == -999998) {
#line 1816
    if (! is_pondering) {
#line 1818
      if (white_to_move == 1) {
#line 1820
        result = 2;
      } else {
#line 1824
        result = 3;
      }
    }
  }
#line 1829
  if (post) {
#line 1829
    if (xb_mode) {
#line 1829
      if (! is_pondering) {
#line 1829
        if (result != 3) {
#line 1829
          if (result != 2) {
#line 1829
            if (result != 4) {
#line 1829
              if (result != 5) {
#line 1829
                if (result != 1) {
#line 1829
                  if (! forcedwin) {
#line 1835
                    if (temp_score > 999600) {
#line 1837
                      if (Variant != 1) {
#line 1839
                        printf((char const   * __restrict  )"tellics kibitz Mate in %d\n",
                               (1000000 - temp_score) / 2);
                      } else {
#line 1843
                        printf((char const   * __restrict  )"tellics ptell Mate in %d, give him no more pieces.\n",
                               (1000000 - temp_score) / 2);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1849
  if (result != 2) {
#line 1849
    if (result != 3) {
#line 1849
      if (result != 1) {
#line 1849
        if (result != 4) {
#line 1849
          if (result != 5) {
#line 1849
            if ((int )true_i_depth >= 3) {
#line 1849
              if (pn_move.target == dummy.target) {
#line 1849
                if (! is_pondering) {
#line 1849
                  if (Variant != 1) {
#line 1858
                    if (bestmovenum == -1) {
#line 1858
                      *((int *)((void *)0)) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1861
  if (Variant == 1) {
#line 1861
    if (temp_score > -999900) {
#line 1863
      if (tradefreely == 0) {
#line 1863
        if (! userealholdings) {
#line 1865
          tradefreely = 1;
#line 1866
          printf((char const   * __restrict  )"tellics ptell You can trade freely.\n");
        }
      }
    } else {
#line 1861
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 1869
  if (temp_score < -999900) {
#line 1869
    if (Variant == 1) {
#line 1869
      if (pn_move.target == dummy.target) {
#line 1871
        if (userealholdings) {
#line 1873
          must_sit = (xbool )1;
        } else {
#line 1877
          userealholdings = 1;
#line 1878
          ProcessHoldings(realholdings);
#line 1879
          tradefreely = 0;
#line 1880
          printf((char const   * __restrict  )"tellics ptell ---trades\n");
#line 1881
          goto restart;
        }
#line 1886
        if (temp_score > -1000000) {
#line 1888
          if (partnerdead) {
#line 1890
            printf((char const   * __restrict  )"tellics kibitz Both players dead...resigning...\n");
#line 1891
            printf((char const   * __restrict  )"tellics resign\n");
          } else {
#line 1895
            printf((char const   * __restrict  )"tellics ptell I am forcedly mated (dead). Tell me \'go\' to start moving into it.\n");
          }
        }
      } else {
#line 1869
        goto _L___10;
      }
    } else {
#line 1869
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 1899
  if (temp_score > -60000) {
#line 1899
    if (temp_score < -40000) {
#line 1899
      if (Variant == 1) {
#line 1899
        if (! partnerdead) {
#line 1899
          if (pn_move.target == dummy.target) {
#line 1901
            must_sit = (xbool )1;
#line 1902
            printf((char const   * __restrict  )"tellics ptell I\'ll have to sit...(lose piece that mates you)\n");
          }
        }
      }
    }
  }
#line 1905
  return (comp_move);
}
}
#line 1910 "search.c"
void tree(int depth , int indent , FILE *output , char *disp_b ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;

  {
#line 1916
  num_moves = 0;
#line 1919
  if (! depth) {
#line 1920
    return;
  }
#line 1924
  gen(& moves[0]);
#line 1925
  num_moves = numb_moves;
#line 1927
  tmp = in_check();
#line 1927
  ic = (int )tmp;
#line 1930
  i = 0;
#line 1930
  while (i < num_moves) {
#line 1931
    make(& moves[0], i);
#line 1934
    tmp___0 = check_legal(& moves[0], i, ic);
#line 1934
    if (tmp___0) {
#line 1936
      j = 0;
#line 1936
      while (j < indent) {
#line 1937
        fputc(' ', output);
#line 1936
        j ++;
      }
#line 1939
      print_move(& moves[0], i, output);
#line 1940
      fprintf((FILE * __restrict  )output, (char const   * __restrict  )"\n");
#line 1943
      if ((int )*(disp_b + 0) == 121) {
#line 1944
        display_board(output, 1);
      }
#line 1948
      tree(depth - 1, indent + 2, output, disp_b);
    }
#line 1952
    unmake(& moves[0], i);
#line 1930
    i ++;
  }
#line 1954
  return;
}
}
#line 1 "see.o"
#pragma merger("0","/tmp/cil-0h0fRbhB.i","")
#line 19 "see.c"
see_data see_attackers[2][16]  ;
#line 20 "see.c"
int see_num_attackers[2]  ;
#line 26
void setup_attackers(int square ) ;
#line 26 "see.c"
static int const   rook_o___2[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
#line 27 "see.c"
static int const   bishop_o___2[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
#line 28 "see.c"
static int const   knight_o___5[8]  = 
#line 28
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 22 "see.c"
void setup_attackers(int square ) 
{ 
  register int a_sq ;
  register int b_sq ;
  register int i ;
  int numw ;
  int numb ;

  {
#line 30
  numw = see_num_attackers[0];
#line 30
  numb = see_num_attackers[1];
#line 33
  i = 0;
#line 33
  while (i < 4) {
#line 35
    a_sq = square + (int )rook_o___2[i];
#line 36
    b_sq = board[a_sq];
#line 39
    if (b_sq == 5) {
#line 41
      see_attackers[0][numw].piece = b_sq;
#line 42
      see_attackers[0][numw].square = a_sq;
#line 43
      numw ++;
#line 44
      break;
    } else
#line 46
    if (b_sq == 6) {
#line 48
      see_attackers[1][numb].piece = b_sq;
#line 49
      see_attackers[1][numb].square = a_sq;
#line 50
      numb ++;
#line 51
      break;
    } else {
#line 56
      while (b_sq != 0) {
#line 58
        if (b_sq == 7) {
#line 60
          see_attackers[0][numw].piece = b_sq;
#line 61
          see_attackers[0][numw].square = a_sq;
#line 62
          numw ++;
#line 63
          break;
        } else
#line 58
        if (b_sq == 9) {
#line 60
          see_attackers[0][numw].piece = b_sq;
#line 61
          see_attackers[0][numw].square = a_sq;
#line 62
          numw ++;
#line 63
          break;
        } else
#line 65
        if (b_sq == 8) {
#line 67
          see_attackers[1][numb].piece = b_sq;
#line 68
          see_attackers[1][numb].square = a_sq;
#line 69
          numb ++;
#line 70
          break;
        } else
#line 65
        if (b_sq == 10) {
#line 67
          see_attackers[1][numb].piece = b_sq;
#line 68
          see_attackers[1][numb].square = a_sq;
#line 69
          numb ++;
#line 70
          break;
        } else
#line 72
        if (b_sq != 13) {
#line 72
          break;
        }
#line 73
        a_sq += (int )rook_o___2[i];
#line 74
        b_sq = board[a_sq];
      }
    }
#line 33
    i ++;
  }
#line 80
  i = 0;
#line 80
  while (i < 4) {
#line 82
    a_sq = square + (int )bishop_o___2[i];
#line 83
    b_sq = board[a_sq];
#line 85
    if (b_sq == 1) {
#line 85
      if (i % 2) {
#line 87
        see_attackers[0][numw].piece = b_sq;
#line 88
        see_attackers[0][numw].square = a_sq;
#line 89
        numw ++;
#line 90
        break;
      } else {
#line 85
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 92
    if (b_sq == 2) {
#line 92
      if (! (i % 2)) {
#line 94
        see_attackers[1][numb].piece = b_sq;
#line 95
        see_attackers[1][numb].square = a_sq;
#line 96
        numb ++;
#line 97
        break;
      } else {
#line 92
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 100
    if (b_sq == 5) {
#line 102
      see_attackers[0][numw].piece = b_sq;
#line 103
      see_attackers[0][numw].square = a_sq;
#line 104
      numw ++;
#line 105
      break;
    } else
#line 107
    if (b_sq == 6) {
#line 109
      see_attackers[1][numb].piece = b_sq;
#line 110
      see_attackers[1][numb].square = a_sq;
#line 111
      numb ++;
#line 112
      break;
    } else {
#line 116
      while (b_sq != 0) {
#line 117
        if (b_sq == 11) {
#line 119
          see_attackers[0][numw].piece = b_sq;
#line 120
          see_attackers[0][numw].square = a_sq;
#line 121
          numw ++;
#line 122
          break;
        } else
#line 117
        if (b_sq == 9) {
#line 119
          see_attackers[0][numw].piece = b_sq;
#line 120
          see_attackers[0][numw].square = a_sq;
#line 121
          numw ++;
#line 122
          break;
        } else
#line 124
        if (b_sq == 12) {
#line 126
          see_attackers[1][numb].piece = b_sq;
#line 127
          see_attackers[1][numb].square = a_sq;
#line 128
          numb ++;
#line 129
          break;
        } else
#line 124
        if (b_sq == 10) {
#line 126
          see_attackers[1][numb].piece = b_sq;
#line 127
          see_attackers[1][numb].square = a_sq;
#line 128
          numb ++;
#line 129
          break;
        } else
#line 131
        if (b_sq != 13) {
#line 131
          break;
        }
#line 132
        a_sq += (int )bishop_o___2[i];
#line 133
        b_sq = board[a_sq];
      }
    }
#line 80
    i ++;
  }
#line 139
  i = 0;
#line 139
  while (i < 8) {
#line 141
    a_sq = square + (int )knight_o___5[i];
#line 142
    b_sq = board[a_sq];
#line 143
    if (b_sq == 3) {
#line 145
      see_attackers[0][numw].piece = b_sq;
#line 146
      see_attackers[0][numw].square = a_sq;
#line 147
      numw ++;
    } else
#line 149
    if (b_sq == 4) {
#line 151
      see_attackers[1][numb].piece = b_sq;
#line 152
      see_attackers[1][numb].square = a_sq;
#line 153
      numb ++;
    }
#line 139
    i ++;
  }
#line 157
  see_num_attackers[0] = numw;
#line 158
  see_num_attackers[1] = numb;
#line 159
  return;
}
}
#line 161 "see.c"
void findlowest(int color , int next___0 ) 
{ 
  int lowestp ;
  int lowestv ;
  see_data swap ;
  int i ;
  int tmp ;

  {
#line 168
  lowestp = next___0;
#line 169
  lowestv = abs(material[see_attackers[color][next___0].piece]);
#line 171
  i = next___0;
#line 171
  while (i < see_num_attackers[color]) {
#line 173
    tmp = abs(material[see_attackers[color][i].piece]);
#line 173
    if (tmp < lowestv) {
#line 175
      lowestp = i;
#line 176
      lowestv = abs(material[see_attackers[color][i].piece]);
    }
#line 171
    i ++;
  }
#line 181
  swap = see_attackers[color][next___0];
#line 182
  see_attackers[color][next___0] = see_attackers[color][lowestp];
#line 183
  see_attackers[color][lowestp] = swap;
#line 184
  return;
}
}
#line 187 "see.c"
int see(int color , int square , int from ) 
{ 
  int sside ;
  int caps[2] ;
  int value ;
  int origpiece ;
  int ourbestvalue ;
  int hisbestvalue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 197
  see_num_attackers[0] = 0;
#line 198
  see_num_attackers[1] = 0;
#line 201
  origpiece = board[from];
#line 202
  board[from] = 13;
#line 204
  (see_num_attackers[color]) ++;
#line 205
  see_attackers[color][0].piece = origpiece;
#line 206
  see_attackers[color][0].square = from;
#line 209
  setup_attackers(square);
#line 212
  value = abs(material[board[square]]);
#line 215
  if (! see_num_attackers[! color]) {
#line 217
    board[from] = origpiece;
#line 218
    return (value);
  } else {
#line 225
    hisbestvalue = value;
#line 226
    ourbestvalue = -1000000;
  }
#line 229
  caps[color] = 1;
#line 230
  caps[! color] = 0;
#line 233
  sside = ! color;
#line 236
  while (caps[sside] < see_num_attackers[sside]) {
#line 239
    findlowest(sside, caps[sside]);
#line 241
    if (sside == color) {
#line 245
      tmp = abs(material[see_attackers[! sside][caps[! sside] - 1].piece]);
#line 245
      value += tmp;
#line 248
      if (see_num_attackers[! sside] <= caps[! sside]) {
#line 248
        if (value > ourbestvalue) {
#line 249
          ourbestvalue = value;
        }
      }
#line 252
      if (value < hisbestvalue) {
#line 252
        hisbestvalue = value;
      }
    } else {
#line 258
      tmp___0 = abs(material[see_attackers[! sside][caps[! sside] - 1].piece]);
#line 258
      value -= tmp___0;
#line 263
      if (value > ourbestvalue) {
#line 265
        ourbestvalue = value;
      }
#line 268
      if (see_num_attackers[! sside] <= caps[! sside]) {
#line 268
        if (value < hisbestvalue) {
#line 269
          hisbestvalue = value;
        }
      }
    }
#line 273
    (caps[sside]) ++;
#line 276
    sside ^= 1;
  }
#line 281
  board[from] = origpiece;
#line 285
  if (ourbestvalue > hisbestvalue) {
#line 285
    tmp___1 = hisbestvalue;
  } else {
#line 285
    tmp___1 = ourbestvalue;
  }
#line 285
  return (tmp___1);
}
}
#line 1 "seval.o"
#pragma merger("0","/tmp/cil-1Rey_RBL.i","")
#line 33 "./protos.h"
int suicide_mid_eval(void) ;
#line 14 "seval.c"
static int scentral[144]  = 
#line 14 "seval.c"
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      -10,      0, 
        3,      5,      5,      3, 
        0,      -10,      0,      0, 
        0,      0,      -10,      2, 
        15,      15,      15,      15, 
        2,      -10,      0,      0, 
        0,      0,      -10,      7, 
        15,      25,      25,      15, 
        7,      -10,      0,      0, 
        0,      0,      -10,      7, 
        15,      25,      25,      15, 
        7,      -10,      0,      0, 
        0,      0,      -10,      2, 
        15,      15,      15,      15, 
        2,      -10,      0,      0, 
        0,      0,      -10,      0, 
        3,      5,      5,      3, 
        0,      -10,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 30 "seval.c"
static int const   knight_o___6[8]  = 
#line 30
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
#line 31 "seval.c"
static int const   king_o___0[8]  = 
#line 31
  {      (int const   )13,      (int const   )12,      (int const   )11,      (int const   )1, 
        (int const   )-1,      (int const   )-11,      (int const   )-12,      (int const   )-13};
#line 33 "seval.c"
static int s_bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
#line 36
  m = 0;
#line 38
  l = square - 13;
#line 38
  while (board[l] == 13) {
#line 39
    m ++;
#line 38
    l -= 13;
  }
#line 40
  l = square - 11;
#line 40
  while (board[l] == 13) {
#line 41
    m ++;
#line 40
    l -= 11;
  }
#line 42
  l = square + 11;
#line 42
  while (board[l] == 13) {
#line 43
    m ++;
#line 42
    l += 11;
  }
#line 44
  l = square + 13;
#line 44
  while (board[l] == 13) {
#line 45
    m ++;
#line 44
    l += 13;
  }
#line 47
  return (m << 2);
}
}
#line 50 "seval.c"
static int s_rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
#line 53
  m = 0;
#line 55
  l = square - 12;
#line 55
  while (board[l] == 13) {
#line 56
    m ++;
#line 55
    l -= 12;
  }
#line 57
  l = square - 1;
#line 57
  while (board[l] == 13) {
#line 58
    m ++;
#line 57
    l --;
  }
#line 59
  l = square + 1;
#line 59
  while (board[l] == 13) {
#line 60
    m ++;
#line 59
    l ++;
  }
#line 61
  l = square + 12;
#line 61
  while (board[l] == 13) {
#line 62
    m ++;
#line 61
    l += 12;
  }
#line 64
  return (m << 2);
}
}
#line 67 "seval.c"
static int s_knight_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
#line 69
  m = 0;
#line 71
  d = 0;
#line 71
  while (d < 8) {
#line 73
    if (board[square + (int )knight_o___6[d]] == 13) {
#line 73
      m ++;
    }
#line 71
    d ++;
  }
#line 76
  return (m << 2);
}
}
#line 79 "seval.c"
static int s_pawn_mobility(int square ) 
{ 
  register int m ;

  {
#line 81
  m = 0;
#line 83
  if (board[square] == 1) {
#line 85
    if (board[square + 12] == 13) {
#line 85
      m ++;
    }
  } else
#line 89
  if (board[square - 12] == 13) {
#line 89
    m ++;
  }
#line 92
  return (m << 3);
}
}
#line 95 "seval.c"
static int s_king_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
#line 97
  m = 0;
#line 99
  d = 0;
#line 99
  while (d < 8) {
#line 101
    if (board[square + (int )king_o___0[d]] == 13) {
#line 101
      m ++;
    }
#line 99
    d ++;
  }
#line 104
  return (m << 2);
}
}
#line 107 "seval.c"
static int black_saccers(int square ) 
{ 
  register int f ;
  xbool tmp___0 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 109
  f = 0;
#line 117
  if (board[square + 24] == 2) {
#line 121
    return (0);
  } else
#line 117
  if (board[square + 22] == 2) {
#line 121
    return (0);
  } else
#line 117
  if (board[square + 26] == 2) {
#line 121
    return (0);
  }
#line 126
  if (Xrank[square] < 6) {
#line 126
    if (board[square + 25] == 2) {
#line 131
      f = 1;
    } else
#line 126
    if (board[square + 23] == 2) {
#line 131
      f = 1;
    } else {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 133
  if (Xrank[square] == 4) {
#line 133
    if (board[square + 35] == 2) {
#line 137
      f = 1;
    } else
#line 133
    if (board[square + 37] == 2) {
#line 137
      f = 1;
    }
  }
#line 140
  if (! f) {
#line 142
    tmp___0 = is_attacked(square + 11, 0);
#line 142
    if (tmp___0) {
#line 142
      f = 1;
    } else {
#line 142
      f = 0;
    }
  }
#line 144
  if (! f) {
#line 146
    tmp___2 = is_attacked(square + 13, 0);
#line 146
    if (tmp___2) {
#line 146
      f = 2;
    } else {
#line 146
      f = 0;
    }
  }
#line 149
  if (! f) {
#line 151
    return (0);
  } else
#line 157
  if (f == 1) {
#line 159
    tmp___3 = calc_attackers(square + 11, 0);
#line 159
    if (tmp___3 > 1) {
#line 162
      return (0);
    } else {
#line 167
      return (30);
    }
  } else {
#line 172
    tmp___4 = calc_attackers(square + 13, 0);
#line 172
    if (tmp___4 > 1) {
#line 174
      return (0);
    } else {
#line 178
      return (30);
    }
  }
}
}
#line 186 "seval.c"
static int white_saccers(int square ) 
{ 
  register int f ;
  xbool tmp___0 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 191
  f = 0;
#line 199
  if (board[square - 24] == 1) {
#line 203
    return (0);
  } else
#line 199
  if (board[square - 22] == 1) {
#line 203
    return (0);
  } else
#line 199
  if (board[square - 26] == 1) {
#line 203
    return (0);
  }
#line 208
  if (Xrank[square] > 3) {
#line 208
    if (board[square - 25] == 1) {
#line 213
      f = 1;
    } else
#line 208
    if (board[square - 23] == 1) {
#line 213
      f = 1;
    } else {
#line 208
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 215
  if (Xrank[square] == 5) {
#line 215
    if (board[square - 35] == 1) {
#line 219
      f = 1;
    } else
#line 215
    if (board[square - 37] == 1) {
#line 219
      f = 1;
    }
  }
#line 222
  if (! f) {
#line 224
    tmp___0 = is_attacked(square - 11, 1);
#line 224
    if (tmp___0) {
#line 224
      f = 1;
    } else {
#line 224
      f = 0;
    }
  }
#line 226
  if (! f) {
#line 228
    tmp___2 = is_attacked(square - 13, 1);
#line 228
    if (tmp___2) {
#line 228
      f = 2;
    } else {
#line 228
      f = 0;
    }
  }
#line 231
  if (! f) {
#line 233
    return (0);
  } else
#line 239
  if (f == 1) {
#line 241
    tmp___3 = calc_attackers(square - 11, 1);
#line 241
    if (tmp___3 > 1) {
#line 244
      return (0);
    } else {
#line 249
      return (30);
    }
  } else {
#line 254
    tmp___4 = calc_attackers(square - 13, 1);
#line 254
    if (tmp___4 > 1) {
#line 256
      return (0);
    } else {
#line 260
      return (30);
    }
  }
}
}
#line 268 "seval.c"
int suicide_eval(void) 
{ 
  int tmp ;

  {
#line 271
  tmp = suicide_mid_eval();
#line 271
  return (tmp);
}
}
#line 274 "seval.c"
int suicide_mid_eval(void) 
{ 
  int srank ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int isolated ;
  int backwards ;
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int wb ;
  int bb ;
  int wbc ;
  int bbc ;
  int wk ;
  int bk ;
  int wr ;
  int br ;
  int wn ;
  int bn ;
  int wp ;
  int bp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 280
  score = 0;
#line 282
  wb = 0;
#line 282
  bb = 0;
#line 282
  wbc = 0;
#line 282
  bbc = 0;
#line 283
  wk = 0;
#line 283
  bk = 0;
#line 283
  wr = 0;
#line 283
  br = 0;
#line 284
  wn = 0;
#line 284
  bn = 0;
#line 284
  wp = 0;
#line 284
  bp = 0;
#line 286
  in_cache = 0;
#line 288
  checkECache(& score, & in_cache);
#line 290
  if (in_cache) {
#line 292
    if (white_to_move == 1) {
#line 292
      return (score);
    }
#line 293
    return (- score);
  }
#line 296
  score = Material;
#line 301
  memset((void *)(pawns), 0, sizeof(pawns));
#line 302
  i = 0;
#line 302
  while (i < 11) {
#line 303
    white_back_pawn[i] = 7;
#line 304
    black_back_pawn[i] = 2;
#line 302
    i ++;
  }
#line 306
  j = 1;
#line 306
  a = 1;
#line 306
  while (a <= piece_count) {
#line 307
    i = pieces[j];
#line 309
    if (! i) {
#line 310
      goto __Cont;
    } else {
#line 312
      a ++;
    }
#line 316
    pawn_file = (int )(Xfile[i] + 1);
#line 317
    srank = (int )Xrank[i];
#line 318
    if (board[i] == 1) {
#line 319
      (pawns[1][pawn_file]) ++;
#line 320
      if (srank < white_back_pawn[pawn_file]) {
#line 321
        white_back_pawn[pawn_file] = srank;
      }
    } else
#line 324
    if (board[i] == 2) {
#line 325
      (pawns[0][pawn_file]) ++;
#line 326
      if (srank > black_back_pawn[pawn_file]) {
#line 327
        black_back_pawn[pawn_file] = srank;
      }
    }
    __Cont: /* CIL Label */ 
#line 306
    j ++;
  }
#line 334
  j = 1;
#line 334
  a = 1;
#line 334
  while (a <= piece_count) {
#line 335
    i = pieces[j];
#line 337
    if (! i) {
#line 338
      goto __Cont___0;
    } else {
#line 340
      a ++;
    }
#line 342
    pawn_file = (int )(Xfile[i] + 1);
#line 343
    srank = (int )Xrank[i];
#line 344
    switch (board[i]) {
    case 1: 
#line 346
    score += scentral[i];
#line 347
    tmp = s_pawn_mobility(i);
#line 347
    score += tmp;
#line 348
    tmp___0 = black_saccers(i);
#line 348
    score -= tmp___0;
#line 349
    wp ++;
#line 350
    isolated = 0;
#line 351
    backwards = 0;
#line 354
    if (white_back_pawn[pawn_file + 1] > srank) {
#line 354
      if (white_back_pawn[pawn_file - 1] > srank) {
#line 356
        score -= 8;
#line 357
        backwards = 1;
#line 359
        if (! pawns[1][pawn_file + 1]) {
#line 359
          if (! pawns[1][pawn_file - 1]) {
#line 360
            score -= 12;
#line 361
            isolated = 1;
          }
        }
      }
    }
#line 365
    if (! pawns[0][pawn_file]) {
#line 366
      if (backwards) {
#line 366
        score -= 5;
      }
#line 367
      if (isolated) {
#line 367
        score -= 8;
      }
    }
#line 370
    if (pawns[1][pawn_file] > 1) {
#line 371
      score -= 15 * (pawns[1][pawn_file] - 1);
    }
#line 373
    if (! pawns[0][pawn_file]) {
#line 373
      if (srank >= black_back_pawn[pawn_file - 1]) {
#line 373
        if (srank >= black_back_pawn[pawn_file + 1]) {
#line 375
          score += 30 + 3 * (int )(Xrank[i] - 2);
#line 378
          if (Xfile[i] == 1) {
#line 379
            score += 4 + 2 * (int )(Xrank[i] - 2);
          } else
#line 378
          if (Xfile[i] == 8) {
#line 379
            score += 4 + 2 * (int )(Xrank[i] - 2);
          }
#line 382
          if (! isolated) {
#line 384
            score += 6;
          }
        }
      }
    }
#line 389
    if (! pawns[1][pawn_file - 1]) {
#line 390
      score -= 20;
    }
#line 392
    break;
    case 2: 
#line 395
    score -= scentral[i];
#line 396
    tmp___1 = s_pawn_mobility(i);
#line 396
    score -= tmp___1;
#line 397
    tmp___2 = white_saccers(i);
#line 397
    score += tmp___2;
#line 398
    isolated = 0;
#line 399
    backwards = 0;
#line 400
    bp ++;
#line 402
    if (black_back_pawn[pawn_file + 1] < srank) {
#line 402
      if (black_back_pawn[pawn_file - 1] < srank) {
#line 404
        score += 8;
#line 405
        backwards = 1;
#line 407
        if (! pawns[0][pawn_file + 1]) {
#line 407
          if (! pawns[0][pawn_file - 1]) {
#line 408
            score += 12;
#line 409
            isolated = 1;
          }
        }
      }
    }
#line 413
    if (! pawns[1][pawn_file]) {
#line 414
      if (backwards) {
#line 414
        score += 5;
      }
#line 415
      if (isolated) {
#line 415
        score += 8;
      }
    }
#line 418
    if (pawns[0][pawn_file] > 1) {
#line 419
      score += 15 * (pawns[0][pawn_file] - 1);
    }
#line 421
    if (! pawns[1][pawn_file]) {
#line 421
      if (srank <= white_back_pawn[pawn_file - 1]) {
#line 421
        if (srank <= white_back_pawn[pawn_file + 1]) {
#line 423
          score -= 30 + 3 * (7 - (int )Xrank[i]);
#line 426
          if (Xfile[i] == 1) {
#line 427
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          } else
#line 426
          if (Xfile[i] == 8) {
#line 427
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          }
#line 430
          if (! isolated) {
#line 432
            score -= 6;
          }
        }
      }
    }
#line 436
    if (! pawns[0][pawn_file - 1]) {
#line 437
      score += 20;
    }
#line 439
    break;
    case 7: 
#line 442
    score += scentral[i];
#line 443
    tmp___3 = s_rook_mobility(i);
#line 443
    score += tmp___3;
#line 444
    wr ++;
#line 445
    break;
    case 8: 
#line 448
    score -= scentral[i];
#line 449
    tmp___4 = s_rook_mobility(i);
#line 449
    score -= tmp___4;
#line 450
    br ++;
#line 451
    break;
    case 11: 
#line 454
    score += scentral[i];
#line 455
    tmp___5 = s_bishop_mobility(i);
#line 455
    score += tmp___5;
#line 456
    if (wb) {
#line 458
      if (sqcolor[i] != (int const   )wbc) {
#line 459
        wb = 99;
      }
    }
#line 461
    wb ++;
#line 462
    wbc = (int )sqcolor[i];
#line 463
    break;
    case 12: 
#line 466
    score -= scentral[i];
#line 467
    tmp___6 = s_bishop_mobility(i);
#line 467
    score -= tmp___6;
#line 468
    if (bb) {
#line 471
      if (sqcolor[i] != (int const   )bbc) {
#line 472
        bb = 99;
      }
    }
#line 474
    bb ++;
#line 475
    bbc = (int )sqcolor[i];
#line 476
    break;
    case 3: 
#line 479
    score += scentral[i];
#line 480
    tmp___7 = s_knight_mobility(i);
#line 480
    score += tmp___7;
#line 481
    wn ++;
#line 482
    break;
    case 4: 
#line 485
    score -= scentral[i];
#line 486
    tmp___8 = s_knight_mobility(i);
#line 486
    score -= tmp___8;
#line 487
    bn ++;
#line 488
    break;
    case 9: 
#line 491
    score += scentral[i];
#line 492
    tmp___9 = s_rook_mobility(i);
#line 492
    score += tmp___9;
#line 493
    tmp___10 = s_bishop_mobility(i);
#line 493
    score += tmp___10;
#line 494
    break;
    case 10: 
#line 497
    score -= scentral[i];
#line 498
    tmp___11 = s_rook_mobility(i);
#line 498
    score -= tmp___11;
#line 499
    tmp___12 = s_bishop_mobility(i);
#line 499
    score -= tmp___12;
#line 500
    break;
    case 5: 
#line 503
    score += scentral[i] >> 1;
#line 504
    tmp___13 = s_king_mobility(i);
#line 504
    score += tmp___13;
#line 505
    wk ++;
#line 506
    break;
    case 6: 
#line 509
    score -= scentral[i] >> 1;
#line 510
    tmp___14 = s_king_mobility(i);
#line 510
    score -= tmp___14;
#line 511
    bk ++;
#line 512
    break;
    }
    __Cont___0: /* CIL Label */ 
#line 334
    j ++;
  }
#line 517
  if (wb < 99) {
#line 517
    if (bb < 99) {
#line 517
      if (wbc != bbc) {
#line 517
        if (piece_count < 32) {
#line 519
          score = (int )((float )score * (float )((double )((float )piece_count) / 32.0));
        }
      }
    }
  }
#line 522
  storeECache(score);
#line 525
  if (white_to_move == 1) {
#line 526
    return (score);
  } else {
#line 529
    return (- score);
  }
}
}
#line 1 "sjeng.o"
#pragma merger("0","/tmp/cil-sHb6yIgM.i","")
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 290 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 27 "./protos.h"
void init_game(void) ;
#line 30
xbool is_move(char *str ) ;
#line 62
void start_up(void) ;
#line 64
void toggle_bool(xbool *var ) ;
#line 68
xbool verify_coord(char *input , move_s *move ) ;
#line 85
void initialize_zobrist(void) ;
#line 104
void PutPiece(int color , char piece , char pfile , int prank ) ;
#line 105
void reset_board(void) ;
#line 131
void free_hash(void) ;
#line 10 "./extvars.h"
char divider[50] ;
#line 12 "./extvars.h"
int board[144]  ;
#line 12 "./extvars.h"
int moved[144]  ;
#line 12 "./extvars.h"
int ep_square  ;
#line 12 "./extvars.h"
int white_to_move  ;
#line 12 "./extvars.h"
int wking_loc  ;
#line 12 "./extvars.h"
int bking_loc  ;
#line 12 "./extvars.h"
int white_castled  ;
#line 12 "./extvars.h"
int black_castled  ;
#line 12 "./extvars.h"
int result  ;
#line 12 "./extvars.h"
int ply  ;
#line 12 "./extvars.h"
int pv_length[300]  ;
#line 12 "./extvars.h"
int squares[144]  ;
#line 12 "./extvars.h"
int num_pieces  ;
#line 12 "./extvars.h"
int i_depth  ;
#line 12 "./extvars.h"
int comp_color  ;
#line 12 "./extvars.h"
int fifty  ;
#line 12 "./extvars.h"
int piece_count  ;
#line 16 "./extvars.h"
int nodes  ;
#line 16 "./extvars.h"
int raw_nodes  ;
#line 16 "./extvars.h"
int qnodes  ;
#line 16 "./extvars.h"
int killer_scores[300]  ;
#line 16 "./extvars.h"
int killer_scores2[300]  ;
#line 16 "./extvars.h"
int killer_scores3[300]  ;
#line 16 "./extvars.h"
int moves_to_tc  ;
#line 16 "./extvars.h"
int min_per_game  ;
#line 16 "./extvars.h"
int sec_per_game  ;
#line 16 "./extvars.h"
int inc  ;
#line 16 "./extvars.h"
int time_left  ;
#line 16 "./extvars.h"
int opp_time  ;
#line 16 "./extvars.h"
int time_cushion  ;
#line 16 "./extvars.h"
int time_for_move  ;
#line 16 "./extvars.h"
int cur_score  ;
#line 20 "./extvars.h"
unsigned int history_h[144][144]  ;
#line 22 "./extvars.h"
xbool captures  ;
#line 22 "./extvars.h"
xbool searching_pv  ;
#line 22 "./extvars.h"
xbool post  ;
#line 22 "./extvars.h"
xbool time_exit  ;
#line 22 "./extvars.h"
xbool time_failure  ;
#line 23 "./extvars.h"
int xb_mode  ;
#line 23 "./extvars.h"
int maxdepth  ;
#line 25 "./extvars.h"
move_s pv[300][300]  ;
#line 25 "./extvars.h"
move_s killer1[300]  ;
#line 25 "./extvars.h"
move_s killer2[300]  ;
#line 25 "./extvars.h"
move_s killer3[300]  ;
#line 28 "./extvars.h"
move_x path_x[300]  ;
#line 29 "./extvars.h"
move_s path[300]  ;
#line 32 "./extvars.h"
rtime_t start_time  ;
#line 44 "./extvars.h"
int pieces[62]  ;
#line 45 "./extvars.h"
int is_promoted[62]  ;
#line 69 "./extvars.h"
int book_ply  ;
#line 70 "./extvars.h"
int use_book  ;
#line 71 "./extvars.h"
char opening_history[256]  ;
#line 72 "./extvars.h"
unsigned int bookidx  ;
#line 81 "./extvars.h"
unsigned int NTries  ;
#line 81 "./extvars.h"
unsigned int NCuts  ;
#line 81 "./extvars.h"
unsigned int TExt  ;
#line 85 "./extvars.h"
xbool is_pondering  ;
#line 87 "./extvars.h"
unsigned int PVS  ;
#line 87 "./extvars.h"
unsigned int FULL  ;
#line 87 "./extvars.h"
unsigned int PVSF  ;
#line 88 "./extvars.h"
unsigned int ext_check  ;
#line 99 "./extvars.h"
int Variant  ;
#line 100 "./extvars.h"
int Giveaway  ;
#line 103 "./extvars.h"
xbool is_analyzing  ;
#line 105 "./extvars.h"
char my_partner[256]  ;
#line 106 "./extvars.h"
xbool have_partner  ;
#line 107 "./extvars.h"
xbool must_sit  ;
#line 109 "./extvars.h"
xbool go_fast  ;
#line 116 "./extvars.h"
int fixed_time  ;
#line 120 "./extvars.h"
int phase  ;
#line 126 "./extvars.h"
int root_to_move  ;
#line 155 "./extvars.h"
int my_rating  ;
#line 155 "./extvars.h"
int opp_rating  ;
#line 159 "./extvars.h"
int move_number  ;
#line 160 "./extvars.h"
unsigned int hash_history[600]  ;
#line 166 "./extvars.h"
char setcode[30]  ;
#line 16 "sjeng.c"
char divider[50]  = 
#line 16 "sjeng.c"
  {      (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'\000'};
#line 17 "sjeng.c"
move_s dummy  =    {0, 0, 0, 0, 0, 0};
#line 57 "sjeng.c"
xbool allow_pondering  ;
#line 75 "sjeng.c"
int main(int argc , char **argv ) 
{ 
  char input[256] ;
  char *p ;
  char output[256] ;
  char readbuff[256] ;
  move_s move ;
  move_s comp_move ;
  int depth ;
  xbool force_mode ;
  xbool show_board ;
  move_s game_history[600] ;
  move_x game_history_x[600] ;
  int is_edit_mode ;
  int edit_color ;
  int pingnum ;
  int braindeadinterface ;
  int automode ;
  rtime_t xstart_time ;
  int tmp ;
  xbool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  xbool tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  rtime_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  xbool tmp___70 ;

  {
#line 80
  depth = 4;
#line 90
  read_rcfile();
#line 91
  initialize_zobrist();
#line 93
  Variant = 2;
#line 96
  memcpy((void * __restrict  )(material), (void const   * __restrict  )(std_material),
         sizeof(std_material));
#line 99
  init_game();
#line 101
  initialize_hash();
#line 102
  clear_tt();
#line 103
  reset_ecache();
#line 105
  ECacheProbes = 0U;
#line 106
  ECacheHits = 0U;
#line 107
  TTProbes = 0U;
#line 108
  TTStores = 0U;
#line 109
  TTHits = 0U;
#line 110
  bookidx = 0U;
#line 111
  total_moves = 0U;
#line 112
  ply = 0;
#line 113
  braindeadinterface = 0;
#line 114
  moves_to_tc = 40;
#line 115
  min_per_game = 5;
#line 116
  time_left = 30000;
#line 117
  opp_rating = 2000;
#line 117
  my_rating = opp_rating;
#line 118
  maxdepth = 40;
#line 119
  maxposdiff = 200;
#line 120
  must_go = 1;
#line 121
  tradefreely = 1;
#line 122
  automode = 0;
#line 124
  xb_mode = 0;
#line 125
  force_mode = (xbool )0;
#line 126
  comp_color = 0;
#line 127
  edit_color = 0;
#line 128
  show_board = (xbool )1;
#line 129
  is_pondering = (xbool )0;
#line 130
  allow_pondering = (xbool )1;
#line 131
  is_analyzing = (xbool )0;
#line 132
  is_edit_mode = 0;
#line 133
  have_partner = (xbool )0;
#line 134
  must_sit = (xbool )0;
#line 135
  go_fast = (xbool )0;
#line 136
  fixed_time = 0;
#line 137
  phase = 0;
#line 138
  root_to_move = 0;
#line 139
  kibitzed = (xbool )0;
#line 141
  move_number = 0;
#line 142
  memset((void *)(game_history), 0, sizeof(game_history));
#line 143
  memset((void *)(game_history_x), 0, sizeof(game_history_x));
#line 145
  hash_history[move_number] = hash;
#line 147
  setbuf((FILE * __restrict  )stdout, (char * __restrict  )((void *)0));
#line 148
  setbuf((FILE * __restrict  )stdin, (char * __restrict  )((void *)0));
#line 149
  start_up();
#line 152
  if (argc == 2) {
#line 154
    printf((char const   * __restrict  )"SPEC Workload\n");
#line 155
    run_autotest(*(argv + 1));
  }
#line 159
  while (1) {
#line 162
    if (! is_edit_mode) {
#line 162
      if (comp_color == white_to_move) {
#line 162
        goto _L___10;
      } else
#line 162
      if (automode) {
        _L___10: /* CIL Label */ 
#line 162
        if (! force_mode) {
#line 162
          if (! must_sit) {
#line 162
            if (! result) {
#line 166
              is_pondering = (xbool )0;
#line 168
              comp_move = think();
#line 170
              ply = 0;
#line 173
              if (! must_sit) {
#line 173
                goto _L___9;
              } else
#line 173
              if (must_go != 0) {
                _L___9: /* CIL Label */ 
#line 176
                if (Variant == 4) {
#line 176
                  goto _L___8;
                } else
#line 176
                if (Variant == 3) {
                  _L___8: /* CIL Label */ 
#line 176
                  if (result != 2) {
#line 176
                    if (result != 3) {
#line 176
                      goto _L___4;
                    } else {
#line 176
                      goto _L___7;
                    }
                  } else {
#line 176
                    goto _L___7;
                  }
                } else
                _L___7: /* CIL Label */ 
#line 176
                if (Variant == 2) {
#line 176
                  goto _L___6;
                } else
#line 176
                if (Variant == 0) {
#line 176
                  goto _L___6;
                } else
#line 176
                if (Variant == 1) {
                  _L___6: /* CIL Label */ 
#line 176
                  if (comp_color == 1) {
#line 176
                    if (result != 2) {
#line 176
                      goto _L___4;
                    } else {
#line 176
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
#line 176
                  if (comp_color == 0) {
#line 176
                    if (result != 3) {
                      _L___4: /* CIL Label */ 
#line 176
                      if (result != 1) {
#line 176
                        if (result != 4) {
#line 176
                          if (result != 5) {
#line 191
                            comp_to_coord(comp_move, output);
#line 193
                            hash_history[move_number] = hash;
#line 195
                            game_history[move_number] = comp_move;
#line 196
                            make(& comp_move, 0);
#line 199
                            tmp = move_number;
#line 199
                            move_number ++;
#line 199
                            game_history_x[tmp] = path_x[0];
#line 201
                            userealholdings = 0;
#line 202
                            must_go --;
#line 205
                            tmp___0 = is_draw();
#line 205
                            if (tmp___0) {
#line 206
                              result = 5;
                            } else
#line 208
                            if (fifty > 100) {
#line 209
                              result = 4;
                            }
#line 212
                            root_to_move ^= 1;
#line 214
                            reset_piece_square();
#line 216
                            if (book_ply < 40) {
#line 217
                              if (! book_ply) {
#line 218
                                strcpy((char * __restrict  )(opening_history), (char const   * __restrict  )(output));
                              } else {
#line 221
                                strcat((char * __restrict  )(opening_history), (char const   * __restrict  )(output));
                              }
                            }
#line 225
                            book_ply ++;
#line 227
                            printf((char const   * __restrict  )"\nNodes: %i (%0.2f%% qnodes)\n",
                                   nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
#line 230
                            printf((char const   * __restrict  )"ECacheProbes : %u   ECacheHits : %u   HitRate : %f%%\n",
                                   ECacheProbes, ECacheHits, (double )(((float )ECacheHits / ((float )ECacheProbes + (float )1)) * (float )100));
#line 234
                            printf((char const   * __restrict  )"TTStores : %u TTProbes : %u   TTHits : %u   HitRate : %f%%\n",
                                   TTStores, TTProbes, TTHits, (double )(((float )TTHits / ((float )TTProbes + (float )1)) * (float )100));
#line 238
                            printf((char const   * __restrict  )"NTries : %u  NCuts : %u  CutRate : %f%%  TExt: %u\n",
                                   NTries, NCuts, (double )(((float )NCuts * (float )100) / ((float )NTries + (float )1)),
                                   TExt);
#line 241
                            printf((char const   * __restrict  )"Check extensions: %u  Razor drops : %u  Razor Material : %u\n",
                                   ext_check, razor_drop, razor_material);
#line 243
                            printf((char const   * __restrict  )"Move ordering : %f%%\n",
                                   (double )(((float )FHF * (float )100) / (float )(FH + 1U)));
#line 245
                            tmp___1 = eval(-1000000, 1000000);
#line 245
                            printf((char const   * __restrict  )"Material score: %d   Eval : %d  MaxPosDiff: %d  White hand: %d  Black hand : %d\n",
                                   Material, tmp___1, maxposdiff, white_hand_eval,
                                   black_hand_eval);
#line 248
                            printf((char const   * __restrict  )"Hash : %X  HoldHash : %X\n",
                                   hash, hold_hash);
#line 251
                            if (! result) {
#line 252
                              if (xb_mode) {
#line 255
                                if (comp_move.from != dummy.from) {
#line 256
                                  printf((char const   * __restrict  )"move %s\n",
                                         output);
                                } else
#line 255
                                if (comp_move.target != dummy.target) {
#line 256
                                  printf((char const   * __restrict  )"move %s\n",
                                         output);
                                }
#line 258
                                if (Variant == 1) {
#line 260
                                  CheckBadFlow((xbool )0);
                                }
                              } else
#line 264
                              if (comp_move.from != dummy.from) {
#line 265
                                printf((char const   * __restrict  )"\n%s\n", output);
                              } else
#line 264
                              if (comp_move.target != dummy.target) {
#line 265
                                printf((char const   * __restrict  )"\n%s\n", output);
                              }
                            } else {
#line 269
                              if (xb_mode) {
#line 270
                                if (comp_move.from != dummy.from) {
#line 271
                                  printf((char const   * __restrict  )"move %s\n",
                                         output);
                                } else
#line 270
                                if (comp_move.target != dummy.target) {
#line 271
                                  printf((char const   * __restrict  )"move %s\n",
                                         output);
                                }
                              } else
#line 274
                              if (comp_move.from != dummy.from) {
#line 275
                                printf((char const   * __restrict  )"\n%s\n", output);
                              } else
#line 274
                              if (comp_move.target != dummy.target) {
#line 275
                                printf((char const   * __restrict  )"\n%s\n", output);
                              }
#line 277
                              if (result == 2) {
#line 278
                                printf((char const   * __restrict  )"0-1 {Black Mates}\n");
                              } else
#line 280
                              if (result == 3) {
#line 281
                                printf((char const   * __restrict  )"1-0 {White Mates}\n");
                              } else
#line 283
                              if (result == 4) {
#line 284
                                printf((char const   * __restrict  )"1/2-1/2 {Fifty move rule}\n");
                              } else
#line 286
                              if (result == 5) {
#line 287
                                printf((char const   * __restrict  )"1/2-1/2 {3 fold repetition}\n");
                              } else {
#line 290
                                printf((char const   * __restrict  )"1/2-1/2 {Draw}\n");
                              }
#line 292
                              automode = 0;
                            }
                          } else {
#line 176
                            goto _L___3;
                          }
                        } else {
#line 176
                          goto _L___3;
                        }
                      } else {
#line 176
                        goto _L___3;
                      }
                    } else {
#line 176
                      goto _L___3;
                    }
                  } else {
#line 176
                    goto _L___3;
                  }
                } else {
                  _L___3: /* CIL Label */ 
#line 297
                  if (result == 2) {
#line 298
                    printf((char const   * __restrict  )"0-1 {Black Mates}\n");
                  } else
#line 300
                  if (result == 3) {
#line 301
                    printf((char const   * __restrict  )"1-0 {White Mates}\n");
                  } else
#line 303
                  if (result == 4) {
#line 304
                    printf((char const   * __restrict  )"1/2-1/2 {Fifty move rule}\n");
                  } else
#line 306
                  if (result == 5) {
#line 307
                    printf((char const   * __restrict  )"1/2-1/2 {3 fold repetition}\n");
                  } else {
#line 310
                    printf((char const   * __restrict  )"1/2-1/2 {Draw}\n");
                  }
#line 312
                  automode = 0;
                }
              }
            }
          }
        }
      }
    }
#line 318
    if (! xb_mode) {
#line 319
      if (show_board) {
#line 320
        printf((char const   * __restrict  )"\n");
#line 321
        display_board(stdout, 1 - comp_color);
      }
#line 323
      if (! automode) {
#line 325
        printf((char const   * __restrict  )"Sjeng: ");
#line 326
        rinput(input, 256, stdin);
      }
    } else {
#line 332
      if (must_sit) {
#line 332
        goto _L___11;
      } else
#line 332
      if (allow_pondering) {
#line 332
        if (! is_edit_mode) {
#line 332
          if (! force_mode) {
#line 332
            if (move_number != 0) {
#line 332
              goto _L___11;
            } else {
#line 332
              goto _L___14;
            }
          } else {
#line 332
            goto _L___14;
          }
        } else {
#line 332
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 332
      if (is_analyzing) {
        _L___11: /* CIL Label */ 
#line 332
        if (! result) {
#line 332
          if (! automode) {
#line 335
            is_pondering = (xbool )1;
#line 336
            think();
#line 337
            is_pondering = (xbool )0;
#line 339
            ply = 0;
          }
        }
      }
#line 341
      if (! automode) {
#line 343
        rinput(input, 256, stdin);
      }
    }
#line 348
    if (! is_edit_mode) {
#line 348
      tmp___70 = is_move(& input[0]);
#line 348
      if (tmp___70) {
#line 349
        tmp___3 = verify_coord(input, & move);
#line 349
        if (tmp___3) {
#line 351
          game_history[move_number] = move;
#line 352
          hash_history[move_number] = hash;
#line 354
          make(& move, 0);
#line 355
          tmp___2 = move_number;
#line 355
          move_number ++;
#line 355
          game_history_x[tmp___2] = path_x[0];
#line 357
          reset_piece_square();
#line 359
          root_to_move ^= 1;
#line 361
          if (book_ply < 40) {
#line 362
            if (! book_ply) {
#line 363
              strcpy((char * __restrict  )(opening_history), (char const   * __restrict  )(input));
            } else {
#line 366
              strcat((char * __restrict  )(opening_history), (char const   * __restrict  )(input));
            }
          }
#line 370
          book_ply ++;
#line 372
          if (show_board) {
#line 373
            printf((char const   * __restrict  )"\n");
#line 374
            display_board(stdout, 1 - comp_color);
          }
        } else {
#line 378
          printf((char const   * __restrict  )"Illegal move: %s\n", input);
        }
      } else {
#line 348
        goto _L___21;
      }
    } else {
      _L___21: /* CIL Label */ 
#line 385
      tmp___5 = strstr((char const   *)(input), "setboard");
#line 385
      if (! tmp___5) {
#line 386
        p = input;
#line 386
        while (*p) {
#line 386
          tmp___4 = tolower((int )*p);
#line 386
          *p = (char )tmp___4;
#line 386
          p ++;
        }
      }
#line 389
      tmp___69 = strcmp((char const   *)(input), "quit");
#line 389
      if (tmp___69) {
#line 394
        tmp___68 = strcmp((char const   *)(input), "exit");
#line 394
        if (tmp___68) {
#line 409
          tmp___66 = strcmp((char const   *)(input), "diagram");
#line 409
          if (tmp___66) {
#line 409
            tmp___67 = strcmp((char const   *)(input), "d");
#line 409
            if (tmp___67) {
#line 412
              tmp___65 = strncmp((char const   *)(input), "perft", (size_t )5);
#line 412
              if (tmp___65) {
#line 420
                tmp___64 = strcmp((char const   *)(input), "new");
#line 420
                if (tmp___64) {
#line 473
                  tmp___63 = strcmp((char const   *)(input), "xboard");
#line 473
                  if (tmp___63) {
#line 484
                    tmp___62 = strcmp((char const   *)(input), "nodes");
#line 484
                    if (tmp___62) {
#line 488
                      tmp___61 = strcmp((char const   *)(input), "post");
#line 488
                      if (tmp___61) {
#line 493
                        tmp___60 = strcmp((char const   *)(input), "nopost");
#line 493
                        if (tmp___60) {
#line 496
                          tmp___59 = strcmp((char const   *)(input), "random");
#line 496
                          if (tmp___59) {
#line 499
                            tmp___58 = strcmp((char const   *)(input), "hard");
#line 499
                            if (tmp___58) {
#line 505
                              tmp___57 = strcmp((char const   *)(input), "easy");
#line 505
                              if (tmp___57) {
#line 511
                                tmp___56 = strcmp((char const   *)(input), "?");
#line 511
                                if (tmp___56) {
#line 514
                                  tmp___55 = strcmp((char const   *)(input), "white");
#line 514
                                  if (tmp___55) {
#line 519
                                    tmp___54 = strcmp((char const   *)(input), "black");
#line 519
                                    if (tmp___54) {
#line 524
                                      tmp___53 = strcmp((char const   *)(input), "force");
#line 524
                                      if (tmp___53) {
#line 527
                                        tmp___52 = strcmp((char const   *)(input),
                                                          "eval");
#line 527
                                        if (tmp___52) {
#line 531
                                          tmp___51 = strcmp((char const   *)(input),
                                                            "go");
#line 531
                                          if (tmp___51) {
#line 535
                                            tmp___50 = strncmp((char const   *)(input),
                                                               "time", (size_t )4);
#line 535
                                            if (tmp___50) {
#line 538
                                              tmp___49 = strncmp((char const   *)(input),
                                                                 "otim", (size_t )4);
#line 538
                                              if (tmp___49) {
#line 541
                                                tmp___48 = strncmp((char const   *)(input),
                                                                   "level", (size_t )5);
#line 541
                                                if (tmp___48) {
#line 560
                                                  tmp___47 = strncmp((char const   *)(input),
                                                                     "rating", (size_t )6);
#line 560
                                                  if (tmp___47) {
#line 565
                                                    tmp___46 = strncmp((char const   *)(input),
                                                                       "holding",
                                                                       (size_t )7);
#line 565
                                                    if (tmp___46) {
#line 568
                                                      tmp___45 = strncmp((char const   *)(input),
                                                                         "variant",
                                                                         (size_t )7);
#line 568
                                                      if (tmp___45) {
#line 607
                                                        tmp___44 = strncmp((char const   *)(input),
                                                                           "analyze",
                                                                           (size_t )7);
#line 607
                                                        if (tmp___44) {
#line 613
                                                          tmp___43 = strncmp((char const   *)(input),
                                                                             "undo",
                                                                             (size_t )4);
#line 613
                                                          if (tmp___43) {
#line 623
                                                            tmp___42 = strncmp((char const   *)(input),
                                                                               "remove",
                                                                               (size_t )5);
#line 623
                                                            if (tmp___42) {
#line 635
                                                              tmp___41 = strncmp((char const   *)(input),
                                                                                 "edit",
                                                                                 (size_t )4);
#line 635
                                                              if (tmp___41) {
#line 639
                                                                tmp___40 = strncmp((char const   *)(input),
                                                                                   ".",
                                                                                   (size_t )1);
#line 639
                                                                if (tmp___40) {
                                                                  _L___20: /* CIL Label */ 
#line 651
                                                                  if (is_edit_mode) {
#line 651
                                                                    tmp___39 = strncmp((char const   *)(input),
                                                                                       "c",
                                                                                       (size_t )1);
#line 651
                                                                    if (tmp___39) {
#line 651
                                                                      goto _L___19;
                                                                    } else
#line 652
                                                                    if (edit_color == 0) {
#line 652
                                                                      edit_color = 1;
                                                                    } else {
#line 652
                                                                      edit_color = 0;
                                                                    }
                                                                  } else
                                                                  _L___19: /* CIL Label */ 
#line 654
                                                                  if (is_edit_mode) {
#line 654
                                                                    tmp___38 = strncmp((char const   *)(input),
                                                                                       "#",
                                                                                       (size_t )1);
#line 654
                                                                    if (tmp___38) {
#line 654
                                                                      goto _L___18;
                                                                    } else {
#line 655
                                                                      reset_board();
#line 656
                                                                      move_number = 0;
                                                                    }
                                                                  } else
                                                                  _L___18: /* CIL Label */ 
#line 658
                                                                  if (is_edit_mode) {
#line 658
                                                                    tmp___35 = __ctype_b_loc();
#line 658
                                                                    if ((int const   )*(*tmp___35 + (int )input[0]) & 1024) {
#line 658
                                                                      tmp___36 = __ctype_b_loc();
#line 658
                                                                      if ((int const   )*(*tmp___36 + (int )input[1]) & 1024) {
#line 658
                                                                        tmp___37 = __ctype_b_loc();
#line 658
                                                                        if ((int const   )*(*tmp___37 + (int )input[2]) & 2048) {
#line 662
                                                                          PutPiece(edit_color,
                                                                                   input[0],
                                                                                   input[1],
                                                                                   (int )input[2]);
                                                                        } else {
#line 658
                                                                          goto _L___17;
                                                                        }
                                                                      } else {
#line 658
                                                                        goto _L___17;
                                                                      }
                                                                    } else {
#line 658
                                                                      goto _L___17;
                                                                    }
                                                                  } else {
                                                                    _L___17: /* CIL Label */ 
#line 664
                                                                    tmp___34 = strncmp((char const   *)(input),
                                                                                       "partner",
                                                                                       (size_t )7);
#line 664
                                                                    if (tmp___34) {
#line 667
                                                                      tmp___33 = strncmp((char const   *)(input),
                                                                                         "$partner",
                                                                                         (size_t )8);
#line 667
                                                                      if (tmp___33) {
#line 670
                                                                        tmp___32 = strncmp((char const   *)(input),
                                                                                           "ptell",
                                                                                           (size_t )5);
#line 670
                                                                        if (tmp___32) {
#line 673
                                                                          tmp___31 = strncmp((char const   *)(input),
                                                                                             "test",
                                                                                             (size_t )4);
#line 673
                                                                          if (tmp___31) {
#line 676
                                                                            tmp___30 = strncmp((char const   *)(input),
                                                                                               "st",
                                                                                               (size_t )2);
#line 676
                                                                            if (tmp___30) {
#line 680
                                                                              tmp___29 = strncmp((char const   *)(input),
                                                                                                 "result",
                                                                                                 (size_t )6);
#line 680
                                                                              if (tmp___29) {
#line 682
                                                                                tmp___28 = strncmp((char const   *)(input),
                                                                                                   "prove",
                                                                                                   (size_t )5);
#line 682
                                                                                if (tmp___28) {
#line 690
                                                                                  tmp___27 = strncmp((char const   *)(input),
                                                                                                     "ping",
                                                                                                     (size_t )4);
#line 690
                                                                                  if (tmp___27) {
#line 694
                                                                                    tmp___26 = strncmp((char const   *)(input),
                                                                                                       "fritz",
                                                                                                       (size_t )5);
#line 694
                                                                                    if (tmp___26) {
#line 697
                                                                                      tmp___25 = strncmp((char const   *)(input),
                                                                                                         "reset",
                                                                                                         (size_t )5);
#line 697
                                                                                      if (tmp___25) {
#line 718
                                                                                        tmp___24 = strncmp((char const   *)(input),
                                                                                                           "setboard",
                                                                                                           (size_t )8);
#line 718
                                                                                        if (tmp___24) {
#line 721
                                                                                          tmp___23 = strncmp((char const   *)(input),
                                                                                                             ".",
                                                                                                             (size_t )1);
#line 721
                                                                                          if (tmp___23) {
#line 726
                                                                                            tmp___22 = strncmp((char const   *)(input),
                                                                                                               "sd",
                                                                                                               (size_t )2);
#line 726
                                                                                            if (tmp___22) {
#line 731
                                                                                              tmp___21 = strncmp((char const   *)(input),
                                                                                                                 "auto",
                                                                                                                 (size_t )4);
#line 731
                                                                                              if (tmp___21) {
#line 735
                                                                                                tmp___20 = strncmp((char const   *)(input),
                                                                                                                   "protover",
                                                                                                                   (size_t )8);
#line 735
                                                                                                if (tmp___20) {
#line 743
                                                                                                  tmp___19 = strncmp((char const   *)(input),
                                                                                                                     "accepted",
                                                                                                                     (size_t )8);
#line 743
                                                                                                  if (tmp___19) {
#line 746
                                                                                                    tmp___18 = strncmp((char const   *)(input),
                                                                                                                       "rejected",
                                                                                                                       (size_t )8);
#line 746
                                                                                                    if (tmp___18) {
#line 749
                                                                                                      tmp___17 = strcmp((char const   *)(input),
                                                                                                                        "help");
#line 749
                                                                                                      if (tmp___17) {
#line 778
                                                                                                        if (! xb_mode) {
#line 779
                                                                                                          printf((char const   * __restrict  )"Illegal move: %s\n",
                                                                                                                 input);
                                                                                                        }
                                                                                                      } else {
#line 750
                                                                                                        printf((char const   * __restrict  )"\n%s\n\n",
                                                                                                               divider);
#line 751
                                                                                                        printf((char const   * __restrict  )"diagram/d:       toggle diagram display\n");
#line 752
                                                                                                        printf((char const   * __restrict  )"exit/quit:       terminate Sjeng\n");
#line 753
                                                                                                        printf((char const   * __restrict  )"go:              make Sjeng play the side to move\n");
#line 754
                                                                                                        printf((char const   * __restrict  )"new:             start a new game\n");
#line 755
                                                                                                        printf((char const   * __restrict  )"level <x>:       the xboard style command to set time\n");
#line 756
                                                                                                        printf((char const   * __restrict  )"  <x> should be in the form: <a> <b> <c> where:\n");
#line 757
                                                                                                        printf((char const   * __restrict  )"  a -> moves to TC (0 if using an ICS style TC)\n");
#line 758
                                                                                                        printf((char const   * __restrict  )"  b -> minutes per game\n");
#line 759
                                                                                                        printf((char const   * __restrict  )"  c -> increment in seconds\n");
#line 760
                                                                                                        printf((char const   * __restrict  )"nodes:           outputs the number of nodes searched\n");
#line 761
                                                                                                        printf((char const   * __restrict  )"perft <x>:       compute raw nodes to depth x\n");
#line 762
                                                                                                        printf((char const   * __restrict  )"post:            toggles thinking output\n");
#line 763
                                                                                                        printf((char const   * __restrict  )"xboard:          put Sjeng into xboard mode\n");
#line 764
                                                                                                        printf((char const   * __restrict  )"test:            run an EPD testsuite\n");
#line 765
                                                                                                        printf((char const   * __restrict  )"speed:           test movegen and evaluation speed\n");
#line 766
                                                                                                        printf((char const   * __restrict  )"proof:           try to prove or disprove the current pos\n");
#line 767
                                                                                                        printf((char const   * __restrict  )"sd <x>:          limit thinking to depth x\n");
#line 768
                                                                                                        printf((char const   * __restrict  )"st <x>:          limit thinking to x centiseconds\n");
#line 769
                                                                                                        printf((char const   * __restrict  )"setboard <FEN>:  set board to a specified FEN string\n");
#line 770
                                                                                                        printf((char const   * __restrict  )"undo:            back up a half move\n");
#line 771
                                                                                                        printf((char const   * __restrict  )"remove:          back up a full move\n");
#line 772
                                                                                                        printf((char const   * __restrict  )"force:           disable computer moving\n");
#line 773
                                                                                                        printf((char const   * __restrict  )"auto:            computer plays both sides\n");
#line 774
                                                                                                        printf((char const   * __restrict  )"\n%s\n\n",
                                                                                                               divider);
#line 776
                                                                                                        show_board = (xbool )0;
                                                                                                      }
                                                                                                    } else {
#line 747
                                                                                                      printf((char const   * __restrict  )"Interface does not support a required feature...expect trouble.\n");
                                                                                                    }
                                                                                                  }
                                                                                                } else {
#line 736
                                                                                                  printf((char const   * __restrict  )"feature ping=0 setboard=1 playother=0 san=0 usermove=0 time=1\n");
#line 737
                                                                                                  printf((char const   * __restrict  )"feature draw=0 sigint=0 sigterm=0 reuse=1 analyze=0\n");
#line 738
                                                                                                  printf((char const   * __restrict  )"feature myname=\"Sjeng SPEC 1.0\"\n");
#line 739
                                                                                                  printf((char const   * __restrict  )"feature variants=\"normal,bughouse,crazyhouse,suicide,giveaway,losers\"\n");
#line 740
                                                                                                  printf((char const   * __restrict  )"feature colors=1 ics=0 name=0 pause=0 done=1\n");
#line 741
                                                                                                  xb_mode = 2;
                                                                                                }
                                                                                              } else {
#line 732
                                                                                                automode = 1;
#line 733
                                                                                                continue;
                                                                                              }
                                                                                            } else {
#line 727
                                                                                              sscanf((char const   * __restrict  )(input + 3),
                                                                                                     (char const   * __restrict  )"%d",
                                                                                                     & maxdepth);
#line 728
                                                                                              printf((char const   * __restrict  )"New max depth set to: %d\n",
                                                                                                     maxdepth);
#line 729
                                                                                              continue;
                                                                                            }
                                                                                          } else {
#line 724
                                                                                            continue;
                                                                                          }
                                                                                        } else {
#line 719
                                                                                          setup_epd_line(input + 9);
                                                                                        }
                                                                                      } else {
#line 699
                                                                                        memcpy((void * __restrict  )(material),
                                                                                               (void const   * __restrict  )(std_material),
                                                                                               sizeof(std_material));
#line 700
                                                                                        Variant = 2;
#line 702
                                                                                        init_game();
#line 703
                                                                                        initialize_hash();
#line 705
                                                                                        clear_tt();
#line 706
                                                                                        reset_ecache();
#line 708
                                                                                        force_mode = (xbool )0;
#line 709
                                                                                        fixed_time = 0;
#line 711
                                                                                        root_to_move = 0;
#line 713
                                                                                        comp_color = 0;
#line 714
                                                                                        move_number = 0;
#line 715
                                                                                        bookidx = 0U;
#line 716
                                                                                        opp_rating = 2000;
#line 716
                                                                                        my_rating = opp_rating;
                                                                                      }
                                                                                    } else {
#line 695
                                                                                      braindeadinterface = 1;
                                                                                    }
                                                                                  } else {
#line 691
                                                                                    sscanf((char const   * __restrict  )(input + 5),
                                                                                           (char const   * __restrict  )"%d",
                                                                                           & pingnum);
#line 692
                                                                                    printf((char const   * __restrict  )"pong %d\n",
                                                                                           pingnum);
                                                                                  }
                                                                                } else {
#line 683
                                                                                  printf((char const   * __restrict  )"\nMax time to search (s): ");
#line 684
                                                                                  start_time = rtime();
#line 685
                                                                                  rinput(readbuff,
                                                                                         256,
                                                                                         stdin);
#line 686
                                                                                  tmp___16 = atol((char const   *)(readbuff));
#line 686
                                                                                  pn_time = (int )(tmp___16 * 100L);
#line 687
                                                                                  printf((char const   * __restrict  )"\n");
#line 688
                                                                                  proofnumbersearch();
                                                                                }
                                                                              }
                                                                            } else {
#line 677
                                                                              sscanf((char const   * __restrict  )(input + 3),
                                                                                     (char const   * __restrict  )"%d",
                                                                                     & fixed_time);
#line 678
                                                                              fixed_time *= 100;
                                                                            }
                                                                          } else {
#line 674
                                                                            run_epd_testsuite();
                                                                          }
                                                                        } else {
#line 671
                                                                          HandlePtell(input);
                                                                        }
                                                                      } else {
#line 668
                                                                        HandlePartner(input + 8);
                                                                      }
                                                                    } else {
#line 665
                                                                      HandlePartner(input + 7);
                                                                    }
                                                                  }
                                                                } else
#line 639
                                                                if (is_edit_mode) {
#line 640
                                                                  is_edit_mode = 0;
#line 641
                                                                  if (wking_loc == 30) {
#line 641
                                                                    white_castled = 0;
                                                                  }
#line 642
                                                                  if (bking_loc == 114) {
#line 642
                                                                    black_castled = 0;
                                                                  }
#line 643
                                                                  book_ply = 50;
#line 644
                                                                  ep_square = 0;
#line 645
                                                                  move_number = 0;
#line 646
                                                                  memset((void *)(opening_history),
                                                                         0, sizeof(opening_history));
#line 647
                                                                  clear_tt();
#line 648
                                                                  initialize_hash();
#line 649
                                                                  reset_piece_square();
                                                                } else {
#line 639
                                                                  goto _L___20;
                                                                }
                                                              } else {
#line 636
                                                                is_edit_mode = 1;
#line 637
                                                                edit_color = 0;
                                                              }
                                                            } else
#line 624
                                                            if (move_number > 1) {
#line 626
                                                              move_number --;
#line 626
                                                              path_x[0] = game_history_x[move_number];
#line 627
                                                              unmake(& game_history[move_number],
                                                                     0);
#line 628
                                                              reset_piece_square();
#line 630
                                                              move_number --;
#line 630
                                                              path_x[0] = game_history_x[move_number];
#line 631
                                                              unmake(& game_history[move_number],
                                                                     0);
#line 632
                                                              reset_piece_square();
                                                            }
                                                          } else {
#line 614
                                                            printf((char const   * __restrict  )"Move number : %d\n",
                                                                   move_number);
#line 615
                                                            if (move_number > 0) {
#line 617
                                                              move_number --;
#line 617
                                                              path_x[0] = game_history_x[move_number];
#line 618
                                                              unmake(& game_history[move_number],
                                                                     0);
#line 619
                                                              reset_piece_square();
#line 620
                                                              root_to_move ^= 1;
                                                            }
                                                          }
                                                        } else {
#line 608
                                                          is_analyzing = (xbool )1;
#line 609
                                                          is_pondering = (xbool )1;
#line 610
                                                          think();
#line 611
                                                          ply = 0;
                                                        }
                                                      } else {
#line 569
                                                        tmp___15 = strstr((char const   *)(input),
                                                                          "normal");
#line 569
                                                        if (tmp___15) {
#line 571
                                                          Variant = 2;
#line 572
                                                          memcpy((void * __restrict  )(material),
                                                                 (void const   * __restrict  )(std_material),
                                                                 sizeof(std_material));
                                                        } else {
#line 574
                                                          tmp___14 = strstr((char const   *)(input),
                                                                            "crazyhouse");
#line 574
                                                          if (tmp___14) {
#line 576
                                                            Variant = 0;
#line 577
                                                            memcpy((void * __restrict  )(material),
                                                                   (void const   * __restrict  )(zh_material),
                                                                   sizeof(zh_material));
                                                          } else {
#line 579
                                                            tmp___13 = strstr((char const   *)(input),
                                                                              "bughouse");
#line 579
                                                            if (tmp___13) {
#line 581
                                                              Variant = 1;
#line 582
                                                              memcpy((void * __restrict  )(material),
                                                                     (void const   * __restrict  )(zh_material),
                                                                     sizeof(zh_material));
                                                            } else {
#line 584
                                                              tmp___12 = strstr((char const   *)(input),
                                                                                "suicide");
#line 584
                                                              if (tmp___12) {
#line 586
                                                                Variant = 3;
#line 587
                                                                Giveaway = 0;
#line 588
                                                                memcpy((void * __restrict  )(material),
                                                                       (void const   * __restrict  )(suicide_material),
                                                                       sizeof(suicide_material));
                                                              } else {
#line 590
                                                                tmp___11 = strstr((char const   *)(input),
                                                                                  "giveaway");
#line 590
                                                                if (tmp___11) {
#line 592
                                                                  Variant = 3;
#line 593
                                                                  Giveaway = 1;
#line 594
                                                                  memcpy((void * __restrict  )(material),
                                                                         (void const   * __restrict  )(suicide_material),
                                                                         sizeof(suicide_material));
                                                                } else {
#line 596
                                                                  tmp___10 = strstr((char const   *)(input),
                                                                                    "losers");
#line 596
                                                                  if (tmp___10) {
#line 598
                                                                    Variant = 4;
#line 599
                                                                    memcpy((void * __restrict  )(material),
                                                                           (void const   * __restrict  )(losers_material),
                                                                           sizeof(losers_material));
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
#line 602
                                                        initialize_hash();
#line 603
                                                        clear_tt();
#line 604
                                                        reset_ecache();
                                                      }
                                                    } else {
#line 566
                                                      ProcessHoldings(input);
                                                    }
                                                  } else {
#line 561
                                                    sscanf((char const   * __restrict  )(input + 7),
                                                           (char const   * __restrict  )"%i %i",
                                                           & my_rating, & opp_rating);
#line 562
                                                    if (my_rating == 0) {
#line 562
                                                      my_rating = 2000;
                                                    }
#line 563
                                                    if (opp_rating == 0) {
#line 563
                                                      opp_rating = 2000;
                                                    }
                                                  }
                                                } else {
#line 542
                                                  tmp___9 = strstr((char const   *)(input + 6),
                                                                   ":");
#line 542
                                                  if (tmp___9) {
#line 545
                                                    sscanf((char const   * __restrict  )(input + 6),
                                                           (char const   * __restrict  )"%i %i:%i %i",
                                                           & moves_to_tc, & min_per_game,
                                                           & sec_per_game, & inc);
#line 547
                                                    time_left = min_per_game * 6000 + sec_per_game * 100;
#line 548
                                                    opp_time = time_left;
                                                  } else {
#line 553
                                                    sscanf((char const   * __restrict  )(input + 6),
                                                           (char const   * __restrict  )"%i %i %i",
                                                           & moves_to_tc, & min_per_game,
                                                           & inc);
#line 554
                                                    time_left = min_per_game * 6000;
#line 555
                                                    opp_time = time_left;
                                                  }
#line 557
                                                  fixed_time = 0;
#line 558
                                                  time_cushion = 0;
                                                }
                                              } else {
#line 539
                                                sscanf((char const   * __restrict  )(input + 5),
                                                       (char const   * __restrict  )"%i",
                                                       & opp_time);
                                              }
                                            } else {
#line 536
                                              sscanf((char const   * __restrict  )(input + 5),
                                                     (char const   * __restrict  )"%i",
                                                     & time_left);
                                            }
                                          } else {
#line 532
                                            comp_color = white_to_move;
#line 533
                                            force_mode = (xbool )0;
                                          }
                                        } else {
#line 528
                                          check_phase();
#line 529
                                          tmp___8 = eval(-1000000, 1000000);
#line 529
                                          printf((char const   * __restrict  )"Eval: %d\n",
                                                 tmp___8);
                                        }
                                      } else {
#line 525
                                        force_mode = (xbool )1;
                                      }
                                    } else {
#line 520
                                      white_to_move = 0;
#line 521
                                      root_to_move = 1;
#line 522
                                      comp_color = 1;
                                    }
                                  } else {
#line 515
                                    white_to_move = 1;
#line 516
                                    root_to_move = 0;
#line 517
                                    comp_color = 0;
                                  }
                                } else {
#line 512
                                  continue;
                                }
                              } else {
#line 507
                                allow_pondering = (xbool )0;
#line 509
                                continue;
                              }
                            } else {
#line 501
                              allow_pondering = (xbool )1;
#line 503
                              continue;
                            }
                          } else {
#line 497
                            continue;
                          }
                        } else {
#line 494
                          post = (xbool )0;
                        }
                      } else {
#line 489
                        toggle_bool(& post);
#line 490
                        if (xb_mode) {
#line 491
                          post = (xbool )1;
                        }
                      }
                    } else {
#line 485
                      printf((char const   * __restrict  )"Number of nodes: %i (%0.2f%% qnodes)\n",
                             nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
                    }
                  } else {
#line 474
                    xb_mode = 1;
#line 475
                    toggle_bool(& show_board);
#line 476
                    signal(2, (void (*)(int  ))1);
#line 477
                    printf((char const   * __restrict  )"\n");
#line 480
                    printf((char const   * __restrict  )"tellics set f5 1=1\n");
#line 482
                    BegForPartner();
                  }
                } else {
#line 422
                  if (xb_mode) {
#line 424
                    printf((char const   * __restrict  )"tellics set 1 Sjeng SPEC 1.0 (SPEC/%s)\n",
                           setcode);
                  }
#line 427
                  if (! is_analyzing) {
#line 429
                    memcpy((void * __restrict  )(material), (void const   * __restrict  )(std_material),
                           sizeof(std_material));
#line 430
                    Variant = 2;
#line 435
                    init_game();
#line 436
                    initialize_hash();
#line 438
                    if (! braindeadinterface) {
#line 440
                      clear_tt();
#line 441
                      reset_ecache();
                    }
#line 444
                    force_mode = (xbool )0;
#line 445
                    must_sit = (xbool )0;
#line 446
                    go_fast = (xbool )0;
#line 447
                    piecedead = (xbool )0;
#line 448
                    partnerdead = (xbool )0;
#line 449
                    kibitzed = (xbool )0;
#line 450
                    fixed_time = 0;
#line 452
                    root_to_move = 0;
#line 454
                    comp_color = 0;
#line 455
                    move_number = 0;
#line 456
                    hash_history[move_number] = 0U;
#line 457
                    bookidx = 0U;
#line 458
                    opp_rating = 2000;
#line 458
                    my_rating = opp_rating;
#line 459
                    must_go = 0;
#line 460
                    tradefreely = 1;
#line 461
                    automode = 0;
#line 463
                    CheckBadFlow((xbool )1);
#line 464
                    ResetHandValue();
                  } else {
#line 468
                    init_game();
#line 469
                    move_number = 0;
                  }
                }
              } else {
#line 413
                sscanf((char const   * __restrict  )(input + 6), (char const   * __restrict  )"%d",
                       & depth);
#line 414
                raw_nodes = 0;
#line 415
                xstart_time = rtime();
#line 416
                perft(depth);
#line 417
                printf((char const   * __restrict  )"Raw nodes for depth %d: %i\n",
                       depth, raw_nodes);
#line 418
                tmp___6 = rtime();
#line 418
                tmp___7 = rdifftime(tmp___6, xstart_time);
#line 418
                printf((char const   * __restrict  )"Time : %.2f\n", (double )((float )tmp___7) / 100.);
              }
            } else {
#line 410
              toggle_bool(& show_board);
            }
          } else {
#line 410
            toggle_bool(& show_board);
          }
        } else
#line 396
        if (is_analyzing) {
#line 398
          is_analyzing = (xbool )0;
#line 399
          is_pondering = (xbool )0;
#line 400
          time_for_move = 0;
        } else {
#line 404
          free_hash();
#line 405
          free_ecache();
#line 406
          exit(0);
        }
      } else {
#line 390
        free_hash();
#line 391
        free_ecache();
#line 392
        exit(0);
      }
    }
  }
#line 786
  return (0);
}
}
#line 1 "ttable.o"
#pragma merger("0","/tmp/cil-1Iji5lm_.i","")
#line 96 "./protos.h"
void LearnStoreTT(int score , unsigned int nhash , unsigned int hhash , int tomove ,
                  int best , int depth ) ;
#line 123
void clear_dp_tt(void) ;
#line 136
void seedMT(unsigned int seed ) ;
#line 137
unsigned int randomMT(void) ;
#line 55 "./extvars.h"
unsigned int zobrist[14][144]  ;
#line 56 "./extvars.h"
unsigned int hash  ;
#line 61 "./extvars.h"
unsigned int TTProbes  ;
#line 62 "./extvars.h"
unsigned int TTHits  ;
#line 63 "./extvars.h"
unsigned int TTStores  ;
#line 47 "ttable.c"
TType *DP_TTable  ;
#line 48 "ttable.c"
TType *AS_TTable  ;
#line 49 "ttable.c"
QTType *QS_TTable  ;
#line 51 "ttable.c"
void clear_tt(void) 
{ 


  {
#line 53
  memset((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
#line 54
  memset((void *)AS_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
#line 55
  memset((void *)QS_TTable, 0, sizeof(QTType ) * (unsigned long )TTSize);
#line 56
  return;
}
}
#line 58 "ttable.c"
void clear_dp_tt(void) 
{ 


  {
#line 60
  memset((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
#line 61
  return;
}
}
#line 63 "ttable.c"
void initialize_zobrist(void) 
{ 
  int p ;
  int q ;

  {
#line 67
  seedMT(31657U);
#line 69
  p = 0;
#line 69
  while (p < 14) {
#line 71
    q = 0;
#line 71
    while (q < 144) {
#line 73
      zobrist[p][q] = randomMT();
#line 71
      q ++;
    }
#line 69
    p ++;
  }
#line 78
  hash = 3735928559U;
#line 79
  hold_hash = 3237998080U;
#line 80
  return;
}
}
#line 82 "ttable.c"
void initialize_hash(void) 
{ 
  int p ;

  {
#line 86
  hash = 3735928559U;
#line 88
  p = 0;
#line 88
  while (p < 144) {
#line 90
    if (board[p] != 13) {
#line 90
      if (board[p] != 0) {
#line 91
        hash ^= zobrist[board[p]][p];
      }
    }
#line 88
    p ++;
  }
#line 94
  hold_hash = 3237998080U;
#line 97
  return;
}
}
#line 99 "ttable.c"
void QStoreTT(int score , int alpha , int beta , int best ) 
{ 
  unsigned int ttindex ;

  {
#line 103
  TTStores ++;
#line 105
  ttindex = hash % (unsigned int )TTSize;
#line 107
  if (score <= alpha) {
#line 108
    (QS_TTable + ttindex)->Type = (char)1;
  } else
#line 109
  if (score >= beta) {
#line 110
    (QS_TTable + ttindex)->Type = (char)2;
  } else {
#line 112
    (QS_TTable + ttindex)->Type = (char)3;
  }
#line 114
  (QS_TTable + ttindex)->HashKey = hash;
#line 115
  (QS_TTable + ttindex)->Hold_hash = hold_hash;
#line 116
  (QS_TTable + ttindex)->Bestmove = (unsigned short )best;
#line 117
  (QS_TTable + ttindex)->Bound = score;
#line 118
  if (white_to_move) {
#line 118
    (QS_TTable + ttindex)->OnMove = (char)0;
  } else {
#line 118
    (QS_TTable + ttindex)->OnMove = (char)1;
  }
#line 120
  return;
}
}
#line 123 "ttable.c"
void StoreTT(int score , int alpha , int beta , int best , int threat , int depth ) 
{ 
  unsigned int ttindex ;

  {
#line 127
  TTStores ++;
#line 129
  ttindex = hash % (unsigned int )TTSize;
#line 132
  if ((int )(DP_TTable + ttindex)->Depth < depth) {
#line 132
    goto _L___2;
  } else
#line 132
  if ((int )(DP_TTable + ttindex)->Depth == depth) {
#line 132
    if ((int )(DP_TTable + ttindex)->Type == 1) {
#line 132
      if (score > alpha) {
#line 132
        goto _L___2;
      } else {
#line 132
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 132
    if (score > alpha) {
#line 132
      if (score < beta) {
        _L___2: /* CIL Label */ 
#line 132
        if (! is_pondering) {
#line 141
          if (score <= alpha) {
#line 143
            (DP_TTable + ttindex)->Type = (char)1;
#line 144
            if (score < -999500) {
#line 144
              score = -999500;
            }
          } else
#line 146
          if (score >= beta) {
#line 148
            (DP_TTable + ttindex)->Type = (char)2;
#line 149
            if (score > 999500) {
#line 149
              score = 999500;
            }
          } else {
#line 153
            (DP_TTable + ttindex)->Type = (char)3;
#line 156
            if (score > 999500) {
#line 157
              score += ply;
            } else
#line 158
            if (score < -999500) {
#line 159
              score -= ply;
            }
          }
#line 162
          (DP_TTable + ttindex)->HashKey = hash;
#line 163
          (DP_TTable + ttindex)->Hold_hash = hold_hash;
#line 164
          (DP_TTable + ttindex)->Depth = (char )depth;
#line 165
          (DP_TTable + ttindex)->Bestmove = (unsigned short )best;
#line 166
          (DP_TTable + ttindex)->Bound = score;
#line 167
          if (white_to_move) {
#line 167
            (DP_TTable + ttindex)->OnMove = (char)0;
          } else {
#line 167
            (DP_TTable + ttindex)->OnMove = (char)1;
          }
#line 168
          (DP_TTable + ttindex)->Threat = (char )threat;
        } else {
#line 132
          goto _L___1;
        }
      } else {
#line 132
        goto _L___1;
      }
    } else {
#line 132
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 172
    if (score <= alpha) {
#line 174
      (AS_TTable + ttindex)->Type = (char)1;
#line 175
      if (score < -999500) {
#line 175
        score = -999500;
      }
    } else
#line 177
    if (score >= beta) {
#line 179
      (AS_TTable + ttindex)->Type = (char)2;
#line 180
      if (score > 999500) {
#line 180
        score = 999500;
      }
    } else {
#line 184
      (AS_TTable + ttindex)->Type = (char)3;
#line 187
      if (score > 999500) {
#line 188
        score += ply;
      } else
#line 189
      if (score < -999500) {
#line 190
        score -= ply;
      }
    }
#line 193
    (AS_TTable + ttindex)->HashKey = hash;
#line 194
    (AS_TTable + ttindex)->Hold_hash = hold_hash;
#line 195
    (AS_TTable + ttindex)->Depth = (char )depth;
#line 196
    (AS_TTable + ttindex)->Bestmove = (unsigned short )best;
#line 197
    (AS_TTable + ttindex)->Bound = score;
#line 198
    if (white_to_move) {
#line 198
      (AS_TTable + ttindex)->OnMove = (char)0;
    } else {
#line 198
      (AS_TTable + ttindex)->OnMove = (char)1;
    }
#line 199
    (AS_TTable + ttindex)->Threat = (char )threat;
  }
#line 202
  return;
}
}
#line 205 "ttable.c"
void LearnStoreTT(int score , unsigned int nhash , unsigned int hhash , int tomove ,
                  int best , int depth ) 
{ 
  unsigned int ttindex ;

  {
#line 209
  ttindex = nhash % (unsigned int )TTSize;
#line 211
  (AS_TTable + ttindex)->Depth = (char )depth;
#line 213
  if (Variant != 3) {
#line 213
    if (Variant != 4) {
#line 215
      (AS_TTable + ttindex)->Type = (char)3;
    } else {
#line 219
      (AS_TTable + ttindex)->Type = (char)1;
    }
  } else {
#line 219
    (AS_TTable + ttindex)->Type = (char)1;
  }
#line 222
  (AS_TTable + ttindex)->HashKey = nhash;
#line 223
  (AS_TTable + ttindex)->Hold_hash = hhash;
#line 224
  (AS_TTable + ttindex)->Bestmove = (unsigned short )best;
#line 225
  (AS_TTable + ttindex)->Bound = score;
#line 226
  (AS_TTable + ttindex)->OnMove = (char )tomove;
#line 227
  (AS_TTable + ttindex)->Threat = (char)0;
#line 229
  return;
}
}
#line 231 "ttable.c"
int ProbeTT(int *score , int beta , int *best , int *threat , int *donull , int depth ) 
{ 
  unsigned int ttindex ;
  int tmp ;
  int tmp___0 ;

  {
#line 236
  *donull = 1;
#line 238
  TTProbes ++;
#line 240
  ttindex = hash % (unsigned int )TTSize;
#line 242
  if ((DP_TTable + ttindex)->HashKey == hash) {
#line 242
    if ((DP_TTable + ttindex)->Hold_hash == hold_hash) {
#line 242
      if (white_to_move) {
#line 242
        tmp___0 = 0;
      } else {
#line 242
        tmp___0 = 1;
      }
#line 242
      if ((int )(DP_TTable + ttindex)->OnMove == (int )((char )tmp___0)) {
#line 246
        TTHits ++;
#line 248
        if ((int )(DP_TTable + ttindex)->Type == 1) {
#line 248
          if ((depth - 2) - 1 <= (int )(DP_TTable + ttindex)->Depth) {
#line 248
            if ((DP_TTable + ttindex)->Bound < beta) {
#line 251
              *donull = 0;
            }
          }
        }
#line 253
        if ((DP_TTable + ttindex)->Threat) {
#line 253
          depth ++;
        }
#line 255
        if ((int )(DP_TTable + ttindex)->Depth >= depth) {
#line 257
          *score = (DP_TTable + ttindex)->Bound;
#line 259
          if (*score > 999500) {
#line 260
            *score -= ply;
          } else
#line 261
          if (*score < -999500) {
#line 262
            *score += ply;
          }
#line 264
          *best = (int )(DP_TTable + ttindex)->Bestmove;
#line 265
          *threat = (int )(DP_TTable + ttindex)->Threat;
#line 267
          return ((int )(DP_TTable + ttindex)->Type);
        } else {
#line 271
          *best = (int )(DP_TTable + ttindex)->Bestmove;
#line 272
          *threat = (int )(DP_TTable + ttindex)->Threat;
#line 274
          return (0);
        }
      } else {
#line 242
        goto _L___0;
      }
    } else {
#line 242
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 277
  if ((AS_TTable + ttindex)->HashKey == hash) {
#line 277
    if ((AS_TTable + ttindex)->Hold_hash == hold_hash) {
#line 277
      if (white_to_move) {
#line 277
        tmp = 0;
      } else {
#line 277
        tmp = 1;
      }
#line 277
      if ((int )(AS_TTable + ttindex)->OnMove == (int )((char )tmp)) {
#line 281
        TTHits ++;
#line 283
        if ((int )(AS_TTable + ttindex)->Type == 1) {
#line 283
          if ((depth - 2) - 1 <= (int )(AS_TTable + ttindex)->Depth) {
#line 283
            if ((AS_TTable + ttindex)->Bound < beta) {
#line 286
              *donull = 0;
            }
          }
        }
#line 288
        if ((AS_TTable + ttindex)->Threat) {
#line 288
          depth ++;
        }
#line 290
        if ((int )(AS_TTable + ttindex)->Depth >= depth) {
#line 292
          *score = (AS_TTable + ttindex)->Bound;
#line 294
          if (*score > 999500) {
#line 295
            *score -= ply;
          } else
#line 296
          if (*score < -999500) {
#line 297
            *score += ply;
          }
#line 299
          *best = (int )(AS_TTable + ttindex)->Bestmove;
#line 300
          *threat = (int )(AS_TTable + ttindex)->Threat;
#line 302
          return ((int )(AS_TTable + ttindex)->Type);
        } else {
#line 306
          *best = (int )(AS_TTable + ttindex)->Bestmove;
#line 307
          *threat = (int )(AS_TTable + ttindex)->Threat;
#line 309
          return (0);
        }
      } else {
#line 313
        return (4);
      }
    } else {
#line 313
      return (4);
    }
  } else {
#line 313
    return (4);
  }
}
}
#line 317 "ttable.c"
int QProbeTT(int *score , int *best ) 
{ 
  unsigned int ttindex ;
  int tmp ;

  {
#line 322
  TTProbes ++;
#line 324
  ttindex = hash % (unsigned int )TTSize;
#line 326
  if ((QS_TTable + ttindex)->HashKey == hash) {
#line 326
    if ((QS_TTable + ttindex)->Hold_hash == hold_hash) {
#line 326
      if (white_to_move) {
#line 326
        tmp = 0;
      } else {
#line 326
        tmp = 1;
      }
#line 326
      if ((int )(QS_TTable + ttindex)->OnMove == (int )((char )tmp)) {
#line 330
        TTHits ++;
#line 332
        *score = (QS_TTable + ttindex)->Bound;
#line 334
        *best = (int )(QS_TTable + ttindex)->Bestmove;
#line 336
        return ((int )(QS_TTable + ttindex)->Type);
      } else {
#line 339
        return (4);
      }
    } else {
#line 339
      return (4);
    }
  } else {
#line 339
    return (4);
  }
}
}
#line 344 "ttable.c"
void alloc_hash(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 346
  tmp = malloc(sizeof(TType ) * (unsigned long )TTSize);
#line 346
  AS_TTable = (TType *)tmp;
#line 347
  tmp___0 = malloc(sizeof(TType ) * (unsigned long )TTSize);
#line 347
  DP_TTable = (TType *)tmp___0;
#line 348
  tmp___1 = malloc(sizeof(QTType ) * (unsigned long )TTSize);
#line 348
  QS_TTable = (QTType *)tmp___1;
#line 350
  if ((unsigned long )AS_TTable == (unsigned long )((void *)0)) {
#line 352
    printf((char const   * __restrict  )"Out of memory allocating hashtables.\n");
#line 353
    exit(1);
  } else
#line 350
  if ((unsigned long )DP_TTable == (unsigned long )((void *)0)) {
#line 352
    printf((char const   * __restrict  )"Out of memory allocating hashtables.\n");
#line 353
    exit(1);
  } else
#line 350
  if ((unsigned long )QS_TTable == (unsigned long )((void *)0)) {
#line 352
    printf((char const   * __restrict  )"Out of memory allocating hashtables.\n");
#line 353
    exit(1);
  }
#line 361
  return;
}
}
#line 364 "ttable.c"
void free_hash(void) 
{ 


  {
#line 366
  free((void *)AS_TTable);
#line 367
  free((void *)DP_TTable);
#line 368
  free((void *)QS_TTable);
#line 369
  return;
}
}
#line 1 "utils.o"
#pragma merger("0","/tmp/cil-mgg54GED.i","")
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 78 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 36 "./protos.h"
void perft_debug(void) ;
#line 53
void rdelay(int time_in_s ) ;
#line 57
void check_piece_square(void) ;
#line 66
void tree_debug(void) ;
#line 26 "utils.c"
static unsigned int state[625]  ;
#line 27 "utils.c"
static unsigned int *next  ;
#line 28 "utils.c"
int left  =    -1;
#line 30 "utils.c"
int allocate_time(void) 
{ 
  double allocated_time ;
  double move_speed ;

  {
#line 36
  allocated_time = 0.0;
#line 36
  move_speed = 20.0;
#line 39
  if (! moves_to_tc) {
#line 48
    if (min_per_game < 6) {
#line 48
      if (! inc) {
#line 48
        goto _L___1;
      } else {
#line 48
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 48
    if ((double )time_left < ((double )(min_per_game * 6000 + sec_per_game * 100) * 4.0) / 5.0) {
      _L___1: /* CIL Label */ 
#line 51
      if ((double )(opp_time - time_left) > (double )opp_time / 5.0) {
#line 51
        if (xb_mode) {
#line 52
          move_speed = 40.0;
        } else {
#line 51
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 53
      if ((double )(opp_time - time_left) > (double )opp_time / 10.0) {
#line 53
        if (xb_mode) {
#line 54
          move_speed = 30.0;
        } else {
#line 53
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 55
      if ((double )(opp_time - time_left) > (double )opp_time / 20.0) {
#line 55
        if (xb_mode) {
#line 56
          move_speed = 25.0;
        }
      }
    }
#line 59
    if (Variant != 3) {
#line 59
      if (Variant != 4) {
#line 61
        if ((double )(time_left - opp_time) > (double )time_left / 5.0) {
#line 61
          if (xb_mode) {
#line 62
            move_speed -= (double )10;
          } else {
#line 61
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 63
        if ((double )(time_left - opp_time) > (double )time_left / 10.0) {
#line 63
          if (xb_mode) {
#line 64
            move_speed -= (double )5;
          }
        }
      } else {
#line 59
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 66
    if (Variant == 3) {
#line 68
      move_speed -= (double )10;
    } else
#line 70
    if (Variant == 4) {
#line 72
      move_speed -= (double )5;
    }
#line 76
    allocated_time = (double )time_left / move_speed;
#line 79
    if (inc) {
#line 80
      if (((double )time_left - allocated_time) - (double )inc > (double )500) {
#line 81
        allocated_time += (double )inc;
      } else
#line 83
      if (((double )time_left - allocated_time) - ((double )inc * 2.0) / 3.0 > (double )100) {
#line 84
        allocated_time += ((double )inc * 2.0) / 3.0;
      }
    }
  } else {
#line 91
    allocated_time = ((double )((float )min_per_game) * 6000. + (double )((float )sec_per_game) * 100.) / (double )((float )moves_to_tc) - 100.;
#line 95
    if (time_cushion) {
#line 96
      allocated_time += ((double )time_cushion * 2.1) / 3.0;
#line 97
      time_cushion -= (int )(((double )time_cushion * 2.1) / 3.0);
    }
  }
#line 101
  if (Variant == 1) {
#line 103
    allocated_time *= 1. / 4.;
#line 105
    if (opp_time > time_left) {
#line 108
      allocated_time *= 1. / 2.;
    } else
#line 105
    if (opp_time < 1500) {
#line 108
      allocated_time *= 1. / 2.;
    }
  }
#line 112
  return ((int )allocated_time);
}
}
#line 116 "utils.c"
void comp_to_san(move_s move , char *str ) 
{ 
  move_s moves[512] ;
  move_s evade_moves[512] ;
  int type_to_char[14] ;
  int i ;
  int num_moves ;
  int evasions ;
  int ambig ;
  int mate ;
  int f_rank ;
  int t_rank ;
  int converter ;
  char f_file ;
  char t_file ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;

  {
#line 120
  type_to_char[0] = 'F';
#line 120
  type_to_char[1] = 'P';
#line 120
  type_to_char[2] = 'P';
#line 120
  type_to_char[3] = 'N';
#line 120
  type_to_char[4] = 'N';
#line 120
  type_to_char[5] = 'K';
#line 120
  type_to_char[6] = 'K';
#line 120
  type_to_char[7] = 'R';
#line 120
  type_to_char[8] = 'R';
#line 120
  type_to_char[9] = 'Q';
#line 120
  type_to_char[10] = 'Q';
#line 120
  type_to_char[11] = 'B';
#line 120
  type_to_char[12] = 'B';
#line 120
  type_to_char[13] = 'E';
#line 126
  f_rank = (int )Xrank[move.from];
#line 127
  t_rank = (int )Xrank[move.target];
#line 128
  converter = 'a';
#line 129
  f_file = (char )((Xfile[move.from] + (int const   )converter) - 1);
#line 130
  t_file = (char )((Xfile[move.target] + (int const   )converter) - 1);
#line 132
  if (move.from == 0) {
#line 134
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c@%c%d", type_to_char[move.promoted],
            (int )t_file, t_rank);
  } else
#line 136
  if (board[move.from] == 1) {
#line 136
    goto _L___0;
  } else
#line 136
  if (board[move.from] == 2) {
    _L___0: /* CIL Label */ 
#line 138
    if (board[move.target] == 13) {
#line 138
      if (! move.ep) {
#line 140
        if (! move.promoted) {
#line 142
          sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d", (int )t_file,
                  t_rank);
        } else {
#line 146
          sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d=%c",
                  (int )t_file, t_rank, type_to_char[move.promoted]);
        }
      } else {
#line 138
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 151
    if (! move.promoted) {
#line 153
      sprintf((char * __restrict  )str, (char const   * __restrict  )"%cx%c%d", (int )f_file,
              (int )t_file, t_rank);
    } else {
#line 157
      sprintf((char * __restrict  )str, (char const   * __restrict  )"%cx%c%d=%c",
              (int )f_file, (int )t_file, t_rank, type_to_char[move.promoted]);
    }
  } else
#line 162
  if (move.castled != 0) {
#line 164
    if (move.castled == 1) {
#line 166
      sprintf((char * __restrict  )str, (char const   * __restrict  )"O-O");
    } else
#line 164
    if (move.castled == 3) {
#line 166
      sprintf((char * __restrict  )str, (char const   * __restrict  )"O-O");
    } else {
#line 170
      sprintf((char * __restrict  )str, (char const   * __restrict  )"O-O-O");
    }
  } else {
#line 175
    ambig = -1;
#line 176
    num_moves = 0;
#line 178
    gen(& moves[0]);
#line 179
    num_moves = numb_moves;
#line 181
    tmp = in_check();
#line 181
    ic = (int )tmp;
#line 185
    i = 0;
#line 185
    while (i < num_moves) {
#line 187
      if (moves[i].target == move.target) {
#line 187
        if (board[moves[i].from] == board[move.from]) {
#line 187
          if (moves[i].from != move.from) {
#line 192
            make(& moves[0], i);
#line 193
            tmp___0 = check_legal(& moves[0], i, ic);
#line 193
            if (tmp___0) {
#line 195
              unmake(& moves[0], i);
#line 196
              ambig = i;
#line 197
              break;
            }
#line 199
            unmake(& moves[0], i);
          }
        }
      }
#line 185
      i ++;
    }
#line 203
    if (ambig != -1) {
#line 206
      if (board[move.target] == 13) {
#line 208
        if (Xfile[moves[ambig].from] != Xfile[move.from]) {
#line 209
          sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%c%c%d",
                  type_to_char[board[move.from]], (int )f_file, (int )t_file, t_rank);
        } else {
#line 212
          sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%d",
                  type_to_char[board[move.from]], f_rank, (int )t_file, t_rank);
        }
      } else
#line 217
      if (Xfile[moves[ambig].from] != Xfile[move.from]) {
#line 218
        sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%cx%c%d",
                type_to_char[board[move.from]], (int )f_file, (int )t_file, t_rank);
      } else {
#line 221
        sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%dx%c%d",
                type_to_char[board[move.from]], f_rank, (int )t_file, t_rank);
      }
    } else
#line 227
    if (board[move.target] == 13) {
#line 229
      sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%c%d", type_to_char[board[move.from]],
              (int )t_file, t_rank);
    } else {
#line 234
      sprintf((char * __restrict  )str, (char const   * __restrict  )"%cx%c%d", type_to_char[board[move.from]],
              (int )t_file, t_rank);
    }
  }
#line 240
  make(& move, 0);
#line 242
  tmp___1 = check_legal(& move, 0, 1);
#line 242
  if (! tmp___1) {
#line 244
    strcpy((char * __restrict  )str, (char const   * __restrict  )"illg");
#line 245
    unmake(& move, 0);
#line 246
    return;
  }
#line 249
  tmp___3 = in_check();
#line 249
  if (tmp___3) {
#line 251
    mate = 1;
#line 252
    evasions = 0;
#line 253
    gen(& evade_moves[0]);
#line 254
    evasions = numb_moves;
#line 256
    i = 0;
#line 256
    while (i < evasions) {
#line 258
      make(& evade_moves[0], i);
#line 259
      tmp___2 = check_legal(& evade_moves[0], i, 1);
#line 259
      if (tmp___2) {
#line 261
        mate = 0;
#line 262
        unmake(& evade_moves[0], i);
#line 263
        break;
      }
#line 265
      unmake(& evade_moves[0], i);
#line 256
      i ++;
    }
#line 267
    if (mate == 1) {
#line 268
      strcat((char * __restrict  )str, (char const   * __restrict  )"#");
    } else {
#line 270
      strcat((char * __restrict  )str, (char const   * __restrict  )"+");
    }
  }
#line 272
  unmake(& move, 0);
#line 274
  return;
}
}
#line 276 "utils.c"
void comp_to_coord(move_s move , char *str ) 
{ 
  int prom ;
  int from ;
  int target ;
  int f_rank ;
  int t_rank ;
  int converter ;
  char f_file ;
  char t_file ;
  int type_to_char[14] ;

  {
#line 283
  type_to_char[0] = 'F';
#line 283
  type_to_char[1] = 'P';
#line 283
  type_to_char[2] = 'p';
#line 283
  type_to_char[3] = 'N';
#line 283
  type_to_char[4] = 'n';
#line 283
  type_to_char[5] = 'K';
#line 283
  type_to_char[6] = 'k';
#line 283
  type_to_char[7] = 'R';
#line 283
  type_to_char[8] = 'r';
#line 283
  type_to_char[9] = 'Q';
#line 283
  type_to_char[10] = 'q';
#line 283
  type_to_char[11] = 'B';
#line 283
  type_to_char[12] = 'b';
#line 283
  type_to_char[13] = 'E';
#line 285
  prom = move.promoted;
#line 286
  from = move.from;
#line 287
  target = move.target;
#line 289
  f_rank = (int )Xrank[from];
#line 290
  t_rank = (int )Xrank[target];
#line 291
  converter = 'a';
#line 292
  f_file = (char )((Xfile[from] + (int const   )converter) - 1);
#line 293
  t_file = (char )((Xfile[target] + (int const   )converter) - 1);
#line 296
  if (from == 0) {
#line 298
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c@%c%d", type_to_char[prom],
            (int )t_file, t_rank);
  } else
#line 303
  if (! prom) {
#line 304
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%d", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 309
  if (prom == 3) {
#line 310
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dn", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 309
  if (prom == 4) {
#line 310
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dn", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 312
  if (prom == 7) {
#line 313
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dr", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 312
  if (prom == 8) {
#line 313
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dr", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 315
  if (prom == 11) {
#line 316
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%db", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 315
  if (prom == 12) {
#line 316
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%db", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 318
  if (prom == 5) {
#line 320
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dk", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else
#line 318
  if (prom == 6) {
#line 320
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dk", (int )f_file,
            f_rank, (int )t_file, t_rank);
  } else {
#line 324
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%c%d%c%dq", (int )f_file,
            f_rank, (int )t_file, t_rank);
  }
#line 328
  return;
}
}
#line 331 "utils.c"
void display_board(FILE *stream , int color ) 
{ 
  char const   *line_sep ;
  char const   *piece_rep[14] ;
  int a ;
  int b ;
  int c ;

  {
#line 335
  line_sep = "+----+----+----+----+----+----+----+----+";
#line 336
  piece_rep[0] = "!!";
#line 336
  piece_rep[1] = " P";
#line 336
  piece_rep[2] = "*P";
#line 336
  piece_rep[3] = " N";
#line 336
  piece_rep[4] = "*N";
#line 336
  piece_rep[5] = " K";
#line 336
  piece_rep[6] = "*K";
#line 336
  piece_rep[7] = " R";
#line 336
  piece_rep[8] = "*R";
#line 336
  piece_rep[9] = " Q";
#line 336
  piece_rep[10] = "*Q";
#line 336
  piece_rep[11] = " B";
#line 336
  piece_rep[12] = "*B";
#line 336
  piece_rep[13] = "  ";
#line 340
  if (color % 2) {
#line 341
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"  %s\n", line_sep);
#line 342
    a = 1;
#line 342
    while (a <= 8) {
#line 343
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%d |", 9 - a);
#line 344
      b = 0;
#line 344
      while (b <= 11) {
#line 345
        c = (120 - a * 12) + b;
#line 346
        if (board[c] != 0) {
#line 347
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )" %s |",
                  piece_rep[board[c]]);
        }
#line 344
        b ++;
      }
#line 349
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n  %s\n",
              line_sep);
#line 342
      a ++;
    }
#line 351
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n     a    b    c    d    e    f    g    h\n\n");
  } else {
#line 355
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"  %s\n", line_sep);
#line 356
    a = 1;
#line 356
    while (a <= 8) {
#line 357
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%d |", a);
#line 358
      b = 0;
#line 358
      while (b <= 11) {
#line 359
        c = (24 + a * 12) - b;
#line 360
        if (board[c] != 0) {
#line 361
          fprintf((FILE * __restrict  )stream, (char const   * __restrict  )" %s |",
                  piece_rep[board[c]]);
        }
#line 358
        b ++;
      }
#line 363
      fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n  %s\n",
              line_sep);
#line 356
      a ++;
    }
#line 365
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n     h    g    f    e    d    c    b    a\n\n");
  }
#line 368
  return;
}
}
#line 370 "utils.c"
void init_game(void) 
{ 
  int init_board[144] ;

  {
#line 374
  init_board[0] = 0;
#line 374
  init_board[1] = 0;
#line 374
  init_board[2] = 0;
#line 374
  init_board[3] = 0;
#line 374
  init_board[4] = 0;
#line 374
  init_board[5] = 0;
#line 374
  init_board[6] = 0;
#line 374
  init_board[7] = 0;
#line 374
  init_board[8] = 0;
#line 374
  init_board[9] = 0;
#line 374
  init_board[10] = 0;
#line 374
  init_board[11] = 0;
#line 374
  init_board[12] = 0;
#line 374
  init_board[13] = 0;
#line 374
  init_board[14] = 0;
#line 374
  init_board[15] = 0;
#line 374
  init_board[16] = 0;
#line 374
  init_board[17] = 0;
#line 374
  init_board[18] = 0;
#line 374
  init_board[19] = 0;
#line 374
  init_board[20] = 0;
#line 374
  init_board[21] = 0;
#line 374
  init_board[22] = 0;
#line 374
  init_board[23] = 0;
#line 374
  init_board[24] = 0;
#line 374
  init_board[25] = 0;
#line 374
  init_board[26] = 7;
#line 374
  init_board[27] = 3;
#line 374
  init_board[28] = 11;
#line 374
  init_board[29] = 9;
#line 374
  init_board[30] = 5;
#line 374
  init_board[31] = 11;
#line 374
  init_board[32] = 3;
#line 374
  init_board[33] = 7;
#line 374
  init_board[34] = 0;
#line 374
  init_board[35] = 0;
#line 374
  init_board[36] = 0;
#line 374
  init_board[37] = 0;
#line 374
  init_board[38] = 1;
#line 374
  init_board[39] = 1;
#line 374
  init_board[40] = 1;
#line 374
  init_board[41] = 1;
#line 374
  init_board[42] = 1;
#line 374
  init_board[43] = 1;
#line 374
  init_board[44] = 1;
#line 374
  init_board[45] = 1;
#line 374
  init_board[46] = 0;
#line 374
  init_board[47] = 0;
#line 374
  init_board[48] = 0;
#line 374
  init_board[49] = 0;
#line 374
  init_board[50] = 13;
#line 374
  init_board[51] = 13;
#line 374
  init_board[52] = 13;
#line 374
  init_board[53] = 13;
#line 374
  init_board[54] = 13;
#line 374
  init_board[55] = 13;
#line 374
  init_board[56] = 13;
#line 374
  init_board[57] = 13;
#line 374
  init_board[58] = 0;
#line 374
  init_board[59] = 0;
#line 374
  init_board[60] = 0;
#line 374
  init_board[61] = 0;
#line 374
  init_board[62] = 13;
#line 374
  init_board[63] = 13;
#line 374
  init_board[64] = 13;
#line 374
  init_board[65] = 13;
#line 374
  init_board[66] = 13;
#line 374
  init_board[67] = 13;
#line 374
  init_board[68] = 13;
#line 374
  init_board[69] = 13;
#line 374
  init_board[70] = 0;
#line 374
  init_board[71] = 0;
#line 374
  init_board[72] = 0;
#line 374
  init_board[73] = 0;
#line 374
  init_board[74] = 13;
#line 374
  init_board[75] = 13;
#line 374
  init_board[76] = 13;
#line 374
  init_board[77] = 13;
#line 374
  init_board[78] = 13;
#line 374
  init_board[79] = 13;
#line 374
  init_board[80] = 13;
#line 374
  init_board[81] = 13;
#line 374
  init_board[82] = 0;
#line 374
  init_board[83] = 0;
#line 374
  init_board[84] = 0;
#line 374
  init_board[85] = 0;
#line 374
  init_board[86] = 13;
#line 374
  init_board[87] = 13;
#line 374
  init_board[88] = 13;
#line 374
  init_board[89] = 13;
#line 374
  init_board[90] = 13;
#line 374
  init_board[91] = 13;
#line 374
  init_board[92] = 13;
#line 374
  init_board[93] = 13;
#line 374
  init_board[94] = 0;
#line 374
  init_board[95] = 0;
#line 374
  init_board[96] = 0;
#line 374
  init_board[97] = 0;
#line 374
  init_board[98] = 2;
#line 374
  init_board[99] = 2;
#line 374
  init_board[100] = 2;
#line 374
  init_board[101] = 2;
#line 374
  init_board[102] = 2;
#line 374
  init_board[103] = 2;
#line 374
  init_board[104] = 2;
#line 374
  init_board[105] = 2;
#line 374
  init_board[106] = 0;
#line 374
  init_board[107] = 0;
#line 374
  init_board[108] = 0;
#line 374
  init_board[109] = 0;
#line 374
  init_board[110] = 8;
#line 374
  init_board[111] = 4;
#line 374
  init_board[112] = 12;
#line 374
  init_board[113] = 10;
#line 374
  init_board[114] = 6;
#line 374
  init_board[115] = 12;
#line 374
  init_board[116] = 4;
#line 374
  init_board[117] = 8;
#line 374
  init_board[118] = 0;
#line 374
  init_board[119] = 0;
#line 374
  init_board[120] = 0;
#line 374
  init_board[121] = 0;
#line 374
  init_board[122] = 0;
#line 374
  init_board[123] = 0;
#line 374
  init_board[124] = 0;
#line 374
  init_board[125] = 0;
#line 374
  init_board[126] = 0;
#line 374
  init_board[127] = 0;
#line 374
  init_board[128] = 0;
#line 374
  init_board[129] = 0;
#line 374
  init_board[130] = 0;
#line 374
  init_board[131] = 0;
#line 374
  init_board[132] = 0;
#line 374
  init_board[133] = 0;
#line 374
  init_board[134] = 0;
#line 374
  init_board[135] = 0;
#line 374
  init_board[136] = 0;
#line 374
  init_board[137] = 0;
#line 374
  init_board[138] = 0;
#line 374
  init_board[139] = 0;
#line 374
  init_board[140] = 0;
#line 374
  init_board[141] = 0;
#line 374
  init_board[142] = 0;
#line 374
  init_board[143] = 0;
#line 389
  memcpy((void * __restrict  )(board), (void const   * __restrict  )(init_board),
         sizeof(init_board));
#line 390
  memset((void *)(moved), 0, sizeof(moved));
#line 392
  white_to_move = 1;
#line 393
  ep_square = 0;
#line 394
  wking_loc = 30;
#line 395
  bking_loc = 114;
#line 396
  white_castled = 0;
#line 397
  black_castled = 0;
#line 399
  result = 0;
#line 400
  captures = (xbool )0;
#line 402
  piece_count = 32;
#line 404
  Material = 0;
#line 406
  memset((void *)(is_promoted), 0, sizeof(is_promoted));
#line 407
  memset((void *)(holding), 0, sizeof(holding));
#line 409
  white_hand_eval = 0;
#line 410
  black_hand_eval = 0;
#line 412
  reset_piece_square();
#line 414
  bookidx = 0U;
#line 415
  book_ply = 0;
#line 416
  fifty = 0;
#line 417
  ply = 0;
#line 419
  phase = 0;
#line 420
  return;
}
}
#line 423 "utils.c"
xbool is_move(char *str ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 428
  tmp___2 = __ctype_b_loc();
#line 428
  if ((int const   )*(*tmp___2 + (int )*(str + 0)) & 1024) {
#line 428
    tmp___3 = __ctype_b_loc();
#line 428
    if ((int const   )*(*tmp___3 + (int )*(str + 1)) & 2048) {
#line 428
      tmp___4 = __ctype_b_loc();
#line 428
      if ((int const   )*(*tmp___4 + (int )*(str + 2)) & 1024) {
#line 428
        tmp___5 = __ctype_b_loc();
#line 428
        if ((int const   )*(*tmp___5 + (int )*(str + 3)) & 2048) {
#line 430
          return ((xbool )1);
        } else {
#line 428
          goto _L___1;
        }
      } else {
#line 428
        goto _L___1;
      }
    } else {
#line 428
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 432
    tmp = __ctype_b_loc();
#line 432
    if ((int const   )*(*tmp + (int )*(str + 0)) & 1024) {
#line 432
      if ((int )*(str + 1) == 64) {
#line 432
        tmp___0 = __ctype_b_loc();
#line 432
        if ((int const   )*(*tmp___0 + (int )*(str + 2)) & 1024) {
#line 432
          tmp___1 = __ctype_b_loc();
#line 432
          if ((int const   )*(*tmp___1 + (int )*(str + 3)) & 2048) {
#line 434
            return ((xbool )1);
          } else {
#line 437
            return ((xbool )0);
          }
        } else {
#line 437
          return ((xbool )0);
        }
      } else {
#line 437
        return ((xbool )0);
      }
    } else {
#line 437
      return ((xbool )0);
    }
  }
}
}
#line 443 "utils.c"
void perft_debug(void) 
{ 
  char input[256] ;
  char *p ;
  move_s move ;
  int depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  xbool tmp___5 ;
  xbool tmp___6 ;

  {
#line 452
  init_game();
#line 456
  while (1) {
#line 458
    printf((char const   * __restrict  )"\n\nPlease enter the desired depth for perft():\n");
#line 459
    rinput(input, 256, stdin);
#line 460
    depth = atoi((char const   *)(input));
#line 463
    raw_nodes = 0;
#line 464
    perft(depth);
#line 465
    printf((char const   * __restrict  )"\n\nRaw nodes for depth %d: %i\n\n", depth,
           raw_nodes);
#line 468
    display_board(stdout, 1);
#line 470
    printf((char const   * __restrict  )"\nPlease input a move/command:\n");
#line 471
    rinput(input, 256, stdin);
#line 474
    p = input;
#line 474
    while (*p) {
#line 474
      tmp = tolower((int )*p);
#line 474
      *p = (char )tmp;
#line 474
      p ++;
    }
#line 475
    tmp___0 = strcmp((char const   *)(input), "exit");
#line 475
    if (tmp___0) {
#line 475
      tmp___1 = strcmp((char const   *)(input), "quit");
#line 475
      if (! tmp___1) {
#line 476
        exit(0);
      }
    } else {
#line 476
      exit(0);
    }
#line 479
    tmp___6 = verify_coord(input, & move);
#line 479
    if (! tmp___6) {
#line 481
      while (1) {
#line 482
        printf((char const   * __restrict  )"\nIllegal move/command!  Please input a new move/command:\n");
#line 483
        rinput(input, 256, stdin);
#line 486
        p = input;
#line 486
        while (*p) {
#line 486
          tmp___2 = tolower((int )*p);
#line 486
          *p = (char )tmp___2;
#line 486
          p ++;
        }
#line 487
        tmp___3 = strcmp((char const   *)(input), "exit");
#line 487
        if (tmp___3) {
#line 487
          tmp___4 = strcmp((char const   *)(input), "quit");
#line 487
          if (! tmp___4) {
#line 488
            exit(0);
          }
        } else {
#line 488
          exit(0);
        }
#line 481
        tmp___5 = verify_coord(input, & move);
#line 481
        if (tmp___5) {
#line 481
          break;
        }
      }
    }
#line 493
    make(& move, 0);
  }
}
}
#line 497 "utils.c"
void hash_extract_pv(int level , char *str ) 
{ 
  int xdummy ;
  int bm ;
  move_s moves[512] ;
  int num_moves ;
  char output[256] ;
  xbool tmp ;
  int tmp___0 ;

  {
#line 505
  level --;
#line 506
  if (! level) {
#line 506
    return;
  }
#line 508
  tmp___0 = ProbeTT(& xdummy, 0, & bm, & xdummy, & xdummy, 0);
#line 508
  if (tmp___0 != 4) {
#line 510
    gen(& moves[0]);
#line 511
    num_moves = numb_moves;
#line 512
    if (bm >= 0) {
#line 512
      if (bm < num_moves) {
#line 514
        comp_to_san(moves[bm], output);
#line 515
        make(& moves[0], bm);
#line 516
        tmp = check_legal(& moves[0], bm, 1);
#line 516
        if (tmp) {
#line 519
          strcat((char * __restrict  )str, (char const   * __restrict  )"<");
#line 520
          strcat((char * __restrict  )str, (char const   * __restrict  )(output));
#line 521
          strcat((char * __restrict  )str, (char const   * __restrict  )"> ");
#line 522
          hash_extract_pv(level, str);
        }
#line 524
        unmake(& moves[0], bm);
      }
    }
  }
#line 527
  return;
}
}
#line 529 "utils.c"
void stringize_pv(char *str ) 
{ 
  char output[256] ;
  int i ;

  {
#line 534
  memset((void *)str, 0, (size_t )256);
#line 536
  i = 1;
#line 536
  while (i < pv_length[1]) {
#line 538
    comp_to_san(pv[1][i], output);
#line 539
    make(& pv[1][i], 0);
#line 540
    strcat((char * __restrict  )str, (char const   * __restrict  )(output));
#line 541
    strcat((char * __restrict  )str, (char const   * __restrict  )" ");
#line 536
    i ++;
  }
#line 544
  hash_extract_pv(7, str);
#line 546
  i = pv_length[1] - 1;
#line 546
  while (i > 0) {
#line 548
    unmake(& pv[1][i], 0);
#line 546
    i --;
  }
#line 551
  return;
}
}
#line 553 "utils.c"
void post_thinking(int score ) 
{ 
  int i ;
  int remake ;
  int nps ;
  int elapsed ;
  char output[256] ;
  char hashpv[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 557
  remake = 0;
#line 565
  tmp = rtime();
#line 565
  elapsed = rdifftime(tmp, start_time);
#line 567
  if (elapsed > 0) {
#line 568
    dnps = (100.0 * (double )nodes) / (double )elapsed;
#line 569
    nps = (int )dnps;
  } else {
#line 572
    nps = nodes;
  }
#line 573
  if (xb_mode) {
#line 574
    printf((char const   * __restrict  )"%2i %7i %5i %8i  ", i_depth, score, elapsed,
           nodes);
  } else {
#line 576
    tmp___0 = abs(score % 100);
#line 576
    tmp___1 = abs(score / 100);
#line 576
    if (score < 0) {
#line 576
      tmp___2 = '-';
    } else {
#line 576
      tmp___2 = ' ';
    }
#line 576
    printf((char const   * __restrict  )"%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1,
           tmp___0, nodes);
  }
#line 584
  if (pv[1][1].from != 0) {
#line 584
    if (board[pv[1][1].from] == 13) {
#line 587
      unmake(& pv[1][1], 0);
#line 588
      remake = 1;
    } else {
#line 584
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 584
  if (pv[1][1].from == 0) {
#line 584
    if (board[pv[1][1].target] != 13) {
#line 587
      unmake(& pv[1][1], 0);
#line 588
      remake = 1;
    }
  }
#line 591
  i = 1;
#line 591
  while (i < pv_length[1]) {
#line 592
    comp_to_san(pv[1][i], output);
#line 593
    make(& pv[1][i], 0);
#line 594
    printf((char const   * __restrict  )"%s ", output);
#line 591
    i ++;
  }
#line 597
  memset((void *)(hashpv), 0, sizeof(hashpv));
#line 599
  hash_extract_pv(7, hashpv);
#line 601
  printf((char const   * __restrict  )"%s", hashpv);
#line 603
  i = pv_length[1] - 1;
#line 603
  while (i > 0) {
#line 605
    unmake(& pv[1][i], 0);
#line 603
    i --;
  }
#line 607
  if (remake) {
#line 608
    make(& pv[1][1], 0);
  }
#line 610
  printf((char const   * __restrict  )"\n");
#line 611
  return;
}
}
#line 613 "utils.c"
void post_fail_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 623
  tmp = rtime();
#line 623
  elapsed = rdifftime(tmp, start_time);
#line 624
  if (elapsed > 0) {
#line 625
    dnps = (100.0 * (double )nodes) / (double )elapsed;
#line 626
    nps = (int )dnps;
  } else {
#line 629
    nps = nodes;
  }
#line 630
  if (xb_mode) {
#line 631
    printf((char const   * __restrict  )"%2i %7i %5i %8i  ", i_depth, score, elapsed,
           nodes);
  } else {
#line 633
    tmp___0 = abs(score % 100);
#line 633
    tmp___1 = abs(score / 100);
#line 633
    if (score < 0) {
#line 633
      tmp___2 = '-';
    } else {
#line 633
      tmp___2 = ' ';
    }
#line 633
    printf((char const   * __restrict  )"%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1,
           tmp___0, nodes);
  }
#line 636
  unmake(failmove, 0);
#line 637
  comp_to_san(*failmove, output);
#line 638
  make(failmove, 0);
#line 639
  printf((char const   * __restrict  )"%s !", output);
#line 640
  printf((char const   * __restrict  )"\n");
#line 641
  return;
}
}
#line 643 "utils.c"
void post_fh_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 652
  tmp = rtime();
#line 652
  elapsed = rdifftime(tmp, start_time);
#line 654
  if (elapsed > 0) {
#line 655
    dnps = (100.0 * (double )nodes) / (double )elapsed;
#line 656
    nps = (int )dnps;
  } else {
#line 659
    nps = nodes;
  }
#line 660
  if (xb_mode) {
#line 661
    printf((char const   * __restrict  )"%2i %7i %5i %8i  ", i_depth, score, elapsed,
           nodes);
  } else {
#line 663
    tmp___0 = abs(score % 100);
#line 663
    tmp___1 = abs(score / 100);
#line 663
    if (score < 0) {
#line 663
      tmp___2 = '-';
    } else {
#line 663
      tmp___2 = ' ';
    }
#line 663
    printf((char const   * __restrict  )"%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1,
           tmp___0, nodes);
  }
#line 665
  unmake(failmove, 0);
#line 666
  comp_to_san(*failmove, output);
#line 667
  make(failmove, 0);
#line 668
  printf((char const   * __restrict  )"%s !!", output);
#line 669
  printf((char const   * __restrict  )"\n");
#line 670
  return;
}
}
#line 672 "utils.c"
void post_fl_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 681
  tmp = rtime();
#line 681
  elapsed = rdifftime(tmp, start_time);
#line 683
  if (elapsed > 0) {
#line 684
    dnps = (100.0 * (double )nodes) / (double )elapsed;
#line 685
    nps = (int )dnps;
  } else {
#line 688
    nps = nodes;
  }
#line 689
  if (xb_mode) {
#line 690
    printf((char const   * __restrict  )"%2i %7i %5i %8i  ", i_depth, score, elapsed,
           nodes);
  } else {
#line 692
    tmp___0 = abs(score % 100);
#line 692
    tmp___1 = abs(score / 100);
#line 692
    if (score < 0) {
#line 692
      tmp___2 = '-';
    } else {
#line 692
      tmp___2 = ' ';
    }
#line 692
    printf((char const   * __restrict  )"%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1,
           tmp___0, nodes);
  }
#line 694
  unmake(failmove, 0);
#line 695
  comp_to_san(*failmove, output);
#line 696
  make(failmove, 0);
#line 697
  printf((char const   * __restrict  )"%s ??", output);
#line 698
  printf((char const   * __restrict  )"\n");
#line 699
  return;
}
}
#line 701 "utils.c"
void post_stat_thinking(void) 
{ 
  int elapsed ;
  rtime_t tmp ;

  {
#line 707
  tmp = rtime();
#line 707
  elapsed = rdifftime(tmp, start_time);
#line 709
  if (xb_mode == 1) {
#line 711
    printf((char const   * __restrict  )"stat01: %i %i %i %i %i\n", elapsed, nodes,
           i_depth, moveleft, movetotal);
  } else
#line 713
  if (xb_mode == 2) {
#line 715
    printf((char const   * __restrict  )"stat01: %i %i %i %i %i %s\n", elapsed, nodes,
           i_depth, moveleft, movetotal, searching_move);
  }
#line 717
  return;
}
}
#line 720 "utils.c"
void print_move(move_s *moves , int m , FILE *stream ) 
{ 
  char move[256] ;

  {
#line 726
  comp_to_san(*(moves + m), move);
#line 728
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s", move);
#line 730
  return;
}
}
#line 733 "utils.c"
void rdelay(int time_in_s ) 
{ 
  rtime_t time1 ;
  rtime_t time2 ;
  int timer ;

  {
#line 738
  timer = 0;
#line 740
  time1 = rtime();
#line 741
  while (timer / 100 < time_in_s) {
#line 742
    time2 = rtime();
#line 743
    timer = rdifftime(time2, time1);
  }
#line 746
  return;
}
}
#line 749 "utils.c"
int rdifftime(rtime_t end , rtime_t start ) 
{ 
  double tmp ;

  {
#line 758
  tmp = difftime(end, start);
#line 758
  return (100 * (int )tmp);
}
}
#line 763 "utils.c"
void check_piece_square(void) 
{ 
  int i ;

  {
#line 767
  i = 1;
#line 767
  while (i <= piece_count) {
#line 769
    if (squares[pieces[i]] != i) {
#line 769
      if (pieces[i] != 0) {
#line 771
        printf((char const   * __restrict  )"Piece->square->piece inconsistency\n");
#line 772
        display_board(stdout, 0);
#line 773
        *((int *)((void *)0)) = 0;
      }
    }
#line 775
    if (board[pieces[i]] == 13) {
#line 775
      if (pieces[i] != 0) {
#line 777
        printf((char const   * __restrict  )"Board/Piece->square inconsistency\n");
#line 778
        display_board(stdout, 0);
#line 779
        *((int *)((void *)0)) = 0;
      }
    }
#line 781
    if (pieces[i] == 0) {
#line 781
      if (squares[pieces[i]] != 0) {
#line 783
        printf((char const   * __restrict  )"Zero-ed piece inconsistency\n");
#line 784
        display_board(stdout, 0);
#line 785
        *((int *)((void *)0)) = 0;
      }
    }
#line 767
    i ++;
  }
#line 788
  i = 0;
#line 788
  while (i < 144) {
#line 790
    if (board[i] == 13) {
#line 790
      goto _L;
    } else
#line 790
    if (board[i] == 0) {
      _L: /* CIL Label */ 
#line 790
      if (squares[i] != 0) {
#line 792
        printf((char const   * __restrict  )"Empty square has piece pointer\n");
#line 793
        display_board(stdout, 0);
#line 794
        *((int *)((void *)0)) = 0;
      }
    }
#line 796
    if (board[i] != 13) {
#line 796
      if (board[i] != 0) {
#line 796
        if (squares[i] == 0) {
#line 798
          printf((char const   * __restrict  )"Filled square %d has no piece pointer\n",
                 i);
#line 799
          display_board(stdout, 0);
#line 800
          *((int *)((void *)0)) = 0;
        }
      }
    }
#line 802
    if (pieces[squares[i]] != i) {
#line 802
      if (squares[i] != 0) {
#line 804
        printf((char const   * __restrict  )"Square->piece->square inconsistency\n");
#line 805
        display_board(stdout, 0);
#line 806
        *((int *)((void *)0)) = 0;
      }
    }
#line 788
    i ++;
  }
#line 809
  return;
}
}
#line 811 "utils.c"
void reset_piece_square(void) 
{ 
  int i ;
  int promoted_board[144] ;

  {
#line 820
  memset((void *)(promoted_board), 0, sizeof(promoted_board));
#line 824
  i = 1;
#line 824
  while (i <= piece_count) {
#line 825
    if (is_promoted[i]) {
#line 826
      promoted_board[pieces[i]] = 1;
    }
#line 824
    i ++;
  }
#line 828
  Material = 0;
#line 830
  piece_count = 0;
#line 832
  memset((void *)(pieces), 0, sizeof(pieces));
#line 833
  memset((void *)(is_promoted), 0, sizeof(is_promoted));
#line 835
  pieces[0] = 0;
#line 837
  i = 26;
#line 837
  while (i < 118) {
#line 838
    if (board[i]) {
#line 838
      if (board[i] < 13) {
#line 840
        Material += material[board[i]];
#line 842
        piece_count ++;
#line 844
        pieces[piece_count] = i;
#line 845
        squares[i] = piece_count;
#line 848
        if (promoted_board[i]) {
#line 849
          is_promoted[piece_count] = 1;
        }
      } else {
#line 852
        squares[i] = 0;
      }
    } else {
#line 852
      squares[i] = 0;
    }
#line 837
    i ++;
  }
#line 853
  return;
}
}
#line 856 "utils.c"
void rinput(char *str , int n , FILE *stream ) 
{ 
  int ch ;
  int i ;
  int tmp ;

  {
#line 862
  i = 0;
#line 864
  while (1) {
#line 864
    ch = _IO_getc(stream);
#line 864
    if (ch != 10) {
#line 864
      if (! (ch != -1)) {
#line 864
        break;
      }
    } else {
#line 864
      break;
    }
#line 865
    if (i < n - 1) {
#line 866
      tmp = i;
#line 866
      i ++;
#line 866
      *(str + tmp) = (char )ch;
    }
  }
#line 870
  *(str + i) = (char )'\000';
#line 872
  return;
}
}
#line 874 "utils.c"
rtime_t rtime(void) 
{ 


  {
#line 895
  return ((rtime_t )0);
}
}
#line 902 "utils.c"
void start_up(void) 
{ 


  {
#line 906
  printf((char const   * __restrict  )"\nSjeng version SPEC 1.0, Copyright (C) 2000-2005 Gian-Carlo Pascutto\n\n");
#line 907
  return;
}
}
#line 910 "utils.c"
void toggle_bool(xbool *var ) 
{ 


  {
#line 914
  if (*var) {
#line 915
    *var = (xbool )0;
  } else {
#line 918
    *var = (xbool )1;
  }
#line 921
  return;
}
}
#line 924 "utils.c"
void tree_debug(void) 
{ 
  char input[256] ;
  FILE *stream ;
  int depth ;

  {
#line 933
  init_game();
#line 936
  printf((char const   * __restrict  )"\nPlease enter the desired depth:\n");
#line 937
  rinput(input, 256, stdin);
#line 938
  depth = atoi((char const   *)(input));
#line 941
  printf((char const   * __restrict  )"\nDo you want tree () output?  (y/n)\n");
#line 942
  rinput(input, 256, stdin);
#line 943
  if ((int )input[0] == 121) {
#line 945
    printf((char const   * __restrict  )"\nPlease enter the name of the output file for tree ():\n");
#line 946
    rinput(input, 256, stdin);
#line 947
    stream = fopen((char const   * __restrict  )(input), (char const   * __restrict  )"w");
#line 947
    if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 948
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open file %s\n",
              input);
    }
#line 952
    printf((char const   * __restrict  )"\nDo you want to output diagrams? (y/n)\n");
#line 953
    rinput(input, 256, stdin);
#line 955
    tree(depth, 0, stream, input);
  }
#line 959
  raw_nodes = 0;
#line 960
  perft(depth);
#line 961
  printf((char const   * __restrict  )"\n\n%s\nRaw nodes for depth %d: %i\n%s\n\n",
         divider, depth, raw_nodes, divider);
#line 964
  return;
}
}
#line 967 "utils.c"
xbool verify_coord(char *input , move_s *move ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  char comp_move[6] ;
  xbool legal ;
  xbool mate ;
  xbool tmp ;
  xbool tmp___0 ;
  int tmp___1 ;

  {
#line 975
  legal = (xbool )0;
#line 978
  if (Variant == 4) {
#line 980
    captures = (xbool )1;
#line 981
    num_moves = 0;
#line 982
    gen(& moves[0]);
#line 983
    num_moves = numb_moves;
#line 984
    captures = (xbool )0;
#line 986
    mate = (xbool )1;
#line 988
    i = 0;
#line 988
    while (i < num_moves) {
#line 990
      make(& moves[0], i);
#line 993
      tmp = check_legal(& moves[0], i, 1);
#line 993
      if (tmp) {
#line 995
        mate = (xbool )0;
#line 996
        unmake(& moves[0], i);
#line 997
        break;
      }
#line 1000
      unmake(& moves[0], i);
#line 988
      i ++;
    }
#line 1003
    if ((unsigned int )mate == 1U) {
#line 1006
      captures = (xbool )0;
#line 1007
      num_moves = 0;
#line 1008
      gen(& moves[0]);
#line 1009
      num_moves = numb_moves;
    }
  } else {
#line 1014
    gen(& moves[0]);
#line 1015
    num_moves = numb_moves;
  }
#line 1019
  i = 0;
#line 1019
  while (i < num_moves) {
#line 1020
    comp_to_coord(moves[i], comp_move);
#line 1021
    tmp___1 = strcmp((char const   *)input, (char const   *)(comp_move));
#line 1021
    if (! tmp___1) {
#line 1022
      make(& moves[0], i);
#line 1023
      tmp___0 = check_legal(& moves[0], i, 1);
#line 1023
      if (tmp___0) {
#line 1024
        legal = (xbool )1;
#line 1025
        *move = moves[i];
      }
#line 1027
      unmake(& moves[0], i);
    }
#line 1019
    i ++;
  }
#line 1031
  return (legal);
}
}
#line 1035 "utils.c"
int interrupt(void) 
{ 


  {
#line 1039
  return (0);
}
}
#line 1042 "utils.c"
void PutPiece(int color , char piece , char pfile , int prank ) 
{ 
  int converterf ;
  int converterr ;
  int norm_file ;
  int norm_rank ;
  int norm_square ;

  {
#line 1044
  converterf = 'a';
#line 1045
  converterr = '1';
#line 1048
  norm_file = (int )pfile - converterf;
#line 1049
  norm_rank = prank - converterr;
#line 1051
  norm_square = (norm_rank * 12 + 26) + norm_file;
#line 1053
  if (color == 0) {
#line 1055
    switch ((int )piece) {
    case 112: 
#line 1058
    board[norm_square] = 1;
#line 1059
    break;
    case 110: 
#line 1061
    board[norm_square] = 3;
#line 1062
    break;
    case 98: 
#line 1064
    board[norm_square] = 11;
#line 1065
    break;
    case 114: 
#line 1067
    board[norm_square] = 7;
#line 1068
    break;
    case 113: 
#line 1070
    board[norm_square] = 9;
#line 1071
    break;
    case 107: 
#line 1073
    board[norm_square] = 5;
#line 1074
    break;
    case 120: 
#line 1076
    board[norm_square] = 13;
#line 1077
    break;
    }
  } else
#line 1080
  if (color == 1) {
#line 1082
    switch ((int )piece) {
    case 112: 
#line 1085
    board[norm_square] = 2;
#line 1086
    break;
    case 110: 
#line 1088
    board[norm_square] = 4;
#line 1089
    break;
    case 98: 
#line 1091
    board[norm_square] = 12;
#line 1092
    break;
    case 114: 
#line 1094
    board[norm_square] = 8;
#line 1095
    break;
    case 113: 
#line 1097
    board[norm_square] = 10;
#line 1098
    break;
    case 107: 
#line 1100
    board[norm_square] = 6;
#line 1101
    break;
    case 120: 
#line 1103
    board[norm_square] = 13;
#line 1104
    break;
    }
  }
#line 1108
  return;
}
}
#line 1111 "utils.c"
void reset_board(void) 
{ 
  int i ;
  int init_board[144] ;

  {
#line 1117
  init_board[0] = 0;
#line 1117
  init_board[1] = 0;
#line 1117
  init_board[2] = 0;
#line 1117
  init_board[3] = 0;
#line 1117
  init_board[4] = 0;
#line 1117
  init_board[5] = 0;
#line 1117
  init_board[6] = 0;
#line 1117
  init_board[7] = 0;
#line 1117
  init_board[8] = 0;
#line 1117
  init_board[9] = 0;
#line 1117
  init_board[10] = 0;
#line 1117
  init_board[11] = 0;
#line 1117
  init_board[12] = 0;
#line 1117
  init_board[13] = 0;
#line 1117
  init_board[14] = 0;
#line 1117
  init_board[15] = 0;
#line 1117
  init_board[16] = 0;
#line 1117
  init_board[17] = 0;
#line 1117
  init_board[18] = 0;
#line 1117
  init_board[19] = 0;
#line 1117
  init_board[20] = 0;
#line 1117
  init_board[21] = 0;
#line 1117
  init_board[22] = 0;
#line 1117
  init_board[23] = 0;
#line 1117
  init_board[24] = 0;
#line 1117
  init_board[25] = 0;
#line 1117
  init_board[26] = 13;
#line 1117
  init_board[27] = 13;
#line 1117
  init_board[28] = 13;
#line 1117
  init_board[29] = 13;
#line 1117
  init_board[30] = 13;
#line 1117
  init_board[31] = 13;
#line 1117
  init_board[32] = 13;
#line 1117
  init_board[33] = 13;
#line 1117
  init_board[34] = 0;
#line 1117
  init_board[35] = 0;
#line 1117
  init_board[36] = 0;
#line 1117
  init_board[37] = 0;
#line 1117
  init_board[38] = 13;
#line 1117
  init_board[39] = 13;
#line 1117
  init_board[40] = 13;
#line 1117
  init_board[41] = 13;
#line 1117
  init_board[42] = 13;
#line 1117
  init_board[43] = 13;
#line 1117
  init_board[44] = 13;
#line 1117
  init_board[45] = 13;
#line 1117
  init_board[46] = 0;
#line 1117
  init_board[47] = 0;
#line 1117
  init_board[48] = 0;
#line 1117
  init_board[49] = 0;
#line 1117
  init_board[50] = 13;
#line 1117
  init_board[51] = 13;
#line 1117
  init_board[52] = 13;
#line 1117
  init_board[53] = 13;
#line 1117
  init_board[54] = 13;
#line 1117
  init_board[55] = 13;
#line 1117
  init_board[56] = 13;
#line 1117
  init_board[57] = 13;
#line 1117
  init_board[58] = 0;
#line 1117
  init_board[59] = 0;
#line 1117
  init_board[60] = 0;
#line 1117
  init_board[61] = 0;
#line 1117
  init_board[62] = 13;
#line 1117
  init_board[63] = 13;
#line 1117
  init_board[64] = 13;
#line 1117
  init_board[65] = 13;
#line 1117
  init_board[66] = 13;
#line 1117
  init_board[67] = 13;
#line 1117
  init_board[68] = 13;
#line 1117
  init_board[69] = 13;
#line 1117
  init_board[70] = 0;
#line 1117
  init_board[71] = 0;
#line 1117
  init_board[72] = 0;
#line 1117
  init_board[73] = 0;
#line 1117
  init_board[74] = 13;
#line 1117
  init_board[75] = 13;
#line 1117
  init_board[76] = 13;
#line 1117
  init_board[77] = 13;
#line 1117
  init_board[78] = 13;
#line 1117
  init_board[79] = 13;
#line 1117
  init_board[80] = 13;
#line 1117
  init_board[81] = 13;
#line 1117
  init_board[82] = 0;
#line 1117
  init_board[83] = 0;
#line 1117
  init_board[84] = 0;
#line 1117
  init_board[85] = 0;
#line 1117
  init_board[86] = 13;
#line 1117
  init_board[87] = 13;
#line 1117
  init_board[88] = 13;
#line 1117
  init_board[89] = 13;
#line 1117
  init_board[90] = 13;
#line 1117
  init_board[91] = 13;
#line 1117
  init_board[92] = 13;
#line 1117
  init_board[93] = 13;
#line 1117
  init_board[94] = 0;
#line 1117
  init_board[95] = 0;
#line 1117
  init_board[96] = 0;
#line 1117
  init_board[97] = 0;
#line 1117
  init_board[98] = 13;
#line 1117
  init_board[99] = 13;
#line 1117
  init_board[100] = 13;
#line 1117
  init_board[101] = 13;
#line 1117
  init_board[102] = 13;
#line 1117
  init_board[103] = 13;
#line 1117
  init_board[104] = 13;
#line 1117
  init_board[105] = 13;
#line 1117
  init_board[106] = 0;
#line 1117
  init_board[107] = 0;
#line 1117
  init_board[108] = 0;
#line 1117
  init_board[109] = 0;
#line 1117
  init_board[110] = 13;
#line 1117
  init_board[111] = 13;
#line 1117
  init_board[112] = 13;
#line 1117
  init_board[113] = 13;
#line 1117
  init_board[114] = 13;
#line 1117
  init_board[115] = 13;
#line 1117
  init_board[116] = 13;
#line 1117
  init_board[117] = 13;
#line 1117
  init_board[118] = 0;
#line 1117
  init_board[119] = 0;
#line 1117
  init_board[120] = 0;
#line 1117
  init_board[121] = 0;
#line 1117
  init_board[122] = 0;
#line 1117
  init_board[123] = 0;
#line 1117
  init_board[124] = 0;
#line 1117
  init_board[125] = 0;
#line 1117
  init_board[126] = 0;
#line 1117
  init_board[127] = 0;
#line 1117
  init_board[128] = 0;
#line 1117
  init_board[129] = 0;
#line 1117
  init_board[130] = 0;
#line 1117
  init_board[131] = 0;
#line 1117
  init_board[132] = 0;
#line 1117
  init_board[133] = 0;
#line 1117
  init_board[134] = 0;
#line 1117
  init_board[135] = 0;
#line 1117
  init_board[136] = 0;
#line 1117
  init_board[137] = 0;
#line 1117
  init_board[138] = 0;
#line 1117
  init_board[139] = 0;
#line 1117
  init_board[140] = 0;
#line 1117
  init_board[141] = 0;
#line 1117
  init_board[142] = 0;
#line 1117
  init_board[143] = 0;
#line 1132
  memcpy((void * __restrict  )(board), (void const   * __restrict  )(init_board),
         sizeof(init_board));
#line 1133
  i = 0;
#line 1133
  while (i <= 143) {
#line 1134
    moved[i] = 0;
#line 1133
    i ++;
  }
#line 1136
  ep_square = 0;
#line 1138
  piece_count = 0;
#line 1140
  Material = 0;
#line 1142
  memset((void *)(is_promoted), 0, sizeof(is_promoted));
#line 1143
  memset((void *)(holding), 0, sizeof(holding));
#line 1145
  white_hand_eval = 0;
#line 1146
  black_hand_eval = 0;
#line 1148
  bookidx = 0U;
#line 1149
  fifty = 0;
#line 1151
  reset_piece_square();
#line 1153
  return;
}
}
#line 1157 "utils.c"
void seedMT(unsigned int seed ) 
{ 
  register unsigned int x ;
  register unsigned int *s ;
  register int j ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 1159
  x = (seed | 1U) & 4294967295U;
#line 1159
  s = state;
#line 1162
  left = 0;
#line 1162
  tmp = s;
#line 1162
  s ++;
#line 1162
  *tmp = x;
#line 1162
  j = 624;
#line 1162
  while (1) {
#line 1162
    j --;
#line 1162
    if (! j) {
#line 1162
      break;
    }
#line 1162
    tmp___0 = s;
#line 1162
    s ++;
#line 1162
    x *= 69069U;
#line 1162
    *tmp___0 = x & 4294967295U;
  }
#line 1164
  return;
}
}
#line 1166 "utils.c"
unsigned int reloadMT(void) 
{ 
  register unsigned int *p0 ;
  register unsigned int *p2 ;
  register unsigned int *pM ;
  register unsigned int s0 ;
  register unsigned int s1 ;
  register int j ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1168
  p0 = state;
#line 1168
  p2 = state + 2;
#line 1168
  pM = state + 397;
#line 1171
  if (left < -1) {
#line 1172
    seedMT(4357U);
  }
#line 1174
  left = 623;
#line 1174
  next = state + 1;
#line 1176
  s0 = state[0];
#line 1176
  s1 = state[1];
#line 1176
  j = 228;
#line 1176
  while (1) {
#line 1176
    j --;
#line 1176
    if (! j) {
#line 1176
      break;
    }
#line 1177
    tmp___0 = p0;
#line 1177
    p0 ++;
#line 1177
    tmp___1 = pM;
#line 1177
    pM ++;
#line 1177
    if (s1 & 1U) {
#line 1177
      tmp___2 = 2567483615U;
    } else {
#line 1177
      tmp___2 = 0U;
    }
#line 1177
    *tmp___0 = (*tmp___1 ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___2;
#line 1176
    s0 = s1;
#line 1176
    tmp = p2;
#line 1176
    p2 ++;
#line 1176
    s1 = *tmp;
  }
#line 1179
  pM = state;
#line 1179
  j = 397;
#line 1179
  while (1) {
#line 1179
    j --;
#line 1179
    if (! j) {
#line 1179
      break;
    }
#line 1180
    tmp___4 = p0;
#line 1180
    p0 ++;
#line 1180
    tmp___5 = pM;
#line 1180
    pM ++;
#line 1180
    if (s1 & 1U) {
#line 1180
      tmp___6 = 2567483615U;
    } else {
#line 1180
      tmp___6 = 0U;
    }
#line 1180
    *tmp___4 = (*tmp___5 ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___6;
#line 1179
    s0 = s1;
#line 1179
    tmp___3 = p2;
#line 1179
    p2 ++;
#line 1179
    s1 = *tmp___3;
  }
#line 1182
  s1 = state[0];
#line 1182
  if (s1 & 1U) {
#line 1182
    tmp___7 = 2567483615U;
  } else {
#line 1182
    tmp___7 = 0U;
  }
#line 1182
  *p0 = (*pM ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___7;
#line 1183
  s1 ^= s1 >> 11;
#line 1184
  s1 ^= (s1 << 7) & 2636928640U;
#line 1185
  s1 ^= (s1 << 15) & 4022730752U;
#line 1186
  return (s1 ^ (s1 >> 18));
}
}
#line 1189 "utils.c"
unsigned int randomMT(void) 
{ 
  unsigned int y ;
  unsigned int tmp ;
  unsigned int *tmp___0 ;

  {
#line 1193
  left --;
#line 1193
  if (left < 0) {
#line 1194
    tmp = reloadMT();
#line 1194
    return (tmp);
  }
#line 1196
  tmp___0 = next;
#line 1196
  next ++;
#line 1196
  y = *tmp___0;
#line 1197
  y ^= y >> 11;
#line 1198
  y ^= (y << 7) & 2636928640U;
#line 1199
  y ^= (y << 15) & 4022730752U;
#line 1200
  return (y ^ (y >> 18));
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 45 "spec.c"
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
#line 203 "./bzlib.h"
struct __anonstruct_bz_stream_25 {
   char *next_in ;
   unsigned int avail_in ;
   unsigned int total_in_lo32 ;
   unsigned int total_in_hi32 ;
   char *next_out ;
   unsigned int avail_out ;
   unsigned int total_out_lo32 ;
   unsigned int total_out_hi32 ;
   void *state ;
   void *(*bzalloc)(void * , int  , int  ) ;
   void (*bzfree)(void * , void * ) ;
   void *opaque ;
};
#line 203 "./bzlib.h"
typedef struct __anonstruct_bz_stream_25 bz_stream;
#line 82 "./bzlib_private.h"
typedef unsigned char Bool;
#line 83 "./bzlib_private.h"
typedef unsigned char UChar;
#line 84 "./bzlib_private.h"
typedef int Int32;
#line 85 "./bzlib_private.h"
typedef unsigned int UInt32;
#line 87 "./bzlib_private.h"
typedef unsigned short UInt16;
#line 230 "./bzlib_private.h"
struct __anonstruct_EState_26 {
   bz_stream *strm ;
   Int32 mode ;
   Int32 state ;
   UInt32 avail_in_expect ;
   UInt32 *arr1 ;
   UInt32 *arr2 ;
   UInt32 *ftab ;
   Int32 origPtr ;
   UInt32 *ptr ;
   UChar *block ;
   UInt16 *mtfv ;
   UChar *zbits ;
   Int32 workFactor ;
   UInt32 state_in_ch ;
   Int32 state_in_len ;
   Int32 rNToGo ;
   Int32 rTPos ;
   Int32 nblock ;
   Int32 nblockMAX ;
   Int32 numZ ;
   Int32 state_out_pos ;
   Int32 nInUse ;
   Bool inUse[256] ;
   UChar unseqToSeq[256] ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   UInt32 blockCRC ;
   UInt32 combinedCRC ;
   Int32 verbosity ;
   Int32 blockNo ;
   Int32 blockSize100k ;
   Int32 nMTF ;
   Int32 mtfFreq[258] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 code[6][258] ;
   Int32 rfreq[6][258] ;
   UInt32 len_pack[258][4] ;
};
#line 230 "./bzlib_private.h"
typedef struct __anonstruct_EState_26 EState;
#line 292 "./bzlib.h"
typedef void BZFILE;
#line 260 "bzip2.c"
typedef char Char;
#line 275 "bzip2.c"
typedef int IntNative;
#line 334 "bzip2.c"
struct __anonstruct_UInt64_53 {
   UChar b[8] ;
};
#line 334 "bzip2.c"
typedef struct __anonstruct_UInt64_53 UInt64;
#line 381 "./bzlib_private.h"
struct __anonstruct_DState_27 {
   bz_stream *strm ;
   Int32 state ;
   UChar state_out_ch ;
   Int32 state_out_len ;
   Bool blockRandomised ;
   Int32 rNToGo ;
   Int32 rTPos ;
   UInt32 bsBuff ;
   Int32 bsLive ;
   Int32 blockSize100k ;
   Bool smallDecompress ;
   Int32 currBlockNo ;
   Int32 verbosity ;
   Int32 origPtr ;
   UInt32 tPos ;
   Int32 k0 ;
   Int32 unzftab[256] ;
   Int32 nblock_used ;
   Int32 cftab[257] ;
   Int32 cftabCopy[257] ;
   UInt32 *tt ;
   UInt16 *ll16 ;
   UChar *ll4 ;
   UInt32 storedBlockCRC ;
   UInt32 storedCombinedCRC ;
   UInt32 calculatedBlockCRC ;
   UInt32 calculatedCombinedCRC ;
   Int32 nInUse ;
   Bool inUse[256] ;
   Bool inUse16[16] ;
   UChar seqToUnseq[256] ;
   UChar mtfa[4096] ;
   Int32 mtfbase[16] ;
   UChar selector[18002] ;
   UChar selectorMtf[18002] ;
   UChar len[6][258] ;
   Int32 limit[6][258] ;
   Int32 base[6][258] ;
   Int32 perm[6][258] ;
   Int32 minLens[6] ;
   Int32 save_i ;
   Int32 save_j ;
   Int32 save_t ;
   Int32 save_alphaSize ;
   Int32 save_nGroups ;
   Int32 save_nSelectors ;
   Int32 save_EOB ;
   Int32 save_groupNo ;
   Int32 save_groupPos ;
   Int32 save_nextSym ;
   Int32 save_nblockMAX ;
   Int32 save_nblock ;
   Int32 save_es ;
   Int32 save_N ;
   Int32 save_curr ;
   Int32 save_zt ;
   Int32 save_zn ;
   Int32 save_zvec ;
   Int32 save_zj ;
   Int32 save_gSel ;
   Int32 save_gMinlen ;
   Int32 *save_gLimit ;
   Int32 *save_gBase ;
   Int32 *save_gPerm ;
};
#line 381 "./bzlib_private.h"
typedef struct __anonstruct_DState_27 DState;
#line 948 "bzlib.c"
struct __anonstruct_bzFile_28 {
   int handle ;
   Char buf[5000] ;
   Int32 bufN ;
   Bool writing ;
   bz_stream strm ;
   Int32 lastErr ;
   Bool initialisedOk ;
};
#line 948 "bzlib.c"
typedef struct __anonstruct_bzFile_28 bzFile;
#line 1 "spec.o"
#pragma merger("0","/tmp/cil-0yChv5wo.i","")
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 396
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 2 "./spec.h"
void spec_initbufs(void) ;
#line 3
void spec_compress(int in , int out , int lev ) ;
#line 4
void spec_uncompress(int in , int out , int lev ) ;
#line 5
int spec_init(void) ;
#line 6
int spec_random_load(int fd ) ;
#line 7
int spec_load(int num , char *filename , int size ) ;
#line 8
int spec_read(int fd , unsigned char *buf , int size ) ;
#line 9
int spec_reset(int fd ) ;
#line 10
int spec_write(int fd , unsigned char *buf , int size ) ;
#line 11
int spec_getc(int fd ) ;
#line 12
int spec_ungetc(unsigned char ch , int fd ) ;
#line 13
int spec_fread(unsigned char *buf , int size , int num , int fd ) ;
#line 14
int spec_fwrite(unsigned char *buf , int size , int num , int fd ) ;
#line 15
int spec_rewind(int fd ) ;
#line 16
int spec_putc(unsigned char ch , int fd ) ;
#line 17
int debug_time(void) ;
#line 21 "spec.c"
unsigned char uncompressStream(int zStream , int stream ) ;
#line 22
void compressStream(int stream , int zStream ) ;
#line 28 "spec.c"
int dbglvl  =    4;
#line 45 "spec.c"
struct spec_fd_t spec_fd[3]  ;
#line 52 "spec.c"
long seedi  ;
#line 53 "spec.c"
double ran(void) 
{ 
  long lo ;
  long hi ;
  long test ;

  {
#line 68
  hi = seedi / 127773L;
#line 69
  lo = seedi % 127773L;
#line 70
  test = 16807L * lo - 2836L * hi;
#line 71
  if (test > 0L) {
#line 72
    seedi = test;
  } else {
#line 74
    seedi = test + 2147483647L;
  }
#line 76
  return ((double )((float )seedi / (float )2147483647L));
}
}
#line 80 "spec.c"
int spec_init(void) 
{ 
  int i ;
  int j ;
  int limit ;
  void *tmp ;

  {
#line 82
  if (3 < dbglvl) {
#line 82
    printf((char const   * __restrict  )"spec_init\n");
  }
#line 87
  i = 0;
#line 87
  while (i < 3) {
#line 88
    limit = spec_fd[i].limit;
#line 89
    memset((void *)(& spec_fd[i]), 0, sizeof(spec_fd[0]));
#line 90
    spec_fd[i].limit = limit;
#line 91
    spec_fd[i].buf = (unsigned char *)malloc(sizeof(bzFile )); //AD
    //AD tmp = malloc((size_t )(limit + 1048576));
#line 91
    //AD spec_fd[i].buf = (unsigned char *)tmp;
#line 92
    if ((unsigned long )spec_fd[i].buf == (unsigned long )((void *)0)) {
#line 93
      printf((char const   * __restrict  )"spec_init: Error mallocing memory!\n");
#line 94
      exit(0);
    }
#line 96
    j = 0;
#line 96
    while (j < limit) {
#line 97
      *(spec_fd[i].buf + j) = (unsigned char)0;
#line 96
      j += 1024;
    }
#line 87
    i ++;
  }
#line 100
  return (0);
}
}
#line 103 "spec.c"
int spec_random_load(int fd ) 
{ 
  int i ;
  int j ;
  char random_text[32][131072] ;
  double tmp ;
  double tmp___0 ;

  {
#line 113
  if (4 < dbglvl) {
#line 113
    printf((char const   * __restrict  )"Creating Chunks\n");
  }
#line 114
  i = 0;
#line 114
  while (i < 32) {
#line 115
    if (5 < dbglvl) {
#line 115
      printf((char const   * __restrict  )"Creating Chunk %d\n", i);
    }
#line 116
    j = 0;
#line 116
    while (j < 131072) {
#line 117
      tmp = ran();
#line 117
      random_text[i][j] = (char )((int )(tmp * (double )256));
#line 116
      j ++;
    }
#line 114
    i ++;
  }
#line 121
  if (4 < dbglvl) {
#line 121
    printf((char const   * __restrict  )"Filling input file\n");
  }
#line 123
  i = 0;
#line 123
  while (i < spec_fd[fd].limit) {
#line 124
    tmp___0 = ran();
#line 124
    memcpy((void * __restrict  )(spec_fd[fd].buf + i), (void const   * __restrict  )(random_text[(int )(tmp___0 * (double )32)]),
           (size_t )131072);
#line 123
    i += 131072;
  }
#line 128
  spec_fd[fd].len = 1048576;
#line 129
  return (0);
}
}
#line 132 "spec.c"
int spec_load(int num , char *filename , int size ) 
{ 
  int fd ;
  int rc ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 138
  fd = open((char const   *)filename, 0);
#line 139
  if (fd < 0) {
#line 140
    tmp = __errno_location();
#line 140
    tmp___0 = strerror(*tmp);
#line 140
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Can\'t open file %s: %s\n",
            filename, tmp___0);
#line 141
    exit(0);
  }
#line 143
  tmp___1 = 0;
#line 143
  spec_fd[num].len = tmp___1;
#line 143
  spec_fd[num].pos = tmp___1;
#line 144
  i = 0;
#line 144
  while (i < size) {
#line 145
    tmp___2 = read(fd, (void *)(spec_fd[num].buf + i), (size_t )131072);
#line 145
    rc = (int )tmp___2;
#line 146
    if (rc == 0) {
#line 146
      break;
    }
#line 147
    if (rc < 0) {
#line 148
      tmp___3 = __errno_location();
#line 148
      tmp___4 = strerror(*tmp___3);
#line 148
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error reading from %s: %s\n",
              filename, tmp___4);
#line 149
      exit(0);
    }
#line 151
    spec_fd[num].len += rc;
#line 144
    i += rc;
  }
#line 153
  close(fd);
#line 154
  while (spec_fd[num].len < size) {
#line 155
    tmp___5 = size - spec_fd[num].len;
#line 156
    if (tmp___5 > spec_fd[num].len) {
#line 156
      tmp___5 = spec_fd[num].len;
    }
#line 157
    if (3 < dbglvl) {
#line 157
      printf((char const   * __restrict  )"Duplicating %d bytes\n", tmp___5);
    }
#line 158
    memcpy((void * __restrict  )(spec_fd[num].buf + spec_fd[num].len), (void const   * __restrict  )spec_fd[num].buf,
           (size_t )tmp___5);
#line 159
    spec_fd[num].len += tmp___5;
  }
#line 161
  return (0);
}
}
#line 164 "spec.c"
int spec_read(int fd , unsigned char *buf , int size ) 
{ 
  int rc ;

  {
#line 165
  rc = 0;
#line 166
  if (4 < dbglvl) {
#line 166
    printf((char const   * __restrict  )"spec_read: %d, %p, %d = ", fd, (void *)buf,
           size);
  }
#line 167
  if (fd > 3) {
#line 168
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 169
    exit(0);
  }
#line 171
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 172
    if (4 < dbglvl) {
#line 172
      printf((char const   * __restrict  )"EOF\n");
    }
#line 173
    return (-1);
  }
#line 175
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
#line 176
    rc = spec_fd[fd].len - spec_fd[fd].pos;
  } else {
#line 178
    rc = size;
  }
#line 180
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(spec_fd[fd].buf + spec_fd[fd].pos),
         (size_t )rc);
#line 181
  spec_fd[fd].pos += rc;
#line 182
  if (4 < dbglvl) {
#line 182
    printf((char const   * __restrict  )"%d\n", rc);
  }
#line 183
  return (rc);
}
}
#line 185 "spec.c"
int spec_fread(unsigned char *buf , int size , int num , int fd ) 
{ 
  int rc ;

  {
#line 186
  rc = 0;
#line 187
  if (4 < dbglvl) {
#line 187
    printf((char const   * __restrict  )"spec_fread: %p, (%d x %d) fd %d =", (void *)buf,
           size, num, fd);
  }
#line 188
  if (fd > 3) {
#line 189
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_fread: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 190
    exit(0);
  }
#line 192
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 193
    if (4 < dbglvl) {
#line 193
      printf((char const   * __restrict  )"EOF\n");
    }
#line 194
    return (-1);
  }
#line 196
  if (spec_fd[fd].pos + size * num >= spec_fd[fd].len) {
#line 197
    rc = (spec_fd[fd].len - spec_fd[fd].pos) / size;
  } else {
#line 199
    rc = num;
  }
#line 201
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(spec_fd[fd].buf + spec_fd[fd].pos),
         (size_t )rc);
#line 202
  spec_fd[fd].pos += rc * size;
#line 203
  if (4 < dbglvl) {
#line 203
    printf((char const   * __restrict  )"%d\n", rc * size);
  }
#line 204
  return (rc);
}
}
#line 206 "spec.c"
int spec_getc(int fd ) 
{ 
  int rc ;
  int tmp ;

  {
#line 207
  rc = 0;
#line 208
  if (4 < dbglvl) {
#line 208
    printf((char const   * __restrict  )"spec_getc: %d = ", fd);
  }
#line 209
  if (fd > 3) {
#line 210
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 211
    exit(0);
  }
#line 213
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 214
    if (4 < dbglvl) {
#line 214
      printf((char const   * __restrict  )"EOF\n");
    }
#line 215
    return (-1);
  }
#line 217
  tmp = spec_fd[fd].pos;
#line 217
  (spec_fd[fd].pos) ++;
#line 217
  rc = (int )*(spec_fd[fd].buf + tmp);
#line 218
  if (4 < dbglvl) {
#line 218
    printf((char const   * __restrict  )"%d\n", rc);
  }
#line 219
  return (rc);
}
}
#line 221 "spec.c"
int spec_ungetc(unsigned char ch , int fd ) 
{ 
  int rc ;

  {
#line 222
  rc = 0;
#line 223
  if (4 < dbglvl) {
#line 223
    printf((char const   * __restrict  )"spec_ungetc: %d = ", fd);
  }
#line 224
  if (fd > 3) {
#line 225
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 226
    exit(0);
  }
#line 228
  if (spec_fd[fd].pos <= 0) {
#line 229
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_ungetc: pos %d <= 0\n",
            spec_fd[fd].pos);
#line 230
    exit(0);
  }
#line 232
  (spec_fd[fd].pos) --;
#line 232
  if ((int )*(spec_fd[fd].buf + spec_fd[fd].pos) != (int )ch) {
#line 233
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
#line 234
    exit(0);
  }
#line 236
  if (4 < dbglvl) {
#line 236
    printf((char const   * __restrict  )"%d\n", rc);
  }
#line 237
  return ((int )ch);
}
}
#line 239 "spec.c"
int spec_rewind(int fd ) 
{ 


  {
#line 240
  spec_fd[fd].pos = 0;
#line 241
  return (0);
}
}
#line 243 "spec.c"
int spec_reset(int fd ) 
{ 
  int tmp ;

  {
#line 244
  memset((void *)spec_fd[fd].buf, 0, (size_t )spec_fd[fd].len);
#line 245
  tmp = 0;
#line 245
  spec_fd[fd].len = tmp;
#line 245
  spec_fd[fd].pos = tmp;
#line 246
  return (0);
}
}
#line 249 "spec.c"
int spec_write(int fd , unsigned char *buf , int size ) 
{ 


  {
#line 250
  if (4 < dbglvl) {
#line 250
    printf((char const   * __restrict  )"spec_write: %d, %p, %d = ", fd, (void *)buf,
           size);
  }
#line 251
  if (fd > 3) {
#line 252
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_write: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 253
    exit(0);
  }
#line 255
  memcpy((void * __restrict  )(spec_fd[fd].buf + spec_fd[fd].pos), (void const   * __restrict  )buf,
         (size_t )size);
#line 256
  spec_fd[fd].len += size;
#line 257
  spec_fd[fd].pos += size;
#line 258
  if (4 < dbglvl) {
#line 258
    printf((char const   * __restrict  )"%d\n", size);
  }
#line 259
  return (size);
}
}
#line 261 "spec.c"
int spec_fwrite(unsigned char *buf , int size , int num , int fd ) 
{ 


  {
#line 262
  if (4 < dbglvl) {
#line 262
    printf((char const   * __restrict  )"spec_fwrite: %p, %d, %d, %d = ", (void *)buf,
           size, num, fd);
  }
#line 263
  if (fd > 3) {
#line 264
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_fwrite: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 265
    exit(0);
  }
#line 267
  memcpy((void * __restrict  )(spec_fd[fd].buf + spec_fd[fd].pos), (void const   * __restrict  )buf,
         (size_t )(size * num));
#line 268
  spec_fd[fd].len += size * num;
#line 269
  spec_fd[fd].pos += size * num;
#line 270
  if (4 < dbglvl) {
#line 270
    printf((char const   * __restrict  )"%d\n", num);
  }
#line 271
  return (num);
}
}
#line 273 "spec.c"
int spec_putc(unsigned char ch , int fd ) 
{ 
  int tmp ;

  {
#line 274
  if (4 < dbglvl) {
#line 274
    printf((char const   * __restrict  )"spec_putc: %d, %d = ", (int )ch, fd);
  }
#line 275
  if (fd > 3) {
#line 276
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"spec_write: fd=%d, > MAX_SPEC_FD!\n",
            fd);
#line 277
    exit(0);
  }
#line 279
  tmp = spec_fd[fd].pos;
#line 279
  (spec_fd[fd].pos) ++;
#line 279
  *(spec_fd[fd].buf + tmp) = ch;
#line 280
  (spec_fd[fd].len) ++;
#line 281
  return ((int )ch);
}
}
#line 286 "spec.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int level ;
  int input_size ;
  int compressed_size ;
  char *input_name ;
  unsigned char *validate_array ;
  void *tmp ;

  {
#line 288
  input_size = 64;
#line 289
  input_name = (char *)"input.combined";
#line 291
  seedi = 10L;
#line 293
  if (argc > 1) {
#line 293
    input_name = *(argv + 1);
  }
#line 294
  if (argc > 2) {
#line 294
    input_size = atoi((char const   *)*(argv + 2));
  }
#line 295
  if (argc > 3) {
#line 296
    compressed_size = atoi((char const   *)*(argv + 3));
  } else {
#line 298
    compressed_size = input_size;
  }
#line 300
  spec_fd[0].limit = input_size * 1048576;
#line 301
  spec_fd[1].limit = compressed_size * 1048576;
#line 302
  spec_fd[2].limit = input_size * 1048576;
#line 303
  spec_init();
#line 305
  debug_time();
#line 306
  if (2 < dbglvl) {
#line 306
    printf((char const   * __restrict  )"Loading Input Data\n");
  }
#line 307
  spec_load(0, input_name, input_size * 1048576);
#line 308
  if (3 < dbglvl) {
#line 308
    printf((char const   * __restrict  )"Input data %d bytes in length\n", spec_fd[0].len);
  }
#line 310
  validate_array = (unsigned char *) malloc((size_t )((input_size * 1048576) / 1024));
  //AD tmp = malloc((size_t )((input_size * 1048576) / 1024));
#line 310
  //AD validate_array = (unsigned char *)tmp;
#line 311
  if ((unsigned long )validate_array == (unsigned long )((void *)0)) {
#line 312
    printf((char const   * __restrict  )"main: Error mallocing memory!\n");
#line 313
    exit(0);
  }
#line 316
  i = 0;
#line 316
  while (i * 1027 < input_size * 1048576) {
#line 317
    *(validate_array + i) = *(spec_fd[0].buf + i * 1027);
#line 316
    i ++;
  }
#line 327
  spec_initbufs();
#line 329
  level = 5;
#line 329
  while (level <= 9) {
#line 330
    debug_time();
#line 331
    if (2 < dbglvl) {
#line 331
      printf((char const   * __restrict  )"Compressing Input Data, level %d\n", level);
    }
#line 333
    spec_compress(0, 1, level);
#line 335
    debug_time();
#line 336
    if (3 < dbglvl) {
#line 336
      printf((char const   * __restrict  )"Compressed data %d bytes in length\n",
             spec_fd[1].len);
    }
#line 348
    spec_reset(0);
#line 349
    spec_rewind(1);
#line 351
    debug_time();
#line 352
    if (2 < dbglvl) {
#line 352
      printf((char const   * __restrict  )"Uncompressing Data\n");
    }
#line 353
    spec_uncompress(1, 0, level);
#line 354
    debug_time();
#line 355
    if (3 < dbglvl) {
#line 355
      printf((char const   * __restrict  )"Uncompressed data %d bytes in length\n",
             spec_fd[0].len);
    }
#line 367
    i = 0;
#line 367
    while (i * 1027 < input_size * 1048576) {
#line 368
      if ((int )*(validate_array + i) != (int )*(spec_fd[0].buf + i * 1027)) {
#line 369
        printf((char const   * __restrict  )"Tested %dMB buffer: Miscompared!!\n",
               input_size);
#line 370
        exit(0);
      }
#line 367
      i ++;
    }
#line 373
    debug_time();
#line 374
    if (3 < dbglvl) {
#line 374
      printf((char const   * __restrict  )"Uncompressed data compared correctly\n");
    }
#line 375
    spec_reset(1);
#line 376
    spec_rewind(0);
#line 329
    level += 2;
  }
#line 378
  printf((char const   * __restrict  )"Tested %dMB buffer: OK!\n", input_size);
#line 380
  return (0);
}
}
#line 384
unsigned char smallMode ;
#line 385
int verbosity ;
#line 387
int workFactor ;
#line 387
int blockSize100k ;
#line 388 "spec.c"
void spec_initbufs(void) 
{ 


  {
#line 389
  smallMode = (unsigned char)0;
#line 390
  verbosity = 0;
#line 391
  blockSize100k = 9;
#line 393
  workFactor = 30;
#line 395
  return;
}
}
#line 396 "spec.c"
void spec_compress(int in , int out , int lev ) 
{ 


  {
#line 397
  blockSize100k = lev;
#line 398
  compressStream(in, out);
#line 399
  return;
}
}
#line 400 "spec.c"
void spec_uncompress(int in , int out , int lev ) 
{ 


  {
#line 401
  blockSize100k = 0;
#line 402
  uncompressStream(in, out);
#line 403
  return;
}
}
#line 408 "spec.c"
int debug_time(void) 
{ 


  {
#line 416
  return (0);
}
}
#line 1 "blocksort.o"
#pragma merger("0","/tmp/cil-0pNMYi6c.i","")
#line 97 "./bzlib_private.h"
void BZ2_bz__AssertH__fail(int errcode ) ;
#line 306
void BZ2_blockSort(EState *s ) ;
#line 77 "blocksort.c"
static void fallbackSimpleSort(UInt32 *fmap , UInt32 *eclass , Int32 lo , Int32 hi ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 tmp ;
  UInt32 ec_tmp ;

  {
#line 87
  if (lo == hi) {
#line 87
    return;
  }
#line 89
  if (hi - lo > 3) {
#line 90
    i = hi - 4;
#line 90
    while (i >= lo) {
#line 91
      tmp = (Int32 )*(fmap + i);
#line 92
      ec_tmp = *(eclass + tmp);
#line 93
      j = i + 4;
#line 93
      while (1) {
#line 93
        if (j <= hi) {
#line 93
          if (! (ec_tmp > *(eclass + *(fmap + j)))) {
#line 93
            break;
          }
        } else {
#line 93
          break;
        }
#line 94
        *(fmap + (j - 4)) = *(fmap + j);
#line 93
        j += 4;
      }
#line 95
      *(fmap + (j - 4)) = (UInt32 )tmp;
#line 90
      i --;
    }
  }
#line 99
  i = hi - 1;
#line 99
  while (i >= lo) {
#line 100
    tmp = (Int32 )*(fmap + i);
#line 101
    ec_tmp = *(eclass + tmp);
#line 102
    j = i + 1;
#line 102
    while (1) {
#line 102
      if (j <= hi) {
#line 102
        if (! (ec_tmp > *(eclass + *(fmap + j)))) {
#line 102
          break;
        }
      } else {
#line 102
        break;
      }
#line 103
      *(fmap + (j - 1)) = *(fmap + j);
#line 102
      j ++;
    }
#line 104
    *(fmap + (j - 1)) = (UInt32 )tmp;
#line 99
    i --;
  }
#line 106
  return;
}
}
#line 139 "blocksort.c"
static void fallbackQSort3(UInt32 *fmap , UInt32 *eclass , Int32 loSt , Int32 hiSt ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  UInt32 med ;
  UInt32 r ;
  UInt32 r3 ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;

  {
#line 151
  r = (UInt32 )0;
#line 153
  sp = 0;
#line 154
  stackLo[sp] = loSt;
#line 154
  stackHi[sp] = hiSt;
#line 154
  sp ++;
#line 156
  while (sp > 0) {
#line 158
    if (! (sp < 100)) {
#line 158
      BZ2_bz__AssertH__fail(1004);
    }
#line 160
    sp --;
#line 160
    lo = stackLo[sp];
#line 160
    hi = stackHi[sp];
#line 161
    if (hi - lo < 10) {
#line 162
      fallbackSimpleSort(fmap, eclass, lo, hi);
#line 163
      continue;
    }
#line 173
    r = (r * 7621U + 1U) % 32768U;
#line 174
    r3 = r % 3U;
#line 175
    if (r3 == 0U) {
#line 175
      med = *(eclass + *(fmap + lo));
    } else
#line 176
    if (r3 == 1U) {
#line 176
      med = *(eclass + *(fmap + ((lo + hi) >> 1)));
    } else {
#line 177
      med = *(eclass + *(fmap + hi));
    }
#line 179
    ltLo = lo;
#line 179
    unLo = ltLo;
#line 180
    gtHi = hi;
#line 180
    unHi = gtHi;
#line 182
    while (1) {
#line 183
      while (! (unLo > unHi)) {
#line 185
        n = (Int32 )*(eclass + *(fmap + unLo)) - (Int32 )med;
#line 186
        if (n == 0) {
#line 187
          zztmp = (Int32 )*(fmap + unLo);
#line 187
          *(fmap + unLo) = *(fmap + ltLo);
#line 187
          *(fmap + ltLo) = (UInt32 )zztmp;
#line 188
          ltLo ++;
#line 188
          unLo ++;
#line 189
          continue;
        }
#line 191
        if (n > 0) {
#line 191
          break;
        }
#line 192
        unLo ++;
      }
#line 194
      while (! (unLo > unHi)) {
#line 196
        n = (Int32 )*(eclass + *(fmap + unHi)) - (Int32 )med;
#line 197
        if (n == 0) {
#line 198
          zztmp___0 = (Int32 )*(fmap + unHi);
#line 198
          *(fmap + unHi) = *(fmap + gtHi);
#line 198
          *(fmap + gtHi) = (UInt32 )zztmp___0;
#line 199
          gtHi --;
#line 199
          unHi --;
#line 200
          continue;
        }
#line 202
        if (n < 0) {
#line 202
          break;
        }
#line 203
        unHi --;
      }
#line 205
      if (unLo > unHi) {
#line 205
        break;
      }
#line 206
      zztmp___1 = (Int32 )*(fmap + unLo);
#line 206
      *(fmap + unLo) = *(fmap + unHi);
#line 206
      *(fmap + unHi) = (UInt32 )zztmp___1;
#line 206
      unLo ++;
#line 206
      unHi --;
    }
#line 211
    if (gtHi < ltLo) {
#line 211
      continue;
    }
#line 213
    if (ltLo - lo < unLo - ltLo) {
#line 213
      n = ltLo - lo;
    } else {
#line 213
      n = unLo - ltLo;
    }
#line 213
    yyp1 = lo;
#line 213
    yyp2 = unLo - n;
#line 213
    yyn = n;
#line 213
    while (yyn > 0) {
#line 213
      zztmp___2 = (Int32 )*(fmap + yyp1);
#line 213
      *(fmap + yyp1) = *(fmap + yyp2);
#line 213
      *(fmap + yyp2) = (UInt32 )zztmp___2;
#line 213
      yyp1 ++;
#line 213
      yyp2 ++;
#line 213
      yyn --;
    }
#line 214
    if (hi - gtHi < gtHi - unHi) {
#line 214
      m = hi - gtHi;
    } else {
#line 214
      m = gtHi - unHi;
    }
#line 214
    yyp1___0 = unLo;
#line 214
    yyp2___0 = (hi - m) + 1;
#line 214
    yyn___0 = m;
#line 214
    while (yyn___0 > 0) {
#line 214
      zztmp___3 = (Int32 )*(fmap + yyp1___0);
#line 214
      *(fmap + yyp1___0) = *(fmap + yyp2___0);
#line 214
      *(fmap + yyp2___0) = (UInt32 )zztmp___3;
#line 214
      yyp1___0 ++;
#line 214
      yyp2___0 ++;
#line 214
      yyn___0 --;
    }
#line 216
    n = ((lo + unLo) - ltLo) - 1;
#line 217
    m = (hi - (gtHi - unHi)) + 1;
#line 219
    if (n - lo > hi - m) {
#line 220
      stackLo[sp] = lo;
#line 220
      stackHi[sp] = n;
#line 220
      sp ++;
#line 221
      stackLo[sp] = m;
#line 221
      stackHi[sp] = hi;
#line 221
      sp ++;
    } else {
#line 223
      stackLo[sp] = m;
#line 223
      stackHi[sp] = hi;
#line 223
      sp ++;
#line 224
      stackLo[sp] = lo;
#line 224
      stackHi[sp] = n;
#line 224
      sp ++;
    }
  }
#line 227
  return;
}
}
#line 258 "blocksort.c"
static void fallbackSort(UInt32 *fmap , UInt32 *eclass , UInt32 *bhtab , Int32 nblock ,
                         Int32 verb ) 
{ 
  Int32 ftab[257] ;
  Int32 ftabCopy[256] ;
  Int32 H ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 l ;
  Int32 r ;
  Int32 cc ;
  Int32 cc1 ;
  Int32 nNotDone ;
  Int32 nBhtab ;
  UChar *eclass8 ;

  {
#line 270
  eclass8 = (UChar *)eclass;
#line 276
  if (verb >= 4) {
#line 277
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        bucket sorting ...\n");
  }
#line 278
  i = 0;
#line 278
  while (i < 257) {
#line 278
    ftab[i] = 0;
#line 278
    i ++;
  }
#line 279
  i = 0;
#line 279
  while (i < nblock) {
#line 279
    (ftab[*(eclass8 + i)]) ++;
#line 279
    i ++;
  }
#line 280
  i = 0;
#line 280
  while (i < 256) {
#line 280
    ftabCopy[i] = ftab[i];
#line 280
    i ++;
  }
#line 281
  i = 1;
#line 281
  while (i < 257) {
#line 281
    ftab[i] += ftab[i - 1];
#line 281
    i ++;
  }
#line 283
  i = 0;
#line 283
  while (i < nblock) {
#line 284
    j = (Int32 )*(eclass8 + i);
#line 285
    k = ftab[j] - 1;
#line 286
    ftab[j] = k;
#line 287
    *(fmap + k) = (UInt32 )i;
#line 283
    i ++;
  }
#line 290
  nBhtab = 2 + nblock / 32;
#line 291
  i = 0;
#line 291
  while (i < nBhtab) {
#line 291
    *(bhtab + i) = (UInt32 )0;
#line 291
    i ++;
  }
#line 292
  i = 0;
#line 292
  while (i < 256) {
#line 292
    *(bhtab + (ftab[i] >> 5)) |= (unsigned int )(1 << (ftab[i] & 31));
#line 292
    i ++;
  }
#line 301
  i = 0;
#line 301
  while (i < 32) {
#line 302
    *(bhtab + ((nblock + 2 * i) >> 5)) |= (unsigned int )(1 << ((nblock + 2 * i) & 31));
#line 303
    *(bhtab + (((nblock + 2 * i) + 1) >> 5)) &= (unsigned int )(~ (1 << (((nblock + 2 * i) + 1) & 31)));
#line 301
    i ++;
  }
#line 307
  H = 1;
#line 308
  while (1) {
#line 310
    if (verb >= 4) {
#line 311
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        depth %6d has ",
              H);
    }
#line 313
    j = 0;
#line 314
    i = 0;
#line 314
    while (i < nblock) {
#line 315
      if (*(bhtab + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
#line 315
        j = i;
      }
#line 316
      k = (Int32 )(*(fmap + i) - (UInt32 )H);
#line 316
      if (k < 0) {
#line 316
        k += nblock;
      }
#line 317
      *(eclass + k) = (UInt32 )j;
#line 314
      i ++;
    }
#line 320
    nNotDone = 0;
#line 321
    r = -1;
#line 322
    while (1) {
#line 325
      k = r + 1;
#line 326
      while (1) {
#line 326
        if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
#line 326
          if (! (k & 31)) {
#line 326
            break;
          }
        } else {
#line 326
          break;
        }
#line 326
        k ++;
      }
#line 327
      if (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
#line 328
        while (*(bhtab + (k >> 5)) == 4294967295U) {
#line 328
          k += 32;
        }
#line 329
        while (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31))) {
#line 329
          k ++;
        }
      }
#line 331
      l = k - 1;
#line 332
      if (l >= nblock) {
#line 332
        break;
      }
#line 333
      while (1) {
#line 333
        if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 333
          if (! (k & 31)) {
#line 333
            break;
          }
        } else {
#line 333
          break;
        }
#line 333
        k ++;
      }
#line 334
      if (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 335
        while (*(bhtab + (k >> 5)) == 0U) {
#line 335
          k += 32;
        }
#line 336
        while (! (*(bhtab + (k >> 5)) & (unsigned int )(1 << (k & 31)))) {
#line 336
          k ++;
        }
      }
#line 338
      r = k - 1;
#line 339
      if (r >= nblock) {
#line 339
        break;
      }
#line 342
      if (r > l) {
#line 343
        nNotDone += (r - l) + 1;
#line 344
        fallbackQSort3(fmap, eclass, l, r);
#line 347
        cc = -1;
#line 348
        i = l;
#line 348
        while (i <= r) {
#line 349
          cc1 = (Int32 )*(eclass + *(fmap + i));
#line 350
          if (cc != cc1) {
#line 350
            *(bhtab + (i >> 5)) |= (unsigned int )(1 << (i & 31));
#line 350
            cc = cc1;
          }
#line 348
          i ++;
        }
      }
    }
#line 355
    if (verb >= 4) {
#line 356
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%6d unresolved strings\n",
              nNotDone);
    }
#line 358
    H *= 2;
#line 359
    if (H > nblock) {
#line 359
      break;
    } else
#line 359
    if (nNotDone == 0) {
#line 359
      break;
    }
  }
#line 367
  if (verb >= 4) {
#line 368
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        reconstructing block ...\n");
  }
#line 369
  j = 0;
#line 370
  i = 0;
#line 370
  while (i < nblock) {
#line 371
    while (ftabCopy[j] == 0) {
#line 371
      j ++;
    }
#line 372
    (ftabCopy[j]) --;
#line 373
    *(eclass8 + *(fmap + i)) = (UChar )j;
#line 370
    i ++;
  }
#line 375
  if (! (j < 256)) {
#line 375
    BZ2_bz__AssertH__fail(1005);
  }
#line 376
  return;
}
}
#line 392 "blocksort.c"
static Bool mainGtU(UInt32 i1 , UInt32 i2 , UChar *block , UInt16 *quadrant , UInt32 nblock ,
                    Int32 *budget ) 
{ 
  Int32 k ;
  UChar c1 ;
  UChar c2 ;
  UInt16 s1 ;
  UInt16 s2 ;

  {
#line 407
  c1 = *(block + i1);
#line 407
  c2 = *(block + i2);
#line 408
  if ((int )c1 != (int )c2) {
#line 408
    return ((Bool )((int )c1 > (int )c2));
  }
#line 409
  i1 ++;
#line 409
  i2 ++;
#line 411
  c1 = *(block + i1);
#line 411
  c2 = *(block + i2);
#line 412
  if ((int )c1 != (int )c2) {
#line 412
    return ((Bool )((int )c1 > (int )c2));
  }
#line 413
  i1 ++;
#line 413
  i2 ++;
#line 415
  c1 = *(block + i1);
#line 415
  c2 = *(block + i2);
#line 416
  if ((int )c1 != (int )c2) {
#line 416
    return ((Bool )((int )c1 > (int )c2));
  }
#line 417
  i1 ++;
#line 417
  i2 ++;
#line 419
  c1 = *(block + i1);
#line 419
  c2 = *(block + i2);
#line 420
  if ((int )c1 != (int )c2) {
#line 420
    return ((Bool )((int )c1 > (int )c2));
  }
#line 421
  i1 ++;
#line 421
  i2 ++;
#line 423
  c1 = *(block + i1);
#line 423
  c2 = *(block + i2);
#line 424
  if ((int )c1 != (int )c2) {
#line 424
    return ((Bool )((int )c1 > (int )c2));
  }
#line 425
  i1 ++;
#line 425
  i2 ++;
#line 427
  c1 = *(block + i1);
#line 427
  c2 = *(block + i2);
#line 428
  if ((int )c1 != (int )c2) {
#line 428
    return ((Bool )((int )c1 > (int )c2));
  }
#line 429
  i1 ++;
#line 429
  i2 ++;
#line 431
  c1 = *(block + i1);
#line 431
  c2 = *(block + i2);
#line 432
  if ((int )c1 != (int )c2) {
#line 432
    return ((Bool )((int )c1 > (int )c2));
  }
#line 433
  i1 ++;
#line 433
  i2 ++;
#line 435
  c1 = *(block + i1);
#line 435
  c2 = *(block + i2);
#line 436
  if ((int )c1 != (int )c2) {
#line 436
    return ((Bool )((int )c1 > (int )c2));
  }
#line 437
  i1 ++;
#line 437
  i2 ++;
#line 439
  c1 = *(block + i1);
#line 439
  c2 = *(block + i2);
#line 440
  if ((int )c1 != (int )c2) {
#line 440
    return ((Bool )((int )c1 > (int )c2));
  }
#line 441
  i1 ++;
#line 441
  i2 ++;
#line 443
  c1 = *(block + i1);
#line 443
  c2 = *(block + i2);
#line 444
  if ((int )c1 != (int )c2) {
#line 444
    return ((Bool )((int )c1 > (int )c2));
  }
#line 445
  i1 ++;
#line 445
  i2 ++;
#line 447
  c1 = *(block + i1);
#line 447
  c2 = *(block + i2);
#line 448
  if ((int )c1 != (int )c2) {
#line 448
    return ((Bool )((int )c1 > (int )c2));
  }
#line 449
  i1 ++;
#line 449
  i2 ++;
#line 451
  c1 = *(block + i1);
#line 451
  c2 = *(block + i2);
#line 452
  if ((int )c1 != (int )c2) {
#line 452
    return ((Bool )((int )c1 > (int )c2));
  }
#line 453
  i1 ++;
#line 453
  i2 ++;
#line 455
  k = (Int32 )(nblock + 8U);
#line 457
  while (1) {
#line 459
    c1 = *(block + i1);
#line 459
    c2 = *(block + i2);
#line 460
    if ((int )c1 != (int )c2) {
#line 460
      return ((Bool )((int )c1 > (int )c2));
    }
#line 461
    s1 = *(quadrant + i1);
#line 461
    s2 = *(quadrant + i2);
#line 462
    if ((int )s1 != (int )s2) {
#line 462
      return ((Bool )((int )s1 > (int )s2));
    }
#line 463
    i1 ++;
#line 463
    i2 ++;
#line 465
    c1 = *(block + i1);
#line 465
    c2 = *(block + i2);
#line 466
    if ((int )c1 != (int )c2) {
#line 466
      return ((Bool )((int )c1 > (int )c2));
    }
#line 467
    s1 = *(quadrant + i1);
#line 467
    s2 = *(quadrant + i2);
#line 468
    if ((int )s1 != (int )s2) {
#line 468
      return ((Bool )((int )s1 > (int )s2));
    }
#line 469
    i1 ++;
#line 469
    i2 ++;
#line 471
    c1 = *(block + i1);
#line 471
    c2 = *(block + i2);
#line 472
    if ((int )c1 != (int )c2) {
#line 472
      return ((Bool )((int )c1 > (int )c2));
    }
#line 473
    s1 = *(quadrant + i1);
#line 473
    s2 = *(quadrant + i2);
#line 474
    if ((int )s1 != (int )s2) {
#line 474
      return ((Bool )((int )s1 > (int )s2));
    }
#line 475
    i1 ++;
#line 475
    i2 ++;
#line 477
    c1 = *(block + i1);
#line 477
    c2 = *(block + i2);
#line 478
    if ((int )c1 != (int )c2) {
#line 478
      return ((Bool )((int )c1 > (int )c2));
    }
#line 479
    s1 = *(quadrant + i1);
#line 479
    s2 = *(quadrant + i2);
#line 480
    if ((int )s1 != (int )s2) {
#line 480
      return ((Bool )((int )s1 > (int )s2));
    }
#line 481
    i1 ++;
#line 481
    i2 ++;
#line 483
    c1 = *(block + i1);
#line 483
    c2 = *(block + i2);
#line 484
    if ((int )c1 != (int )c2) {
#line 484
      return ((Bool )((int )c1 > (int )c2));
    }
#line 485
    s1 = *(quadrant + i1);
#line 485
    s2 = *(quadrant + i2);
#line 486
    if ((int )s1 != (int )s2) {
#line 486
      return ((Bool )((int )s1 > (int )s2));
    }
#line 487
    i1 ++;
#line 487
    i2 ++;
#line 489
    c1 = *(block + i1);
#line 489
    c2 = *(block + i2);
#line 490
    if ((int )c1 != (int )c2) {
#line 490
      return ((Bool )((int )c1 > (int )c2));
    }
#line 491
    s1 = *(quadrant + i1);
#line 491
    s2 = *(quadrant + i2);
#line 492
    if ((int )s1 != (int )s2) {
#line 492
      return ((Bool )((int )s1 > (int )s2));
    }
#line 493
    i1 ++;
#line 493
    i2 ++;
#line 495
    c1 = *(block + i1);
#line 495
    c2 = *(block + i2);
#line 496
    if ((int )c1 != (int )c2) {
#line 496
      return ((Bool )((int )c1 > (int )c2));
    }
#line 497
    s1 = *(quadrant + i1);
#line 497
    s2 = *(quadrant + i2);
#line 498
    if ((int )s1 != (int )s2) {
#line 498
      return ((Bool )((int )s1 > (int )s2));
    }
#line 499
    i1 ++;
#line 499
    i2 ++;
#line 501
    c1 = *(block + i1);
#line 501
    c2 = *(block + i2);
#line 502
    if ((int )c1 != (int )c2) {
#line 502
      return ((Bool )((int )c1 > (int )c2));
    }
#line 503
    s1 = *(quadrant + i1);
#line 503
    s2 = *(quadrant + i2);
#line 504
    if ((int )s1 != (int )s2) {
#line 504
      return ((Bool )((int )s1 > (int )s2));
    }
#line 505
    i1 ++;
#line 505
    i2 ++;
#line 507
    if (i1 >= nblock) {
#line 507
      i1 -= nblock;
    }
#line 508
    if (i2 >= nblock) {
#line 508
      i2 -= nblock;
    }
#line 510
    k -= 8;
#line 511
    (*budget) --;
#line 457
    if (! (k >= 0)) {
#line 457
      break;
    }
  }
#line 515
  return ((Bool )0);
}
}
#line 526 "blocksort.c"
static Int32 incs[14]  = 
#line 526
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
#line 531 "blocksort.c"
static void mainSimpleSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                           Int32 lo , Int32 hi , Int32 d , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 h ;
  Int32 bigN ;
  Int32 hp ;
  UInt32 v ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 544
  bigN = (hi - lo) + 1;
#line 545
  if (bigN < 2) {
#line 545
    return;
  }
#line 547
  hp = 0;
#line 548
  while (incs[hp] < bigN) {
#line 548
    hp ++;
  }
#line 549
  hp --;
#line 551
  while (hp >= 0) {
#line 552
    h = incs[hp];
#line 554
    i = lo + h;
#line 555
    while (! (i > hi)) {
#line 559
      v = *(ptr + i);
#line 560
      j = i;
#line 561
      while (1) {
#line 561
        tmp = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                      (UInt32 )nblock, budget);
#line 561
        if (! tmp) {
#line 561
          break;
        }
#line 564
        *(ptr + j) = *(ptr + (j - h));
#line 565
        j -= h;
#line 566
        if (j <= (lo + h) - 1) {
#line 566
          break;
        }
      }
#line 568
      *(ptr + j) = v;
#line 569
      i ++;
#line 572
      if (i > hi) {
#line 572
        break;
      }
#line 573
      v = *(ptr + i);
#line 574
      j = i;
#line 575
      while (1) {
#line 575
        tmp___0 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
#line 575
        if (! tmp___0) {
#line 575
          break;
        }
#line 578
        *(ptr + j) = *(ptr + (j - h));
#line 579
        j -= h;
#line 580
        if (j <= (lo + h) - 1) {
#line 580
          break;
        }
      }
#line 582
      *(ptr + j) = v;
#line 583
      i ++;
#line 586
      if (i > hi) {
#line 586
        break;
      }
#line 587
      v = *(ptr + i);
#line 588
      j = i;
#line 589
      while (1) {
#line 589
        tmp___1 = mainGtU(*(ptr + (j - h)) + (UInt32 )d, v + (UInt32 )d, block, quadrant,
                          (UInt32 )nblock, budget);
#line 589
        if (! tmp___1) {
#line 589
          break;
        }
#line 592
        *(ptr + j) = *(ptr + (j - h));
#line 593
        j -= h;
#line 594
        if (j <= (lo + h) - 1) {
#line 594
          break;
        }
      }
#line 596
      *(ptr + j) = v;
#line 597
      i ++;
#line 599
      if (*budget < 0) {
#line 599
        return;
      }
    }
#line 551
    hp --;
  }
#line 602
  return;
}
}
#line 628 "blocksort.c"
static UChar mmed3(UChar a , UChar b , UChar c ) 
{ 
  UChar t ;

  {
#line 633
  if ((int )a > (int )b) {
#line 633
    t = a;
#line 633
    a = b;
#line 633
    b = t;
  }
#line 634
  if ((int )b > (int )c) {
#line 635
    b = c;
#line 636
    if ((int )a > (int )b) {
#line 636
      b = a;
    }
  }
#line 638
  return (b);
}
}
#line 667 "blocksort.c"
static void mainQSort3(UInt32 *ptr , UChar *block , UInt16 *quadrant , Int32 nblock ,
                       Int32 loSt , Int32 hiSt , Int32 dSt , Int32 *budget ) 
{ 
  Int32 unLo ;
  Int32 unHi ;
  Int32 ltLo ;
  Int32 gtHi ;
  Int32 n ;
  Int32 m ;
  Int32 med ;
  Int32 sp ;
  Int32 lo ;
  Int32 hi ;
  Int32 d ;
  Int32 stackLo[100] ;
  Int32 stackHi[100] ;
  Int32 stackD[100] ;
  Int32 nextLo[3] ;
  Int32 nextHi[3] ;
  Int32 nextD[3] ;
  UChar tmp ;
  Int32 zztmp ;
  Int32 zztmp___0 ;
  Int32 zztmp___1 ;
  Int32 yyp1 ;
  Int32 yyp2 ;
  Int32 yyn ;
  Int32 zztmp___2 ;
  Int32 yyp1___0 ;
  Int32 yyp2___0 ;
  Int32 yyn___0 ;
  Int32 zztmp___3 ;
  Int32 tz ;
  Int32 tz___0 ;
  Int32 tz___1 ;

  {
#line 688
  sp = 0;
#line 689
  stackLo[sp] = loSt;
#line 689
  stackHi[sp] = hiSt;
#line 689
  stackD[sp] = dSt;
#line 689
  sp ++;
#line 691
  while (sp > 0) {
#line 693
    if (! (sp < 100)) {
#line 693
      BZ2_bz__AssertH__fail(1001);
    }
#line 695
    sp --;
#line 695
    lo = stackLo[sp];
#line 695
    hi = stackHi[sp];
#line 695
    d = stackD[sp];
#line 696
    if (hi - lo < 20) {
#line 696
      goto _L;
    } else
#line 696
    if (d > 14) {
      _L: /* CIL Label */ 
#line 698
      mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget);
#line 699
      if (*budget < 0) {
#line 699
        return;
      }
#line 700
      continue;
    }
#line 703
    tmp = mmed3(*(block + (*(ptr + lo) + (UInt32 )d)), *(block + (*(ptr + hi) + (UInt32 )d)),
                *(block + (*(ptr + ((lo + hi) >> 1)) + (UInt32 )d)));
#line 703
    med = (Int32 )tmp;
#line 708
    ltLo = lo;
#line 708
    unLo = ltLo;
#line 709
    gtHi = hi;
#line 709
    unHi = gtHi;
#line 711
    while (1) {
#line 712
      while (! (unLo > unHi)) {
#line 714
        n = (Int32 )*(block + (*(ptr + unLo) + (UInt32 )d)) - med;
#line 715
        if (n == 0) {
#line 716
          zztmp = (Int32 )*(ptr + unLo);
#line 716
          *(ptr + unLo) = *(ptr + ltLo);
#line 716
          *(ptr + ltLo) = (UInt32 )zztmp;
#line 717
          ltLo ++;
#line 717
          unLo ++;
#line 717
          continue;
        }
#line 719
        if (n > 0) {
#line 719
          break;
        }
#line 720
        unLo ++;
      }
#line 722
      while (! (unLo > unHi)) {
#line 724
        n = (Int32 )*(block + (*(ptr + unHi) + (UInt32 )d)) - med;
#line 725
        if (n == 0) {
#line 726
          zztmp___0 = (Int32 )*(ptr + unHi);
#line 726
          *(ptr + unHi) = *(ptr + gtHi);
#line 726
          *(ptr + gtHi) = (UInt32 )zztmp___0;
#line 727
          gtHi --;
#line 727
          unHi --;
#line 727
          continue;
        }
#line 729
        if (n < 0) {
#line 729
          break;
        }
#line 730
        unHi --;
      }
#line 732
      if (unLo > unHi) {
#line 732
        break;
      }
#line 733
      zztmp___1 = (Int32 )*(ptr + unLo);
#line 733
      *(ptr + unLo) = *(ptr + unHi);
#line 733
      *(ptr + unHi) = (UInt32 )zztmp___1;
#line 733
      unLo ++;
#line 733
      unHi --;
    }
#line 738
    if (gtHi < ltLo) {
#line 739
      stackLo[sp] = lo;
#line 739
      stackHi[sp] = hi;
#line 739
      stackD[sp] = d + 1;
#line 739
      sp ++;
#line 740
      continue;
    }
#line 743
    if (ltLo - lo < unLo - ltLo) {
#line 743
      n = ltLo - lo;
    } else {
#line 743
      n = unLo - ltLo;
    }
#line 743
    yyp1 = lo;
#line 743
    yyp2 = unLo - n;
#line 743
    yyn = n;
#line 743
    while (yyn > 0) {
#line 743
      zztmp___2 = (Int32 )*(ptr + yyp1);
#line 743
      *(ptr + yyp1) = *(ptr + yyp2);
#line 743
      *(ptr + yyp2) = (UInt32 )zztmp___2;
#line 743
      yyp1 ++;
#line 743
      yyp2 ++;
#line 743
      yyn --;
    }
#line 744
    if (hi - gtHi < gtHi - unHi) {
#line 744
      m = hi - gtHi;
    } else {
#line 744
      m = gtHi - unHi;
    }
#line 744
    yyp1___0 = unLo;
#line 744
    yyp2___0 = (hi - m) + 1;
#line 744
    yyn___0 = m;
#line 744
    while (yyn___0 > 0) {
#line 744
      zztmp___3 = (Int32 )*(ptr + yyp1___0);
#line 744
      *(ptr + yyp1___0) = *(ptr + yyp2___0);
#line 744
      *(ptr + yyp2___0) = (UInt32 )zztmp___3;
#line 744
      yyp1___0 ++;
#line 744
      yyp2___0 ++;
#line 744
      yyn___0 --;
    }
#line 746
    n = ((lo + unLo) - ltLo) - 1;
#line 747
    m = (hi - (gtHi - unHi)) + 1;
#line 749
    nextLo[0] = lo;
#line 749
    nextHi[0] = n;
#line 749
    nextD[0] = d;
#line 750
    nextLo[1] = m;
#line 750
    nextHi[1] = hi;
#line 750
    nextD[1] = d;
#line 751
    nextLo[2] = n + 1;
#line 751
    nextHi[2] = m - 1;
#line 751
    nextD[2] = d + 1;
#line 753
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 753
      tz = nextLo[0];
#line 753
      nextLo[0] = nextLo[1];
#line 753
      nextLo[1] = tz;
#line 753
      tz = nextHi[0];
#line 753
      nextHi[0] = nextHi[1];
#line 753
      nextHi[1] = tz;
#line 753
      tz = nextD[0];
#line 753
      nextD[0] = nextD[1];
#line 753
      nextD[1] = tz;
    }
#line 754
    if (nextHi[1] - nextLo[1] < nextHi[2] - nextLo[2]) {
#line 754
      tz___0 = nextLo[1];
#line 754
      nextLo[1] = nextLo[2];
#line 754
      nextLo[2] = tz___0;
#line 754
      tz___0 = nextHi[1];
#line 754
      nextHi[1] = nextHi[2];
#line 754
      nextHi[2] = tz___0;
#line 754
      tz___0 = nextD[1];
#line 754
      nextD[1] = nextD[2];
#line 754
      nextD[2] = tz___0;
    }
#line 755
    if (nextHi[0] - nextLo[0] < nextHi[1] - nextLo[1]) {
#line 755
      tz___1 = nextLo[0];
#line 755
      nextLo[0] = nextLo[1];
#line 755
      nextLo[1] = tz___1;
#line 755
      tz___1 = nextHi[0];
#line 755
      nextHi[0] = nextHi[1];
#line 755
      nextHi[1] = tz___1;
#line 755
      tz___1 = nextD[0];
#line 755
      nextD[0] = nextD[1];
#line 755
      nextD[1] = tz___1;
    }
#line 760
    stackLo[sp] = nextLo[0];
#line 760
    stackHi[sp] = nextHi[0];
#line 760
    stackD[sp] = nextD[0];
#line 760
    sp ++;
#line 761
    stackLo[sp] = nextLo[1];
#line 761
    stackHi[sp] = nextHi[1];
#line 761
    stackD[sp] = nextD[1];
#line 761
    sp ++;
#line 762
    stackLo[sp] = nextLo[2];
#line 762
    stackHi[sp] = nextHi[2];
#line 762
    stackD[sp] = nextD[2];
#line 762
    sp ++;
  }
#line 764
  return;
}
}
#line 797 "blocksort.c"
static void mainSort(UInt32 *ptr , UChar *block , UInt16 *quadrant , UInt32 *ftab ,
                     Int32 nblock , Int32 verb , Int32 *budget ) 
{ 
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Int32 ss ;
  Int32 sb ;
  Int32 runningOrder[256] ;
  Bool bigDone[256] ;
  Int32 copyStart[256] ;
  Int32 copyEnd[256] ;
  UChar c1 ;
  Int32 numQSorted ;
  UInt16 s ;
  Int32 vv ;
  Int32 h ;
  Int32 lo ;
  Int32 hi ;
  Int32 tmp ;
  Int32 tmp___0 ;
  Int32 bbStart ;
  Int32 bbSize ;
  Int32 shifts ;
  Int32 a2update ;
  UInt16 qVal ;

  {
#line 814
  if (verb >= 4) {
#line 814
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        main sort initialise ...\n");
  }
#line 817
  i = 65536;
#line 817
  while (i >= 0) {
#line 817
    *(ftab + i) = (UInt32 )0;
#line 817
    i --;
  }
#line 819
  j = (int )*(block + 0) << 8;
#line 820
  i = nblock - 1;
#line 821
  while (i >= 3) {
#line 822
    *(quadrant + i) = (UInt16 )0;
#line 823
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 824
    (*(ftab + j)) ++;
#line 825
    *(quadrant + (i - 1)) = (UInt16 )0;
#line 826
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 1))) << 8);
#line 827
    (*(ftab + j)) ++;
#line 828
    *(quadrant + (i - 2)) = (UInt16 )0;
#line 829
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 2))) << 8);
#line 830
    (*(ftab + j)) ++;
#line 831
    *(quadrant + (i - 3)) = (UInt16 )0;
#line 832
    j = (j >> 8) | ((int )((UInt16 )*(block + (i - 3))) << 8);
#line 833
    (*(ftab + j)) ++;
#line 821
    i -= 4;
  }
#line 835
  while (i >= 0) {
#line 836
    *(quadrant + i) = (UInt16 )0;
#line 837
    j = (j >> 8) | ((int )((UInt16 )*(block + i)) << 8);
#line 838
    (*(ftab + j)) ++;
#line 835
    i --;
  }
#line 842
  i = 0;
#line 842
  while (i < 34) {
#line 843
    *(block + (nblock + i)) = *(block + i);
#line 844
    *(quadrant + (nblock + i)) = (UInt16 )0;
#line 842
    i ++;
  }
#line 847
  if (verb >= 4) {
#line 847
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        bucket sorting ...\n");
  }
#line 850
  i = 1;
#line 850
  while (i <= 65536) {
#line 850
    *(ftab + i) += *(ftab + (i - 1));
#line 850
    i ++;
  }
#line 852
  s = (UInt16 )((int )*(block + 0) << 8);
#line 853
  i = nblock - 1;
#line 854
  while (i >= 3) {
#line 855
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 856
    j = (Int32 )(*(ftab + s) - 1U);
#line 857
    *(ftab + s) = (UInt32 )j;
#line 858
    *(ptr + j) = (UInt32 )i;
#line 859
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 1)) << 8));
#line 860
    j = (Int32 )(*(ftab + s) - 1U);
#line 861
    *(ftab + s) = (UInt32 )j;
#line 862
    *(ptr + j) = (UInt32 )(i - 1);
#line 863
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 2)) << 8));
#line 864
    j = (Int32 )(*(ftab + s) - 1U);
#line 865
    *(ftab + s) = (UInt32 )j;
#line 866
    *(ptr + j) = (UInt32 )(i - 2);
#line 867
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + (i - 3)) << 8));
#line 868
    j = (Int32 )(*(ftab + s) - 1U);
#line 869
    *(ftab + s) = (UInt32 )j;
#line 870
    *(ptr + j) = (UInt32 )(i - 3);
#line 854
    i -= 4;
  }
#line 872
  while (i >= 0) {
#line 873
    s = (UInt16 )(((int )s >> 8) | ((int )*(block + i) << 8));
#line 874
    j = (Int32 )(*(ftab + s) - 1U);
#line 875
    *(ftab + s) = (UInt32 )j;
#line 876
    *(ptr + j) = (UInt32 )i;
#line 872
    i --;
  }
#line 884
  i = 0;
#line 884
  while (i <= 255) {
#line 885
    bigDone[i] = (Bool )0;
#line 886
    runningOrder[i] = i;
#line 884
    i ++;
  }
#line 891
  h = 1;
#line 892
  while (1) {
#line 892
    h = 3 * h + 1;
#line 892
    if (! (h <= 256)) {
#line 892
      break;
    }
  }
#line 893
  while (1) {
#line 894
    h /= 3;
#line 895
    i = h;
#line 895
    while (i <= 255) {
#line 896
      vv = runningOrder[i];
#line 897
      j = i;
#line 898
      while (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8))) {
#line 899
        runningOrder[j] = runningOrder[j - h];
#line 900
        j -= h;
#line 901
        if (j <= h - 1) {
#line 901
          goto zero;
        }
      }
      zero: 
#line 904
      runningOrder[j] = vv;
#line 895
      i ++;
    }
#line 893
    if (! (h != 1)) {
#line 893
      break;
    }
  }
#line 913
  numQSorted = 0;
#line 915
  i = 0;
#line 915
  while (i <= 255) {
#line 923
    ss = runningOrder[i];
#line 933
    j = 0;
#line 933
    while (j <= 255) {
#line 934
      if (j != ss) {
#line 935
        sb = (ss << 8) + j;
#line 936
        if (! (*(ftab + sb) & (unsigned int )(1 << 21))) {
#line 937
          lo = (Int32 )(*(ftab + sb) & (unsigned int )(~ (1 << 21)));
#line 938
          hi = (Int32 )((*(ftab + (sb + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 939
          if (hi > lo) {
#line 940
            if (verb >= 4) {
#line 941
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      (unsigned int )ss, (unsigned int )j, numQSorted, (hi - lo) + 1);
            }
#line 944
            mainQSort3(ptr, block, quadrant, nblock, lo, hi, 2, budget);
#line 948
            numQSorted += (hi - lo) + 1;
#line 949
            if (*budget < 0) {
#line 949
              return;
            }
          }
        }
#line 952
        *(ftab + sb) |= (unsigned int )(1 << 21);
      }
#line 933
      j ++;
    }
#line 956
    if (! (! bigDone[ss])) {
#line 956
      BZ2_bz__AssertH__fail(1006);
    }
#line 966
    j = 0;
#line 966
    while (j <= 255) {
#line 967
      copyStart[j] = (Int32 )(*(ftab + ((j << 8) + ss)) & (unsigned int )(~ (1 << 21)));
#line 968
      copyEnd[j] = (Int32 )((*(ftab + (((j << 8) + ss) + 1)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 966
      j ++;
    }
#line 970
    j = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
#line 970
    while (j < copyStart[ss]) {
#line 971
      k = (Int32 )(*(ptr + j) - 1U);
#line 971
      if (k < 0) {
#line 971
        k += nblock;
      }
#line 972
      c1 = *(block + k);
#line 973
      if (! bigDone[c1]) {
#line 974
        tmp = copyStart[c1];
#line 974
        (copyStart[c1]) ++;
#line 974
        *(ptr + tmp) = (UInt32 )k;
      }
#line 970
      j ++;
    }
#line 976
    j = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - 1U);
#line 976
    while (j > copyEnd[ss]) {
#line 977
      k = (Int32 )(*(ptr + j) - 1U);
#line 977
      if (k < 0) {
#line 977
        k += nblock;
      }
#line 978
      c1 = *(block + k);
#line 979
      if (! bigDone[c1]) {
#line 980
        tmp___0 = copyEnd[c1];
#line 980
        (copyEnd[c1]) --;
#line 980
        *(ptr + tmp___0) = (UInt32 )k;
      }
#line 976
      j --;
    }
#line 984
    if (! (copyStart[ss] - 1 == copyEnd[ss])) {
#line 984
      if (copyStart[ss] == 0) {
#line 984
        if (! (copyEnd[ss] == nblock - 1)) {
#line 984
          BZ2_bz__AssertH__fail(1007);
        }
      } else {
#line 984
        BZ2_bz__AssertH__fail(1007);
      }
    }
#line 993
    j = 0;
#line 993
    while (j <= 255) {
#line 993
      *(ftab + ((j << 8) + ss)) |= (unsigned int )(1 << 21);
#line 993
      j ++;
    }
#line 1034
    bigDone[ss] = (Bool )1;
#line 1036
    if (i < 255) {
#line 1037
      bbStart = (Int32 )(*(ftab + (ss << 8)) & (unsigned int )(~ (1 << 21)));
#line 1038
      bbSize = (Int32 )((*(ftab + ((ss + 1) << 8)) & (unsigned int )(~ (1 << 21))) - (unsigned int )bbStart);
#line 1039
      shifts = 0;
#line 1041
      while (bbSize >> shifts > 65534) {
#line 1041
        shifts ++;
      }
#line 1043
      j = bbSize - 1;
#line 1043
      while (j >= 0) {
#line 1044
        a2update = (Int32 )*(ptr + (bbStart + j));
#line 1045
        qVal = (UInt16 )(j >> shifts);
#line 1046
        *(quadrant + a2update) = qVal;
#line 1047
        if (a2update < 34) {
#line 1048
          *(quadrant + (a2update + nblock)) = qVal;
        }
#line 1043
        j --;
      }
#line 1050
      if (! ((bbSize - 1) >> shifts <= 65535)) {
#line 1050
        BZ2_bz__AssertH__fail(1002);
      }
    }
#line 915
    i ++;
  }
#line 1055
  if (verb >= 4) {
#line 1056
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"        %d pointers, %d sorted, %d scanned\n",
            nblock, numQSorted, nblock - numQSorted);
  }
#line 1058
  return;
}
}
#line 1078 "blocksort.c"
void BZ2_blockSort(EState *s ) 
{ 
  UInt32 *ptr ;
  UChar *block ;
  UInt32 *ftab ;
  Int32 nblock ;
  Int32 verb ;
  Int32 wfact ;
  UInt16 *quadrant ;
  Int32 budget ;
  Int32 budgetInit ;
  Int32 i ;
  int tmp ;

  {
#line 1080
  ptr = s->ptr;
#line 1081
  block = s->block;
#line 1082
  ftab = s->ftab;
#line 1083
  nblock = s->nblock;
#line 1084
  verb = s->verbosity;
#line 1085
  wfact = s->workFactor;
#line 1091
  if (nblock < 10000) {
#line 1092
    fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
  } else {
#line 1099
    i = nblock + 34;
#line 1100
    if (i & 1) {
#line 1100
      i ++;
    }
#line 1101
    quadrant = (UInt16 *)(block + i);
#line 1110
    if (wfact < 1) {
#line 1110
      wfact = 1;
    }
#line 1111
    if (wfact > 100) {
#line 1111
      wfact = 100;
    }
#line 1112
    budgetInit = nblock * ((wfact - 1) / 3);
#line 1113
    budget = budgetInit;
#line 1115
    mainSort(ptr, block, quadrant, ftab, nblock, verb, & budget);
#line 1116
    if (verb >= 3) {
#line 1117
      if (nblock == 0) {
#line 1117
        tmp = 1;
      } else {
#line 1117
        tmp = nblock;
      }
#line 1117
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      %d work, %d block, ratio %5.2f\n",
              budgetInit - budget, nblock, (double )((float )(budgetInit - budget) / (float )tmp));
    }
#line 1122
    if (budget < 0) {
#line 1123
      if (verb >= 2) {
#line 1124
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    too repetitive; using fallback sorting algorithm\n");
      }
#line 1126
      fallbackSort(s->arr1, s->arr2, ftab, nblock, verb);
    }
  }
#line 1130
  s->origPtr = -1;
#line 1131
  i = 0;
#line 1131
  while (i < s->nblock) {
#line 1132
    if (*(ptr + i) == 0U) {
#line 1133
      s->origPtr = i;
#line 1133
      break;
    }
#line 1131
    i ++;
  }
#line 1135
  if (! (s->origPtr != -1)) {
#line 1135
    BZ2_bz__AssertH__fail(1003);
  }
#line 1136
  return;
}
}
#line 1 "bzip2.o"
#pragma merger("0","/tmp/cil-GbQtjORU.i","")
#line 775 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 294 "./bzlib.h"
BZFILE *BZ2_bzReadOpen(int *bzerror , int f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) ;
#line 307
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
#line 312
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) ;
#line 319
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 326
BZFILE *BZ2_bzWriteOpen(int *bzerror , int f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) ;
#line 338
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 353
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) ;
#line 282 "bzip2.c"
int verbosity  ;
#line 283 "bzip2.c"
Bool keepInputFiles  ;
#line 283 "bzip2.c"
unsigned char smallMode  ;
#line 283 "bzip2.c"
Bool deleteOutputOnInterrupt  ;
#line 284 "bzip2.c"
Bool forceOverwrite  ;
#line 284 "bzip2.c"
Bool testFailsExist  ;
#line 284 "bzip2.c"
Bool unzFailsExist  ;
#line 284 "bzip2.c"
Bool noisy  ;
#line 285 "bzip2.c"
Int32 numFileNames  ;
#line 285 "bzip2.c"
Int32 numFilesProcessed  ;
#line 285 "bzip2.c"
int blockSize100k  ;
#line 286 "bzip2.c"
Int32 exitValue  ;
#line 298 "bzip2.c"
Int32 opMode  ;
#line 299 "bzip2.c"
Int32 srcMode  ;
#line 303 "bzip2.c"
Int32 longestFileName  ;
#line 304 "bzip2.c"
Char inName[1034]  ;
#line 305 "bzip2.c"
Char outName[1034]  ;
#line 306 "bzip2.c"
Char tmpName[1034]  ;
#line 307 "bzip2.c"
Char *progName  ;
#line 308 "bzip2.c"
Char progNameReally[1034]  ;
#line 310 "bzip2.c"
int outputHandleJustInCase  ;
#line 314 "bzip2.c"
int workFactor  ;
#line 316
static void panic(Char *s ) ;
#line 317
static void ioError(void) ;
#line 318
static void outOfMemory(void) ;
#line 319
static void configError(void) ;
#line 320
static void crcError(void) ;
#line 321
static void cleanUpAndFail(Int32 ec ) ;
#line 322
static void compressedStreamEOF(void) ;
#line 339 "bzip2.c"
static void uInt64_from_UInt32s(UInt64 *n , UInt32 lo32 , UInt32 hi32 ) 
{ 


  {
#line 342
  n->b[7] = (UChar )((hi32 >> 24) & 255U);
#line 343
  n->b[6] = (UChar )((hi32 >> 16) & 255U);
#line 344
  n->b[5] = (UChar )((hi32 >> 8) & 255U);
#line 345
  n->b[4] = (UChar )(hi32 & 255U);
#line 346
  n->b[3] = (UChar )((lo32 >> 24) & 255U);
#line 347
  n->b[2] = (UChar )((lo32 >> 16) & 255U);
#line 348
  n->b[1] = (UChar )((lo32 >> 8) & 255U);
#line 349
  n->b[0] = (UChar )(lo32 & 255U);
#line 350
  return;
}
}
#line 353 "bzip2.c"
static double uInt64_to_double(UInt64 *n ) 
{ 
  Int32 i ;
  double base ;
  double sum ;

  {
#line 357
  base = 1.0;
#line 358
  sum = 0.0;
#line 359
  i = 0;
#line 359
  while (i < 8) {
#line 360
    sum += base * (double )n->b[i];
#line 361
    base *= 256.0;
#line 359
    i ++;
  }
#line 363
  return (sum);
}
}
#line 367 "bzip2.c"
static Bool uInt64_isZero(UInt64 *n ) 
{ 
  Int32 i ;

  {
#line 371
  i = 0;
#line 371
  while (i < 8) {
#line 372
    if ((int )n->b[i] != 0) {
#line 372
      return ((Bool )0);
    }
#line 371
    i ++;
  }
#line 373
  return ((Bool )1);
}
}
#line 378 "bzip2.c"
static Int32 uInt64_qrm10(UInt64 *n ) 
{ 
  UInt32 rem ;
  UInt32 tmp ;
  Int32 i ;

  {
#line 383
  rem = (UInt32 )0;
#line 384
  i = 7;
#line 384
  while (i >= 0) {
#line 385
    tmp = rem * 256U + (UInt32 )n->b[i];
#line 386
    n->b[i] = (UChar )(tmp / 10U);
#line 387
    rem = tmp % 10U;
#line 384
    i --;
  }
#line 389
  return ((Int32 )rem);
}
}
#line 396 "bzip2.c"
static void uInt64_toAscii(char *outbuf , UInt64 *n ) 
{ 
  Int32 i ;
  Int32 q ;
  UChar buf[32] ;
  Int32 nBuf ;
  UInt64 n_copy ;
  Bool tmp ;

  {
#line 401
  nBuf = 0;
#line 402
  n_copy = *n;
#line 403
  while (1) {
#line 404
    q = uInt64_qrm10(& n_copy);
#line 405
    buf[nBuf] = (UChar )(q + 48);
#line 406
    nBuf ++;
#line 403
    tmp = uInt64_isZero(& n_copy);
#line 403
    if (tmp) {
#line 403
      break;
    }
  }
#line 408
  *(outbuf + nBuf) = (char)0;
#line 409
  i = 0;
#line 409
  while (i < nBuf) {
#line 410
    *(outbuf + i) = (char )buf[(nBuf - i) - 1];
#line 409
    i ++;
  }
#line 411
  return;
}
}
#line 419 "bzip2.c"
static Bool myfeof(int f ) 
{ 
  Int32 c ;
  int tmp ;

  {
#line 426
  tmp = spec_getc(f);
#line 426
  c = tmp;
#line 427
  if (c == -1) {
#line 427
    return ((Bool )1);
  }
#line 428
  spec_ungetc((unsigned char )c, f);
#line 429
  return ((Bool )0);
}
}
#line 435 "bzip2.c"
void compressStream(int stream , int zStream ) 
{ 
  BZFILE *bzf ;
  UChar ibuf[5000] ;
  Int32 nIbuf ;
  UInt32 nbytes_in_lo32 ;
  UInt32 nbytes_in_hi32 ;
  UInt32 nbytes_out_lo32 ;
  UInt32 nbytes_out_hi32 ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Bool tmp ;
  Char buf_nin[32] ;
  Char buf_nout[32] ;
  UInt64 nbytes_in ;
  UInt64 nbytes_out ;
  double nbytes_in_d ;
  double nbytes_out_d ;

  {
#line 441
  bzf = (void *)0;
#line 454
  bzf = BZ2_bzWriteOpen(& bzerr, zStream, blockSize100k, verbosity, workFactor);
#line 456
  if (bzerr != 0) {
#line 456
    goto errhandler;
  }
#line 458
  if (verbosity >= 2) {
#line 458
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
#line 460
  while (1) {
#line 462
    tmp = myfeof(stream);
#line 462
    if (tmp) {
#line 462
      break;
    }
#line 463
    nIbuf = spec_fread(ibuf, (int )sizeof(UChar ), 5000, stream);
#line 465
    if (nIbuf > 0) {
#line 465
      BZ2_bzWrite(& bzerr, bzf, (void *)(ibuf), nIbuf);
    }
#line 466
    if (bzerr != 0) {
#line 466
      goto errhandler;
    }
  }
#line 470
  BZ2_bzWriteClose64(& bzerr, bzf, 0, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
#line 473
  if (bzerr != 0) {
#line 473
    goto errhandler;
  }
#line 476
  ret = 0;
#line 477
  if (ret == -1) {
#line 477
    goto errhandler_io;
  }
#line 479
  if (zStream != 1) {
#line 483
    ret = 0;
#line 484
    outputHandleJustInCase = (int )((void *)0);
#line 485
    if (ret == -1) {
#line 485
      goto errhandler_io;
    }
  }
#line 487
  outputHandleJustInCase = (int )((void *)0);
#line 489
  ret = 0;
#line 490
  if (ret == -1) {
#line 490
    goto errhandler_io;
  }
#line 492
  if (verbosity >= 1) {
#line 493
    if (nbytes_in_lo32 == 0U) {
#line 493
      if (nbytes_in_hi32 == 0U) {
#line 494
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" no data compressed.\n");
      } else {
#line 493
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 499
      uInt64_from_UInt32s(& nbytes_in, nbytes_in_lo32, nbytes_in_hi32);
#line 501
      uInt64_from_UInt32s(& nbytes_out, nbytes_out_lo32, nbytes_out_hi32);
#line 503
      nbytes_in_d = uInt64_to_double(& nbytes_in);
#line 504
      nbytes_out_d = uInt64_to_double(& nbytes_out);
#line 505
      uInt64_toAscii(buf_nin, & nbytes_in);
#line 506
      uInt64_toAscii(buf_nout, & nbytes_out);
#line 507
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n",
              nbytes_in_d / nbytes_out_d, (8.0 * nbytes_out_d) / nbytes_in_d, 100.0 * (1.0 - nbytes_out_d / nbytes_in_d),
              buf_nin, buf_nout);
    }
  }
#line 518
  return;
  errhandler: 
#line 521
  BZ2_bzWriteClose64(& bzerr_dummy, bzf, 1, & nbytes_in_lo32, & nbytes_in_hi32, & nbytes_out_lo32,
                     & nbytes_out_hi32);
#line 524
  switch (bzerr) {
  case -9: 
#line 526
  configError();
#line 526
  break;
  case -3: 
#line 528
  outOfMemory();
#line 528
  break;
//AD errhandler_io:  //AD ref #12345
  case -6: 
#line 531
 errhandler_io:  //AD ref #12345
  ioError();
#line 531
  break;
  default: 
#line 533
  panic((Char *)"compress:unexpected error");
  }
#line 536
  panic((Char *)"compress:end");
#line 538
  return;
}
}
#line 544 "bzip2.c"
unsigned char uncompressStream(int zStream , int stream ) 
{ 
  BZFILE *bzf ;
  Int32 bzerr ;
  Int32 bzerr_dummy ;
  Int32 ret ;
  Int32 nread ;
  Int32 streamNo ;
  Int32 i ;
  UChar obuf[5000] ;
  UChar unused[5000] ;
  Int32 nUnused ;
  void *unusedTmpV ;
  UChar *unusedTmp ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 550
  bzf = (void *)0;
#line 558
  nUnused = 0;
#line 559
  streamNo = 0;
#line 567
  while (1) {
#line 569
    bzf = BZ2_bzReadOpen(& bzerr, zStream, verbosity, (int )smallMode, (void *)(unused),
                         nUnused);
#line 573
    if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 573
      goto errhandler;
    } else
#line 573
    if (bzerr != 0) {
#line 573
      goto errhandler;
    }
#line 574
    streamNo ++;
#line 576
    while (bzerr == 0) {
#line 577
      nread = BZ2_bzRead(& bzerr, bzf, (void *)(obuf), 5000);
#line 578
      if (bzerr == -5) {
#line 578
        goto trycat;
      }
#line 579
      if (bzerr == 0) {
#line 579
        goto _L;
      } else
#line 579
      if (bzerr == 4) {
        _L: /* CIL Label */ 
#line 579
        if (nread > 0) {
#line 580
          spec_fwrite(obuf, (int )sizeof(UChar ), nread, stream);
        }
      }
    }
#line 583
    if (bzerr != 4) {
#line 583
      goto errhandler;
    }
#line 585
    BZ2_bzReadGetUnused(& bzerr, bzf, & unusedTmpV, & nUnused);
#line 586
    if (bzerr != 0) {
#line 586
      panic((Char *)"decompress:bzReadGetUnused");
    }
#line 588
    unusedTmp = (UChar *)unusedTmpV;
#line 589
    i = 0;
#line 589
    while (i < nUnused) {
#line 589
      unused[i] = *(unusedTmp + i);
#line 589
      i ++;
    }
#line 591
    BZ2_bzReadClose(& bzerr, bzf);
#line 592
    if (bzerr != 0) {
#line 592
      panic((Char *)"decompress:bzReadGetUnused");
    }
#line 594
    if (nUnused == 0) {
#line 594
      tmp = myfeof(zStream);
#line 594
      if (tmp) {
#line 594
        break;
      }
    }
  }
  closeok: 
#line 599
  ret = 0;
#line 600
  if (ret == -1) {
#line 600
    goto errhandler_io;
  }
#line 603
  ret = 0;
#line 604
  if (ret != 0) {
#line 604
    goto errhandler_io;
  }
#line 606
  if (stream != 1) {
#line 610
    ret = 0;
#line 611
    outputHandleJustInCase = (int )((void *)0);
#line 612
    if (ret == -1) {
#line 612
      goto errhandler_io;
    }
  }
#line 614
  outputHandleJustInCase = (int )((void *)0);
#line 615
  if (verbosity >= 2) {
#line 615
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    ");
  }
#line 616
  return ((Bool )1);
  trycat: 
#line 619
  if (forceOverwrite) {
#line 620
    spec_rewind(zStream);
#line 621
    while (1) {
#line 622
      tmp___0 = myfeof(zStream);
#line 622
      if (tmp___0) {
#line 622
        break;
      }
#line 623
      nread = spec_fread(obuf, (int )sizeof(UChar ), 5000, zStream);
#line 625
      if (nread > 0) {
#line 625
        spec_fwrite(obuf, (int )sizeof(UChar ), nread, stream);
      }
    }
#line 628
    goto closeok;
  }
  errhandler: 
#line 632
  BZ2_bzReadClose(& bzerr_dummy, bzf);
#line 633
  switch (bzerr) {
  case -9: 
#line 635
  configError();
#line 635
  break;
//AD errhandler_io:  //AD ref #123456
  case -6: 
#line 638
  errhandler_io:  //AD ref #123456
  ioError();
#line 638
  break;
  case -4: 
#line 640
  crcError();
  case -3: 
#line 642
  outOfMemory();
  case -7: 
#line 644
  compressedStreamEOF();
  case -5: ;
#line 653
  if (streamNo == 1) {
#line 654
    return ((Bool )0);
  } else {
#line 656
    if (noisy) {
#line 657
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: trailing garbage after EOF ignored\n",
              progName, inName);
    }
#line 660
    return ((Bool )1);
  }
  default: 
#line 663
  panic((Char *)"decompress:unexpected error");
  }
#line 666
  panic((Char *)"decompress:end");
#line 667
  return ((Bool )1);
}
}
#line 777 "bzip2.c"
static void setExit(Int32 v ) 
{ 


  {
#line 781
  exitValue = 0;
#line 785
  return;
}
}
#line 789 "bzip2.c"
static void cadvise(void) 
{ 


  {
#line 792
  if (noisy) {
#line 793
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n");
  }
#line 800
  return;
}
}
#line 804 "bzip2.c"
static void showFileNames(void) 
{ 


  {
#line 807
  if (noisy) {
#line 808
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tInput file = %s, output file = %s\n",
            inName, outName);
  }
#line 813
  return;
}
}
#line 817 "bzip2.c"
static void cleanUpAndFail(Int32 ec ) 
{ 


  {
#line 872
  setExit(ec);
#line 873
  exit(exitValue);
}
}
#line 878 "bzip2.c"
static void panic(Char *s ) 
{ 


  {
#line 881
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is probably a BUG, but it may be in your COMPILER.  Please do not bother\n\tthe original author.\n",
          progName, s);
#line 892
  showFileNames();
#line 893
  cleanUpAndFail(3);
#line 894
  return;
}
}
#line 898 "bzip2.c"
static void crcError(void) 
{ 


  {
#line 901
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Data integrity error when decompressing.\n",
          progName);
#line 904
  showFileNames();
#line 905
  cadvise();
#line 906
  cleanUpAndFail(2);
#line 907
  return;
}
}
#line 911 "bzip2.c"
static void compressedStreamEOF(void) 
{ 


  {
#line 914
  if (noisy) {
#line 915
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
            progName);
#line 919
    perror((char const   *)progName);
#line 920
    showFileNames();
#line 921
    cadvise();
  }
#line 923
  cleanUpAndFail(2);
#line 924
  return;
}
}
#line 928 "bzip2.c"
static void ioError(void) 
{ 


  {
#line 931
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
#line 935
  perror((char const   *)progName);
#line 936
  showFileNames();
#line 937
  cleanUpAndFail(1);
#line 938
  return;
}
}
#line 1013 "bzip2.c"
static void outOfMemory(void) 
{ 


  {
#line 1016
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: couldn\'t allocate enough memory\n",
          progName);
#line 1019
  showFileNames();
#line 1020
  cleanUpAndFail(1);
#line 1021
  return;
}
}
#line 1025 "bzip2.c"
static void configError(void) 
{ 


  {
#line 1028
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n");
#line 1034
  setExit(3);
#line 1035
  exit(exitValue);
}
}
#line 1 "bzlib.o"
#pragma merger("0","/tmp/cil-NBgbav3u.i","")
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 255 "./bzlib.h"
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) ;
#line 262
int BZ2_bzCompress(bz_stream *strm , int action ) ;
#line 267
int BZ2_bzCompressEnd(bz_stream *strm ) ;
#line 271
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) ;
#line 277
int BZ2_bzDecompress(bz_stream *strm ) ;
#line 281
int BZ2_bzDecompressEnd(bz_stream *strm ) ;
#line 345
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) ;
#line 367
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) ;
#line 377
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) ;
#line 397
char const   *BZ2_bzlibVersion(void) ;
#line 402
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) ;
#line 407
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) ;
#line 412
int BZ2_bzread(BZFILE *b , void *buf , int len ) ;
#line 418
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) ;
#line 424
int BZ2_bzflush(BZFILE *b ) ;
#line 428
void BZ2_bzclose(BZFILE *b ) ;
#line 432
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) ;
#line 165 "./bzlib_private.h"
Int32 BZ2_rNums[512] ;
#line 189
UInt32 BZ2_crc32Table[256] ;
#line 309
void BZ2_compressBlock(EState *s , Bool is_last_block ) ;
#line 512
Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) ;
#line 515
Int32 BZ2_decompress(DState *s ) ;
#line 87 "bzlib.c"
void BZ2_bz__AssertH__fail(int errcode ) 
{ 
  char const   *tmp ;

  {
#line 89
  tmp = BZ2_bzlibVersion();
#line 89
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n\nbzip2/libbzip2: internal error number %d.\nThis may be a bug in bzip2/libbzip2, %s.\nIt may also be a bug in your compiler.  Please do not bother the\noriginal author of bzip2 with a bug report for this.  He\ndoesn\'t know anything about bzip2 as it appears in CPU2006.\n\n",
          errcode, tmp);
#line 109
  if (errcode == 1007) {
#line 110
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n*** A special note about internal error number 1007 ***\n\nExperience suggests that a common cause of i.e. 1007\nis unreliable memory or other hardware.  The 1007 assertion\njust happens to cross-check the results of huge numbers of\nmemory reads/writes, and so acts (unintendedly) as a stress\ntest of your memory system.\n\nI suggest the following: try compressing the file again,\npossibly monitoring progress in detail with the -vv flag.\n\n* If the error cannot be reproduced, and/or happens at different\n  points in compression, you may have a flaky memory system.\n  Try a memory-test program.  I have used Memtest86\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\n  Memtest86 tests memory much more thorougly than your BIOSs\n  power-on test, and may find failures that the BIOS doesn\'t.\n\n* If the error can be repeatably reproduced, this is a bug in\n  bzip2, and I would very much like to hear about it.  Please\n  let me know, and, ideally, save a copy of the file causing the\n  problem -- without which I will be unable to investigate it.\n\n");
  }
#line 140
  exit(0);
}
}
#line 147 "bzlib.c"
static int bz_config_ok(void) 
{ 


  {
#line 150
  if (sizeof(int ) != 4UL) {
#line 150
    return (0);
  }
#line 151
  if (sizeof(short ) != 2UL) {
#line 151
    return (0);
  }
#line 152
  if (sizeof(char ) != 1UL) {
#line 152
    return (0);
  }
#line 153
  return (1);
}
}
#line 158 "bzlib.c"
static void *default_bzalloc(void *opaque , Int32 items , Int32 size ) 
{ 
  void *v ;
  void *tmp ;

  {
#line 161
  tmp = malloc((size_t )(items * size));
#line 161
  v = tmp;
#line 162
  return (v);
}
}
#line 165 "bzlib.c"
static void default_bzfree(void *opaque , void *addr ) 
{ 


  {
#line 168
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
#line 168
    free(addr);
  }
#line 169
  return;
}
}
#line 173 "bzlib.c"
static void prepare_new_block(EState *s ) 
{ 
  Int32 i ;

  {
#line 177
  s->nblock = 0;
#line 178
  s->numZ = 0;
#line 179
  s->state_out_pos = 0;
#line 180
  s->blockCRC = (UInt32 )4294967295L;
#line 181
  i = 0;
#line 181
  while (i < 256) {
#line 181
    s->inUse[i] = (Bool )0;
#line 181
    i ++;
  }
#line 182
  (s->blockNo) ++;
#line 183
  return;
}
}
#line 187 "bzlib.c"
static void init_RL(EState *s ) 
{ 


  {
#line 190
  s->state_in_ch = (UInt32 )256;
#line 191
  s->state_in_len = 0;
#line 192
  return;
}
}
#line 195 "bzlib.c"
static Bool isempty_RL(EState *s ) 
{ 


  {
#line 198
  if (s->state_in_ch < 256U) {
#line 198
    if (s->state_in_len > 0) {
#line 199
      return ((Bool )0);
    } else {
#line 200
      return ((Bool )1);
    }
  } else {
#line 200
    return ((Bool )1);
  }
}
}
#line 205 "bzlib.c"
int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k___0 , int verbosity___0 ,
                       int workFactor___0 ) 
{ 
  Int32 n ;
  EState *s ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 214
  tmp = bz_config_ok();
#line 214
  if (! tmp) {
#line 214
    return (-9);
  }
#line 216
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 219
    return (-2);
  } else
#line 216
  if (blockSize100k___0 < 1) {
#line 219
    return (-2);
  } else
#line 216
  if (blockSize100k___0 > 9) {
#line 219
    return (-2);
  } else
#line 216
  if (workFactor___0 < 0) {
#line 219
    return (-2);
  } else
#line 216
  if (workFactor___0 > 250) {
#line 219
    return (-2);
  }
#line 221
  if (workFactor___0 == 0) {
#line 221
    workFactor___0 = 30;
  }
#line 222
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
#line 222
    strm->bzalloc = & default_bzalloc;
  }
#line 223
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
#line 223
    strm->bzfree = & default_bzfree;
  }
#line 225
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(EState ), 1);
#line 225
  s = (EState *)tmp___0;
#line 226
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 226
    return (-3);
  }
#line 227
  s->strm = strm;
#line 229
  s->arr1 = (UInt32 *)((void *)0);
#line 230
  s->arr2 = (UInt32 *)((void *)0);
#line 231
  s->ftab = (UInt32 *)((void *)0);
#line 233
  n = 100000 * blockSize100k___0;
#line 234
  tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )n * sizeof(UInt32 )),
                               1);
#line 234
  s->arr1 = (UInt32 *)tmp___1;
#line 235
  tmp___2 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(n + 34) * sizeof(UInt32 )),
                               1);
#line 235
  s->arr2 = (UInt32 *)tmp___2;
#line 236
  tmp___3 = (*(strm->bzalloc))(strm->opaque, (int )(65537UL * sizeof(UInt32 )), 1);
#line 236
  s->ftab = (UInt32 *)tmp___3;
#line 238
  if ((unsigned long )s->arr1 == (unsigned long )((void *)0)) {
#line 238
    goto _L;
  } else
#line 238
  if ((unsigned long )s->arr2 == (unsigned long )((void *)0)) {
#line 238
    goto _L;
  } else
#line 238
  if ((unsigned long )s->ftab == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 239
    if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
#line 239
      (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
    }
#line 240
    if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
#line 240
      (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
    }
#line 241
    if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
#line 241
      (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
    }
#line 242
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 242
      (*(strm->bzfree))(strm->opaque, (void *)s);
    }
#line 243
    return (-3);
  }
#line 246
  s->blockNo = 0;
#line 247
  s->state = 2;
#line 248
  s->mode = 2;
#line 249
  s->combinedCRC = (UInt32 )0;
#line 250
  s->blockSize100k = blockSize100k___0;
#line 251
  s->nblockMAX = 100000 * blockSize100k___0 - 19;
#line 252
  s->verbosity = verbosity___0;
#line 253
  s->workFactor = workFactor___0;
#line 255
  s->block = (UChar *)s->arr2;
#line 256
  s->mtfv = (UInt16 *)s->arr1;
#line 257
  s->zbits = (UChar *)((void *)0);
#line 258
  s->ptr = s->arr1;
#line 260
  strm->state = (void *)s;
#line 261
  strm->total_in_lo32 = 0U;
#line 262
  strm->total_in_hi32 = 0U;
#line 263
  strm->total_out_lo32 = 0U;
#line 264
  strm->total_out_hi32 = 0U;
#line 265
  init_RL(s);
#line 266
  prepare_new_block(s);
#line 267
  return (0);
}
}
#line 272 "bzlib.c"
static void add_pair_to_block(EState *s ) 
{ 
  Int32 i ;
  UChar ch ;

  {
#line 276
  ch = (UChar )s->state_in_ch;
#line 277
  i = 0;
#line 277
  while (i < s->state_in_len) {
#line 278
    s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 277
    i ++;
  }
#line 280
  s->inUse[s->state_in_ch] = (Bool )1;
#line 281
  switch (s->state_in_len) {
  case 1: 
#line 283
  *(s->block + s->nblock) = ch;
#line 283
  (s->nblock) ++;
#line 284
  break;
  case 2: 
#line 286
  *(s->block + s->nblock) = ch;
#line 286
  (s->nblock) ++;
#line 287
  *(s->block + s->nblock) = ch;
#line 287
  (s->nblock) ++;
#line 288
  break;
  case 3: 
#line 290
  *(s->block + s->nblock) = ch;
#line 290
  (s->nblock) ++;
#line 291
  *(s->block + s->nblock) = ch;
#line 291
  (s->nblock) ++;
#line 292
  *(s->block + s->nblock) = ch;
#line 292
  (s->nblock) ++;
#line 293
  break;
  default: 
#line 295
  s->inUse[s->state_in_len - 4] = (Bool )1;
#line 296
  *(s->block + s->nblock) = ch;
#line 296
  (s->nblock) ++;
#line 297
  *(s->block + s->nblock) = ch;
#line 297
  (s->nblock) ++;
#line 298
  *(s->block + s->nblock) = ch;
#line 298
  (s->nblock) ++;
#line 299
  *(s->block + s->nblock) = ch;
#line 299
  (s->nblock) ++;
#line 300
  *(s->block + s->nblock) = (UChar )(s->state_in_len - 4);
#line 301
  (s->nblock) ++;
#line 302
  break;
  }
#line 304
  return;
}
}
#line 308 "bzlib.c"
static void flush_RL(EState *s ) 
{ 


  {
#line 311
  if (s->state_in_ch < 256U) {
#line 311
    add_pair_to_block(s);
  }
#line 312
  init_RL(s);
#line 313
  return;
}
}
#line 345 "bzlib.c"
static Bool copy_input_until_stop(EState *s ) 
{ 
  Bool progress_in ;
  UInt32 zchh ;
  UChar ch ;
  UInt32 zchh___0 ;
  UChar ch___0 ;

  {
#line 348
  progress_in = (Bool )0;
#line 350
  if (s->mode == 2) {
#line 353
    while (! (s->nblock >= s->nblockMAX)) {
#line 357
      if ((s->strm)->avail_in == 0U) {
#line 357
        break;
      }
#line 358
      progress_in = (Bool )1;
#line 359
      zchh = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 359
      if (zchh != s->state_in_ch) {
#line 359
        if (s->state_in_len == 1) {
#line 359
          ch = (UChar )s->state_in_ch;
#line 359
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch];
#line 359
          s->inUse[s->state_in_ch] = (Bool )1;
#line 359
          *(s->block + s->nblock) = ch;
#line 359
          (s->nblock) ++;
#line 359
          s->state_in_ch = zchh;
        } else {
#line 359
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 359
      if (zchh != s->state_in_ch) {
#line 359
        goto _L;
      } else
#line 359
      if (s->state_in_len == 255) {
        _L: /* CIL Label */ 
#line 359
        if (s->state_in_ch < 256U) {
#line 359
          add_pair_to_block(s);
        }
#line 359
        s->state_in_ch = zchh;
#line 359
        s->state_in_len = 1;
      } else {
#line 359
        (s->state_in_len) ++;
      }
#line 360
      ((s->strm)->next_in) ++;
#line 361
      ((s->strm)->avail_in) --;
#line 362
      ((s->strm)->total_in_lo32) ++;
#line 363
      if ((s->strm)->total_in_lo32 == 0U) {
#line 363
        ((s->strm)->total_in_hi32) ++;
      }
    }
  } else {
#line 369
    while (! (s->nblock >= s->nblockMAX)) {
#line 373
      if ((s->strm)->avail_in == 0U) {
#line 373
        break;
      }
#line 375
      if (s->avail_in_expect == 0U) {
#line 375
        break;
      }
#line 376
      progress_in = (Bool )1;
#line 377
      zchh___0 = (UInt32 )*((UChar *)(s->strm)->next_in);
#line 377
      if (zchh___0 != s->state_in_ch) {
#line 377
        if (s->state_in_len == 1) {
#line 377
          ch___0 = (UChar )s->state_in_ch;
#line 377
          s->blockCRC = (s->blockCRC << 8) ^ BZ2_crc32Table[(s->blockCRC >> 24) ^ (unsigned int )ch___0];
#line 377
          s->inUse[s->state_in_ch] = (Bool )1;
#line 377
          *(s->block + s->nblock) = ch___0;
#line 377
          (s->nblock) ++;
#line 377
          s->state_in_ch = zchh___0;
        } else {
#line 377
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 377
      if (zchh___0 != s->state_in_ch) {
#line 377
        goto _L___1;
      } else
#line 377
      if (s->state_in_len == 255) {
        _L___1: /* CIL Label */ 
#line 377
        if (s->state_in_ch < 256U) {
#line 377
          add_pair_to_block(s);
        }
#line 377
        s->state_in_ch = zchh___0;
#line 377
        s->state_in_len = 1;
      } else {
#line 377
        (s->state_in_len) ++;
      }
#line 378
      ((s->strm)->next_in) ++;
#line 379
      ((s->strm)->avail_in) --;
#line 380
      ((s->strm)->total_in_lo32) ++;
#line 381
      if ((s->strm)->total_in_lo32 == 0U) {
#line 381
        ((s->strm)->total_in_hi32) ++;
      }
#line 382
      (s->avail_in_expect) --;
    }
  }
#line 385
  return (progress_in);
}
}
#line 390 "bzlib.c"
static Bool copy_output_until_stop(EState *s ) 
{ 
  Bool progress_out ;

  {
#line 393
  progress_out = (Bool )0;
#line 395
  while (! ((s->strm)->avail_out == 0U)) {
#line 401
    if (s->state_out_pos >= s->numZ) {
#line 401
      break;
    }
#line 403
    progress_out = (Bool )1;
#line 404
    *((s->strm)->next_out) = (char )*(s->zbits + s->state_out_pos);
#line 405
    (s->state_out_pos) ++;
#line 406
    ((s->strm)->avail_out) --;
#line 407
    ((s->strm)->next_out) ++;
#line 408
    ((s->strm)->total_out_lo32) ++;
#line 409
    if ((s->strm)->total_out_lo32 == 0U) {
#line 409
      ((s->strm)->total_out_hi32) ++;
    }
  }
#line 412
  return (progress_out);
}
}
#line 417 "bzlib.c"
static Bool handle_compress(bz_stream *strm ) 
{ 
  Bool progress_in ;
  Bool progress_out ;
  EState *s ;
  Bool tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;
  int tmp___3 ;

  {
#line 420
  progress_in = (Bool )0;
#line 421
  progress_out = (Bool )0;
#line 422
  s = (EState *)strm->state;
#line 424
  while (1) {
#line 426
    if (s->state == 1) {
#line 427
      tmp = copy_output_until_stop(s);
#line 427
      progress_out = (Bool )((int )progress_out | (int )tmp);
#line 428
      if (s->state_out_pos < s->numZ) {
#line 428
        break;
      }
#line 429
      if (s->mode == 4) {
#line 429
        if (s->avail_in_expect == 0U) {
#line 429
          tmp___0 = isempty_RL(s);
#line 429
          if (tmp___0) {
#line 431
            break;
          }
        }
      }
#line 432
      prepare_new_block(s);
#line 433
      s->state = 2;
#line 434
      if (s->mode == 3) {
#line 434
        if (s->avail_in_expect == 0U) {
#line 434
          tmp___1 = isempty_RL(s);
#line 434
          if (tmp___1) {
#line 436
            break;
          }
        }
      }
    }
#line 439
    if (s->state == 2) {
#line 440
      tmp___2 = copy_input_until_stop(s);
#line 440
      progress_in = (Bool )((int )progress_in | (int )tmp___2);
#line 441
      if (s->mode != 2) {
#line 441
        if (s->avail_in_expect == 0U) {
#line 442
          flush_RL(s);
#line 443
          BZ2_compressBlock(s, (Bool )(s->mode == 4));
#line 444
          s->state = 1;
        } else {
#line 441
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 447
      if (s->nblock >= s->nblockMAX) {
#line 448
        BZ2_compressBlock(s, (Bool )0);
#line 449
        s->state = 1;
      } else
#line 452
      if ((s->strm)->avail_in == 0U) {
#line 453
        break;
      }
    }
  }
#line 459
  if (progress_in) {
#line 459
    tmp___3 = 1;
  } else
#line 459
  if (progress_out) {
#line 459
    tmp___3 = 1;
  } else {
#line 459
    tmp___3 = 0;
  }
#line 459
  return ((Bool )tmp___3);
}
}
#line 464 "bzlib.c"
int BZ2_bzCompress(bz_stream *strm , int action ) 
{ 
  Bool progress ;
  EState *s ;
  int tmp ;
  Bool tmp___0 ;
  Bool tmp___1 ;

  {
#line 468
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 468
    return (-2);
  }
#line 469
  s = (EState *)strm->state;
#line 470
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 470
    return (-2);
  }
#line 471
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 471
    return (-2);
  }
  preswitch: 
#line 474
  switch (s->mode) {
  case 1: 
#line 477
  return (-1);
  case 2: 
#line 480
  if (action == 0) {
#line 481
    progress = handle_compress(strm);
#line 482
    if (progress) {
#line 482
      tmp = 1;
    } else {
#line 482
      tmp = -2;
    }
#line 482
    return (tmp);
  } else
#line 485
  if (action == 1) {
#line 486
    s->avail_in_expect = strm->avail_in;
#line 487
    s->mode = 3;
#line 488
    goto preswitch;
  } else
#line 491
  if (action == 2) {
#line 492
    s->avail_in_expect = strm->avail_in;
#line 493
    s->mode = 4;
#line 494
    goto preswitch;
  } else {
#line 497
    return (-2);
  }
  case 3: 
#line 500
  if (action != 1) {
#line 500
    return (-1);
  }
#line 501
  if (s->avail_in_expect != (s->strm)->avail_in) {
#line 502
    return (-1);
  }
#line 503
  progress = handle_compress(strm);
#line 504
  if (s->avail_in_expect > 0U) {
#line 505
    return (2);
  } else {
#line 504
    tmp___0 = isempty_RL(s);
#line 504
    if (tmp___0) {
#line 504
      if (s->state_out_pos < s->numZ) {
#line 505
        return (2);
      }
    } else {
#line 505
      return (2);
    }
  }
#line 506
  s->mode = 2;
#line 507
  return (1);
  case 4: 
#line 510
  if (action != 2) {
#line 510
    return (-1);
  }
#line 511
  if (s->avail_in_expect != (s->strm)->avail_in) {
#line 512
    return (-1);
  }
#line 513
  progress = handle_compress(strm);
#line 514
  if (! progress) {
#line 514
    return (-1);
  }
#line 515
  if (s->avail_in_expect > 0U) {
#line 516
    return (3);
  } else {
#line 515
    tmp___1 = isempty_RL(s);
#line 515
    if (tmp___1) {
#line 515
      if (s->state_out_pos < s->numZ) {
#line 516
        return (3);
      }
    } else {
#line 516
      return (3);
    }
  }
#line 517
  s->mode = 1;
#line 518
  return (4);
  }
#line 520
  return (0);
}
}
#line 525 "bzlib.c"
int BZ2_bzCompressEnd(bz_stream *strm ) 
{ 
  EState *s ;

  {
#line 528
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 528
    return (-2);
  }
#line 529
  s = (EState *)strm->state;
#line 530
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 530
    return (-2);
  }
#line 531
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 531
    return (-2);
  }
#line 533
  if ((unsigned long )s->arr1 != (unsigned long )((void *)0)) {
#line 533
    (*(strm->bzfree))(strm->opaque, (void *)s->arr1);
  }
#line 534
  if ((unsigned long )s->arr2 != (unsigned long )((void *)0)) {
#line 534
    (*(strm->bzfree))(strm->opaque, (void *)s->arr2);
  }
#line 535
  if ((unsigned long )s->ftab != (unsigned long )((void *)0)) {
#line 535
    (*(strm->bzfree))(strm->opaque, (void *)s->ftab);
  }
#line 536
  (*(strm->bzfree))(strm->opaque, strm->state);
#line 538
  strm->state = (void *)0;
#line 540
  return (0);
}
}
#line 549 "bzlib.c"
int BZ2_bzDecompressInit(bz_stream *strm , int verbosity___0 , int small ) 
{ 
  DState *s ;
  int tmp ;
  void *tmp___0 ;

  {
#line 556
  tmp = bz_config_ok();
#line 556
  if (! tmp) {
#line 556
    return (-9);
  }
#line 558
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 558
    return (-2);
  }
#line 559
  if (small != 0) {
#line 559
    if (small != 1) {
#line 559
      return (-2);
    }
  }
#line 560
  if (verbosity___0 < 0) {
#line 560
    return (-2);
  } else
#line 560
  if (verbosity___0 > 4) {
#line 560
    return (-2);
  }
#line 562
  if ((unsigned long )strm->bzalloc == (unsigned long )((void *)0)) {
#line 562
    strm->bzalloc = & default_bzalloc;
  }
#line 563
  if ((unsigned long )strm->bzfree == (unsigned long )((void *)0)) {
#line 563
    strm->bzfree = & default_bzfree;
  }
#line 565
  tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )sizeof(DState ), 1);
#line 565
  s = (DState *)tmp___0;
#line 566
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 566
    return (-3);
  }
#line 567
  s->strm = strm;
#line 568
  strm->state = (void *)s;
#line 569
  s->state = 10;
#line 570
  s->bsLive = 0;
#line 571
  s->bsBuff = (UInt32 )0;
#line 572
  s->calculatedCombinedCRC = (UInt32 )0;
#line 573
  strm->total_in_lo32 = 0U;
#line 574
  strm->total_in_hi32 = 0U;
#line 575
  strm->total_out_lo32 = 0U;
#line 576
  strm->total_out_hi32 = 0U;
#line 577
  s->smallDecompress = (Bool )small;
#line 578
  s->ll4 = (UChar *)((void *)0);
#line 579
  s->ll16 = (UInt16 *)((void *)0);
#line 580
  s->tt = (UInt32 *)((void *)0);
#line 581
  s->currBlockNo = 0;
#line 582
  s->verbosity = verbosity___0;
#line 584
  return (0);
}
}
#line 592 "bzlib.c"
static Bool unRLE_obuf_to_output_FAST(DState *s ) 
{ 
  UChar k1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  UInt32 c_calculatedBlockCRC ;
  UChar c_state_out_ch ;
  Int32 c_state_out_len ;
  Int32 c_nblock_used ;
  Int32 c_k0 ;
  UInt32 *c_tt ;
  UInt32 c_tPos ;
  char *cs_next_out ;
  unsigned int cs_avail_out ;
  UInt32 avail_out_INIT ;
  Int32 s_save_nblockPP ;
  unsigned int total_out_lo32_old ;

  {
#line 597
  if (s->blockRandomised) {
#line 599
    while (1) {
#line 601
      while (1) {
#line 602
        if ((s->strm)->avail_out == 0U) {
#line 602
          return ((Bool )0);
        }
#line 603
        if (s->state_out_len == 0) {
#line 603
          break;
        }
#line 604
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 605
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 606
        (s->state_out_len) --;
#line 607
        ((s->strm)->next_out) ++;
#line 608
        ((s->strm)->avail_out) --;
#line 609
        ((s->strm)->total_out_lo32) ++;
#line 610
        if ((s->strm)->total_out_lo32 == 0U) {
#line 610
          ((s->strm)->total_out_hi32) ++;
        }
      }
#line 614
      if (s->nblock_used == s->save_nblock + 1) {
#line 614
        return ((Bool )0);
      }
#line 617
      if (s->nblock_used > s->save_nblock + 1) {
#line 618
        return ((Bool )1);
      }
#line 620
      s->state_out_len = 1;
#line 621
      s->state_out_ch = (UChar )s->k0;
#line 622
      s->tPos = *(s->tt + s->tPos);
#line 622
      k1 = (UChar )(s->tPos & 255U);
#line 622
      s->tPos >>= 8;
#line 622
      if (s->rNToGo == 0) {
#line 622
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 622
        (s->rTPos) ++;
#line 622
        if (s->rTPos == 512) {
#line 622
          s->rTPos = 0;
        }
      }
#line 622
      (s->rNToGo) --;
#line 623
      if (s->rNToGo == 1) {
#line 623
        tmp = 1;
      } else {
#line 623
        tmp = 0;
      }
#line 623
      k1 = (UChar )((int )k1 ^ tmp);
#line 623
      (s->nblock_used) ++;
#line 624
      if (s->nblock_used == s->save_nblock + 1) {
#line 624
        continue;
      }
#line 625
      if ((int )k1 != s->k0) {
#line 625
        s->k0 = (Int32 )k1;
#line 625
        continue;
      }
#line 627
      s->state_out_len = 2;
#line 628
      s->tPos = *(s->tt + s->tPos);
#line 628
      k1 = (UChar )(s->tPos & 255U);
#line 628
      s->tPos >>= 8;
#line 628
      if (s->rNToGo == 0) {
#line 628
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 628
        (s->rTPos) ++;
#line 628
        if (s->rTPos == 512) {
#line 628
          s->rTPos = 0;
        }
      }
#line 628
      (s->rNToGo) --;
#line 629
      if (s->rNToGo == 1) {
#line 629
        tmp___0 = 1;
      } else {
#line 629
        tmp___0 = 0;
      }
#line 629
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 629
      (s->nblock_used) ++;
#line 630
      if (s->nblock_used == s->save_nblock + 1) {
#line 630
        continue;
      }
#line 631
      if ((int )k1 != s->k0) {
#line 631
        s->k0 = (Int32 )k1;
#line 631
        continue;
      }
#line 633
      s->state_out_len = 3;
#line 634
      s->tPos = *(s->tt + s->tPos);
#line 634
      k1 = (UChar )(s->tPos & 255U);
#line 634
      s->tPos >>= 8;
#line 634
      if (s->rNToGo == 0) {
#line 634
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 634
        (s->rTPos) ++;
#line 634
        if (s->rTPos == 512) {
#line 634
          s->rTPos = 0;
        }
      }
#line 634
      (s->rNToGo) --;
#line 635
      if (s->rNToGo == 1) {
#line 635
        tmp___1 = 1;
      } else {
#line 635
        tmp___1 = 0;
      }
#line 635
      k1 = (UChar )((int )k1 ^ tmp___1);
#line 635
      (s->nblock_used) ++;
#line 636
      if (s->nblock_used == s->save_nblock + 1) {
#line 636
        continue;
      }
#line 637
      if ((int )k1 != s->k0) {
#line 637
        s->k0 = (Int32 )k1;
#line 637
        continue;
      }
#line 639
      s->tPos = *(s->tt + s->tPos);
#line 639
      k1 = (UChar )(s->tPos & 255U);
#line 639
      s->tPos >>= 8;
#line 639
      if (s->rNToGo == 0) {
#line 639
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 639
        (s->rTPos) ++;
#line 639
        if (s->rTPos == 512) {
#line 639
          s->rTPos = 0;
        }
      }
#line 639
      (s->rNToGo) --;
#line 640
      if (s->rNToGo == 1) {
#line 640
        tmp___2 = 1;
      } else {
#line 640
        tmp___2 = 0;
      }
#line 640
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 640
      (s->nblock_used) ++;
#line 641
      s->state_out_len = (Int32 )k1 + 4;
#line 642
      s->tPos = *(s->tt + s->tPos);
#line 642
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 642
      s->tPos >>= 8;
#line 642
      if (s->rNToGo == 0) {
#line 642
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 642
        (s->rTPos) ++;
#line 642
        if (s->rTPos == 512) {
#line 642
          s->rTPos = 0;
        }
      }
#line 642
      (s->rNToGo) --;
#line 643
      if (s->rNToGo == 1) {
#line 643
        tmp___3 = 1;
      } else {
#line 643
        tmp___3 = 0;
      }
#line 643
      s->k0 ^= tmp___3;
#line 643
      (s->nblock_used) ++;
    }
  } else {
#line 649
    c_calculatedBlockCRC = s->calculatedBlockCRC;
#line 650
    c_state_out_ch = s->state_out_ch;
#line 651
    c_state_out_len = s->state_out_len;
#line 652
    c_nblock_used = s->nblock_used;
#line 653
    c_k0 = s->k0;
#line 654
    c_tt = s->tt;
#line 655
    c_tPos = s->tPos;
#line 656
    cs_next_out = (s->strm)->next_out;
#line 657
    cs_avail_out = (s->strm)->avail_out;
#line 660
    avail_out_INIT = cs_avail_out;
#line 661
    s_save_nblockPP = s->save_nblock + 1;
#line 664
    while (1) {
#line 667
      if (c_state_out_len > 0) {
#line 668
        while (1) {
#line 669
          if (cs_avail_out == 0U) {
#line 669
            goto return_notr;
          }
#line 670
          if (c_state_out_len == 1) {
#line 670
            break;
          }
#line 671
          *((UChar *)cs_next_out) = c_state_out_ch;
#line 672
          c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 673
          c_state_out_len --;
#line 674
          cs_next_out ++;
#line 675
          cs_avail_out --;
        }
        s_state_out_len_eq_one: 
#line 679
        if (cs_avail_out == 0U) {
#line 680
          c_state_out_len = 1;
#line 680
          goto return_notr;
        }
#line 682
        *((UChar *)cs_next_out) = c_state_out_ch;
#line 683
        c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ (unsigned int )c_state_out_ch];
#line 684
        cs_next_out ++;
#line 685
        cs_avail_out --;
      }
#line 689
      if (c_nblock_used > s_save_nblockPP) {
#line 690
        return ((Bool )1);
      }
#line 693
      if (c_nblock_used == s_save_nblockPP) {
#line 694
        c_state_out_len = 0;
#line 694
        goto return_notr;
      }
#line 696
      c_state_out_ch = (UChar )c_k0;
#line 697
      c_tPos = *(c_tt + c_tPos);
#line 697
      k1 = (UChar )(c_tPos & 255U);
#line 697
      c_tPos >>= 8;
#line 697
      c_nblock_used ++;
#line 698
      if ((int )k1 != c_k0) {
#line 699
        c_k0 = (Int32 )k1;
#line 699
        goto s_state_out_len_eq_one;
      }
#line 701
      if (c_nblock_used == s_save_nblockPP) {
#line 702
        goto s_state_out_len_eq_one;
      }
#line 704
      c_state_out_len = 2;
#line 705
      c_tPos = *(c_tt + c_tPos);
#line 705
      k1 = (UChar )(c_tPos & 255U);
#line 705
      c_tPos >>= 8;
#line 705
      c_nblock_used ++;
#line 706
      if (c_nblock_used == s_save_nblockPP) {
#line 706
        continue;
      }
#line 707
      if ((int )k1 != c_k0) {
#line 707
        c_k0 = (Int32 )k1;
#line 707
        continue;
      }
#line 709
      c_state_out_len = 3;
#line 710
      c_tPos = *(c_tt + c_tPos);
#line 710
      k1 = (UChar )(c_tPos & 255U);
#line 710
      c_tPos >>= 8;
#line 710
      c_nblock_used ++;
#line 711
      if (c_nblock_used == s_save_nblockPP) {
#line 711
        continue;
      }
#line 712
      if ((int )k1 != c_k0) {
#line 712
        c_k0 = (Int32 )k1;
#line 712
        continue;
      }
#line 714
      c_tPos = *(c_tt + c_tPos);
#line 714
      k1 = (UChar )(c_tPos & 255U);
#line 714
      c_tPos >>= 8;
#line 714
      c_nblock_used ++;
#line 715
      c_state_out_len = (Int32 )k1 + 4;
#line 716
      c_tPos = *(c_tt + c_tPos);
#line 716
      c_k0 = (Int32 )((UChar )(c_tPos & 255U));
#line 716
      c_tPos >>= 8;
#line 716
      c_nblock_used ++;
    }
    return_notr: 
#line 720
    total_out_lo32_old = (s->strm)->total_out_lo32;
#line 721
    (s->strm)->total_out_lo32 += avail_out_INIT - cs_avail_out;
#line 722
    if ((s->strm)->total_out_lo32 < total_out_lo32_old) {
#line 723
      ((s->strm)->total_out_hi32) ++;
    }
#line 726
    s->calculatedBlockCRC = c_calculatedBlockCRC;
#line 727
    s->state_out_ch = c_state_out_ch;
#line 728
    s->state_out_len = c_state_out_len;
#line 729
    s->nblock_used = c_nblock_used;
#line 730
    s->k0 = c_k0;
#line 731
    s->tt = c_tt;
#line 732
    s->tPos = c_tPos;
#line 733
    (s->strm)->next_out = cs_next_out;
#line 734
    (s->strm)->avail_out = cs_avail_out;
  }
#line 737
  return ((Bool )0);
}
}
#line 743 "bzlib.c"
Int32 BZ2_indexIntoF(Int32 indx , Int32 *cftab ) 
{ 
  Int32 nb ;
  Int32 na ;
  Int32 mid ;

  {
#line 746
  nb = 0;
#line 747
  na = 256;
#line 748
  while (1) {
#line 749
    mid = (nb + na) >> 1;
#line 750
    if (indx >= *(cftab + mid)) {
#line 750
      nb = mid;
    } else {
#line 750
      na = mid;
    }
#line 748
    if (! (na - nb != 1)) {
#line 748
      break;
    }
  }
#line 753
  return (nb);
}
}
#line 761 "bzlib.c"
static Bool unRLE_obuf_to_output_SMALL(DState *s ) 
{ 
  UChar k1 ;
  Int32 tmp ;
  int tmp___0 ;
  Int32 tmp___1 ;
  int tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Int32 tmp___8 ;
  Int32 tmp___9 ;
  Int32 tmp___10 ;
  Int32 tmp___11 ;

  {
#line 766
  if (s->blockRandomised) {
#line 768
    while (1) {
#line 770
      while (1) {
#line 771
        if ((s->strm)->avail_out == 0U) {
#line 771
          return ((Bool )0);
        }
#line 772
        if (s->state_out_len == 0) {
#line 772
          break;
        }
#line 773
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 774
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 775
        (s->state_out_len) --;
#line 776
        ((s->strm)->next_out) ++;
#line 777
        ((s->strm)->avail_out) --;
#line 778
        ((s->strm)->total_out_lo32) ++;
#line 779
        if ((s->strm)->total_out_lo32 == 0U) {
#line 779
          ((s->strm)->total_out_hi32) ++;
        }
      }
#line 783
      if (s->nblock_used == s->save_nblock + 1) {
#line 783
        return ((Bool )0);
      }
#line 786
      if (s->nblock_used > s->save_nblock + 1) {
#line 787
        return ((Bool )1);
      }
#line 789
      s->state_out_len = 1;
#line 790
      s->state_out_ch = (UChar )s->k0;
#line 791
      tmp = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 791
      k1 = (UChar )tmp;
#line 791
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 791
      if (s->rNToGo == 0) {
#line 791
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 791
        (s->rTPos) ++;
#line 791
        if (s->rTPos == 512) {
#line 791
          s->rTPos = 0;
        }
      }
#line 791
      (s->rNToGo) --;
#line 792
      if (s->rNToGo == 1) {
#line 792
        tmp___0 = 1;
      } else {
#line 792
        tmp___0 = 0;
      }
#line 792
      k1 = (UChar )((int )k1 ^ tmp___0);
#line 792
      (s->nblock_used) ++;
#line 793
      if (s->nblock_used == s->save_nblock + 1) {
#line 793
        continue;
      }
#line 794
      if ((int )k1 != s->k0) {
#line 794
        s->k0 = (Int32 )k1;
#line 794
        continue;
      }
#line 796
      s->state_out_len = 2;
#line 797
      tmp___1 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 797
      k1 = (UChar )tmp___1;
#line 797
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 797
      if (s->rNToGo == 0) {
#line 797
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 797
        (s->rTPos) ++;
#line 797
        if (s->rTPos == 512) {
#line 797
          s->rTPos = 0;
        }
      }
#line 797
      (s->rNToGo) --;
#line 798
      if (s->rNToGo == 1) {
#line 798
        tmp___2 = 1;
      } else {
#line 798
        tmp___2 = 0;
      }
#line 798
      k1 = (UChar )((int )k1 ^ tmp___2);
#line 798
      (s->nblock_used) ++;
#line 799
      if (s->nblock_used == s->save_nblock + 1) {
#line 799
        continue;
      }
#line 800
      if ((int )k1 != s->k0) {
#line 800
        s->k0 = (Int32 )k1;
#line 800
        continue;
      }
#line 802
      s->state_out_len = 3;
#line 803
      tmp___3 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 803
      k1 = (UChar )tmp___3;
#line 803
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 803
      if (s->rNToGo == 0) {
#line 803
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 803
        (s->rTPos) ++;
#line 803
        if (s->rTPos == 512) {
#line 803
          s->rTPos = 0;
        }
      }
#line 803
      (s->rNToGo) --;
#line 804
      if (s->rNToGo == 1) {
#line 804
        tmp___4 = 1;
      } else {
#line 804
        tmp___4 = 0;
      }
#line 804
      k1 = (UChar )((int )k1 ^ tmp___4);
#line 804
      (s->nblock_used) ++;
#line 805
      if (s->nblock_used == s->save_nblock + 1) {
#line 805
        continue;
      }
#line 806
      if ((int )k1 != s->k0) {
#line 806
        s->k0 = (Int32 )k1;
#line 806
        continue;
      }
#line 808
      tmp___5 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 808
      k1 = (UChar )tmp___5;
#line 808
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 808
      if (s->rNToGo == 0) {
#line 808
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 808
        (s->rTPos) ++;
#line 808
        if (s->rTPos == 512) {
#line 808
          s->rTPos = 0;
        }
      }
#line 808
      (s->rNToGo) --;
#line 809
      if (s->rNToGo == 1) {
#line 809
        tmp___6 = 1;
      } else {
#line 809
        tmp___6 = 0;
      }
#line 809
      k1 = (UChar )((int )k1 ^ tmp___6);
#line 809
      (s->nblock_used) ++;
#line 810
      s->state_out_len = (Int32 )k1 + 4;
#line 811
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 811
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 811
      if (s->rNToGo == 0) {
#line 811
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 811
        (s->rTPos) ++;
#line 811
        if (s->rTPos == 512) {
#line 811
          s->rTPos = 0;
        }
      }
#line 811
      (s->rNToGo) --;
#line 812
      if (s->rNToGo == 1) {
#line 812
        tmp___7 = 1;
      } else {
#line 812
        tmp___7 = 0;
      }
#line 812
      s->k0 ^= tmp___7;
#line 812
      (s->nblock_used) ++;
    }
  } else {
#line 817
    while (1) {
#line 819
      while (1) {
#line 820
        if ((s->strm)->avail_out == 0U) {
#line 820
          return ((Bool )0);
        }
#line 821
        if (s->state_out_len == 0) {
#line 821
          break;
        }
#line 822
        *((UChar *)(s->strm)->next_out) = s->state_out_ch;
#line 823
        s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ (unsigned int )s->state_out_ch];
#line 824
        (s->state_out_len) --;
#line 825
        ((s->strm)->next_out) ++;
#line 826
        ((s->strm)->avail_out) --;
#line 827
        ((s->strm)->total_out_lo32) ++;
#line 828
        if ((s->strm)->total_out_lo32 == 0U) {
#line 828
          ((s->strm)->total_out_hi32) ++;
        }
      }
#line 832
      if (s->nblock_used == s->save_nblock + 1) {
#line 832
        return ((Bool )0);
      }
#line 835
      if (s->nblock_used > s->save_nblock + 1) {
#line 836
        return ((Bool )1);
      }
#line 838
      s->state_out_len = 1;
#line 839
      s->state_out_ch = (UChar )s->k0;
#line 840
      tmp___8 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 840
      k1 = (UChar )tmp___8;
#line 840
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 840
      (s->nblock_used) ++;
#line 841
      if (s->nblock_used == s->save_nblock + 1) {
#line 841
        continue;
      }
#line 842
      if ((int )k1 != s->k0) {
#line 842
        s->k0 = (Int32 )k1;
#line 842
        continue;
      }
#line 844
      s->state_out_len = 2;
#line 845
      tmp___9 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 845
      k1 = (UChar )tmp___9;
#line 845
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 845
      (s->nblock_used) ++;
#line 846
      if (s->nblock_used == s->save_nblock + 1) {
#line 846
        continue;
      }
#line 847
      if ((int )k1 != s->k0) {
#line 847
        s->k0 = (Int32 )k1;
#line 847
        continue;
      }
#line 849
      s->state_out_len = 3;
#line 850
      tmp___10 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 850
      k1 = (UChar )tmp___10;
#line 850
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 850
      (s->nblock_used) ++;
#line 851
      if (s->nblock_used == s->save_nblock + 1) {
#line 851
        continue;
      }
#line 852
      if ((int )k1 != s->k0) {
#line 852
        s->k0 = (Int32 )k1;
#line 852
        continue;
      }
#line 854
      tmp___11 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 854
      k1 = (UChar )tmp___11;
#line 854
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 854
      (s->nblock_used) ++;
#line 855
      s->state_out_len = (Int32 )k1 + 4;
#line 856
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 856
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 856
      (s->nblock_used) ++;
    }
  }
}
}
#line 864 "bzlib.c"
int BZ2_bzDecompress(bz_stream *strm ) 
{ 
  Bool corrupt ;
  DState *s ;
  Int32 r ;
  Int32 tmp ;

  {
#line 868
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 868
    return (-2);
  }
#line 869
  s = (DState *)strm->state;
#line 870
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 870
    return (-2);
  }
#line 871
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 871
    return (-2);
  }
#line 873
  while (1) {
#line 874
    if (s->state == 1) {
#line 874
      return (-1);
    }
#line 875
    if (s->state == 2) {
#line 876
      if (s->smallDecompress) {
#line 877
        corrupt = unRLE_obuf_to_output_SMALL(s);
      } else {
#line 878
        corrupt = unRLE_obuf_to_output_FAST(s);
      }
#line 879
      if (corrupt) {
#line 879
        return (-4);
      }
#line 880
      if (s->nblock_used == s->save_nblock + 1) {
#line 880
        if (s->state_out_len == 0) {
#line 881
          s->calculatedBlockCRC = ~ s->calculatedBlockCRC;
#line 882
          if (s->verbosity >= 3) {
#line 883
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" {0x%08x, 0x%08x}",
                    s->storedBlockCRC, s->calculatedBlockCRC);
          }
#line 885
          if (s->verbosity >= 2) {
#line 885
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"]");
          }
#line 886
          if (s->calculatedBlockCRC != s->storedBlockCRC) {
#line 887
            return (-4);
          }
#line 888
          s->calculatedCombinedCRC = (s->calculatedCombinedCRC << 1) | (s->calculatedCombinedCRC >> 31);
#line 891
          s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
#line 892
          s->state = 14;
        } else {
#line 894
          return (0);
        }
      } else {
#line 894
        return (0);
      }
    }
#line 897
    if (s->state >= 10) {
#line 898
      tmp = BZ2_decompress(s);
#line 898
      r = tmp;
#line 899
      if (r == 4) {
#line 900
        if (s->verbosity >= 3) {
#line 901
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    combined CRCs: stored = 0x%08x, computed = 0x%08x",
                  s->storedCombinedCRC, s->calculatedCombinedCRC);
        }
#line 903
        if (s->calculatedCombinedCRC != s->storedCombinedCRC) {
#line 904
          return (-4);
        }
#line 905
        return (r);
      }
#line 907
      if (s->state != 2) {
#line 907
        return (r);
      }
    }
  }
#line 911
  BZ2_bz__AssertH__fail(6001);
#line 913
  return (0);
}
}
#line 918 "bzlib.c"
int BZ2_bzDecompressEnd(bz_stream *strm ) 
{ 
  DState *s ;

  {
#line 921
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
#line 921
    return (-2);
  }
#line 922
  s = (DState *)strm->state;
#line 923
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 923
    return (-2);
  }
#line 924
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 924
    return (-2);
  }
#line 926
  if ((unsigned long )s->tt != (unsigned long )((void *)0)) {
#line 926
    (*(strm->bzfree))(strm->opaque, (void *)s->tt);
  }
#line 927
  if ((unsigned long )s->ll16 != (unsigned long )((void *)0)) {
#line 927
    (*(strm->bzfree))(strm->opaque, (void *)s->ll16);
  }
#line 928
  if ((unsigned long )s->ll4 != (unsigned long )((void *)0)) {
#line 928
    (*(strm->bzfree))(strm->opaque, (void *)s->ll4);
  }
#line 930
  (*(strm->bzfree))(strm->opaque, strm->state);
#line 931
  strm->state = (void *)0;
#line 933
  return (0);
}
}
#line 967 "bzlib.c"
static Bool myfeof___0(int f ) 
{ 
  Int32 c ;
  int tmp ;

  {
#line 972
  tmp = spec_getc(f);
#line 972
  c = tmp;
#line 973
  if (c == -1) {
#line 973
    return ((Bool )1);
  }
#line 974
  spec_ungetc((unsigned char )c, f);
#line 975
  return ((Bool )0);
}
}
#line 980 "bzlib.c"
BZFILE *BZ2_bzWriteOpen(int *bzerror , int f , int blockSize100k___0 , int verbosity___0 ,
                        int workFactor___0 ) 
{ 
  Int32 ret ;
  bzFile *bzf ;
  void *tmp ;

  {
#line 992
  bzf = (bzFile *)((void *)0);
#line 994
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 994
    *bzerror = 0;
  }
#line 994
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 994
    bzf->lastErr = 0;
  }
#line 996
  if (f == (int )((void *)0)) {
#line 996
    goto _L___0;
  } else
#line 996
  if (blockSize100k___0 < 1) {
#line 996
    goto _L___0;
  } else
#line 996
  if (blockSize100k___0 > 9) {
#line 996
    goto _L___0;
  } else
#line 996
  if (workFactor___0 < 0) {
#line 996
    goto _L___0;
  } else
#line 996
  if (workFactor___0 > 250) {
#line 996
    goto _L___0;
  } else
#line 996
  if (verbosity___0 < 0) {
#line 996
    goto _L___0;
  } else
#line 996
  if (verbosity___0 > 4) {
    _L___0: /* CIL Label */ 
#line 1000
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1000
      *bzerror = -2;
    }
#line 1000
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1000
      bzf->lastErr = -2;
    }
#line 1000
    return ((void *)0);
  }
#line 1005
  bzf = (bzFile*)malloc(sizeof(bzFile )); //AD
  //AD tmp = malloc(sizeof(bzFile ));
#line 1005
  //AD bzf = (bzFile *)tmp;
#line 1006
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1007
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1007
      *bzerror = -3;
    }
#line 1007
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1007
      bzf->lastErr = -3;
    }
#line 1007
    return ((void *)0);
  }
#line 1009
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1009
    *bzerror = 0;
  }
#line 1009
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1009
    bzf->lastErr = 0;
  }
#line 1010
  bzf->initialisedOk = (Bool )0;
#line 1011
  bzf->bufN = 0;
#line 1012
  bzf->handle = f;
#line 1013
  bzf->writing = (Bool )1;
#line 1014
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1015
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1016
  bzf->strm.opaque = (void *)0;
#line 1018
  if (workFactor___0 == 0) {
#line 1018
    workFactor___0 = 30;
  }
#line 1019
  ret = BZ2_bzCompressInit(& bzf->strm, blockSize100k___0, verbosity___0, workFactor___0);
#line 1021
  if (ret != 0) {
#line 1022
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1022
      *bzerror = ret;
    }
#line 1022
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1022
      bzf->lastErr = ret;
    }
#line 1022
    free((void *)bzf);
#line 1022
    return ((void *)0);
  }
#line 1024
  bzf->strm.avail_in = 0U;
#line 1025
  bzf->initialisedOk = (Bool )1;
#line 1026
  return ((BZFILE *)bzf);
}
}
#line 1032 "bzlib.c"
void BZ2_bzWrite(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;

  {
#line 1039
  bzf = (bzFile *)b;
#line 1041
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1041
    *bzerror = 0;
  }
#line 1041
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1041
    bzf->lastErr = 0;
  }
#line 1042
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1042
    goto _L;
  } else
#line 1042
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1042
    goto _L;
  } else
#line 1042
  if (len < 0) {
    _L: /* CIL Label */ 
#line 1043
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1043
      *bzerror = -2;
    }
#line 1043
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1043
      bzf->lastErr = -2;
    }
#line 1043
    return;
  }
#line 1044
  if (! bzf->writing) {
#line 1045
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1045
      *bzerror = -1;
    }
#line 1045
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1045
      bzf->lastErr = -1;
    }
#line 1045
    return;
  }
#line 1049
  if (len == 0) {
#line 1050
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1050
      *bzerror = 0;
    }
#line 1050
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1050
      bzf->lastErr = 0;
    }
#line 1050
    return;
  }
#line 1052
  bzf->strm.avail_in = (unsigned int )len;
#line 1053
  bzf->strm.next_in = (char *)buf;
#line 1055
  while (1) {
#line 1056
    bzf->strm.avail_out = 5000U;
#line 1057
    bzf->strm.next_out = bzf->buf;
#line 1058
    ret = BZ2_bzCompress(& bzf->strm, 0);
#line 1059
    if (ret != 1) {
#line 1060
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1060
        *bzerror = ret;
      }
#line 1060
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1060
        bzf->lastErr = ret;
      }
#line 1060
      return;
    }
#line 1062
    if (bzf->strm.avail_out < 5000U) {
#line 1063
      n = (Int32 )(5000U - bzf->strm.avail_out);
#line 1064
      n2 = spec_fwrite((unsigned char *)((void *)(bzf->buf)), (int )sizeof(UChar ),
                       n, bzf->handle);
#line 1066
      if (n != n2) {
#line 1066
        goto _L___0;
      } else
#line 1066
      if (0) {
        _L___0: /* CIL Label */ 
#line 1067
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1067
          *bzerror = -6;
        }
#line 1067
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1067
          bzf->lastErr = -6;
        }
#line 1067
        return;
      }
    }
#line 1070
    if (bzf->strm.avail_in == 0U) {
#line 1071
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1071
        *bzerror = 0;
      }
#line 1071
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1071
        bzf->lastErr = 0;
      }
#line 1071
      return;
    }
  }
}
}
#line 1077 "bzlib.c"
void BZ2_bzWriteClose(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in ,
                      unsigned int *nbytes_out ) 
{ 


  {
#line 1084
  BZ2_bzWriteClose64(bzerror, b, abandon, nbytes_in, (unsigned int *)((void *)0),
                     nbytes_out, (unsigned int *)((void *)0));
#line 1086
  return;
}
}
#line 1089 "bzlib.c"
void BZ2_bzWriteClose64(int *bzerror , BZFILE *b , int abandon , unsigned int *nbytes_in_lo32 ,
                        unsigned int *nbytes_in_hi32 , unsigned int *nbytes_out_lo32 ,
                        unsigned int *nbytes_out_hi32 ) 
{ 
  Int32 n ;
  Int32 n2 ;
  Int32 ret ;
  bzFile *bzf ;
  int tmp ;

  {
#line 1099
  bzf = (bzFile *)b;
#line 1101
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1102
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1102
      *bzerror = 0;
    }
#line 1102
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1102
      bzf->lastErr = 0;
    }
#line 1102
    return;
  }
#line 1103
  if (! bzf->writing) {
#line 1104
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1104
      *bzerror = -1;
    }
#line 1104
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1104
      bzf->lastErr = -1;
    }
#line 1104
    return;
  }
#line 1108
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
#line 1108
    *nbytes_in_lo32 = 0U;
  }
#line 1109
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
#line 1109
    *nbytes_in_hi32 = 0U;
  }
#line 1110
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
#line 1110
    *nbytes_out_lo32 = 0U;
  }
#line 1111
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
#line 1111
    *nbytes_out_hi32 = 0U;
  }
#line 1113
  if (! abandon) {
#line 1113
    if (bzf->lastErr == 0) {
#line 1114
      while (1) {
#line 1115
        bzf->strm.avail_out = 5000U;
#line 1116
        bzf->strm.next_out = bzf->buf;
#line 1117
        ret = BZ2_bzCompress(& bzf->strm, 2);
#line 1118
        if (ret != 3) {
#line 1118
          if (ret != 4) {
#line 1119
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1119
              *bzerror = ret;
            }
#line 1119
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1119
              bzf->lastErr = ret;
            }
#line 1119
            return;
          }
        }
#line 1121
        if (bzf->strm.avail_out < 5000U) {
#line 1122
          n = (Int32 )(5000U - bzf->strm.avail_out);
#line 1123
          n2 = spec_fwrite((unsigned char *)((void *)(bzf->buf)), (int )sizeof(UChar ),
                           n, bzf->handle);
#line 1125
          if (n != n2) {
#line 1125
            goto _L;
          } else
#line 1125
          if (0) {
            _L: /* CIL Label */ 
#line 1126
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1126
              *bzerror = -6;
            }
#line 1126
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1126
              bzf->lastErr = -6;
            }
#line 1126
            return;
          }
        }
#line 1129
        if (ret == 4) {
#line 1129
          break;
        }
      }
    }
  }
#line 1133
  if (! abandon) {
#line 1133
    tmp = 1;
  } else {
#line 1133
    tmp = 0;
  }
#line 1139
  if ((unsigned long )nbytes_in_lo32 != (unsigned long )((void *)0)) {
#line 1140
    *nbytes_in_lo32 = bzf->strm.total_in_lo32;
  }
#line 1141
  if ((unsigned long )nbytes_in_hi32 != (unsigned long )((void *)0)) {
#line 1142
    *nbytes_in_hi32 = bzf->strm.total_in_hi32;
  }
#line 1143
  if ((unsigned long )nbytes_out_lo32 != (unsigned long )((void *)0)) {
#line 1144
    *nbytes_out_lo32 = bzf->strm.total_out_lo32;
  }
#line 1145
  if ((unsigned long )nbytes_out_hi32 != (unsigned long )((void *)0)) {
#line 1146
    *nbytes_out_hi32 = bzf->strm.total_out_hi32;
  }
#line 1148
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1148
    *bzerror = 0;
  }
#line 1148
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1148
    bzf->lastErr = 0;
  }
#line 1149
  BZ2_bzCompressEnd(& bzf->strm);
#line 1150
  free((void *)bzf);
#line 1151
  return;
}
}
#line 1155 "bzlib.c"
BZFILE *BZ2_bzReadOpen(int *bzerror , int f , int verbosity___0 , int small , void *unused ,
                       int nUnused ) 
{ 
  bzFile *bzf ;
  int ret ;
  void *tmp ;

  {
#line 1167
  bzf = (bzFile *)((void *)0);
#line 1170
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1170
    *bzerror = 0;
  }
#line 1170
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1170
    bzf->lastErr = 0;
  }
#line 1172
  if (f == (int )((void *)0)) {
#line 1172
    goto _L___0;
  } else
#line 1172
  if (small != 0) {
#line 1172
    if (small != 1) {
#line 1172
      goto _L___0;
    } else {
#line 1172
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1172
  if (verbosity___0 < 0) {
#line 1172
    goto _L___0;
  } else
#line 1172
  if (verbosity___0 > 4) {
#line 1172
    goto _L___0;
  } else
#line 1172
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
#line 1172
    if (nUnused != 0) {
#line 1172
      goto _L___0;
    } else {
#line 1172
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1172
  if ((unsigned long )unused != (unsigned long )((void *)0)) {
#line 1172
    if (nUnused < 0) {
#line 1172
      goto _L___0;
    } else
#line 1172
    if (nUnused > 5000) {
      _L___0: /* CIL Label */ 
#line 1177
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1177
        *bzerror = -2;
      }
#line 1177
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1177
        bzf->lastErr = -2;
      }
#line 1177
      return ((void *)0);
    }
  }
#line 1182
  bzf = (bzFile*)malloc(sizeof(bzFile )); //AD
  //AD tmp = malloc(sizeof(bzFile ));
#line 1182
  //AD bzf = (bzFile *)tmp;
#line 1183
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1184
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1184
      *bzerror = -3;
    }
#line 1184
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1184
      bzf->lastErr = -3;
    }
#line 1184
    return ((void *)0);
  }
#line 1186
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1186
    *bzerror = 0;
  }
#line 1186
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1186
    bzf->lastErr = 0;
  }
#line 1188
  bzf->initialisedOk = (Bool )0;
#line 1189
  bzf->handle = f;
#line 1190
  bzf->bufN = 0;
#line 1191
  bzf->writing = (Bool )0;
#line 1192
  bzf->strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1193
  bzf->strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1194
  bzf->strm.opaque = (void *)0;
#line 1196
  while (nUnused > 0) {
#line 1197
    bzf->buf[bzf->bufN] = (Char )*((UChar *)unused);
#line 1197
    (bzf->bufN) ++;
#line 1198
    unused = (void *)((UChar *)unused + 1);
#line 1199
    nUnused --;
  }
#line 1202
  ret = BZ2_bzDecompressInit(& bzf->strm, verbosity___0, small);
#line 1203
  if (ret != 0) {
#line 1204
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1204
      *bzerror = ret;
    }
#line 1204
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1204
      bzf->lastErr = ret;
    }
#line 1204
    free((void *)bzf);
#line 1204
    return ((void *)0);
  }
#line 1206
  bzf->strm.avail_in = (unsigned int )bzf->bufN;
#line 1207
  bzf->strm.next_in = bzf->buf;
#line 1209
  bzf->initialisedOk = (Bool )1;
#line 1210
  return ((BZFILE *)bzf);
}
}
#line 1215 "bzlib.c"
void BZ2_bzReadClose(int *bzerror , BZFILE *b ) 
{ 
  bzFile *bzf ;

  {
#line 1217
  bzf = (bzFile *)b;
#line 1219
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1219
    *bzerror = 0;
  }
#line 1219
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1219
    bzf->lastErr = 0;
  }
#line 1220
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1221
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1221
      *bzerror = 0;
    }
#line 1221
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1221
      bzf->lastErr = 0;
    }
#line 1221
    return;
  }
#line 1223
  if (bzf->writing) {
#line 1224
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1224
      *bzerror = -1;
    }
#line 1224
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1224
      bzf->lastErr = -1;
    }
#line 1224
    return;
  }
#line 1226
  if (bzf->initialisedOk) {
#line 1227
    BZ2_bzDecompressEnd(& bzf->strm);
  }
#line 1228
  free((void *)bzf);
#line 1229
  return;
}
}
#line 1233 "bzlib.c"
int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) 
{ 
  Int32 n ;
  Int32 ret ;
  bzFile *bzf ;
  Bool tmp ;
  Bool tmp___0 ;

  {
#line 1240
  bzf = (bzFile *)b;
#line 1242
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1242
    *bzerror = 0;
  }
#line 1242
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1242
    bzf->lastErr = 0;
  }
#line 1244
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1244
    goto _L;
  } else
#line 1244
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1244
    goto _L;
  } else
#line 1244
  if (len < 0) {
    _L: /* CIL Label */ 
#line 1245
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1245
      *bzerror = -2;
    }
#line 1245
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1245
      bzf->lastErr = -2;
    }
#line 1245
    return (0);
  }
#line 1247
  if (bzf->writing) {
#line 1248
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1248
      *bzerror = -1;
    }
#line 1248
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1248
      bzf->lastErr = -1;
    }
#line 1248
    return (0);
  }
#line 1250
  if (len == 0) {
#line 1251
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1251
      *bzerror = 0;
    }
#line 1251
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1251
      bzf->lastErr = 0;
    }
#line 1251
    return (0);
  }
#line 1253
  bzf->strm.avail_out = (unsigned int )len;
#line 1254
  bzf->strm.next_out = (char *)buf;
#line 1256
  while (1) {
#line 1261
    if (bzf->strm.avail_in == 0U) {
#line 1261
      tmp = myfeof___0(bzf->handle);
#line 1261
      if (! tmp) {
#line 1262
        n = spec_fread((unsigned char *)(bzf->buf), (int )sizeof(UChar ), 5000, bzf->handle);
#line 1266
        bzf->bufN = n;
#line 1267
        bzf->strm.avail_in = (unsigned int )bzf->bufN;
#line 1268
        bzf->strm.next_in = bzf->buf;
      }
    }
#line 1271
    ret = BZ2_bzDecompress(& bzf->strm);
#line 1273
    if (ret != 0) {
#line 1273
      if (ret != 4) {
#line 1274
        if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1274
          *bzerror = ret;
        }
#line 1274
        if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1274
          bzf->lastErr = ret;
        }
#line 1274
        return (0);
      }
    }
#line 1276
    if (ret == 0) {
#line 1276
      tmp___0 = myfeof___0(bzf->handle);
#line 1276
      if (tmp___0) {
#line 1276
        if (bzf->strm.avail_in == 0U) {
#line 1276
          if (bzf->strm.avail_out > 0U) {
#line 1278
            if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1278
              *bzerror = -7;
            }
#line 1278
            if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1278
              bzf->lastErr = -7;
            }
#line 1278
            return (0);
          }
        }
      }
    }
#line 1280
    if (ret == 4) {
#line 1281
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1281
        *bzerror = 4;
      }
#line 1281
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1281
        bzf->lastErr = 4;
      }
#line 1282
      return ((int )((unsigned int )len - bzf->strm.avail_out));
    }
#line 1283
    if (bzf->strm.avail_out == 0U) {
#line 1284
      if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1284
        *bzerror = 0;
      }
#line 1284
      if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1284
        bzf->lastErr = 0;
      }
#line 1284
      return (len);
    }
  }
#line 1288
  return (0);
}
}
#line 1293 "bzlib.c"
void BZ2_bzReadGetUnused(int *bzerror , BZFILE *b , void **unused , int *nUnused ) 
{ 
  bzFile *bzf ;

  {
#line 1299
  bzf = (bzFile *)b;
#line 1300
  if ((unsigned long )bzf == (unsigned long )((void *)0)) {
#line 1301
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1301
      *bzerror = -2;
    }
#line 1301
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1301
      bzf->lastErr = -2;
    }
#line 1301
    return;
  }
#line 1302
  if (bzf->lastErr != 4) {
#line 1303
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1303
      *bzerror = -1;
    }
#line 1303
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1303
      bzf->lastErr = -1;
    }
#line 1303
    return;
  }
#line 1304
  if ((unsigned long )unused == (unsigned long )((void *)0)) {
#line 1304
    goto _L;
  } else
#line 1304
  if ((unsigned long )nUnused == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1305
    if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1305
      *bzerror = -2;
    }
#line 1305
    if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1305
      bzf->lastErr = -2;
    }
#line 1305
    return;
  }
#line 1307
  if ((unsigned long )bzerror != (unsigned long )((void *)0)) {
#line 1307
    *bzerror = 0;
  }
#line 1307
  if ((unsigned long )bzf != (unsigned long )((void *)0)) {
#line 1307
    bzf->lastErr = 0;
  }
#line 1308
  *nUnused = (int )bzf->strm.avail_in;
#line 1309
  *unused = (void *)bzf->strm.next_in;
#line 1310
  return;
}
}
#line 1319 "bzlib.c"
int BZ2_bzBuffToBuffCompress(char *dest , unsigned int *destLen , char *source , unsigned int sourceLen ,
                             int blockSize100k___0 , int verbosity___0 , int workFactor___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
#line 1331
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1336
    return (-2);
  } else
#line 1331
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
#line 1336
    return (-2);
  } else
#line 1331
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 1336
    return (-2);
  } else
#line 1331
  if (blockSize100k___0 < 1) {
#line 1336
    return (-2);
  } else
#line 1331
  if (blockSize100k___0 > 9) {
#line 1336
    return (-2);
  } else
#line 1331
  if (verbosity___0 < 0) {
#line 1336
    return (-2);
  } else
#line 1331
  if (verbosity___0 > 4) {
#line 1336
    return (-2);
  } else
#line 1331
  if (workFactor___0 < 0) {
#line 1336
    return (-2);
  } else
#line 1331
  if (workFactor___0 > 250) {
#line 1336
    return (-2);
  }
#line 1338
  if (workFactor___0 == 0) {
#line 1338
    workFactor___0 = 30;
  }
#line 1339
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1340
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1341
  strm.opaque = (void *)0;
#line 1342
  ret = BZ2_bzCompressInit(& strm, blockSize100k___0, verbosity___0, workFactor___0);
#line 1344
  if (ret != 0) {
#line 1344
    return (ret);
  }
#line 1346
  strm.next_in = source;
#line 1347
  strm.next_out = dest;
#line 1348
  strm.avail_in = sourceLen;
#line 1349
  strm.avail_out = *destLen;
#line 1351
  ret = BZ2_bzCompress(& strm, 2);
#line 1352
  if (ret == 3) {
#line 1352
    goto output_overflow;
  }
#line 1353
  if (ret != 4) {
#line 1353
    goto errhandler;
  }
#line 1356
  *destLen -= strm.avail_out;
#line 1357
  BZ2_bzCompressEnd(& strm);
#line 1358
  return (0);
  output_overflow: 
#line 1361
  BZ2_bzCompressEnd(& strm);
#line 1362
  return (-8);
  errhandler: 
#line 1365
  BZ2_bzCompressEnd(& strm);
#line 1366
  return (ret);
}
}
#line 1371 "bzlib.c"
int BZ2_bzBuffToBuffDecompress(char *dest , unsigned int *destLen , char *source ,
                               unsigned int sourceLen , int small , int verbosity___0 ) 
{ 
  bz_stream strm ;
  int ret ;

  {
#line 1382
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1386
    return (-2);
  } else
#line 1382
  if ((unsigned long )destLen == (unsigned long )((void *)0)) {
#line 1386
    return (-2);
  } else
#line 1382
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 1386
    return (-2);
  } else
#line 1382
  if (small != 0) {
#line 1382
    if (small != 1) {
#line 1386
      return (-2);
    } else {
#line 1382
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1382
  if (verbosity___0 < 0) {
#line 1386
    return (-2);
  } else
#line 1382
  if (verbosity___0 > 4) {
#line 1386
    return (-2);
  }
#line 1388
  strm.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
#line 1389
  strm.bzfree = (void (*)(void * , void * ))((void *)0);
#line 1390
  strm.opaque = (void *)0;
#line 1391
  ret = BZ2_bzDecompressInit(& strm, verbosity___0, small);
#line 1392
  if (ret != 0) {
#line 1392
    return (ret);
  }
#line 1394
  strm.next_in = source;
#line 1395
  strm.next_out = dest;
#line 1396
  strm.avail_in = sourceLen;
#line 1397
  strm.avail_out = *destLen;
#line 1399
  ret = BZ2_bzDecompress(& strm);
#line 1400
  if (ret == 0) {
#line 1400
    goto output_overflow_or_eof;
  }
#line 1401
  if (ret != 4) {
#line 1401
    goto errhandler;
  }
#line 1404
  *destLen -= strm.avail_out;
#line 1405
  BZ2_bzDecompressEnd(& strm);
#line 1406
  return (0);
  output_overflow_or_eof: 
#line 1409
  if (strm.avail_out > 0U) {
#line 1410
    BZ2_bzDecompressEnd(& strm);
#line 1411
    return (-7);
  } else {
#line 1413
    BZ2_bzDecompressEnd(& strm);
#line 1414
    return (-8);
  }
  errhandler: 
#line 1418
  BZ2_bzDecompressEnd(& strm);
#line 1419
  return (ret);
}
}
#line 1439 "bzlib.c"
char const   *BZ2_bzlibVersion(void) 
{ 


  {
#line 1441
  return ("1.0.3, 15-Feb-2005");
}
}
#line 1457 "bzlib.c"
static BZFILE *bzopen_or_bzdopen(char const   *path , int fd , char const   *mode ,
                                 int open_mode ) 
{ 
  int bzerr ;
  char unused[5000] ;
  int blockSize100k___0 ;
  int writing ;
  char mode2[10] ;
  unsigned int tmp ;
  int fp ;
  BZFILE *bzfp ;
  int verbosity___0 ;
  int workFactor___0 ;
  int smallMode___0 ;
  int nUnused ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1466
  blockSize100k___0 = 9;
#line 1467
  writing = 0;
#line 1468
  mode2[0] = (char )'\000';
#line 1468
  tmp = 1U;
#line 1468
  while (! (tmp >= 10U)) {
#line 1468
    mode2[tmp] = (char)0;
#line 1468
    tmp ++;
  }
#line 1470
  fp = 0;
#line 1474
  bzfp = (void *)0;
#line 1475
  verbosity___0 = 0;
#line 1476
  workFactor___0 = 30;
#line 1477
  smallMode___0 = 0;
#line 1478
  nUnused = 0;
#line 1480
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
#line 1480
    return ((void *)0);
  }
#line 1481
  while (*mode) {
#line 1482
    switch ((int const   )*mode) {
    case 114: 
#line 1484
    writing = 0;
#line 1484
    break;
    case 119: 
#line 1486
    writing = 1;
#line 1486
    break;
    case 115: 
#line 1488
    smallMode___0 = 1;
#line 1488
    break;
    default: 
#line 1490
    tmp___0 = __ctype_b_loc();
#line 1490
    if ((int const   )*(*tmp___0 + (int )*mode) & 2048) {
#line 1491
      blockSize100k___0 = (int )((int const   )*mode - 48);
    }
    }
#line 1494
    mode ++;
  }
#line 1496
  if (writing) {
#line 1496
    tmp___1 = "w";
  } else {
#line 1496
    tmp___1 = "r";
  }
#line 1496
  strcat((char * __restrict  )(mode2), (char const   * __restrict  )tmp___1);
#line 1497
  strcat((char * __restrict  )(mode2), (char const   * __restrict  )"b");
#line 1499
  if (open_mode == 0) {
#line 1500
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1500
      goto _L;
    } else {
#line 1500
      tmp___2 = strcmp(path, "");
#line 1500
      if (tmp___2 == 0) {
        _L: /* CIL Label */ 
#line 1502
        if (writing) {
#line 1502
          fp = 1;
        } else {
#line 1502
          fp = 0;
        }
      } else {
#line 1508
        fp = 0;
      }
    }
  } else {
#line 1512
    fp = (int )((void *)0);
  }
#line 1521
  if (fp == (int )((void *)0)) {
#line 1521
    return ((void *)0);
  }
#line 1523
  if (writing) {
#line 1525
    if (blockSize100k___0 < 1) {
#line 1525
      blockSize100k___0 = 1;
    }
#line 1526
    if (blockSize100k___0 > 9) {
#line 1526
      blockSize100k___0 = 9;
    }
#line 1527
    bzfp = BZ2_bzWriteOpen(& bzerr, fp, blockSize100k___0, verbosity___0, workFactor___0);
  } else {
#line 1530
    bzfp = BZ2_bzReadOpen(& bzerr, fp, verbosity___0, smallMode___0, (void *)(unused),
                          nUnused);
  }
#line 1533
  if ((unsigned long )bzfp == (unsigned long )((void *)0)) {
#line 1535
    if (fp != 0) {
#line 1535
      if (fp != 1) {
#line 1535
        tmp___3 = 1;
      } else {
#line 1535
        tmp___3 = 0;
      }
    } else {
#line 1535
      tmp___3 = 0;
    }
#line 1539
    return ((void *)0);
  }
#line 1541
  return (bzfp);
}
}
#line 1551 "bzlib.c"
BZFILE *BZ2_bzopen(char const   *path , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
#line 1555
  tmp = bzopen_or_bzdopen(path, -1, mode, 0);
#line 1555
  return (tmp);
}
}
#line 1560 "bzlib.c"
BZFILE *BZ2_bzdopen(int fd , char const   *mode ) 
{ 
  BZFILE *tmp ;

  {
#line 1564
  tmp = bzopen_or_bzdopen((char const   *)((void *)0), fd, mode, 1);
#line 1564
  return (tmp);
}
}
#line 1569 "bzlib.c"
int BZ2_bzread(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;
  int nread ;

  {
#line 1572
  if (((bzFile *)b)->lastErr == 4) {
#line 1572
    return (0);
  }
#line 1573
  nread = BZ2_bzRead(& bzerr, b, buf, len);
#line 1574
  if (bzerr == 0) {
#line 1575
    return (nread);
  } else
#line 1574
  if (bzerr == 4) {
#line 1575
    return (nread);
  } else {
#line 1577
    return (-1);
  }
}
}
#line 1583 "bzlib.c"
int BZ2_bzwrite(BZFILE *b , void *buf , int len ) 
{ 
  int bzerr ;

  {
#line 1587
  BZ2_bzWrite(& bzerr, b, buf, len);
#line 1588
  if (bzerr == 0) {
#line 1589
    return (len);
  } else {
#line 1591
    return (-1);
  }
}
}
#line 1597 "bzlib.c"
int BZ2_bzflush(BZFILE *b ) 
{ 


  {
#line 1600
  return (0);
}
}
#line 1605 "bzlib.c"
void BZ2_bzclose(BZFILE *b ) 
{ 
  int bzerr ;
  int fp ;
  int tmp ;

  {
#line 1609
  fp = ((bzFile *)b)->handle;
#line 1614
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1614
    return;
  }
#line 1615
  if (((bzFile *)b)->writing) {
#line 1616
    BZ2_bzWriteClose(& bzerr, b, 0, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
#line 1617
    if (bzerr != 0) {
#line 1618
      BZ2_bzWriteClose((int *)((void *)0), b, 1, (unsigned int *)((void *)0), (unsigned int *)((void *)0));
    }
  } else {
#line 1621
    BZ2_bzReadClose(& bzerr, b);
  }
#line 1624
  if (fp != 0) {
#line 1624
    if (fp != 1) {
#line 1624
      tmp = 1;
    } else {
#line 1624
      tmp = 0;
    }
  } else {
#line 1624
    tmp = 0;
  }
#line 1630
  return;
}
}
#line 1637 "bzlib.c"
static char *bzerrorstrings[16]  = 
#line 1637
  {      (char *)"OK",      (char *)"SEQUENCE_ERROR",      (char *)"PARAM_ERROR",      (char *)"MEM_ERROR", 
        (char *)"DATA_ERROR",      (char *)"DATA_ERROR_MAGIC",      (char *)"IO_ERROR",      (char *)"UNEXPECTED_EOF", 
        (char *)"OUTBUFF_FULL",      (char *)"CONFIG_ERROR",      (char *)"???",      (char *)"???", 
        (char *)"???",      (char *)"???",      (char *)"???",      (char *)"???"};
#line 1657 "bzlib.c"
char const   *BZ2_bzerror(BZFILE *b , int *errnum ) 
{ 
  int err ;

  {
#line 1659
  err = ((bzFile *)b)->lastErr;
#line 1661
  if (err > 0) {
#line 1661
    err = 0;
  }
#line 1662
  *errnum = err;
#line 1663
  return ((char const   *)bzerrorstrings[err * -1]);
}
}
#line 1 "compress.o"
#pragma merger("0","/tmp/cil-5nkdDWbu.i","")
#line 312 "./bzlib_private.h"
void BZ2_bsInitWrite(EState *s ) ;
#line 315
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) ;
#line 318
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) ;
#line 81 "compress.c"
void BZ2_bsInitWrite(EState *s ) 
{ 


  {
#line 83
  s->bsLive = 0;
#line 84
  s->bsBuff = (UInt32 )0;
#line 85
  return;
}
}
#line 89 "compress.c"
static void bsFinishWrite(EState *s ) 
{ 


  {
#line 92
  while (s->bsLive > 0) {
#line 93
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
#line 94
    (s->numZ) ++;
#line 95
    s->bsBuff <<= 8;
#line 96
    s->bsLive -= 8;
  }
#line 98
  return;
}
}
#line 115 "compress.c"
static void bsW(EState *s , Int32 n , UInt32 v ) 
{ 


  {
#line 119
  while (s->bsLive >= 8) {
#line 119
    *(s->zbits + s->numZ) = (UChar )(s->bsBuff >> 24);
#line 119
    (s->numZ) ++;
#line 119
    s->bsBuff <<= 8;
#line 119
    s->bsLive -= 8;
  }
#line 120
  s->bsBuff |= v << ((32 - s->bsLive) - n);
#line 121
  s->bsLive += n;
#line 122
  return;
}
}
#line 126 "compress.c"
static void bsPutUInt32(EState *s , UInt32 u ) 
{ 


  {
#line 129
  bsW(s, 8, (UInt32 )((long )(u >> 24) & 255L));
#line 130
  bsW(s, 8, (UInt32 )((long )(u >> 16) & 255L));
#line 131
  bsW(s, 8, (UInt32 )((long )(u >> 8) & 255L));
#line 132
  bsW(s, 8, (UInt32 )((long )u & 255L));
#line 133
  return;
}
}
#line 137 "compress.c"
static void bsPutUChar(EState *s , UChar c ) 
{ 


  {
#line 140
  bsW(s, 8, (UInt32 )c);
#line 141
  return;
}
}
#line 149 "compress.c"
static void makeMaps_e(EState *s ) 
{ 
  Int32 i ;

  {
#line 153
  s->nInUse = 0;
#line 154
  i = 0;
#line 154
  while (i < 256) {
#line 155
    if (s->inUse[i]) {
#line 156
      s->unseqToSeq[i] = (UChar )s->nInUse;
#line 157
      (s->nInUse) ++;
    }
#line 154
    i ++;
  }
#line 159
  return;
}
}
#line 163 "compress.c"
static void generateMTFValues(EState *s ) 
{ 
  UChar yy[256] ;
  Int32 i ;
  Int32 j ;
  Int32 zPend ;
  Int32 wr ;
  Int32 EOB ;
  UInt32 *ptr ;
  UChar *block ;
  UInt16 *mtfv ;
  UChar ll_i ;
  register UChar rtmp ;
  register UChar *ryy_j ;
  register UChar rll_i ;
  register UChar rtmp2 ;

  {
#line 194
  ptr = s->ptr;
#line 195
  block = s->block;
#line 196
  mtfv = s->mtfv;
#line 198
  makeMaps_e(s);
#line 199
  EOB = s->nInUse + 1;
#line 201
  i = 0;
#line 201
  while (i <= EOB) {
#line 201
    s->mtfFreq[i] = 0;
#line 201
    i ++;
  }
#line 203
  wr = 0;
#line 204
  zPend = 0;
#line 205
  i = 0;
#line 205
  while (i < s->nInUse) {
#line 205
    yy[i] = (UChar )i;
#line 205
    i ++;
  }
#line 207
  i = 0;
#line 207
  while (i < s->nblock) {
#line 210
    j = (Int32 )(*(ptr + i) - 1U);
#line 210
    if (j < 0) {
#line 210
      j += s->nblock;
    }
#line 211
    ll_i = s->unseqToSeq[*(block + j)];
#line 214
    if ((int )yy[0] == (int )ll_i) {
#line 215
      zPend ++;
    } else {
#line 218
      if (zPend > 0) {
#line 219
        zPend --;
#line 220
        while (1) {
#line 221
          if (zPend & 1) {
#line 222
            *(mtfv + wr) = (UInt16 )1;
#line 222
            wr ++;
#line 223
            (s->mtfFreq[1]) ++;
          } else {
#line 225
            *(mtfv + wr) = (UInt16 )0;
#line 225
            wr ++;
#line 226
            (s->mtfFreq[0]) ++;
          }
#line 228
          if (zPend < 2) {
#line 228
            break;
          }
#line 229
          zPend = (zPend - 2) / 2;
        }
#line 231
        zPend = 0;
      }
#line 237
      rtmp = yy[1];
#line 238
      yy[1] = yy[0];
#line 239
      ryy_j = & yy[1];
#line 240
      rll_i = ll_i;
#line 241
      while ((int )rll_i != (int )rtmp) {
#line 243
        ryy_j ++;
#line 244
        rtmp2 = rtmp;
#line 245
        rtmp = *ryy_j;
#line 246
        *ryy_j = rtmp2;
      }
#line 248
      yy[0] = rtmp;
#line 249
      j = (Int32 )(ryy_j - & yy[0]);
#line 250
      *(mtfv + wr) = (UInt16 )(j + 1);
#line 250
      wr ++;
#line 250
      (s->mtfFreq[j + 1]) ++;
    }
#line 207
    i ++;
  }
#line 256
  if (zPend > 0) {
#line 257
    zPend --;
#line 258
    while (1) {
#line 259
      if (zPend & 1) {
#line 260
        *(mtfv + wr) = (UInt16 )1;
#line 260
        wr ++;
#line 261
        (s->mtfFreq[1]) ++;
      } else {
#line 263
        *(mtfv + wr) = (UInt16 )0;
#line 263
        wr ++;
#line 264
        (s->mtfFreq[0]) ++;
      }
#line 266
      if (zPend < 2) {
#line 266
        break;
      }
#line 267
      zPend = (zPend - 2) / 2;
    }
#line 269
    zPend = 0;
  }
#line 272
  *(mtfv + wr) = (UInt16 )EOB;
#line 272
  wr ++;
#line 272
  (s->mtfFreq[EOB]) ++;
#line 274
  s->nMTF = wr;
#line 275
  return;
}
}
#line 282 "compress.c"
static void sendMTFValues(EState *s ) 
{ 
  Int32 v ;
  Int32 t ;
  Int32 i ;
  Int32 j ;
  Int32 gs ;
  Int32 ge ;
  Int32 totc ;
  Int32 bt ;
  Int32 bc ;
  Int32 iter ;
  Int32 nSelectors ;
  Int32 alphaSize ;
  Int32 minLen ;
  Int32 maxLen ;
  Int32 selCtr ;
  Int32 nGroups ;
  Int32 nBytes ;
  UInt16 cost[6] ;
  Int32 fave[6] ;
  UInt16 *mtfv ;
  Int32 nPart ;
  Int32 remF ;
  Int32 tFreq ;
  Int32 aFreq ;
  register UInt32 cost01 ;
  register UInt32 cost23 ;
  register UInt32 cost45 ;
  register UInt16 icv ;
  UInt16 icv___0 ;
  UChar pos[6] ;
  UChar ll_i ;
  UChar tmp2 ;
  UChar tmp ;
  Bool inUse16[16] ;
  Int32 curr ;
  UInt16 mtfv_i ;
  UChar *s_len_sel_selCtr ;
  Int32 *s_code_sel_selCtr ;

  {
#line 303
  mtfv = s->mtfv;
#line 305
  if (s->verbosity >= 3) {
#line 306
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            s->nblock, s->nMTF, s->nInUse);
  }
#line 310
  alphaSize = s->nInUse + 2;
#line 311
  t = 0;
#line 311
  while (t < 6) {
#line 312
    v = 0;
#line 312
    while (v < alphaSize) {
#line 313
      s->len[t][v] = (UChar )15;
#line 312
      v ++;
    }
#line 311
    t ++;
  }
#line 316
  if (! (s->nMTF > 0)) {
#line 316
    BZ2_bz__AssertH__fail(3001);
  }
#line 317
  if (s->nMTF < 200) {
#line 317
    nGroups = 2;
  } else
#line 318
  if (s->nMTF < 600) {
#line 318
    nGroups = 3;
  } else
#line 319
  if (s->nMTF < 1200) {
#line 319
    nGroups = 4;
  } else
#line 320
  if (s->nMTF < 2400) {
#line 320
    nGroups = 5;
  } else {
#line 321
    nGroups = 6;
  }
#line 327
  nPart = nGroups;
#line 328
  remF = s->nMTF;
#line 329
  gs = 0;
#line 330
  while (nPart > 0) {
#line 331
    tFreq = remF / nPart;
#line 332
    ge = gs - 1;
#line 333
    aFreq = 0;
#line 334
    while (1) {
#line 334
      if (aFreq < tFreq) {
#line 334
        if (! (ge < alphaSize - 1)) {
#line 334
          break;
        }
      } else {
#line 334
        break;
      }
#line 335
      ge ++;
#line 336
      aFreq += s->mtfFreq[ge];
    }
#line 339
    if (ge > gs) {
#line 339
      if (nPart != nGroups) {
#line 339
        if (nPart != 1) {
#line 339
          if ((nGroups - nPart) % 2 == 1) {
#line 342
            aFreq -= s->mtfFreq[ge];
#line 343
            ge --;
          }
        }
      }
    }
#line 346
    if (s->verbosity >= 3) {
#line 347
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )s->nMTF));
    }
#line 352
    v = 0;
#line 352
    while (v < alphaSize) {
#line 353
      if (v >= gs) {
#line 353
        if (v <= ge) {
#line 354
          s->len[nPart - 1][v] = (UChar )0;
        } else {
#line 355
          s->len[nPart - 1][v] = (UChar )15;
        }
      } else {
#line 355
        s->len[nPart - 1][v] = (UChar )15;
      }
#line 352
      v ++;
    }
#line 357
    nPart --;
#line 358
    gs = ge + 1;
#line 359
    remF -= aFreq;
  }
#line 366
  iter = 0;
#line 366
  while (iter < 4) {
#line 368
    t = 0;
#line 368
    while (t < nGroups) {
#line 368
      fave[t] = 0;
#line 368
      t ++;
    }
#line 370
    t = 0;
#line 370
    while (t < nGroups) {
#line 371
      v = 0;
#line 371
      while (v < alphaSize) {
#line 372
        s->rfreq[t][v] = 0;
#line 371
        v ++;
      }
#line 370
      t ++;
    }
#line 378
    if (nGroups == 6) {
#line 379
      v = 0;
#line 379
      while (v < alphaSize) {
#line 380
        s->len_pack[v][0] = (UInt32 )(((int )s->len[1][v] << 16) | (int )s->len[0][v]);
#line 381
        s->len_pack[v][1] = (UInt32 )(((int )s->len[3][v] << 16) | (int )s->len[2][v]);
#line 382
        s->len_pack[v][2] = (UInt32 )(((int )s->len[5][v] << 16) | (int )s->len[4][v]);
#line 379
        v ++;
      }
    }
#line 386
    nSelectors = 0;
#line 387
    totc = 0;
#line 388
    gs = 0;
#line 389
    while (! (gs >= s->nMTF)) {
#line 393
      ge = (gs + 50) - 1;
#line 394
      if (ge >= s->nMTF) {
#line 394
        ge = s->nMTF - 1;
      }
#line 400
      t = 0;
#line 400
      while (t < nGroups) {
#line 400
        cost[t] = (UInt16 )0;
#line 400
        t ++;
      }
#line 402
      if (nGroups == 6) {
#line 402
        if (50 == (ge - gs) + 1) {
#line 406
          cost45 = (UInt32 )0;
#line 406
          cost23 = cost45;
#line 406
          cost01 = cost23;
#line 414
          icv = *(mtfv + gs);
#line 414
          cost01 += s->len_pack[icv][0];
#line 414
          cost23 += s->len_pack[icv][1];
#line 414
          cost45 += s->len_pack[icv][2];
#line 414
          icv = *(mtfv + (gs + 1));
#line 414
          cost01 += s->len_pack[icv][0];
#line 414
          cost23 += s->len_pack[icv][1];
#line 414
          cost45 += s->len_pack[icv][2];
#line 414
          icv = *(mtfv + (gs + 2));
#line 414
          cost01 += s->len_pack[icv][0];
#line 414
          cost23 += s->len_pack[icv][1];
#line 414
          cost45 += s->len_pack[icv][2];
#line 414
          icv = *(mtfv + (gs + 3));
#line 414
          cost01 += s->len_pack[icv][0];
#line 414
          cost23 += s->len_pack[icv][1];
#line 414
          cost45 += s->len_pack[icv][2];
#line 414
          icv = *(mtfv + (gs + 4));
#line 414
          cost01 += s->len_pack[icv][0];
#line 414
          cost23 += s->len_pack[icv][1];
#line 414
          cost45 += s->len_pack[icv][2];
#line 415
          icv = *(mtfv + (gs + 5));
#line 415
          cost01 += s->len_pack[icv][0];
#line 415
          cost23 += s->len_pack[icv][1];
#line 415
          cost45 += s->len_pack[icv][2];
#line 415
          icv = *(mtfv + (gs + 6));
#line 415
          cost01 += s->len_pack[icv][0];
#line 415
          cost23 += s->len_pack[icv][1];
#line 415
          cost45 += s->len_pack[icv][2];
#line 415
          icv = *(mtfv + (gs + 7));
#line 415
          cost01 += s->len_pack[icv][0];
#line 415
          cost23 += s->len_pack[icv][1];
#line 415
          cost45 += s->len_pack[icv][2];
#line 415
          icv = *(mtfv + (gs + 8));
#line 415
          cost01 += s->len_pack[icv][0];
#line 415
          cost23 += s->len_pack[icv][1];
#line 415
          cost45 += s->len_pack[icv][2];
#line 415
          icv = *(mtfv + (gs + 9));
#line 415
          cost01 += s->len_pack[icv][0];
#line 415
          cost23 += s->len_pack[icv][1];
#line 415
          cost45 += s->len_pack[icv][2];
#line 416
          icv = *(mtfv + (gs + 10));
#line 416
          cost01 += s->len_pack[icv][0];
#line 416
          cost23 += s->len_pack[icv][1];
#line 416
          cost45 += s->len_pack[icv][2];
#line 416
          icv = *(mtfv + (gs + 11));
#line 416
          cost01 += s->len_pack[icv][0];
#line 416
          cost23 += s->len_pack[icv][1];
#line 416
          cost45 += s->len_pack[icv][2];
#line 416
          icv = *(mtfv + (gs + 12));
#line 416
          cost01 += s->len_pack[icv][0];
#line 416
          cost23 += s->len_pack[icv][1];
#line 416
          cost45 += s->len_pack[icv][2];
#line 416
          icv = *(mtfv + (gs + 13));
#line 416
          cost01 += s->len_pack[icv][0];
#line 416
          cost23 += s->len_pack[icv][1];
#line 416
          cost45 += s->len_pack[icv][2];
#line 416
          icv = *(mtfv + (gs + 14));
#line 416
          cost01 += s->len_pack[icv][0];
#line 416
          cost23 += s->len_pack[icv][1];
#line 416
          cost45 += s->len_pack[icv][2];
#line 417
          icv = *(mtfv + (gs + 15));
#line 417
          cost01 += s->len_pack[icv][0];
#line 417
          cost23 += s->len_pack[icv][1];
#line 417
          cost45 += s->len_pack[icv][2];
#line 417
          icv = *(mtfv + (gs + 16));
#line 417
          cost01 += s->len_pack[icv][0];
#line 417
          cost23 += s->len_pack[icv][1];
#line 417
          cost45 += s->len_pack[icv][2];
#line 417
          icv = *(mtfv + (gs + 17));
#line 417
          cost01 += s->len_pack[icv][0];
#line 417
          cost23 += s->len_pack[icv][1];
#line 417
          cost45 += s->len_pack[icv][2];
#line 417
          icv = *(mtfv + (gs + 18));
#line 417
          cost01 += s->len_pack[icv][0];
#line 417
          cost23 += s->len_pack[icv][1];
#line 417
          cost45 += s->len_pack[icv][2];
#line 417
          icv = *(mtfv + (gs + 19));
#line 417
          cost01 += s->len_pack[icv][0];
#line 417
          cost23 += s->len_pack[icv][1];
#line 417
          cost45 += s->len_pack[icv][2];
#line 418
          icv = *(mtfv + (gs + 20));
#line 418
          cost01 += s->len_pack[icv][0];
#line 418
          cost23 += s->len_pack[icv][1];
#line 418
          cost45 += s->len_pack[icv][2];
#line 418
          icv = *(mtfv + (gs + 21));
#line 418
          cost01 += s->len_pack[icv][0];
#line 418
          cost23 += s->len_pack[icv][1];
#line 418
          cost45 += s->len_pack[icv][2];
#line 418
          icv = *(mtfv + (gs + 22));
#line 418
          cost01 += s->len_pack[icv][0];
#line 418
          cost23 += s->len_pack[icv][1];
#line 418
          cost45 += s->len_pack[icv][2];
#line 418
          icv = *(mtfv + (gs + 23));
#line 418
          cost01 += s->len_pack[icv][0];
#line 418
          cost23 += s->len_pack[icv][1];
#line 418
          cost45 += s->len_pack[icv][2];
#line 418
          icv = *(mtfv + (gs + 24));
#line 418
          cost01 += s->len_pack[icv][0];
#line 418
          cost23 += s->len_pack[icv][1];
#line 418
          cost45 += s->len_pack[icv][2];
#line 419
          icv = *(mtfv + (gs + 25));
#line 419
          cost01 += s->len_pack[icv][0];
#line 419
          cost23 += s->len_pack[icv][1];
#line 419
          cost45 += s->len_pack[icv][2];
#line 419
          icv = *(mtfv + (gs + 26));
#line 419
          cost01 += s->len_pack[icv][0];
#line 419
          cost23 += s->len_pack[icv][1];
#line 419
          cost45 += s->len_pack[icv][2];
#line 419
          icv = *(mtfv + (gs + 27));
#line 419
          cost01 += s->len_pack[icv][0];
#line 419
          cost23 += s->len_pack[icv][1];
#line 419
          cost45 += s->len_pack[icv][2];
#line 419
          icv = *(mtfv + (gs + 28));
#line 419
          cost01 += s->len_pack[icv][0];
#line 419
          cost23 += s->len_pack[icv][1];
#line 419
          cost45 += s->len_pack[icv][2];
#line 419
          icv = *(mtfv + (gs + 29));
#line 419
          cost01 += s->len_pack[icv][0];
#line 419
          cost23 += s->len_pack[icv][1];
#line 419
          cost45 += s->len_pack[icv][2];
#line 420
          icv = *(mtfv + (gs + 30));
#line 420
          cost01 += s->len_pack[icv][0];
#line 420
          cost23 += s->len_pack[icv][1];
#line 420
          cost45 += s->len_pack[icv][2];
#line 420
          icv = *(mtfv + (gs + 31));
#line 420
          cost01 += s->len_pack[icv][0];
#line 420
          cost23 += s->len_pack[icv][1];
#line 420
          cost45 += s->len_pack[icv][2];
#line 420
          icv = *(mtfv + (gs + 32));
#line 420
          cost01 += s->len_pack[icv][0];
#line 420
          cost23 += s->len_pack[icv][1];
#line 420
          cost45 += s->len_pack[icv][2];
#line 420
          icv = *(mtfv + (gs + 33));
#line 420
          cost01 += s->len_pack[icv][0];
#line 420
          cost23 += s->len_pack[icv][1];
#line 420
          cost45 += s->len_pack[icv][2];
#line 420
          icv = *(mtfv + (gs + 34));
#line 420
          cost01 += s->len_pack[icv][0];
#line 420
          cost23 += s->len_pack[icv][1];
#line 420
          cost45 += s->len_pack[icv][2];
#line 421
          icv = *(mtfv + (gs + 35));
#line 421
          cost01 += s->len_pack[icv][0];
#line 421
          cost23 += s->len_pack[icv][1];
#line 421
          cost45 += s->len_pack[icv][2];
#line 421
          icv = *(mtfv + (gs + 36));
#line 421
          cost01 += s->len_pack[icv][0];
#line 421
          cost23 += s->len_pack[icv][1];
#line 421
          cost45 += s->len_pack[icv][2];
#line 421
          icv = *(mtfv + (gs + 37));
#line 421
          cost01 += s->len_pack[icv][0];
#line 421
          cost23 += s->len_pack[icv][1];
#line 421
          cost45 += s->len_pack[icv][2];
#line 421
          icv = *(mtfv + (gs + 38));
#line 421
          cost01 += s->len_pack[icv][0];
#line 421
          cost23 += s->len_pack[icv][1];
#line 421
          cost45 += s->len_pack[icv][2];
#line 421
          icv = *(mtfv + (gs + 39));
#line 421
          cost01 += s->len_pack[icv][0];
#line 421
          cost23 += s->len_pack[icv][1];
#line 421
          cost45 += s->len_pack[icv][2];
#line 422
          icv = *(mtfv + (gs + 40));
#line 422
          cost01 += s->len_pack[icv][0];
#line 422
          cost23 += s->len_pack[icv][1];
#line 422
          cost45 += s->len_pack[icv][2];
#line 422
          icv = *(mtfv + (gs + 41));
#line 422
          cost01 += s->len_pack[icv][0];
#line 422
          cost23 += s->len_pack[icv][1];
#line 422
          cost45 += s->len_pack[icv][2];
#line 422
          icv = *(mtfv + (gs + 42));
#line 422
          cost01 += s->len_pack[icv][0];
#line 422
          cost23 += s->len_pack[icv][1];
#line 422
          cost45 += s->len_pack[icv][2];
#line 422
          icv = *(mtfv + (gs + 43));
#line 422
          cost01 += s->len_pack[icv][0];
#line 422
          cost23 += s->len_pack[icv][1];
#line 422
          cost45 += s->len_pack[icv][2];
#line 422
          icv = *(mtfv + (gs + 44));
#line 422
          cost01 += s->len_pack[icv][0];
#line 422
          cost23 += s->len_pack[icv][1];
#line 422
          cost45 += s->len_pack[icv][2];
#line 423
          icv = *(mtfv + (gs + 45));
#line 423
          cost01 += s->len_pack[icv][0];
#line 423
          cost23 += s->len_pack[icv][1];
#line 423
          cost45 += s->len_pack[icv][2];
#line 423
          icv = *(mtfv + (gs + 46));
#line 423
          cost01 += s->len_pack[icv][0];
#line 423
          cost23 += s->len_pack[icv][1];
#line 423
          cost45 += s->len_pack[icv][2];
#line 423
          icv = *(mtfv + (gs + 47));
#line 423
          cost01 += s->len_pack[icv][0];
#line 423
          cost23 += s->len_pack[icv][1];
#line 423
          cost45 += s->len_pack[icv][2];
#line 423
          icv = *(mtfv + (gs + 48));
#line 423
          cost01 += s->len_pack[icv][0];
#line 423
          cost23 += s->len_pack[icv][1];
#line 423
          cost45 += s->len_pack[icv][2];
#line 423
          icv = *(mtfv + (gs + 49));
#line 423
          cost01 += s->len_pack[icv][0];
#line 423
          cost23 += s->len_pack[icv][1];
#line 423
          cost45 += s->len_pack[icv][2];
#line 427
          cost[0] = (UInt16 )(cost01 & 65535U);
#line 427
          cost[1] = (UInt16 )(cost01 >> 16);
#line 428
          cost[2] = (UInt16 )(cost23 & 65535U);
#line 428
          cost[3] = (UInt16 )(cost23 >> 16);
#line 429
          cost[4] = (UInt16 )(cost45 & 65535U);
#line 429
          cost[5] = (UInt16 )(cost45 >> 16);
        } else {
#line 402
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 433
        i = gs;
#line 433
        while (i <= ge) {
#line 434
          icv___0 = *(mtfv + i);
#line 435
          t = 0;
#line 435
          while (t < nGroups) {
#line 435
            cost[t] = (UInt16 )((int )cost[t] + (int )s->len[t][icv___0]);
#line 435
            t ++;
          }
#line 433
          i ++;
        }
      }
#line 443
      bc = 999999999;
#line 443
      bt = -1;
#line 444
      t = 0;
#line 444
      while (t < nGroups) {
#line 445
        if ((int )cost[t] < bc) {
#line 445
          bc = (Int32 )cost[t];
#line 445
          bt = t;
        }
#line 444
        t ++;
      }
#line 446
      totc += bc;
#line 447
      (fave[bt]) ++;
#line 448
      s->selector[nSelectors] = (UChar )bt;
#line 449
      nSelectors ++;
#line 454
      if (nGroups == 6) {
#line 454
        if (50 == (ge - gs) + 1) {
#line 459
          (s->rfreq[bt][*(mtfv + gs)]) ++;
#line 459
          (s->rfreq[bt][*(mtfv + (gs + 1))]) ++;
#line 459
          (s->rfreq[bt][*(mtfv + (gs + 2))]) ++;
#line 459
          (s->rfreq[bt][*(mtfv + (gs + 3))]) ++;
#line 459
          (s->rfreq[bt][*(mtfv + (gs + 4))]) ++;
#line 460
          (s->rfreq[bt][*(mtfv + (gs + 5))]) ++;
#line 460
          (s->rfreq[bt][*(mtfv + (gs + 6))]) ++;
#line 460
          (s->rfreq[bt][*(mtfv + (gs + 7))]) ++;
#line 460
          (s->rfreq[bt][*(mtfv + (gs + 8))]) ++;
#line 460
          (s->rfreq[bt][*(mtfv + (gs + 9))]) ++;
#line 461
          (s->rfreq[bt][*(mtfv + (gs + 10))]) ++;
#line 461
          (s->rfreq[bt][*(mtfv + (gs + 11))]) ++;
#line 461
          (s->rfreq[bt][*(mtfv + (gs + 12))]) ++;
#line 461
          (s->rfreq[bt][*(mtfv + (gs + 13))]) ++;
#line 461
          (s->rfreq[bt][*(mtfv + (gs + 14))]) ++;
#line 462
          (s->rfreq[bt][*(mtfv + (gs + 15))]) ++;
#line 462
          (s->rfreq[bt][*(mtfv + (gs + 16))]) ++;
#line 462
          (s->rfreq[bt][*(mtfv + (gs + 17))]) ++;
#line 462
          (s->rfreq[bt][*(mtfv + (gs + 18))]) ++;
#line 462
          (s->rfreq[bt][*(mtfv + (gs + 19))]) ++;
#line 463
          (s->rfreq[bt][*(mtfv + (gs + 20))]) ++;
#line 463
          (s->rfreq[bt][*(mtfv + (gs + 21))]) ++;
#line 463
          (s->rfreq[bt][*(mtfv + (gs + 22))]) ++;
#line 463
          (s->rfreq[bt][*(mtfv + (gs + 23))]) ++;
#line 463
          (s->rfreq[bt][*(mtfv + (gs + 24))]) ++;
#line 464
          (s->rfreq[bt][*(mtfv + (gs + 25))]) ++;
#line 464
          (s->rfreq[bt][*(mtfv + (gs + 26))]) ++;
#line 464
          (s->rfreq[bt][*(mtfv + (gs + 27))]) ++;
#line 464
          (s->rfreq[bt][*(mtfv + (gs + 28))]) ++;
#line 464
          (s->rfreq[bt][*(mtfv + (gs + 29))]) ++;
#line 465
          (s->rfreq[bt][*(mtfv + (gs + 30))]) ++;
#line 465
          (s->rfreq[bt][*(mtfv + (gs + 31))]) ++;
#line 465
          (s->rfreq[bt][*(mtfv + (gs + 32))]) ++;
#line 465
          (s->rfreq[bt][*(mtfv + (gs + 33))]) ++;
#line 465
          (s->rfreq[bt][*(mtfv + (gs + 34))]) ++;
#line 466
          (s->rfreq[bt][*(mtfv + (gs + 35))]) ++;
#line 466
          (s->rfreq[bt][*(mtfv + (gs + 36))]) ++;
#line 466
          (s->rfreq[bt][*(mtfv + (gs + 37))]) ++;
#line 466
          (s->rfreq[bt][*(mtfv + (gs + 38))]) ++;
#line 466
          (s->rfreq[bt][*(mtfv + (gs + 39))]) ++;
#line 467
          (s->rfreq[bt][*(mtfv + (gs + 40))]) ++;
#line 467
          (s->rfreq[bt][*(mtfv + (gs + 41))]) ++;
#line 467
          (s->rfreq[bt][*(mtfv + (gs + 42))]) ++;
#line 467
          (s->rfreq[bt][*(mtfv + (gs + 43))]) ++;
#line 467
          (s->rfreq[bt][*(mtfv + (gs + 44))]) ++;
#line 468
          (s->rfreq[bt][*(mtfv + (gs + 45))]) ++;
#line 468
          (s->rfreq[bt][*(mtfv + (gs + 46))]) ++;
#line 468
          (s->rfreq[bt][*(mtfv + (gs + 47))]) ++;
#line 468
          (s->rfreq[bt][*(mtfv + (gs + 48))]) ++;
#line 468
          (s->rfreq[bt][*(mtfv + (gs + 49))]) ++;
        } else {
#line 454
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 474
        i = gs;
#line 474
        while (i <= ge) {
#line 475
          (s->rfreq[bt][*(mtfv + i)]) ++;
#line 474
          i ++;
        }
      }
#line 478
      gs = ge + 1;
    }
#line 480
    if (s->verbosity >= 3) {
#line 481
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      pass %d: size is %d, grp uses are ",
              iter + 1, totc / 8);
#line 483
      t = 0;
#line 483
      while (t < nGroups) {
#line 484
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d ", fave[t]);
#line 483
        t ++;
      }
#line 485
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
#line 493
    t = 0;
#line 493
    while (t < nGroups) {
#line 494
      BZ2_hbMakeCodeLengths(& s->len[t][0], & s->rfreq[t][0], alphaSize, 17);
#line 493
      t ++;
    }
#line 366
    iter ++;
  }
#line 499
  if (! (nGroups < 8)) {
#line 499
    BZ2_bz__AssertH__fail(3002);
  }
#line 500
  if (nSelectors < 32768) {
#line 500
    if (! (nSelectors <= 18002)) {
#line 500
      BZ2_bz__AssertH__fail(3003);
    }
  } else {
#line 500
    BZ2_bz__AssertH__fail(3003);
  }
#line 508
  i = 0;
#line 508
  while (i < nGroups) {
#line 508
    pos[i] = (UChar )i;
#line 508
    i ++;
  }
#line 509
  i = 0;
#line 509
  while (i < nSelectors) {
#line 510
    ll_i = s->selector[i];
#line 511
    j = 0;
#line 512
    tmp = pos[j];
#line 513
    while ((int )ll_i != (int )tmp) {
#line 514
      j ++;
#line 515
      tmp2 = tmp;
#line 516
      tmp = pos[j];
#line 517
      pos[j] = tmp2;
    }
#line 519
    pos[0] = tmp;
#line 520
    s->selectorMtf[i] = (UChar )j;
#line 509
    i ++;
  }
#line 525
  t = 0;
#line 525
  while (t < nGroups) {
#line 526
    minLen = 32;
#line 527
    maxLen = 0;
#line 528
    i = 0;
#line 528
    while (i < alphaSize) {
#line 529
      if ((int )s->len[t][i] > maxLen) {
#line 529
        maxLen = (Int32 )s->len[t][i];
      }
#line 530
      if ((int )s->len[t][i] < minLen) {
#line 530
        minLen = (Int32 )s->len[t][i];
      }
#line 528
      i ++;
    }
#line 532
    if (! (! (maxLen > 17))) {
#line 532
      BZ2_bz__AssertH__fail(3004);
    }
#line 533
    if (! (! (minLen < 1))) {
#line 533
      BZ2_bz__AssertH__fail(3005);
    }
#line 534
    BZ2_hbAssignCodes(& s->code[t][0], & s->len[t][0], minLen, maxLen, alphaSize);
#line 525
    t ++;
  }
#line 541
  i = 0;
#line 541
  while (i < 16) {
#line 542
    inUse16[i] = (Bool )0;
#line 543
    j = 0;
#line 543
    while (j < 16) {
#line 544
      if (s->inUse[i * 16 + j]) {
#line 544
        inUse16[i] = (Bool )1;
      }
#line 543
      j ++;
    }
#line 541
    i ++;
  }
#line 547
  nBytes = s->numZ;
#line 548
  i = 0;
#line 548
  while (i < 16) {
#line 549
    if (inUse16[i]) {
#line 549
      bsW(s, 1, (UInt32 )1);
    } else {
#line 549
      bsW(s, 1, (UInt32 )0);
    }
#line 548
    i ++;
  }
#line 551
  i = 0;
#line 551
  while (i < 16) {
#line 552
    if (inUse16[i]) {
#line 553
      j = 0;
#line 553
      while (j < 16) {
#line 554
        if (s->inUse[i * 16 + j]) {
#line 554
          bsW(s, 1, (UInt32 )1);
        } else {
#line 554
          bsW(s, 1, (UInt32 )0);
        }
#line 553
        j ++;
      }
    }
#line 551
    i ++;
  }
#line 557
  if (s->verbosity >= 3) {
#line 558
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"      bytes: mapping %d, ",
            s->numZ - nBytes);
  }
#line 562
  nBytes = s->numZ;
#line 563
  bsW(s, 3, (UInt32 )nGroups);
#line 564
  bsW(s, 15, (UInt32 )nSelectors);
#line 565
  i = 0;
#line 565
  while (i < nSelectors) {
#line 566
    j = 0;
#line 566
    while (j < (Int32 )s->selectorMtf[i]) {
#line 566
      bsW(s, 1, (UInt32 )1);
#line 566
      j ++;
    }
#line 567
    bsW(s, 1, (UInt32 )0);
#line 565
    i ++;
  }
#line 569
  if (s->verbosity >= 3) {
#line 570
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"selectors %d, ",
            s->numZ - nBytes);
  }
#line 573
  nBytes = s->numZ;
#line 575
  t = 0;
#line 575
  while (t < nGroups) {
#line 576
    curr = (Int32 )s->len[t][0];
#line 577
    bsW(s, 5, (UInt32 )curr);
#line 578
    i = 0;
#line 578
    while (i < alphaSize) {
#line 579
      while (curr < (Int32 )s->len[t][i]) {
#line 579
        bsW(s, 2, (UInt32 )2);
#line 579
        curr ++;
      }
#line 580
      while (curr > (Int32 )s->len[t][i]) {
#line 580
        bsW(s, 2, (UInt32 )3);
#line 580
        curr --;
      }
#line 581
      bsW(s, 1, (UInt32 )0);
#line 578
      i ++;
    }
#line 575
    t ++;
  }
#line 585
  if (s->verbosity >= 3) {
#line 586
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"code lengths %d, ",
            s->numZ - nBytes);
  }
#line 589
  nBytes = s->numZ;
#line 590
  selCtr = 0;
#line 591
  gs = 0;
#line 592
  while (! (gs >= s->nMTF)) {
#line 594
    ge = (gs + 50) - 1;
#line 595
    if (ge >= s->nMTF) {
#line 595
      ge = s->nMTF - 1;
    }
#line 596
    if (! ((int )s->selector[selCtr] < nGroups)) {
#line 596
      BZ2_bz__AssertH__fail(3006);
    }
#line 598
    if (nGroups == 6) {
#line 598
      if (50 == (ge - gs) + 1) {
#line 601
        s_len_sel_selCtr = & s->len[s->selector[selCtr]][0];
#line 603
        s_code_sel_selCtr = & s->code[s->selector[selCtr]][0];
#line 612
        mtfv_i = *(mtfv + gs);
#line 612
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 612
        mtfv_i = *(mtfv + (gs + 1));
#line 612
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 612
        mtfv_i = *(mtfv + (gs + 2));
#line 612
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 612
        mtfv_i = *(mtfv + (gs + 3));
#line 612
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 612
        mtfv_i = *(mtfv + (gs + 4));
#line 612
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 613
        mtfv_i = *(mtfv + (gs + 5));
#line 613
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 613
        mtfv_i = *(mtfv + (gs + 6));
#line 613
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 613
        mtfv_i = *(mtfv + (gs + 7));
#line 613
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 613
        mtfv_i = *(mtfv + (gs + 8));
#line 613
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 613
        mtfv_i = *(mtfv + (gs + 9));
#line 613
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 614
        mtfv_i = *(mtfv + (gs + 10));
#line 614
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 614
        mtfv_i = *(mtfv + (gs + 11));
#line 614
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 614
        mtfv_i = *(mtfv + (gs + 12));
#line 614
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 614
        mtfv_i = *(mtfv + (gs + 13));
#line 614
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 614
        mtfv_i = *(mtfv + (gs + 14));
#line 614
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 615
        mtfv_i = *(mtfv + (gs + 15));
#line 615
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 615
        mtfv_i = *(mtfv + (gs + 16));
#line 615
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 615
        mtfv_i = *(mtfv + (gs + 17));
#line 615
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 615
        mtfv_i = *(mtfv + (gs + 18));
#line 615
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 615
        mtfv_i = *(mtfv + (gs + 19));
#line 615
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 616
        mtfv_i = *(mtfv + (gs + 20));
#line 616
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 616
        mtfv_i = *(mtfv + (gs + 21));
#line 616
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 616
        mtfv_i = *(mtfv + (gs + 22));
#line 616
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 616
        mtfv_i = *(mtfv + (gs + 23));
#line 616
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 616
        mtfv_i = *(mtfv + (gs + 24));
#line 616
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 617
        mtfv_i = *(mtfv + (gs + 25));
#line 617
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 617
        mtfv_i = *(mtfv + (gs + 26));
#line 617
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 617
        mtfv_i = *(mtfv + (gs + 27));
#line 617
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 617
        mtfv_i = *(mtfv + (gs + 28));
#line 617
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 617
        mtfv_i = *(mtfv + (gs + 29));
#line 617
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 618
        mtfv_i = *(mtfv + (gs + 30));
#line 618
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 618
        mtfv_i = *(mtfv + (gs + 31));
#line 618
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 618
        mtfv_i = *(mtfv + (gs + 32));
#line 618
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 618
        mtfv_i = *(mtfv + (gs + 33));
#line 618
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 618
        mtfv_i = *(mtfv + (gs + 34));
#line 618
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 619
        mtfv_i = *(mtfv + (gs + 35));
#line 619
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 619
        mtfv_i = *(mtfv + (gs + 36));
#line 619
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 619
        mtfv_i = *(mtfv + (gs + 37));
#line 619
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 619
        mtfv_i = *(mtfv + (gs + 38));
#line 619
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 619
        mtfv_i = *(mtfv + (gs + 39));
#line 619
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 620
        mtfv_i = *(mtfv + (gs + 40));
#line 620
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 620
        mtfv_i = *(mtfv + (gs + 41));
#line 620
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 620
        mtfv_i = *(mtfv + (gs + 42));
#line 620
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 620
        mtfv_i = *(mtfv + (gs + 43));
#line 620
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 620
        mtfv_i = *(mtfv + (gs + 44));
#line 620
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 621
        mtfv_i = *(mtfv + (gs + 45));
#line 621
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 621
        mtfv_i = *(mtfv + (gs + 46));
#line 621
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 621
        mtfv_i = *(mtfv + (gs + 47));
#line 621
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 621
        mtfv_i = *(mtfv + (gs + 48));
#line 621
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
#line 621
        mtfv_i = *(mtfv + (gs + 49));
#line 621
        bsW(s, (Int32 )*(s_len_sel_selCtr + mtfv_i), (UInt32 )*(s_code_sel_selCtr + mtfv_i));
      } else {
#line 598
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 627
      i = gs;
#line 627
      while (i <= ge) {
#line 628
        bsW(s, (Int32 )s->len[s->selector[selCtr]][*(mtfv + i)], (UInt32 )s->code[s->selector[selCtr]][*(mtfv + i)]);
#line 627
        i ++;
      }
    }
#line 635
    gs = ge + 1;
#line 636
    selCtr ++;
  }
#line 638
  if (! (selCtr == nSelectors)) {
#line 638
    BZ2_bz__AssertH__fail(3007);
  }
#line 640
  if (s->verbosity >= 3) {
#line 641
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"codes %d\n",
            s->numZ - nBytes);
  }
#line 642
  return;
}
}
#line 646 "compress.c"
void BZ2_compressBlock(EState *s , Bool is_last_block ) 
{ 


  {
#line 648
  if (s->nblock > 0) {
#line 650
    s->blockCRC = ~ s->blockCRC;
#line 651
    s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
#line 652
    s->combinedCRC ^= s->blockCRC;
#line 653
    if (s->blockNo > 1) {
#line 653
      s->numZ = 0;
    }
#line 655
    if (s->verbosity >= 2) {
#line 656
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\n",
              s->blockNo, s->blockCRC, s->combinedCRC, s->nblock);
    }
#line 660
    BZ2_blockSort(s);
  }
#line 663
  s->zbits = (UChar *)s->arr2 + s->nblock;
#line 666
  if (s->blockNo == 1) {
#line 667
    BZ2_bsInitWrite(s);
#line 668
    bsPutUChar(s, (UChar )66);
#line 669
    bsPutUChar(s, (UChar )90);
#line 670
    bsPutUChar(s, (UChar )104);
#line 671
    bsPutUChar(s, (UChar )(48 + s->blockSize100k));
  }
#line 674
  if (s->nblock > 0) {
#line 676
    bsPutUChar(s, (UChar )49);
#line 676
    bsPutUChar(s, (UChar )65);
#line 677
    bsPutUChar(s, (UChar )89);
#line 677
    bsPutUChar(s, (UChar )38);
#line 678
    bsPutUChar(s, (UChar )83);
#line 678
    bsPutUChar(s, (UChar )89);
#line 681
    bsPutUInt32(s, s->blockCRC);
#line 692
    bsW(s, 1, (UInt32 )0);
#line 694
    bsW(s, 24, (UInt32 )s->origPtr);
#line 695
    generateMTFValues(s);
#line 696
    sendMTFValues(s);
  }
#line 701
  if (is_last_block) {
#line 703
    bsPutUChar(s, (UChar )23);
#line 703
    bsPutUChar(s, (UChar )114);
#line 704
    bsPutUChar(s, (UChar )69);
#line 704
    bsPutUChar(s, (UChar )56);
#line 705
    bsPutUChar(s, (UChar )80);
#line 705
    bsPutUChar(s, (UChar )144);
#line 706
    bsPutUInt32(s, s->combinedCRC);
#line 707
    if (s->verbosity >= 2) {
#line 708
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    final combined CRC = 0x%08x\n   ",
              s->combinedCRC);
    }
#line 709
    bsFinishWrite(s);
  }
#line 711
  return;
}
}
#line 1 "crctable.o"
#pragma merger("0","/tmp/cil-luIpsjEV.i","")
#line 71 "crctable.c"
UInt32 BZ2_crc32Table[256]  = 
#line 71 "crctable.c"
  {      (UInt32 )0L,      (UInt32 )79764919L,      (UInt32 )159529838L,      (UInt32 )222504665L, 
        (UInt32 )319059676L,      (UInt32 )398814059L,      (UInt32 )445009330L,      (UInt32 )507990021L, 
        (UInt32 )638119352L,      (UInt32 )583659535L,      (UInt32 )797628118L,      (UInt32 )726387553L, 
        (UInt32 )890018660L,      (UInt32 )835552979L,      (UInt32 )1015980042L,      (UInt32 )944750013L, 
        (UInt32 )1276238704L,      (UInt32 )1221641927L,      (UInt32 )1167319070L,      (UInt32 )1095957929L, 
        (UInt32 )1595256236L,      (UInt32 )1540665371L,      (UInt32 )1452775106L,      (UInt32 )1381403509L, 
        (UInt32 )1780037320L,      (UInt32 )1859660671L,      (UInt32 )1671105958L,      (UInt32 )1733955601L, 
        (UInt32 )2031960084L,      (UInt32 )2111593891L,      (UInt32 )1889500026L,      (UInt32 )1952343757L, 
        (UInt32 )2552477408L,      (UInt32 )2632100695L,      (UInt32 )2443283854L,      (UInt32 )2506133561L, 
        (UInt32 )2334638140L,      (UInt32 )2414271883L,      (UInt32 )2191915858L,      (UInt32 )2254759653L, 
        (UInt32 )3190512472L,      (UInt32 )3135915759L,      (UInt32 )3081330742L,      (UInt32 )3009969537L, 
        (UInt32 )2905550212L,      (UInt32 )2850959411L,      (UInt32 )2762807018L,      (UInt32 )2691435357L, 
        (UInt32 )3560074640L,      (UInt32 )3505614887L,      (UInt32 )3719321342L,      (UInt32 )3648080713L, 
        (UInt32 )3342211916L,      (UInt32 )3287746299L,      (UInt32 )3467911202L,      (UInt32 )3396681109L, 
        (UInt32 )4063920168L,      (UInt32 )4143685023L,      (UInt32 )4223187782L,      (UInt32 )4286162673L, 
        (UInt32 )3779000052L,      (UInt32 )3858754371L,      (UInt32 )3904687514L,      (UInt32 )3967668269L, 
        (UInt32 )881225847L,      (UInt32 )809987520L,      (UInt32 )1023691545L,      (UInt32 )969234094L, 
        (UInt32 )662832811L,      (UInt32 )591600412L,      (UInt32 )771767749L,      (UInt32 )717299826L, 
        (UInt32 )311336399L,      (UInt32 )374308984L,      (UInt32 )453813921L,      (UInt32 )533576470L, 
        (UInt32 )25881363L,      (UInt32 )88864420L,      (UInt32 )134795389L,      (UInt32 )214552010L, 
        (UInt32 )2023205639L,      (UInt32 )2086057648L,      (UInt32 )1897238633L,      (UInt32 )1976864222L, 
        (UInt32 )1804852699L,      (UInt32 )1867694188L,      (UInt32 )1645340341L,      (UInt32 )1724971778L, 
        (UInt32 )1587496639L,      (UInt32 )1516133128L,      (UInt32 )1461550545L,      (UInt32 )1406951526L, 
        (UInt32 )1302016099L,      (UInt32 )1230646740L,      (UInt32 )1142491917L,      (UInt32 )1087903418L, 
        (UInt32 )2896545431L,      (UInt32 )2825181984L,      (UInt32 )2770861561L,      (UInt32 )2716262478L, 
        (UInt32 )3215044683L,      (UInt32 )3143675388L,      (UInt32 )3055782693L,      (UInt32 )3001194130L, 
        (UInt32 )2326604591L,      (UInt32 )2389456536L,      (UInt32 )2200899649L,      (UInt32 )2280525302L, 
        (UInt32 )2578013683L,      (UInt32 )2640855108L,      (UInt32 )2418763421L,      (UInt32 )2498394922L, 
        (UInt32 )3769900519L,      (UInt32 )3832873040L,      (UInt32 )3912640137L,      (UInt32 )3992402750L, 
        (UInt32 )4088425275L,      (UInt32 )4151408268L,      (UInt32 )4197601365L,      (UInt32 )4277358050L, 
        (UInt32 )3334271071L,      (UInt32 )3263032808L,      (UInt32 )3476998961L,      (UInt32 )3422541446L, 
        (UInt32 )3585640067L,      (UInt32 )3514407732L,      (UInt32 )3694837229L,      (UInt32 )3640369242L, 
        (UInt32 )1762451694L,      (UInt32 )1842216281L,      (UInt32 )1619975040L,      (UInt32 )1682949687L, 
        (UInt32 )2047383090L,      (UInt32 )2127137669L,      (UInt32 )1938468188L,      (UInt32 )2001449195L, 
        (UInt32 )1325665622L,      (UInt32 )1271206113L,      (UInt32 )1183200824L,      (UInt32 )1111960463L, 
        (UInt32 )1543535498L,      (UInt32 )1489069629L,      (UInt32 )1434599652L,      (UInt32 )1363369299L, 
        (UInt32 )622672798L,      (UInt32 )568075817L,      (UInt32 )748617968L,      (UInt32 )677256519L, 
        (UInt32 )907627842L,      (UInt32 )853037301L,      (UInt32 )1067152940L,      (UInt32 )995781531L, 
        (UInt32 )51762726L,      (UInt32 )131386257L,      (UInt32 )177728840L,      (UInt32 )240578815L, 
        (UInt32 )269590778L,      (UInt32 )349224269L,      (UInt32 )429104020L,      (UInt32 )491947555L, 
        (UInt32 )4046411278L,      (UInt32 )4126034873L,      (UInt32 )4172115296L,      (UInt32 )4234965207L, 
        (UInt32 )3794477266L,      (UInt32 )3874110821L,      (UInt32 )3953728444L,      (UInt32 )4016571915L, 
        (UInt32 )3609705398L,      (UInt32 )3555108353L,      (UInt32 )3735388376L,      (UInt32 )3664026991L, 
        (UInt32 )3290680682L,      (UInt32 )3236090077L,      (UInt32 )3449943556L,      (UInt32 )3378572211L, 
        (UInt32 )3174993278L,      (UInt32 )3120533705L,      (UInt32 )3032266256L,      (UInt32 )2961025959L, 
        (UInt32 )2923101090L,      (UInt32 )2868635157L,      (UInt32 )2813903052L,      (UInt32 )2742672763L, 
        (UInt32 )2604032198L,      (UInt32 )2683796849L,      (UInt32 )2461293480L,      (UInt32 )2524268063L, 
        (UInt32 )2284983834L,      (UInt32 )2364738477L,      (UInt32 )2175806836L,      (UInt32 )2238787779L, 
        (UInt32 )1569362073L,      (UInt32 )1498123566L,      (UInt32 )1409854455L,      (UInt32 )1355396672L, 
        (UInt32 )1317987909L,      (UInt32 )1246755826L,      (UInt32 )1192025387L,      (UInt32 )1137557660L, 
        (UInt32 )2072149281L,      (UInt32 )2135122070L,      (UInt32 )1912620623L,      (UInt32 )1992383480L, 
        (UInt32 )1753615357L,      (UInt32 )1816598090L,      (UInt32 )1627664531L,      (UInt32 )1707420964L, 
        (UInt32 )295390185L,      (UInt32 )358241886L,      (UInt32 )404320391L,      (UInt32 )483945776L, 
        (UInt32 )43990325L,      (UInt32 )106832002L,      (UInt32 )186451547L,      (UInt32 )266083308L, 
        (UInt32 )932423249L,      (UInt32 )861060070L,      (UInt32 )1041341759L,      (UInt32 )986742920L, 
        (UInt32 )613929101L,      (UInt32 )542559546L,      (UInt32 )756411363L,      (UInt32 )701822548L, 
        (UInt32 )3316196985L,      (UInt32 )3244833742L,      (UInt32 )3425377559L,      (UInt32 )3370778784L, 
        (UInt32 )3601682597L,      (UInt32 )3530312978L,      (UInt32 )3744426955L,      (UInt32 )3689838204L, 
        (UInt32 )3819031489L,      (UInt32 )3881883254L,      (UInt32 )3928223919L,      (UInt32 )4007849240L, 
        (UInt32 )4037393693L,      (UInt32 )4100235434L,      (UInt32 )4180117107L,      (UInt32 )4259748804L, 
        (UInt32 )2310601993L,      (UInt32 )2373574846L,      (UInt32 )2151335527L,      (UInt32 )2231098320L, 
        (UInt32 )2596047829L,      (UInt32 )2659030626L,      (UInt32 )2470359227L,      (UInt32 )2550115596L, 
        (UInt32 )2947551409L,      (UInt32 )2876312838L,      (UInt32 )2788305887L,      (UInt32 )2733848168L, 
        (UInt32 )3165939309L,      (UInt32 )3094707162L,      (UInt32 )3040238851L,      (UInt32 )2985771188L};
#line 1 "decompress.o"
#pragma merger("0","/tmp/cil-SqILImBo.i","")
#line 518 "./bzlib_private.h"
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) ;
#line 66 "decompress.c"
static void makeMaps_d(DState *s ) 
{ 
  Int32 i ;

  {
#line 70
  s->nInUse = 0;
#line 71
  i = 0;
#line 71
  while (i < 256) {
#line 72
    if (s->inUse[i]) {
#line 73
      s->seqToUnseq[s->nInUse] = (UChar )i;
#line 74
      (s->nInUse) ++;
    }
#line 71
    i ++;
  }
#line 76
  return;
}
}
#line 146 "decompress.c"
Int32 BZ2_decompress(DState *s ) 
{ 
  UChar uc ;
  Int32 retVal ;
  Int32 minLen ;
  Int32 maxLen ;
  bz_stream *strm ;
  Int32 i ;
  Int32 j ;
  Int32 t ;
  Int32 alphaSize ;
  Int32 nGroups ;
  Int32 nSelectors ;
  Int32 EOB ;
  Int32 groupNo ;
  Int32 groupPos ;
  Int32 nextSym ;
  Int32 nblockMAX ;
  Int32 nblock ;
  Int32 es ;
  Int32 N ;
  Int32 curr ;
  Int32 zt ;
  Int32 zn ;
  Int32 zvec ;
  Int32 zj ;
  Int32 gSel ;
  Int32 gMinlen ;
  Int32 *gLimit ;
  Int32 *gBase ;
  Int32 *gPerm ;
  UInt32 v ;
  UInt32 v___0 ;
  UInt32 v___1 ;
  UInt32 v___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  UInt32 v___3 ;
  UInt32 v___4 ;
  UInt32 v___5 ;
  UInt32 v___6 ;
  UInt32 v___7 ;
  UInt32 v___8 ;
  UInt32 v___9 ;
  UInt32 v___10 ;
  UInt32 v___11 ;
  UInt32 v___12 ;
  UInt32 v___13 ;
  UInt32 v___14 ;
  UInt32 v___15 ;
  UInt32 v___16 ;
  UInt32 v___17 ;
  UInt32 v___18 ;
  UInt32 v___19 ;
  UInt32 v___20 ;
  UInt32 v___21 ;
  UChar pos[6] ;
  UChar tmp___2 ;
  UChar v___22 ;
  UInt32 v___23 ;
  UInt32 v___24 ;
  UInt32 v___25 ;
  Int32 ii ;
  Int32 jj ;
  Int32 kk ;
  UInt32 v___26 ;
  UInt32 v___27 ;
  UInt32 v___28 ;
  UInt32 v___29 ;
  Int32 ii___0 ;
  Int32 jj___0 ;
  Int32 kk___0 ;
  Int32 pp ;
  Int32 lno ;
  Int32 off ;
  UInt32 nn ;
  Int32 z ;
  UInt32 v___30 ;
  UInt32 v___31 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  UInt32 v___32 ;
  UInt32 v___33 ;
  UInt32 v___34 ;
  UInt32 v___35 ;
  UInt32 v___36 ;
  UInt32 v___37 ;
  UInt32 v___38 ;
  UInt32 v___39 ;
  UInt32 v___40 ;

  {
#line 151
  strm = s->strm;
#line 179
  if (s->state == 10) {
#line 181
    s->save_i = 0;
#line 182
    s->save_j = 0;
#line 183
    s->save_t = 0;
#line 184
    s->save_alphaSize = 0;
#line 185
    s->save_nGroups = 0;
#line 186
    s->save_nSelectors = 0;
#line 187
    s->save_EOB = 0;
#line 188
    s->save_groupNo = 0;
#line 189
    s->save_groupPos = 0;
#line 190
    s->save_nextSym = 0;
#line 191
    s->save_nblockMAX = 0;
#line 192
    s->save_nblock = 0;
#line 193
    s->save_es = 0;
#line 194
    s->save_N = 0;
#line 195
    s->save_curr = 0;
#line 196
    s->save_zt = 0;
#line 197
    s->save_zn = 0;
#line 198
    s->save_zvec = 0;
#line 199
    s->save_zj = 0;
#line 200
    s->save_gSel = 0;
#line 201
    s->save_gMinlen = 0;
#line 202
    s->save_gLimit = (Int32 *)((void *)0);
#line 203
    s->save_gBase = (Int32 *)((void *)0);
#line 204
    s->save_gPerm = (Int32 *)((void *)0);
  }
#line 208
  i = s->save_i;
#line 209
  j = s->save_j;
#line 210
  t = s->save_t;
#line 211
  alphaSize = s->save_alphaSize;
#line 212
  nGroups = s->save_nGroups;
#line 213
  nSelectors = s->save_nSelectors;
#line 214
  EOB = s->save_EOB;
#line 215
  groupNo = s->save_groupNo;
#line 216
  groupPos = s->save_groupPos;
#line 217
  nextSym = s->save_nextSym;
#line 218
  nblockMAX = s->save_nblockMAX;
#line 219
  nblock = s->save_nblock;
#line 220
  es = s->save_es;
#line 221
  N = s->save_N;
#line 222
  curr = s->save_curr;
#line 223
  zt = s->save_zt;
#line 224
  zn = s->save_zn;
#line 225
  zvec = s->save_zvec;
#line 226
  zj = s->save_zj;
#line 227
  gSel = s->save_gSel;
#line 228
  gMinlen = s->save_gMinlen;
#line 229
  gLimit = s->save_gLimit;
#line 230
  gBase = s->save_gBase;
#line 231
  gPerm = s->save_gPerm;
#line 233
  retVal = 0;
#line 235
  switch (s->state) {
  case 10: 
#line 237
  s->state = 10;
#line 237
  while (1) {
#line 237
    if (s->bsLive >= 8) {
#line 237
      v = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 237
      s->bsLive -= 8;
#line 237
      uc = (UChar )v;
#line 237
      break;
    }
#line 237
    if ((s->strm)->avail_in == 0U) {
#line 237
      retVal = 0;
#line 237
      goto save_state_and_return;
    }
#line 237
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 237
    s->bsLive += 8;
#line 237
    ((s->strm)->next_in) ++;
#line 237
    ((s->strm)->avail_in) --;
#line 237
    ((s->strm)->total_in_lo32) ++;
#line 237
    if ((s->strm)->total_in_lo32 == 0U) {
#line 237
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 238
  if ((int )uc != 66) {
#line 238
    retVal = -5;
#line 238
    goto save_state_and_return;
  }
  case 11: 
#line 240
  s->state = 11;
#line 240
  while (1) {
#line 240
    if (s->bsLive >= 8) {
#line 240
      v___0 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 240
      s->bsLive -= 8;
#line 240
      uc = (UChar )v___0;
#line 240
      break;
    }
#line 240
    if ((s->strm)->avail_in == 0U) {
#line 240
      retVal = 0;
#line 240
      goto save_state_and_return;
    }
#line 240
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 240
    s->bsLive += 8;
#line 240
    ((s->strm)->next_in) ++;
#line 240
    ((s->strm)->avail_in) --;
#line 240
    ((s->strm)->total_in_lo32) ++;
#line 240
    if ((s->strm)->total_in_lo32 == 0U) {
#line 240
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 241
  if ((int )uc != 90) {
#line 241
    retVal = -5;
#line 241
    goto save_state_and_return;
  }
  case 12: 
#line 243
  s->state = 12;
#line 243
  while (1) {
#line 243
    if (s->bsLive >= 8) {
#line 243
      v___1 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 243
      s->bsLive -= 8;
#line 243
      uc = (UChar )v___1;
#line 243
      break;
    }
#line 243
    if ((s->strm)->avail_in == 0U) {
#line 243
      retVal = 0;
#line 243
      goto save_state_and_return;
    }
#line 243
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 243
    s->bsLive += 8;
#line 243
    ((s->strm)->next_in) ++;
#line 243
    ((s->strm)->avail_in) --;
#line 243
    ((s->strm)->total_in_lo32) ++;
#line 243
    if ((s->strm)->total_in_lo32 == 0U) {
#line 243
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 244
  if ((int )uc != 104) {
#line 244
    retVal = -5;
#line 244
    goto save_state_and_return;
  }
  case 13: 
#line 246
  s->state = 13;
#line 246
  while (1) {
#line 246
    if (s->bsLive >= 8) {
#line 246
      v___2 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 246
      s->bsLive -= 8;
#line 246
      s->blockSize100k = (Int32 )v___2;
#line 246
      break;
    }
#line 246
    if ((s->strm)->avail_in == 0U) {
#line 246
      retVal = 0;
#line 246
      goto save_state_and_return;
    }
#line 246
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 246
    s->bsLive += 8;
#line 246
    ((s->strm)->next_in) ++;
#line 246
    ((s->strm)->avail_in) --;
#line 246
    ((s->strm)->total_in_lo32) ++;
#line 246
    if ((s->strm)->total_in_lo32 == 0U) {
#line 246
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 247
  if (s->blockSize100k < 49) {
#line 248
    retVal = -5;
#line 248
    goto save_state_and_return;
  } else
#line 247
  if (s->blockSize100k > 57) {
#line 248
    retVal = -5;
#line 248
    goto save_state_and_return;
  }
#line 249
  s->blockSize100k -= 48;
#line 251
  if (s->smallDecompress) {
#line 252
    tmp = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(UInt16 )),
                             1);
#line 252
    s->ll16 = (UInt16 *)tmp;
#line 253
    tmp___0 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar )),
                                 1);
#line 253
    s->ll4 = (UChar *)tmp___0;
#line 256
    if ((unsigned long )s->ll16 == (unsigned long )((void *)0)) {
#line 256
      retVal = -3;
#line 256
      goto save_state_and_return;
    } else
#line 256
    if ((unsigned long )s->ll4 == (unsigned long )((void *)0)) {
#line 256
      retVal = -3;
#line 256
      goto save_state_and_return;
    }
  } else {
#line 258
    tmp___1 = (*(strm->bzalloc))(strm->opaque, (int )((unsigned long )(s->blockSize100k * 100000) * sizeof(Int32 )),
                                 1);
#line 258
    s->tt = (UInt32 *)tmp___1;
#line 259
    if ((unsigned long )s->tt == (unsigned long )((void *)0)) {
#line 259
      retVal = -3;
#line 259
      goto save_state_and_return;
    }
  }
  case 14: 
#line 262
  s->state = 14;
#line 262
  while (1) {
#line 262
    if (s->bsLive >= 8) {
#line 262
      v___3 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 262
      s->bsLive -= 8;
#line 262
      uc = (UChar )v___3;
#line 262
      break;
    }
#line 262
    if ((s->strm)->avail_in == 0U) {
#line 262
      retVal = 0;
#line 262
      goto save_state_and_return;
    }
#line 262
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 262
    s->bsLive += 8;
#line 262
    ((s->strm)->next_in) ++;
#line 262
    ((s->strm)->avail_in) --;
#line 262
    ((s->strm)->total_in_lo32) ++;
#line 262
    if ((s->strm)->total_in_lo32 == 0U) {
#line 262
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 264
  if ((int )uc == 23) {
#line 264
    goto endhdr_2;
  }
#line 265
  if ((int )uc != 49) {
#line 265
    retVal = -4;
#line 265
    goto save_state_and_return;
  }
  case 15: 
#line 266
  s->state = 15;
#line 266
  while (1) {
#line 266
    if (s->bsLive >= 8) {
#line 266
      v___4 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 266
      s->bsLive -= 8;
#line 266
      uc = (UChar )v___4;
#line 266
      break;
    }
#line 266
    if ((s->strm)->avail_in == 0U) {
#line 266
      retVal = 0;
#line 266
      goto save_state_and_return;
    }
#line 266
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 266
    s->bsLive += 8;
#line 266
    ((s->strm)->next_in) ++;
#line 266
    ((s->strm)->avail_in) --;
#line 266
    ((s->strm)->total_in_lo32) ++;
#line 266
    if ((s->strm)->total_in_lo32 == 0U) {
#line 266
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 267
  if ((int )uc != 65) {
#line 267
    retVal = -4;
#line 267
    goto save_state_and_return;
  }
  case 16: 
#line 268
  s->state = 16;
#line 268
  while (1) {
#line 268
    if (s->bsLive >= 8) {
#line 268
      v___5 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 268
      s->bsLive -= 8;
#line 268
      uc = (UChar )v___5;
#line 268
      break;
    }
#line 268
    if ((s->strm)->avail_in == 0U) {
#line 268
      retVal = 0;
#line 268
      goto save_state_and_return;
    }
#line 268
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 268
    s->bsLive += 8;
#line 268
    ((s->strm)->next_in) ++;
#line 268
    ((s->strm)->avail_in) --;
#line 268
    ((s->strm)->total_in_lo32) ++;
#line 268
    if ((s->strm)->total_in_lo32 == 0U) {
#line 268
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 269
  if ((int )uc != 89) {
#line 269
    retVal = -4;
#line 269
    goto save_state_and_return;
  }
  case 17: 
#line 270
  s->state = 17;
#line 270
  while (1) {
#line 270
    if (s->bsLive >= 8) {
#line 270
      v___6 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 270
      s->bsLive -= 8;
#line 270
      uc = (UChar )v___6;
#line 270
      break;
    }
#line 270
    if ((s->strm)->avail_in == 0U) {
#line 270
      retVal = 0;
#line 270
      goto save_state_and_return;
    }
#line 270
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 270
    s->bsLive += 8;
#line 270
    ((s->strm)->next_in) ++;
#line 270
    ((s->strm)->avail_in) --;
#line 270
    ((s->strm)->total_in_lo32) ++;
#line 270
    if ((s->strm)->total_in_lo32 == 0U) {
#line 270
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 271
  if ((int )uc != 38) {
#line 271
    retVal = -4;
#line 271
    goto save_state_and_return;
  }
  case 18: 
#line 272
  s->state = 18;
#line 272
  while (1) {
#line 272
    if (s->bsLive >= 8) {
#line 272
      v___7 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 272
      s->bsLive -= 8;
#line 272
      uc = (UChar )v___7;
#line 272
      break;
    }
#line 272
    if ((s->strm)->avail_in == 0U) {
#line 272
      retVal = 0;
#line 272
      goto save_state_and_return;
    }
#line 272
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 272
    s->bsLive += 8;
#line 272
    ((s->strm)->next_in) ++;
#line 272
    ((s->strm)->avail_in) --;
#line 272
    ((s->strm)->total_in_lo32) ++;
#line 272
    if ((s->strm)->total_in_lo32 == 0U) {
#line 272
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 273
  if ((int )uc != 83) {
#line 273
    retVal = -4;
#line 273
    goto save_state_and_return;
  }
  case 19: 
#line 274
  s->state = 19;
#line 274
  while (1) {
#line 274
    if (s->bsLive >= 8) {
#line 274
      v___8 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 274
      s->bsLive -= 8;
#line 274
      uc = (UChar )v___8;
#line 274
      break;
    }
#line 274
    if ((s->strm)->avail_in == 0U) {
#line 274
      retVal = 0;
#line 274
      goto save_state_and_return;
    }
#line 274
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 274
    s->bsLive += 8;
#line 274
    ((s->strm)->next_in) ++;
#line 274
    ((s->strm)->avail_in) --;
#line 274
    ((s->strm)->total_in_lo32) ++;
#line 274
    if ((s->strm)->total_in_lo32 == 0U) {
#line 274
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 275
  if ((int )uc != 89) {
#line 275
    retVal = -4;
#line 275
    goto save_state_and_return;
  }
#line 277
  (s->currBlockNo) ++;
#line 278
  if (s->verbosity >= 2) {
#line 279
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n    [%d: huff+mtf ",
            s->currBlockNo);
  }
#line 281
  s->storedBlockCRC = (UInt32 )0;
  case 20: 
#line 282
  s->state = 20;
#line 282
  while (1) {
#line 282
    if (s->bsLive >= 8) {
#line 282
      v___9 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 282
      s->bsLive -= 8;
#line 282
      uc = (UChar )v___9;
#line 282
      break;
    }
#line 282
    if ((s->strm)->avail_in == 0U) {
#line 282
      retVal = 0;
#line 282
      goto save_state_and_return;
    }
#line 282
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 282
    s->bsLive += 8;
#line 282
    ((s->strm)->next_in) ++;
#line 282
    ((s->strm)->avail_in) --;
#line 282
    ((s->strm)->total_in_lo32) ++;
#line 282
    if ((s->strm)->total_in_lo32 == 0U) {
#line 282
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 283
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 21: 
#line 284
  s->state = 21;
#line 284
  while (1) {
#line 284
    if (s->bsLive >= 8) {
#line 284
      v___10 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 284
      s->bsLive -= 8;
#line 284
      uc = (UChar )v___10;
#line 284
      break;
    }
#line 284
    if ((s->strm)->avail_in == 0U) {
#line 284
      retVal = 0;
#line 284
      goto save_state_and_return;
    }
#line 284
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 284
    s->bsLive += 8;
#line 284
    ((s->strm)->next_in) ++;
#line 284
    ((s->strm)->avail_in) --;
#line 284
    ((s->strm)->total_in_lo32) ++;
#line 284
    if ((s->strm)->total_in_lo32 == 0U) {
#line 284
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 285
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 22: 
#line 286
  s->state = 22;
#line 286
  while (1) {
#line 286
    if (s->bsLive >= 8) {
#line 286
      v___11 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 286
      s->bsLive -= 8;
#line 286
      uc = (UChar )v___11;
#line 286
      break;
    }
#line 286
    if ((s->strm)->avail_in == 0U) {
#line 286
      retVal = 0;
#line 286
      goto save_state_and_return;
    }
#line 286
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 286
    s->bsLive += 8;
#line 286
    ((s->strm)->next_in) ++;
#line 286
    ((s->strm)->avail_in) --;
#line 286
    ((s->strm)->total_in_lo32) ++;
#line 286
    if ((s->strm)->total_in_lo32 == 0U) {
#line 286
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 287
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 23: 
#line 288
  s->state = 23;
#line 288
  while (1) {
#line 288
    if (s->bsLive >= 8) {
#line 288
      v___12 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 288
      s->bsLive -= 8;
#line 288
      uc = (UChar )v___12;
#line 288
      break;
    }
#line 288
    if ((s->strm)->avail_in == 0U) {
#line 288
      retVal = 0;
#line 288
      goto save_state_and_return;
    }
#line 288
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 288
    s->bsLive += 8;
#line 288
    ((s->strm)->next_in) ++;
#line 288
    ((s->strm)->avail_in) --;
#line 288
    ((s->strm)->total_in_lo32) ++;
#line 288
    if ((s->strm)->total_in_lo32 == 0U) {
#line 288
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 289
  s->storedBlockCRC = (s->storedBlockCRC << 8) | (UInt32 )uc;
  case 24: 
#line 291
  s->state = 24;
#line 291
  while (1) {
#line 291
    if (s->bsLive >= 1) {
#line 291
      v___13 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 291
      (s->bsLive) --;
#line 291
      s->blockRandomised = (Bool )v___13;
#line 291
      break;
    }
#line 291
    if ((s->strm)->avail_in == 0U) {
#line 291
      retVal = 0;
#line 291
      goto save_state_and_return;
    }
#line 291
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 291
    s->bsLive += 8;
#line 291
    ((s->strm)->next_in) ++;
#line 291
    ((s->strm)->avail_in) --;
#line 291
    ((s->strm)->total_in_lo32) ++;
#line 291
    if ((s->strm)->total_in_lo32 == 0U) {
#line 291
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 293
  s->origPtr = 0;
  case 25: 
#line 294
  s->state = 25;
#line 294
  while (1) {
#line 294
    if (s->bsLive >= 8) {
#line 294
      v___14 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 294
      s->bsLive -= 8;
#line 294
      uc = (UChar )v___14;
#line 294
      break;
    }
#line 294
    if ((s->strm)->avail_in == 0U) {
#line 294
      retVal = 0;
#line 294
      goto save_state_and_return;
    }
#line 294
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 294
    s->bsLive += 8;
#line 294
    ((s->strm)->next_in) ++;
#line 294
    ((s->strm)->avail_in) --;
#line 294
    ((s->strm)->total_in_lo32) ++;
#line 294
    if ((s->strm)->total_in_lo32 == 0U) {
#line 294
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 295
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 26: 
#line 296
  s->state = 26;
#line 296
  while (1) {
#line 296
    if (s->bsLive >= 8) {
#line 296
      v___15 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 296
      s->bsLive -= 8;
#line 296
      uc = (UChar )v___15;
#line 296
      break;
    }
#line 296
    if ((s->strm)->avail_in == 0U) {
#line 296
      retVal = 0;
#line 296
      goto save_state_and_return;
    }
#line 296
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 296
    s->bsLive += 8;
#line 296
    ((s->strm)->next_in) ++;
#line 296
    ((s->strm)->avail_in) --;
#line 296
    ((s->strm)->total_in_lo32) ++;
#line 296
    if ((s->strm)->total_in_lo32 == 0U) {
#line 296
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 297
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
  case 27: 
#line 298
  s->state = 27;
#line 298
  while (1) {
#line 298
    if (s->bsLive >= 8) {
#line 298
      v___16 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 298
      s->bsLive -= 8;
#line 298
      uc = (UChar )v___16;
#line 298
      break;
    }
#line 298
    if ((s->strm)->avail_in == 0U) {
#line 298
      retVal = 0;
#line 298
      goto save_state_and_return;
    }
#line 298
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 298
    s->bsLive += 8;
#line 298
    ((s->strm)->next_in) ++;
#line 298
    ((s->strm)->avail_in) --;
#line 298
    ((s->strm)->total_in_lo32) ++;
#line 298
    if ((s->strm)->total_in_lo32 == 0U) {
#line 298
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 299
  s->origPtr = (s->origPtr << 8) | (Int32 )uc;
#line 301
  if (s->origPtr < 0) {
#line 302
    retVal = -4;
#line 302
    goto save_state_and_return;
  }
#line 303
  if (s->origPtr > 10 + 100000 * s->blockSize100k) {
#line 304
    retVal = -4;
#line 304
    goto save_state_and_return;
  }
#line 307
  i = 0;
#line 307
  while (i < 16) {
    case 28: 
#line 308
    s->state = 28;
#line 308
    while (1) {
#line 308
      if (s->bsLive >= 1) {
#line 308
        v___17 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 308
        (s->bsLive) --;
#line 308
        uc = (UChar )v___17;
#line 308
        break;
      }
#line 308
      if ((s->strm)->avail_in == 0U) {
#line 308
        retVal = 0;
#line 308
        goto save_state_and_return;
      }
#line 308
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 308
      s->bsLive += 8;
#line 308
      ((s->strm)->next_in) ++;
#line 308
      ((s->strm)->avail_in) --;
#line 308
      ((s->strm)->total_in_lo32) ++;
#line 308
      if ((s->strm)->total_in_lo32 == 0U) {
#line 308
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 309
    if ((int )uc == 1) {
#line 310
      s->inUse16[i] = (Bool )1;
    } else {
#line 311
      s->inUse16[i] = (Bool )0;
    }
#line 307
    i ++;
  }
#line 314
  i = 0;
#line 314
  while (i < 256) {
#line 314
    s->inUse[i] = (Bool )0;
#line 314
    i ++;
  }
#line 316
  i = 0;
#line 316
  while (i < 16) {
#line 317
    if (s->inUse16[i]) {
#line 318
      j = 0;
#line 318
      while (j < 16) {
        case 29: 
#line 319
        s->state = 29;
#line 319
        while (1) {
#line 319
          if (s->bsLive >= 1) {
#line 319
            v___18 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 319
            (s->bsLive) --;
#line 319
            uc = (UChar )v___18;
#line 319
            break;
          }
#line 319
          if ((s->strm)->avail_in == 0U) {
#line 319
            retVal = 0;
#line 319
            goto save_state_and_return;
          }
#line 319
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 319
          s->bsLive += 8;
#line 319
          ((s->strm)->next_in) ++;
#line 319
          ((s->strm)->avail_in) --;
#line 319
          ((s->strm)->total_in_lo32) ++;
#line 319
          if ((s->strm)->total_in_lo32 == 0U) {
#line 319
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 320
        if ((int )uc == 1) {
#line 320
          s->inUse[i * 16 + j] = (Bool )1;
        }
#line 318
        j ++;
      }
    }
#line 316
    i ++;
  }
#line 322
  makeMaps_d(s);
#line 323
  if (s->nInUse == 0) {
#line 323
    retVal = -4;
#line 323
    goto save_state_and_return;
  }
#line 324
  alphaSize = s->nInUse + 2;
  case 30: 
#line 327
  s->state = 30;
#line 327
  while (1) {
#line 327
    if (s->bsLive >= 3) {
#line 327
      v___19 = (s->bsBuff >> (s->bsLive - 3)) & (unsigned int )((1 << 3) - 1);
#line 327
      s->bsLive -= 3;
#line 327
      nGroups = (Int32 )v___19;
#line 327
      break;
    }
#line 327
    if ((s->strm)->avail_in == 0U) {
#line 327
      retVal = 0;
#line 327
      goto save_state_and_return;
    }
#line 327
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 327
    s->bsLive += 8;
#line 327
    ((s->strm)->next_in) ++;
#line 327
    ((s->strm)->avail_in) --;
#line 327
    ((s->strm)->total_in_lo32) ++;
#line 327
    if ((s->strm)->total_in_lo32 == 0U) {
#line 327
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 328
  if (nGroups < 2) {
#line 328
    retVal = -4;
#line 328
    goto save_state_and_return;
  } else
#line 328
  if (nGroups > 6) {
#line 328
    retVal = -4;
#line 328
    goto save_state_and_return;
  }
  case 31: 
#line 329
  s->state = 31;
#line 329
  while (1) {
#line 329
    if (s->bsLive >= 15) {
#line 329
      v___20 = (s->bsBuff >> (s->bsLive - 15)) & (unsigned int )((1 << 15) - 1);
#line 329
      s->bsLive -= 15;
#line 329
      nSelectors = (Int32 )v___20;
#line 329
      break;
    }
#line 329
    if ((s->strm)->avail_in == 0U) {
#line 329
      retVal = 0;
#line 329
      goto save_state_and_return;
    }
#line 329
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 329
    s->bsLive += 8;
#line 329
    ((s->strm)->next_in) ++;
#line 329
    ((s->strm)->avail_in) --;
#line 329
    ((s->strm)->total_in_lo32) ++;
#line 329
    if ((s->strm)->total_in_lo32 == 0U) {
#line 329
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 330
  if (nSelectors < 1) {
#line 330
    retVal = -4;
#line 330
    goto save_state_and_return;
  }
#line 331
  i = 0;
#line 331
  while (i < nSelectors) {
#line 332
    j = 0;
#line 333
    while (1) {
      case 32: 
#line 334
      s->state = 32;
#line 334
      while (1) {
#line 334
        if (s->bsLive >= 1) {
#line 334
          v___21 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 334
          (s->bsLive) --;
#line 334
          uc = (UChar )v___21;
#line 334
          break;
        }
#line 334
        if ((s->strm)->avail_in == 0U) {
#line 334
          retVal = 0;
#line 334
          goto save_state_and_return;
        }
#line 334
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 334
        s->bsLive += 8;
#line 334
        ((s->strm)->next_in) ++;
#line 334
        ((s->strm)->avail_in) --;
#line 334
        ((s->strm)->total_in_lo32) ++;
#line 334
        if ((s->strm)->total_in_lo32 == 0U) {
#line 334
          ((s->strm)->total_in_hi32) ++;
        }
      }
#line 335
      if ((int )uc == 0) {
#line 335
        break;
      }
#line 336
      j ++;
#line 337
      if (j >= nGroups) {
#line 337
        retVal = -4;
#line 337
        goto save_state_and_return;
      }
    }
#line 339
    s->selectorMtf[i] = (UChar )j;
#line 331
    i ++;
  }
#line 345
  v___22 = (UChar )0;
#line 345
  while ((int )v___22 < nGroups) {
#line 345
    pos[v___22] = v___22;
#line 345
    v___22 = (UChar )((int )v___22 + 1);
  }
#line 347
  i = 0;
#line 347
  while (i < nSelectors) {
#line 348
    v___22 = s->selectorMtf[i];
#line 349
    tmp___2 = pos[v___22];
#line 350
    while ((int )v___22 > 0) {
#line 350
      pos[v___22] = pos[(int )v___22 - 1];
#line 350
      v___22 = (UChar )((int )v___22 - 1);
    }
#line 351
    pos[0] = tmp___2;
#line 352
    s->selector[i] = tmp___2;
#line 347
    i ++;
  }
#line 357
  t = 0;
#line 357
  while (t < nGroups) {
    case 33: 
#line 358
    s->state = 33;
#line 358
    while (1) {
#line 358
      if (s->bsLive >= 5) {
#line 358
        v___23 = (s->bsBuff >> (s->bsLive - 5)) & (unsigned int )((1 << 5) - 1);
#line 358
        s->bsLive -= 5;
#line 358
        curr = (Int32 )v___23;
#line 358
        break;
      }
#line 358
      if ((s->strm)->avail_in == 0U) {
#line 358
        retVal = 0;
#line 358
        goto save_state_and_return;
      }
#line 358
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 358
      s->bsLive += 8;
#line 358
      ((s->strm)->next_in) ++;
#line 358
      ((s->strm)->avail_in) --;
#line 358
      ((s->strm)->total_in_lo32) ++;
#line 358
      if ((s->strm)->total_in_lo32 == 0U) {
#line 358
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 359
    i = 0;
#line 359
    while (i < alphaSize) {
#line 360
      while (1) {
#line 361
        if (curr < 1) {
#line 361
          retVal = -4;
#line 361
          goto save_state_and_return;
        } else
#line 361
        if (curr > 20) {
#line 361
          retVal = -4;
#line 361
          goto save_state_and_return;
        }
        case 34: 
#line 362
        s->state = 34;
#line 362
        while (1) {
#line 362
          if (s->bsLive >= 1) {
#line 362
            v___24 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 362
            (s->bsLive) --;
#line 362
            uc = (UChar )v___24;
#line 362
            break;
          }
#line 362
          if ((s->strm)->avail_in == 0U) {
#line 362
            retVal = 0;
#line 362
            goto save_state_and_return;
          }
#line 362
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 362
          s->bsLive += 8;
#line 362
          ((s->strm)->next_in) ++;
#line 362
          ((s->strm)->avail_in) --;
#line 362
          ((s->strm)->total_in_lo32) ++;
#line 362
          if ((s->strm)->total_in_lo32 == 0U) {
#line 362
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 363
        if ((int )uc == 0) {
#line 363
          break;
        }
        case 35: 
#line 364
        s->state = 35;
#line 364
        while (1) {
#line 364
          if (s->bsLive >= 1) {
#line 364
            v___25 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 364
            (s->bsLive) --;
#line 364
            uc = (UChar )v___25;
#line 364
            break;
          }
#line 364
          if ((s->strm)->avail_in == 0U) {
#line 364
            retVal = 0;
#line 364
            goto save_state_and_return;
          }
#line 364
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 364
          s->bsLive += 8;
#line 364
          ((s->strm)->next_in) ++;
#line 364
          ((s->strm)->avail_in) --;
#line 364
          ((s->strm)->total_in_lo32) ++;
#line 364
          if ((s->strm)->total_in_lo32 == 0U) {
#line 364
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 365
        if ((int )uc == 0) {
#line 365
          curr ++;
        } else {
#line 365
          curr --;
        }
      }
#line 367
      s->len[t][i] = (UChar )curr;
#line 359
      i ++;
    }
#line 357
    t ++;
  }
#line 372
  t = 0;
#line 372
  while (t < nGroups) {
#line 373
    minLen = 32;
#line 374
    maxLen = 0;
#line 375
    i = 0;
#line 375
    while (i < alphaSize) {
#line 376
      if ((int )s->len[t][i] > maxLen) {
#line 376
        maxLen = (Int32 )s->len[t][i];
      }
#line 377
      if ((int )s->len[t][i] < minLen) {
#line 377
        minLen = (Int32 )s->len[t][i];
      }
#line 375
      i ++;
    }
#line 379
    BZ2_hbCreateDecodeTables(& s->limit[t][0], & s->base[t][0], & s->perm[t][0], & s->len[t][0],
                             minLen, maxLen, alphaSize);
#line 386
    s->minLens[t] = minLen;
#line 372
    t ++;
  }
#line 391
  EOB = s->nInUse + 1;
#line 392
  nblockMAX = 100000 * s->blockSize100k;
#line 393
  groupNo = -1;
#line 394
  groupPos = 0;
#line 396
  i = 0;
#line 396
  while (i <= 255) {
#line 396
    s->unzftab[i] = 0;
#line 396
    i ++;
  }
#line 401
  kk = 4095;
#line 402
  ii = 15;
#line 402
  while (ii >= 0) {
#line 403
    jj = 15;
#line 403
    while (jj >= 0) {
#line 404
      s->mtfa[kk] = (UChar )(ii * 16 + jj);
#line 405
      kk --;
#line 403
      jj --;
    }
#line 407
    s->mtfbase[ii] = kk + 1;
#line 402
    ii --;
  }
#line 412
  nblock = 0;
#line 413
  if (groupPos == 0) {
#line 413
    groupNo ++;
#line 413
    if (groupNo >= nSelectors) {
#line 413
      retVal = -4;
#line 413
      goto save_state_and_return;
    }
#line 413
    groupPos = 50;
#line 413
    gSel = (Int32 )s->selector[groupNo];
#line 413
    gMinlen = s->minLens[gSel];
#line 413
    gLimit = & s->limit[gSel][0];
#line 413
    gPerm = & s->perm[gSel][0];
#line 413
    gBase = & s->base[gSel][0];
  }
#line 413
  groupPos --;
#line 413
  zn = gMinlen;
  case 36: 
#line 413
  s->state = 36;
#line 413
  while (1) {
#line 413
    if (s->bsLive >= zn) {
#line 413
      v___26 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 413
      s->bsLive -= zn;
#line 413
      zvec = (Int32 )v___26;
#line 413
      break;
    }
#line 413
    if ((s->strm)->avail_in == 0U) {
#line 413
      retVal = 0;
#line 413
      goto save_state_and_return;
    }
#line 413
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 413
    s->bsLive += 8;
#line 413
    ((s->strm)->next_in) ++;
#line 413
    ((s->strm)->avail_in) --;
#line 413
    ((s->strm)->total_in_lo32) ++;
#line 413
    if ((s->strm)->total_in_lo32 == 0U) {
#line 413
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 413
  while (1) {
#line 413
    if (zn > 20) {
#line 413
      retVal = -4;
#line 413
      goto save_state_and_return;
    }
#line 413
    if (zvec <= *(gLimit + zn)) {
#line 413
      break;
    }
#line 413
    zn ++;
    case 37: 
#line 413
    s->state = 37;
#line 413
    while (1) {
#line 413
      if (s->bsLive >= 1) {
#line 413
        v___27 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 413
        (s->bsLive) --;
#line 413
        zj = (Int32 )v___27;
#line 413
        break;
      }
#line 413
      if ((s->strm)->avail_in == 0U) {
#line 413
        retVal = 0;
#line 413
        goto save_state_and_return;
      }
#line 413
      s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 413
      s->bsLive += 8;
#line 413
      ((s->strm)->next_in) ++;
#line 413
      ((s->strm)->avail_in) --;
#line 413
      ((s->strm)->total_in_lo32) ++;
#line 413
      if ((s->strm)->total_in_lo32 == 0U) {
#line 413
        ((s->strm)->total_in_hi32) ++;
      }
    }
#line 413
    zvec = (zvec << 1) | zj;
  }
#line 413
  if (zvec - *(gBase + zn) < 0) {
#line 413
    retVal = -4;
#line 413
    goto save_state_and_return;
  } else
#line 413
  if (zvec - *(gBase + zn) >= 258) {
#line 413
    retVal = -4;
#line 413
    goto save_state_and_return;
  }
#line 413
  nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 415
  while (! (nextSym == EOB)) {
#line 419
    if (nextSym == 0) {
#line 419
      goto _L;
    } else
#line 419
    if (nextSym == 1) {
      _L: /* CIL Label */ 
#line 421
      es = -1;
#line 422
      N = 1;
#line 423
      while (1) {
#line 424
        if (nextSym == 0) {
#line 424
          es += N;
        } else
#line 425
        if (nextSym == 1) {
#line 425
          es += 2 * N;
        }
#line 426
        N *= 2;
#line 427
        if (groupPos == 0) {
#line 427
          groupNo ++;
#line 427
          if (groupNo >= nSelectors) {
#line 427
            retVal = -4;
#line 427
            goto save_state_and_return;
          }
#line 427
          groupPos = 50;
#line 427
          gSel = (Int32 )s->selector[groupNo];
#line 427
          gMinlen = s->minLens[gSel];
#line 427
          gLimit = & s->limit[gSel][0];
#line 427
          gPerm = & s->perm[gSel][0];
#line 427
          gBase = & s->base[gSel][0];
        }
#line 427
        groupPos --;
#line 427
        zn = gMinlen;
        case 38: 
#line 427
        s->state = 38;
#line 427
        while (1) {
#line 427
          if (s->bsLive >= zn) {
#line 427
            v___28 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 427
            s->bsLive -= zn;
#line 427
            zvec = (Int32 )v___28;
#line 427
            break;
          }
#line 427
          if ((s->strm)->avail_in == 0U) {
#line 427
            retVal = 0;
#line 427
            goto save_state_and_return;
          }
#line 427
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 427
          s->bsLive += 8;
#line 427
          ((s->strm)->next_in) ++;
#line 427
          ((s->strm)->avail_in) --;
#line 427
          ((s->strm)->total_in_lo32) ++;
#line 427
          if ((s->strm)->total_in_lo32 == 0U) {
#line 427
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 427
        while (1) {
#line 427
          if (zn > 20) {
#line 427
            retVal = -4;
#line 427
            goto save_state_and_return;
          }
#line 427
          if (zvec <= *(gLimit + zn)) {
#line 427
            break;
          }
#line 427
          zn ++;
          case 39: 
#line 427
          s->state = 39;
#line 427
          while (1) {
#line 427
            if (s->bsLive >= 1) {
#line 427
              v___29 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 427
              (s->bsLive) --;
#line 427
              zj = (Int32 )v___29;
#line 427
              break;
            }
#line 427
            if ((s->strm)->avail_in == 0U) {
#line 427
              retVal = 0;
#line 427
              goto save_state_and_return;
            }
#line 427
            s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 427
            s->bsLive += 8;
#line 427
            ((s->strm)->next_in) ++;
#line 427
            ((s->strm)->avail_in) --;
#line 427
            ((s->strm)->total_in_lo32) ++;
#line 427
            if ((s->strm)->total_in_lo32 == 0U) {
#line 427
              ((s->strm)->total_in_hi32) ++;
            }
          }
#line 427
          zvec = (zvec << 1) | zj;
        }
#line 427
        if (zvec - *(gBase + zn) < 0) {
#line 427
          retVal = -4;
#line 427
          goto save_state_and_return;
        } else
#line 427
        if (zvec - *(gBase + zn) >= 258) {
#line 427
          retVal = -4;
#line 427
          goto save_state_and_return;
        }
#line 427
        nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 423
        if (! (nextSym == 0)) {
#line 423
          if (! (nextSym == 1)) {
#line 423
            break;
          }
        }
      }
#line 431
      es ++;
#line 432
      uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];
#line 433
      s->unzftab[uc] += es;
#line 435
      if (s->smallDecompress) {
#line 436
        while (es > 0) {
#line 437
          if (nblock >= nblockMAX) {
#line 437
            retVal = -4;
#line 437
            goto save_state_and_return;
          }
#line 438
          *(s->ll16 + nblock) = (UInt16 )uc;
#line 439
          nblock ++;
#line 440
          es --;
        }
      } else {
#line 443
        while (es > 0) {
#line 444
          if (nblock >= nblockMAX) {
#line 444
            retVal = -4;
#line 444
            goto save_state_and_return;
          }
#line 445
          *(s->tt + nblock) = (UInt32 )uc;
#line 446
          nblock ++;
#line 447
          es --;
        }
      }
#line 450
      continue;
    } else {
#line 454
      if (nblock >= nblockMAX) {
#line 454
        retVal = -4;
#line 454
        goto save_state_and_return;
      }
#line 460
      nn = (UInt32 )(nextSym - 1);
#line 462
      if (nn < 16U) {
#line 464
        pp = s->mtfbase[0];
#line 465
        uc = s->mtfa[(UInt32 )pp + nn];
#line 466
        while (nn > 3U) {
#line 467
          z = (Int32 )((UInt32 )pp + nn);
#line 468
          s->mtfa[z] = s->mtfa[z - 1];
#line 469
          s->mtfa[z - 1] = s->mtfa[z - 2];
#line 470
          s->mtfa[z - 2] = s->mtfa[z - 3];
#line 471
          s->mtfa[z - 3] = s->mtfa[z - 4];
#line 472
          nn -= 4U;
        }
#line 474
        while (nn > 0U) {
#line 475
          s->mtfa[(UInt32 )pp + nn] = s->mtfa[((UInt32 )pp + nn) - 1U];
#line 475
          nn --;
        }
#line 477
        s->mtfa[pp] = uc;
      } else {
#line 480
        lno = (Int32 )(nn / 16U);
#line 481
        off = (Int32 )(nn % 16U);
#line 482
        pp = s->mtfbase[lno] + off;
#line 483
        uc = s->mtfa[pp];
#line 484
        while (pp > s->mtfbase[lno]) {
#line 485
          s->mtfa[pp] = s->mtfa[pp - 1];
#line 485
          pp --;
        }
#line 487
        (s->mtfbase[lno]) ++;
#line 488
        while (lno > 0) {
#line 489
          (s->mtfbase[lno]) --;
#line 490
          s->mtfa[s->mtfbase[lno]] = s->mtfa[(s->mtfbase[lno - 1] + 16) - 1];
#line 492
          lno --;
        }
#line 494
        (s->mtfbase[0]) --;
#line 495
        s->mtfa[s->mtfbase[0]] = uc;
#line 496
        if (s->mtfbase[0] == 0) {
#line 497
          kk___0 = 4095;
#line 498
          ii___0 = 15;
#line 498
          while (ii___0 >= 0) {
#line 499
            jj___0 = 15;
#line 499
            while (jj___0 >= 0) {
#line 500
              s->mtfa[kk___0] = s->mtfa[s->mtfbase[ii___0] + jj___0];
#line 501
              kk___0 --;
#line 499
              jj___0 --;
            }
#line 503
            s->mtfbase[ii___0] = kk___0 + 1;
#line 498
            ii___0 --;
          }
        }
      }
#line 510
      (s->unzftab[s->seqToUnseq[uc]]) ++;
#line 511
      if (s->smallDecompress) {
#line 512
        *(s->ll16 + nblock) = (UInt16 )s->seqToUnseq[uc];
      } else {
#line 513
        *(s->tt + nblock) = (UInt32 )s->seqToUnseq[uc];
      }
#line 514
      nblock ++;
#line 516
      if (groupPos == 0) {
#line 516
        groupNo ++;
#line 516
        if (groupNo >= nSelectors) {
#line 516
          retVal = -4;
#line 516
          goto save_state_and_return;
        }
#line 516
        groupPos = 50;
#line 516
        gSel = (Int32 )s->selector[groupNo];
#line 516
        gMinlen = s->minLens[gSel];
#line 516
        gLimit = & s->limit[gSel][0];
#line 516
        gPerm = & s->perm[gSel][0];
#line 516
        gBase = & s->base[gSel][0];
      }
#line 516
      groupPos --;
#line 516
      zn = gMinlen;
      case 40: 
#line 516
      s->state = 40;
#line 516
      while (1) {
#line 516
        if (s->bsLive >= zn) {
#line 516
          v___30 = (s->bsBuff >> (s->bsLive - zn)) & (unsigned int )((1 << zn) - 1);
#line 516
          s->bsLive -= zn;
#line 516
          zvec = (Int32 )v___30;
#line 516
          break;
        }
#line 516
        if ((s->strm)->avail_in == 0U) {
#line 516
          retVal = 0;
#line 516
          goto save_state_and_return;
        }
#line 516
        s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 516
        s->bsLive += 8;
#line 516
        ((s->strm)->next_in) ++;
#line 516
        ((s->strm)->avail_in) --;
#line 516
        ((s->strm)->total_in_lo32) ++;
#line 516
        if ((s->strm)->total_in_lo32 == 0U) {
#line 516
          ((s->strm)->total_in_hi32) ++;
        }
      }
#line 516
      while (1) {
#line 516
        if (zn > 20) {
#line 516
          retVal = -4;
#line 516
          goto save_state_and_return;
        }
#line 516
        if (zvec <= *(gLimit + zn)) {
#line 516
          break;
        }
#line 516
        zn ++;
        case 41: 
#line 516
        s->state = 41;
#line 516
        while (1) {
#line 516
          if (s->bsLive >= 1) {
#line 516
            v___31 = (s->bsBuff >> (s->bsLive - 1)) & (unsigned int )((1 << 1) - 1);
#line 516
            (s->bsLive) --;
#line 516
            zj = (Int32 )v___31;
#line 516
            break;
          }
#line 516
          if ((s->strm)->avail_in == 0U) {
#line 516
            retVal = 0;
#line 516
            goto save_state_and_return;
          }
#line 516
          s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 516
          s->bsLive += 8;
#line 516
          ((s->strm)->next_in) ++;
#line 516
          ((s->strm)->avail_in) --;
#line 516
          ((s->strm)->total_in_lo32) ++;
#line 516
          if ((s->strm)->total_in_lo32 == 0U) {
#line 516
            ((s->strm)->total_in_hi32) ++;
          }
        }
#line 516
        zvec = (zvec << 1) | zj;
      }
#line 516
      if (zvec - *(gBase + zn) < 0) {
#line 516
        retVal = -4;
#line 516
        goto save_state_and_return;
      } else
#line 516
      if (zvec - *(gBase + zn) >= 258) {
#line 516
        retVal = -4;
#line 516
        goto save_state_and_return;
      }
#line 516
      nextSym = *(gPerm + (zvec - *(gBase + zn)));
#line 517
      continue;
    }
  }
#line 524
  if (s->origPtr < 0) {
#line 525
    retVal = -4;
#line 525
    goto save_state_and_return;
  } else
#line 524
  if (s->origPtr >= nblock) {
#line 525
    retVal = -4;
#line 525
    goto save_state_and_return;
  }
#line 528
  s->cftab[0] = 0;
#line 529
  i = 1;
#line 529
  while (i <= 256) {
#line 529
    s->cftab[i] = s->unzftab[i - 1];
#line 529
    i ++;
  }
#line 530
  i = 1;
#line 530
  while (i <= 256) {
#line 530
    s->cftab[i] += s->cftab[i - 1];
#line 530
    i ++;
  }
#line 531
  i = 0;
#line 531
  while (i <= 256) {
#line 532
    if (s->cftab[i] < 0) {
#line 534
      retVal = -4;
#line 534
      goto save_state_and_return;
    } else
#line 532
    if (s->cftab[i] > nblock) {
#line 534
      retVal = -4;
#line 534
      goto save_state_and_return;
    }
#line 531
    i ++;
  }
#line 538
  s->state_out_len = 0;
#line 539
  s->state_out_ch = (UChar )0;
#line 540
  s->calculatedBlockCRC = (UInt32 )4294967295L;
#line 541
  s->state = 2;
#line 542
  if (s->verbosity >= 2) {
#line 542
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"rt+rld");
  }
#line 544
  if (s->smallDecompress) {
#line 547
    i = 0;
#line 547
    while (i <= 256) {
#line 547
      s->cftabCopy[i] = s->cftab[i];
#line 547
      i ++;
    }
#line 550
    i = 0;
#line 550
    while (i < nblock) {
#line 551
      uc = (UChar )*(s->ll16 + i);
#line 552
      *(s->ll16 + i) = (UInt16 )(s->cftabCopy[uc] & 65535);
#line 552
      if ((i & 1) == 0) {
#line 552
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 240) | (s->cftabCopy[uc] >> 16));
      } else {
#line 552
        *(s->ll4 + (i >> 1)) = (UChar )(((int )*(s->ll4 + (i >> 1)) & 15) | ((s->cftabCopy[uc] >> 16) << 4));
      }
#line 553
      (s->cftabCopy[uc]) ++;
#line 550
      i ++;
    }
#line 557
    i = s->origPtr;
#line 558
    j = (Int32 )((UInt32 )*(s->ll16 + i) | ((((UInt32 )*(s->ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
#line 559
    while (1) {
#line 560
      tmp___3 = (Int32 )((UInt32 )*(s->ll16 + j) | ((((UInt32 )*(s->ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 561
      *(s->ll16 + j) = (UInt16 )(i & 65535);
#line 561
      if ((j & 1) == 0) {
#line 561
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 240) | (i >> 16));
      } else {
#line 561
        *(s->ll4 + (j >> 1)) = (UChar )(((int )*(s->ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
      }
#line 562
      i = j;
#line 563
      j = tmp___3;
#line 559
      if (! (i != s->origPtr)) {
#line 559
        break;
      }
    }
#line 567
    s->tPos = (UInt32 )s->origPtr;
#line 568
    s->nblock_used = 0;
#line 569
    if (s->blockRandomised) {
#line 570
      s->rNToGo = 0;
#line 570
      s->rTPos = 0;
#line 571
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 571
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 571
      (s->nblock_used) ++;
#line 572
      if (s->rNToGo == 0) {
#line 572
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 572
        (s->rTPos) ++;
#line 572
        if (s->rTPos == 512) {
#line 572
          s->rTPos = 0;
        }
      }
#line 572
      (s->rNToGo) --;
#line 572
      if (s->rNToGo == 1) {
#line 572
        tmp___4 = 1;
      } else {
#line 572
        tmp___4 = 0;
      }
#line 572
      s->k0 ^= tmp___4;
    } else {
#line 574
      s->k0 = BZ2_indexIntoF((Int32 )s->tPos, s->cftab);
#line 574
      s->tPos = (UInt32 )*(s->ll16 + s->tPos) | ((((UInt32 )*(s->ll4 + (s->tPos >> 1)) >> ((s->tPos << 2) & 4U)) & 15U) << 16);
#line 574
      (s->nblock_used) ++;
    }
  } else {
#line 580
    i = 0;
#line 580
    while (i < nblock) {
#line 581
      uc = (UChar )(*(s->tt + i) & 255U);
#line 582
      *(s->tt + s->cftab[uc]) |= (unsigned int )(i << 8);
#line 583
      (s->cftab[uc]) ++;
#line 580
      i ++;
    }
#line 586
    s->tPos = *(s->tt + s->origPtr) >> 8;
#line 587
    s->nblock_used = 0;
#line 588
    if (s->blockRandomised) {
#line 589
      s->rNToGo = 0;
#line 589
      s->rTPos = 0;
#line 590
      s->tPos = *(s->tt + s->tPos);
#line 590
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 590
      s->tPos >>= 8;
#line 590
      (s->nblock_used) ++;
#line 591
      if (s->rNToGo == 0) {
#line 591
        s->rNToGo = BZ2_rNums[s->rTPos];
#line 591
        (s->rTPos) ++;
#line 591
        if (s->rTPos == 512) {
#line 591
          s->rTPos = 0;
        }
      }
#line 591
      (s->rNToGo) --;
#line 591
      if (s->rNToGo == 1) {
#line 591
        tmp___5 = 1;
      } else {
#line 591
        tmp___5 = 0;
      }
#line 591
      s->k0 ^= tmp___5;
    } else {
#line 593
      s->tPos = *(s->tt + s->tPos);
#line 593
      s->k0 = (Int32 )((UChar )(s->tPos & 255U));
#line 593
      s->tPos >>= 8;
#line 593
      (s->nblock_used) ++;
    }
  }
#line 598
  retVal = 0;
#line 598
  goto save_state_and_return;
  endhdr_2: 
  case 42: 
#line 604
  s->state = 42;
#line 604
  while (1) {
#line 604
    if (s->bsLive >= 8) {
#line 604
      v___32 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 604
      s->bsLive -= 8;
#line 604
      uc = (UChar )v___32;
#line 604
      break;
    }
#line 604
    if ((s->strm)->avail_in == 0U) {
#line 604
      retVal = 0;
#line 604
      goto save_state_and_return;
    }
#line 604
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 604
    s->bsLive += 8;
#line 604
    ((s->strm)->next_in) ++;
#line 604
    ((s->strm)->avail_in) --;
#line 604
    ((s->strm)->total_in_lo32) ++;
#line 604
    if ((s->strm)->total_in_lo32 == 0U) {
#line 604
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 605
  if ((int )uc != 114) {
#line 605
    retVal = -4;
#line 605
    goto save_state_and_return;
  }
  case 43: 
#line 606
  s->state = 43;
#line 606
  while (1) {
#line 606
    if (s->bsLive >= 8) {
#line 606
      v___33 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 606
      s->bsLive -= 8;
#line 606
      uc = (UChar )v___33;
#line 606
      break;
    }
#line 606
    if ((s->strm)->avail_in == 0U) {
#line 606
      retVal = 0;
#line 606
      goto save_state_and_return;
    }
#line 606
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 606
    s->bsLive += 8;
#line 606
    ((s->strm)->next_in) ++;
#line 606
    ((s->strm)->avail_in) --;
#line 606
    ((s->strm)->total_in_lo32) ++;
#line 606
    if ((s->strm)->total_in_lo32 == 0U) {
#line 606
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 607
  if ((int )uc != 69) {
#line 607
    retVal = -4;
#line 607
    goto save_state_and_return;
  }
  case 44: 
#line 608
  s->state = 44;
#line 608
  while (1) {
#line 608
    if (s->bsLive >= 8) {
#line 608
      v___34 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 608
      s->bsLive -= 8;
#line 608
      uc = (UChar )v___34;
#line 608
      break;
    }
#line 608
    if ((s->strm)->avail_in == 0U) {
#line 608
      retVal = 0;
#line 608
      goto save_state_and_return;
    }
#line 608
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 608
    s->bsLive += 8;
#line 608
    ((s->strm)->next_in) ++;
#line 608
    ((s->strm)->avail_in) --;
#line 608
    ((s->strm)->total_in_lo32) ++;
#line 608
    if ((s->strm)->total_in_lo32 == 0U) {
#line 608
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 609
  if ((int )uc != 56) {
#line 609
    retVal = -4;
#line 609
    goto save_state_and_return;
  }
  case 45: 
#line 610
  s->state = 45;
#line 610
  while (1) {
#line 610
    if (s->bsLive >= 8) {
#line 610
      v___35 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 610
      s->bsLive -= 8;
#line 610
      uc = (UChar )v___35;
#line 610
      break;
    }
#line 610
    if ((s->strm)->avail_in == 0U) {
#line 610
      retVal = 0;
#line 610
      goto save_state_and_return;
    }
#line 610
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 610
    s->bsLive += 8;
#line 610
    ((s->strm)->next_in) ++;
#line 610
    ((s->strm)->avail_in) --;
#line 610
    ((s->strm)->total_in_lo32) ++;
#line 610
    if ((s->strm)->total_in_lo32 == 0U) {
#line 610
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 611
  if ((int )uc != 80) {
#line 611
    retVal = -4;
#line 611
    goto save_state_and_return;
  }
  case 46: 
#line 612
  s->state = 46;
#line 612
  while (1) {
#line 612
    if (s->bsLive >= 8) {
#line 612
      v___36 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 612
      s->bsLive -= 8;
#line 612
      uc = (UChar )v___36;
#line 612
      break;
    }
#line 612
    if ((s->strm)->avail_in == 0U) {
#line 612
      retVal = 0;
#line 612
      goto save_state_and_return;
    }
#line 612
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 612
    s->bsLive += 8;
#line 612
    ((s->strm)->next_in) ++;
#line 612
    ((s->strm)->avail_in) --;
#line 612
    ((s->strm)->total_in_lo32) ++;
#line 612
    if ((s->strm)->total_in_lo32 == 0U) {
#line 612
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 613
  if ((int )uc != 144) {
#line 613
    retVal = -4;
#line 613
    goto save_state_and_return;
  }
#line 615
  s->storedCombinedCRC = (UInt32 )0;
  case 47: 
#line 616
  s->state = 47;
#line 616
  while (1) {
#line 616
    if (s->bsLive >= 8) {
#line 616
      v___37 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 616
      s->bsLive -= 8;
#line 616
      uc = (UChar )v___37;
#line 616
      break;
    }
#line 616
    if ((s->strm)->avail_in == 0U) {
#line 616
      retVal = 0;
#line 616
      goto save_state_and_return;
    }
#line 616
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 616
    s->bsLive += 8;
#line 616
    ((s->strm)->next_in) ++;
#line 616
    ((s->strm)->avail_in) --;
#line 616
    ((s->strm)->total_in_lo32) ++;
#line 616
    if ((s->strm)->total_in_lo32 == 0U) {
#line 616
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 617
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 48: 
#line 618
  s->state = 48;
#line 618
  while (1) {
#line 618
    if (s->bsLive >= 8) {
#line 618
      v___38 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 618
      s->bsLive -= 8;
#line 618
      uc = (UChar )v___38;
#line 618
      break;
    }
#line 618
    if ((s->strm)->avail_in == 0U) {
#line 618
      retVal = 0;
#line 618
      goto save_state_and_return;
    }
#line 618
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 618
    s->bsLive += 8;
#line 618
    ((s->strm)->next_in) ++;
#line 618
    ((s->strm)->avail_in) --;
#line 618
    ((s->strm)->total_in_lo32) ++;
#line 618
    if ((s->strm)->total_in_lo32 == 0U) {
#line 618
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 619
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 49: 
#line 620
  s->state = 49;
#line 620
  while (1) {
#line 620
    if (s->bsLive >= 8) {
#line 620
      v___39 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 620
      s->bsLive -= 8;
#line 620
      uc = (UChar )v___39;
#line 620
      break;
    }
#line 620
    if ((s->strm)->avail_in == 0U) {
#line 620
      retVal = 0;
#line 620
      goto save_state_and_return;
    }
#line 620
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 620
    s->bsLive += 8;
#line 620
    ((s->strm)->next_in) ++;
#line 620
    ((s->strm)->avail_in) --;
#line 620
    ((s->strm)->total_in_lo32) ++;
#line 620
    if ((s->strm)->total_in_lo32 == 0U) {
#line 620
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 621
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
  case 50: 
#line 622
  s->state = 50;
#line 622
  while (1) {
#line 622
    if (s->bsLive >= 8) {
#line 622
      v___40 = (s->bsBuff >> (s->bsLive - 8)) & (unsigned int )((1 << 8) - 1);
#line 622
      s->bsLive -= 8;
#line 622
      uc = (UChar )v___40;
#line 622
      break;
    }
#line 622
    if ((s->strm)->avail_in == 0U) {
#line 622
      retVal = 0;
#line 622
      goto save_state_and_return;
    }
#line 622
    s->bsBuff = (s->bsBuff << 8) | (UInt32 )*((UChar *)(s->strm)->next_in);
#line 622
    s->bsLive += 8;
#line 622
    ((s->strm)->next_in) ++;
#line 622
    ((s->strm)->avail_in) --;
#line 622
    ((s->strm)->total_in_lo32) ++;
#line 622
    if ((s->strm)->total_in_lo32 == 0U) {
#line 622
      ((s->strm)->total_in_hi32) ++;
    }
  }
#line 623
  s->storedCombinedCRC = (s->storedCombinedCRC << 8) | (UInt32 )uc;
#line 625
  s->state = 1;
#line 626
  retVal = 4;
#line 626
  goto save_state_and_return;
  default: 
#line 628
  BZ2_bz__AssertH__fail(4001);
  }
#line 631
  BZ2_bz__AssertH__fail(4002);
  save_state_and_return: 
#line 635
  s->save_i = i;
#line 636
  s->save_j = j;
#line 637
  s->save_t = t;
#line 638
  s->save_alphaSize = alphaSize;
#line 639
  s->save_nGroups = nGroups;
#line 640
  s->save_nSelectors = nSelectors;
#line 641
  s->save_EOB = EOB;
#line 642
  s->save_groupNo = groupNo;
#line 643
  s->save_groupPos = groupPos;
#line 644
  s->save_nextSym = nextSym;
#line 645
  s->save_nblockMAX = nblockMAX;
#line 646
  s->save_nblock = nblock;
#line 647
  s->save_es = es;
#line 648
  s->save_N = N;
#line 649
  s->save_curr = curr;
#line 650
  s->save_zt = zt;
#line 651
  s->save_zn = zn;
#line 652
  s->save_zvec = zvec;
#line 653
  s->save_zj = zj;
#line 654
  s->save_gSel = gSel;
#line 655
  s->save_gMinlen = gMinlen;
#line 656
  s->save_gLimit = gLimit;
#line 657
  s->save_gBase = gBase;
#line 658
  s->save_gPerm = gPerm;
#line 660
  return (retVal);
}
}
#line 1 "huffman.o"
#pragma merger("0","/tmp/cil-D6MpaUPs.i","")
#line 103 "huffman.c"
void BZ2_hbMakeCodeLengths(UChar *len , Int32 *freq , Int32 alphaSize , Int32 maxLen ) 
{ 
  Int32 nNodes ;
  Int32 nHeap ;
  Int32 n1 ;
  Int32 n2 ;
  Int32 i ;
  Int32 j ;
  Int32 k ;
  Bool tooLong ;
  Int32 heap[260] ;
  Int32 weight[516] ;
  Int32 parent[516] ;
  int tmp ;
  Int32 zz ;
  Int32 tmp___0 ;
  Int32 zz___0 ;
  Int32 yy ;
  Int32 tmp___1 ;
  Int32 zz___1 ;
  Int32 yy___0 ;
  Int32 tmp___2 ;
  Int32 tmp___3 ;
  int tmp___4 ;
  Int32 zz___2 ;
  Int32 tmp___5 ;

  {
#line 119
  i = 0;
#line 119
  while (i < alphaSize) {
#line 120
    if (*(freq + i) == 0) {
#line 120
      tmp = 1;
    } else {
#line 120
      tmp = *(freq + i);
    }
#line 120
    weight[i + 1] = tmp << 8;
#line 119
    i ++;
  }
#line 122
  while (1) {
#line 124
    nNodes = alphaSize;
#line 125
    nHeap = 0;
#line 127
    heap[0] = 0;
#line 128
    weight[0] = 0;
#line 129
    parent[0] = -2;
#line 131
    i = 1;
#line 131
    while (i <= alphaSize) {
#line 132
      parent[i] = -1;
#line 133
      nHeap ++;
#line 134
      heap[nHeap] = i;
#line 135
      zz = nHeap;
#line 135
      tmp___0 = heap[zz];
#line 135
      while (weight[tmp___0] < weight[heap[zz >> 1]]) {
#line 135
        heap[zz] = heap[zz >> 1];
#line 135
        zz >>= 1;
      }
#line 135
      heap[zz] = tmp___0;
#line 131
      i ++;
    }
#line 138
    if (! (nHeap < 260)) {
#line 138
      BZ2_bz__AssertH__fail(2001);
    }
#line 140
    while (nHeap > 1) {
#line 141
      n1 = heap[1];
#line 141
      heap[1] = heap[nHeap];
#line 141
      nHeap --;
#line 141
      zz___0 = 1;
#line 141
      tmp___1 = heap[zz___0];
#line 141
      while (1) {
#line 141
        yy = zz___0 << 1;
#line 141
        if (yy > nHeap) {
#line 141
          break;
        }
#line 141
        if (yy < nHeap) {
#line 141
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 141
            yy ++;
          }
        }
#line 141
        if (weight[tmp___1] < weight[heap[yy]]) {
#line 141
          break;
        }
#line 141
        heap[zz___0] = heap[yy];
#line 141
        zz___0 = yy;
      }
#line 141
      heap[zz___0] = tmp___1;
#line 142
      n2 = heap[1];
#line 142
      heap[1] = heap[nHeap];
#line 142
      nHeap --;
#line 142
      zz___1 = 1;
#line 142
      tmp___2 = heap[zz___1];
#line 142
      while (1) {
#line 142
        yy___0 = zz___1 << 1;
#line 142
        if (yy___0 > nHeap) {
#line 142
          break;
        }
#line 142
        if (yy___0 < nHeap) {
#line 142
          if (weight[heap[yy___0 + 1]] < weight[heap[yy___0]]) {
#line 142
            yy___0 ++;
          }
        }
#line 142
        if (weight[tmp___2] < weight[heap[yy___0]]) {
#line 142
          break;
        }
#line 142
        heap[zz___1] = heap[yy___0];
#line 142
        zz___1 = yy___0;
      }
#line 142
      heap[zz___1] = tmp___2;
#line 143
      nNodes ++;
#line 144
      tmp___3 = nNodes;
#line 144
      parent[n2] = tmp___3;
#line 144
      parent[n1] = tmp___3;
#line 145
      if ((weight[n1] & 255) > (weight[n2] & 255)) {
#line 145
        tmp___4 = weight[n1] & 255;
      } else {
#line 145
        tmp___4 = weight[n2] & 255;
      }
#line 145
      weight[nNodes] = (Int32 )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )(1 + tmp___4));
#line 146
      parent[nNodes] = -1;
#line 147
      nHeap ++;
#line 148
      heap[nHeap] = nNodes;
#line 149
      zz___2 = nHeap;
#line 149
      tmp___5 = heap[zz___2];
#line 149
      while (weight[tmp___5] < weight[heap[zz___2 >> 1]]) {
#line 149
        heap[zz___2] = heap[zz___2 >> 1];
#line 149
        zz___2 >>= 1;
      }
#line 149
      heap[zz___2] = tmp___5;
    }
#line 152
    if (! (nNodes < 516)) {
#line 152
      BZ2_bz__AssertH__fail(2002);
    }
#line 154
    tooLong = (Bool )0;
#line 155
    i = 1;
#line 155
    while (i <= alphaSize) {
#line 156
      j = 0;
#line 157
      k = i;
#line 158
      while (parent[k] >= 0) {
#line 158
        k = parent[k];
#line 158
        j ++;
      }
#line 159
      *(len + (i - 1)) = (UChar )j;
#line 160
      if (j > maxLen) {
#line 160
        tooLong = (Bool )1;
      }
#line 155
      i ++;
    }
#line 163
    if (! tooLong) {
#line 163
      break;
    }
#line 182
    i = 1;
#line 182
    while (i <= alphaSize) {
#line 183
      j = weight[i] >> 8;
#line 184
      j = 1 + j / 2;
#line 185
      weight[i] = j << 8;
#line 182
      i ++;
    }
  }
#line 188
  return;
}
}
#line 192 "huffman.c"
void BZ2_hbAssignCodes(Int32 *code , UChar *length , Int32 minLen , Int32 maxLen ,
                       Int32 alphaSize ) 
{ 
  Int32 n ;
  Int32 vec ;
  Int32 i ;

  {
#line 200
  vec = 0;
#line 201
  n = minLen;
#line 201
  while (n <= maxLen) {
#line 202
    i = 0;
#line 202
    while (i < alphaSize) {
#line 203
      if ((int )*(length + i) == n) {
#line 203
        *(code + i) = vec;
#line 203
        vec ++;
      }
#line 202
      i ++;
    }
#line 204
    vec <<= 1;
#line 201
    n ++;
  }
#line 206
  return;
}
}
#line 210 "huffman.c"
void BZ2_hbCreateDecodeTables(Int32 *limit , Int32 *base , Int32 *perm , UChar *length ,
                              Int32 minLen , Int32 maxLen , Int32 alphaSize ) 
{ 
  Int32 pp ;
  Int32 i ;
  Int32 j ;
  Int32 vec ;

  {
#line 220
  pp = 0;
#line 221
  i = minLen;
#line 221
  while (i <= maxLen) {
#line 222
    j = 0;
#line 222
    while (j < alphaSize) {
#line 223
      if ((int )*(length + j) == i) {
#line 223
        *(perm + pp) = j;
#line 223
        pp ++;
      }
#line 222
      j ++;
    }
#line 221
    i ++;
  }
#line 225
  i = 0;
#line 225
  while (i < 23) {
#line 225
    *(base + i) = 0;
#line 225
    i ++;
  }
#line 226
  i = 0;
#line 226
  while (i < alphaSize) {
#line 226
    (*(base + ((int )*(length + i) + 1))) ++;
#line 226
    i ++;
  }
#line 228
  i = 1;
#line 228
  while (i < 23) {
#line 228
    *(base + i) += *(base + (i - 1));
#line 228
    i ++;
  }
#line 230
  i = 0;
#line 230
  while (i < 23) {
#line 230
    *(limit + i) = 0;
#line 230
    i ++;
  }
#line 231
  vec = 0;
#line 233
  i = minLen;
#line 233
  while (i <= maxLen) {
#line 234
    vec += *(base + (i + 1)) - *(base + i);
#line 235
    *(limit + i) = vec - 1;
#line 236
    vec <<= 1;
#line 233
    i ++;
  }
#line 238
  i = minLen + 1;
#line 238
  while (i <= maxLen) {
#line 239
    *(base + i) = ((*(limit + (i - 1)) + 1) << 1) - *(base + i);
#line 238
    i ++;
  }
#line 240
  return;
}
}
#line 1 "randtable.o"
#pragma merger("0","/tmp/cil-CKRvzXZV.i","")
#line 66 "randtable.c"
Int32 BZ2_rNums[512]  = 
#line 66 "randtable.c"
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};

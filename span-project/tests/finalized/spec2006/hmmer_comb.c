/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 26 "./gki.h"
struct gki_elem {
   char *key ;
   int idx ;
   struct gki_elem *nxt ;
};
#line 36 "./gki.h"
struct __anonstruct_GKI_29 {
   struct gki_elem **table ;
   int primelevel ;
   int nhash ;
   int nkeys ;
};
#line 36 "./gki.h"
typedef struct __anonstruct_GKI_29 GKI;
#line 112 "./msa.h"
struct msa_struct {
   char **aseq ;
   char **sqname ;
   float *wgt ;
   int alen ;
   int nseq ;
   int flags ;
   int type ;
   char *name ;
   char *desc ;
   char *acc ;
   char *au ;
   char *ss_cons ;
   char *sa_cons ;
   char *rf ;
   char **sqacc ;
   char **sqdesc ;
   char **ss ;
   char **sa ;
   float cutoff[6] ;
   int cutoff_is_set[6] ;
   char **comment ;
   int ncomment ;
   int alloc_ncomment ;
   char **gf_tag ;
   char **gf ;
   int ngf ;
   int alloc_ngf ;
   char **gs_tag ;
   char ***gs ;
   GKI *gs_idx ;
   int ngs ;
   char **gc_tag ;
   char **gc ;
   GKI *gc_idx ;
   int ngc ;
   char **gr_tag ;
   char ***gr ;
   GKI *gr_idx ;
   int ngr ;
   GKI *index ;
   int nseqalloc ;
   int nseqlump ;
   int *sqlen ;
   int *sslen ;
   int *salen ;
   int lastidx ;
};
#line 112 "./msa.h"
typedef struct msa_struct MSA;
#line 101 "./structs.h"
struct plan7_s {
   char *name ;
   char *acc ;
   char *desc ;
   char *rf ;
   char *cs ;
   char *ca ;
   char *comlog ;
   int nseq ;
   char *ctime ;
   int *map ;
   int checksum ;
   int *tpri ;
   int *mpri ;
   int *ipri ;
   float ga1 ;
   float ga2 ;
   float tc1 ;
   float tc2 ;
   float nc1 ;
   float nc2 ;
   int M ;
   float **t ;
   float **mat ;
   float **ins ;
   float tbd1 ;
   float xt[4][2] ;
   float *begin ;
   float *end ;
   float null[20] ;
   float p1 ;
   int **tsc ;
   int **msc ;
   int **isc ;
   int xsc[4][2] ;
   int *bsc ;
   int *esc ;
   int *tsc_mem ;
   int *msc_mem ;
   int *isc_mem ;
   int *bsc_mem ;
   int *esc_mem ;
   int **dnam ;
   int **dnai ;
   int dna2 ;
   int dna4 ;
   float mu ;
   float lambda ;
   int flags ;
};
#line 289 "./structs.h"
struct dpmatrix_s {
   int **xmx ;
   int **mmx ;
   int **imx ;
   int **dmx ;
   void *xmx_mem ;
   void *mmx_mem ;
   void *imx_mem ;
   void *dmx_mem ;
   int maxN ;
   int maxM ;
   int padN ;
   int padM ;
};
#line 320 "./structs.h"
struct dpshadow_s {
   char **xtb ;
   char **mtb ;
   char **itb ;
   char **dtb ;
   int *esrc ;
};
#line 374 "./structs.h"
struct p7trace_s {
   int tlen ;
   char *statetype ;
   int *nodeidx ;
   int *pos ;
};
#line 447 "./structs.h"
struct fancyali_s {
   char *rfline ;
   char *csline ;
   char *model ;
   char *mline ;
   char *aseq ;
   int len ;
   char *query ;
   char *target ;
   int sqfrom ;
   int sqto ;
};
#line 470 "./structs.h"
struct hit_s {
   double sortkey ;
   float score ;
   double pvalue ;
   float mothersc ;
   double motherp ;
   char *name ;
   char *acc ;
   char *desc ;
   int sqfrom ;
   int sqto ;
   int sqlen ;
   int hmmfrom ;
   int hmmto ;
   int hmmlen ;
   int domidx ;
   int ndom ;
   struct fancyali_s *ali ;
};
#line 497 "./structs.h"
struct tophit_s {
   struct hit_s **hit ;
   struct hit_s *unsrt ;
   int alloc ;
   int num ;
   int lump ;
};
#line 518
enum __anonenum_autocut_30 {
    CUT_NONE = 0,
    CUT_GA = 1,
    CUT_NC = 2,
    CUT_TC = 3
} ;
#line 518 "./structs.h"
struct threshold_s {
   float globT ;
   double globE ;
   float domT ;
   double domE ;
   enum __anonenum_autocut_30 autocut ;
   int Z ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 385 "./structs.h"
struct p7prior_s {
   int strategy ;
   int tnum ;
   float tq[200] ;
   float t[200][7] ;
   int mnum ;
   float mq[200] ;
   float m[200][20] ;
   int inum ;
   float iq[200] ;
   float i[200][20] ;
};
#line 419 "./structs.h"
struct histogram_s {
   int *histogram ;
   int min ;
   int max ;
   int highscore ;
   int lowscore ;
   int lumpsize ;
   int total ;
   float *expect ;
   int fit_type ;
   float param[3] ;
   float chisq ;
   float chip ;
};
#line 40 "./squid.h"
typedef unsigned short sqd_uint16;
#line 41 "./squid.h"
typedef unsigned int sqd_uint32;
#line 42 "./squid.h"
typedef unsigned long long sqd_uint64;
#line 35 "./ssi.h"
union __anonunion_off_30 {
   sqd_uint32 i32 ;
   sqd_uint64 i64 ;
};
#line 35 "./ssi.h"
struct ssioffset_s {
   char mode ;
   union __anonunion_off_30 off ;
};
#line 42 "./ssi.h"
typedef struct ssioffset_s SSIOFFSET;
#line 49 "./ssi.h"
struct ssifile_s {
   FILE *fp ;
   sqd_uint32 flags ;
   sqd_uint16 nfiles ;
   sqd_uint32 nprimary ;
   sqd_uint32 nsecondary ;
   sqd_uint32 flen ;
   sqd_uint32 plen ;
   sqd_uint32 slen ;
   sqd_uint32 frecsize ;
   sqd_uint32 precsize ;
   sqd_uint32 srecsize ;
   SSIOFFSET foffset ;
   SSIOFFSET poffset ;
   SSIOFFSET soffset ;
   char imode ;
   char smode ;
   char **filename ;
   sqd_uint32 *fileformat ;
   sqd_uint32 *fileflags ;
   sqd_uint32 *bpl ;
   sqd_uint32 *rpl ;
};
#line 76 "./ssi.h"
typedef struct ssifile_s SSIFILE;
#line 332 "./structs.h"
struct hmmfile_s {
   FILE *f ;
   SSIFILE *ssi ;
   int (*parser)(struct hmmfile_s * , struct plan7_s ** ) ;
   int is_binary ;
   int byteswap ;
   int is_seekable ;
   int mode ;
   SSIOFFSET offset ;
};
#line 350 "./structs.h"
typedef struct hmmfile_s HMMFILE;
#line 560 "./structs.h"
struct basic_state {
   float t[3] ;
   float p[20] ;
};
#line 567 "./structs.h"
struct plan9_s {
   int M ;
   struct basic_state *ins ;
   struct basic_state *mat ;
   struct basic_state *del ;
   float null[20] ;
   char *name ;
   char *ref ;
   char *cs ;
   float *xray ;
   int flags ;
};
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 330 "./squid.h"
struct opt_s {
   char *name ;
   int single ;
   int argtype ;
};
#line 34 "./stopwatch.h"
struct stopwatch_s {
   time_t t0 ;
   clock_t cpu0 ;
   double elapsed ;
   double user ;
   double sys ;
};
#line 46 "./stopwatch.h"
typedef struct stopwatch_s Stopwatch_t;
#line 84 "./squid.h"
struct seqinfo_s {
   int flags ;
   char name[64] ;
   char id[64] ;
   char acc[64] ;
   char desc[128] ;
   int len ;
   int start ;
   int stop ;
   int olen ;
   int type ;
   char *ss ;
   char *sa ;
};
#line 98 "./squid.h"
typedef struct seqinfo_s SQINFO;
#line 186 "./msa.h"
struct msafile_struct {
   FILE *f ;
   char *fname ;
   int linenumber ;
   char *buf ;
   int buflen ;
   SSIFILE *ssi ;
   int do_gzip ;
   int do_stdin ;
   int format ;
};
#line 186 "./msa.h"
typedef struct msafile_struct MSAFILE;
#line 197 "./squid.h"
struct ReadSeqVars {
   FILE *f ;
   char *fname ;
   int linenumber ;
   char *buf ;
   int buflen ;
   int ssimode ;
   SSIOFFSET ssioffset ;
   SSIOFFSET r_off ;
   SSIOFFSET d_off ;
   int rpl ;
   int lastrpl ;
   int maxrpl ;
   int bpl ;
   int lastbpl ;
   int maxbpl ;
   char *seq ;
   SQINFO *sqinfo ;
   char *sp ;
   int seqlen ;
   int maxseq ;
   int format ;
   int do_gzip ;
   int do_stdin ;
   MSA *msa ;
   MSAFILE *afp ;
};
#line 240 "./squid.h"
typedef struct ReadSeqVars SQFILE;
#line 65 "./msa.h"
struct aliinfo_s {
   int flags ;
   int alen ;
   int nseq ;
   float *wgt ;
   char *cs ;
   char *rf ;
   struct seqinfo_s *sqinfo ;
   char *name ;
   char *desc ;
   char *acc ;
   char *au ;
   float tc1 ;
   float tc2 ;
   float nc1 ;
   float nc2 ;
   float ga1 ;
   float ga2 ;
};
#line 83 "./msa.h"
typedef struct aliinfo_s AINFO;
#line 258 "./squid.h"
struct phylo_s {
   int parent ;
   int left ;
   int right ;
   float diff ;
   float lblen ;
   float rblen ;
   char *is_in ;
   int incnum ;
};
#line 273
enum clust_strategy {
    CLUSTER_MEAN = 0,
    CLUSTER_MAX = 1,
    CLUSTER_MIN = 2
} ;
#line 282 "./squid.h"
struct intstack_s {
   int data ;
   struct intstack_s *nxt ;
};
#line 46 "./gsi.h"
struct gsi_s {
   FILE *gsifp ;
   sqd_uint16 nfiles ;
   sqd_uint32 recnum ;
};
#line 51 "./gsi.h"
typedef struct gsi_s GSIFILE;
#line 53 "./gsi.h"
struct gsikey_s {
   char key[32] ;
   sqd_uint16 filenum ;
   sqd_uint32 offset ;
};
#line 58 "./gsi.h"
struct gsiindex_s {
   char **filenames ;
   int *fmt ;
   sqd_uint16 nfiles ;
   struct gsikey_s *elems ;
   int nkeys ;
};
#line 349 "./squid.h"
struct sqd_regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 349 "./squid.h"
typedef struct sqd_regexp sqd_regexp;
#line 295 "hsregex.c"
struct comp {
   char *regparse ;
   int regnpar ;
   char *regcode ;
   char regdummy[3] ;
   long regsize ;
};
#line 821 "hsregex.c"
struct exec {
   char *reginput ;
   char *regbol ;
   char **regstartp ;
   char **regendp ;
};
#line 117 "./squid.h"
struct iupactype {
   char sym ;
   char symcomp ;
   char code ;
   char comp ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 25 "./rk.h"
typedef unsigned long Hashseq;
#line 91 "selex.c"
struct block_struc {
   int lcol ;
   int rcol ;
};
#line 32 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list___0;
#line 91 "./ssi.h"
struct ssipkey_s {
   char *key ;
   sqd_uint16 fnum ;
   SSIOFFSET r_off ;
   SSIOFFSET d_off ;
   sqd_uint32 len ;
};
#line 98 "./ssi.h"
struct ssiskey_s {
   char *key ;
   char *pkey ;
};
#line 102 "./ssi.h"
struct ssiindex_s {
   int smode ;
   int imode ;
   int external ;
   int max_ram ;
   char **filenames ;
   sqd_uint32 *fileformat ;
   sqd_uint32 *bpl ;
   sqd_uint32 *rpl ;
   sqd_uint32 flen ;
   sqd_uint16 nfiles ;
   struct ssipkey_s *pkeys ;
   sqd_uint32 plen ;
   sqd_uint32 nprimary ;
   char *ptmpfile ;
   FILE *ptmp ;
   struct ssiskey_s *skeys ;
   sqd_uint32 slen ;
   sqd_uint32 nsecondary ;
   char *stmpfile ;
   FILE *stmp ;
};
#line 127 "./ssi.h"
typedef struct ssiindex_s SSIINDEX;
#line 1 "alphabet.o"
#pragma merger("0","/tmp/cil-K8YyzvkN.i","")
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 125 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 126 "./squid.h"
char *stdcode1[65] ;
#line 150 "./sqfuncs.h"
void Die(char *format  , ...) ;
#line 151
void Warn(char *format  , ...) ;
#line 179
int Seqtype(char *seq ) ;
#line 220
void *sre_malloc(char *file , int line , size_t size ) ;
#line 57 "./structs.h"
char Alphabet[25] ;
#line 58
int Alphabet_type ;
#line 59
int Alphabet_size ;
#line 60
int Alphabet_iupac ;
#line 61
char Degenerate[24][20] ;
#line 62
int DegenCount[24] ;
#line 28 "./funcs.h"
void DetermineAlphabet(char **rseqs , int nseq ) ;
#line 29
void SetAlphabet(int type ) ;
#line 30
int SymbolIndex(char sym ) ;
#line 31
char *DigitizeSequence(char *seq , int L ) ;
#line 32
char *DedigitizeSequence(char *dsq , int L ) ;
#line 33
void DigitizeAlignment(MSA *msa , char ***ret_dsqs ) ;
#line 34
void P7CountSymbol(float *counters , char symidx , float wt ) ;
#line 35
void DefaultGeneticCode(int *aacode ) ;
#line 36
void DefaultCodonBias(float *codebias ) ;
#line 30 "alphabet.c"
static void set_degenerate(char iupac___0 , char *syms ) ;
#line 43 "alphabet.c"
void DetermineAlphabet(char **rseqs , int nseq ) 
{ 
  int idx ;
  int other ;
  int nucleic ;
  int amino ;
  int type ;
  int tmp ;

  {
#line 52
  type = 0;
#line 53
  amino = 0;
#line 53
  nucleic = amino;
#line 53
  other = nucleic;
#line 54
  idx = 0;
#line 54
  while (idx < nseq) {
#line 55
    tmp = Seqtype(*(rseqs + idx));
#line 55
    switch (tmp) {
    case 2: 
#line 56
    nucleic ++;
#line 56
    break;
    case 1: 
#line 57
    nucleic ++;
#line 57
    break;
    case 3: 
#line 58
    amino ++;
#line 58
    break;
    case 0: 
#line 59
    other ++;
#line 59
    break;
    default: 
#line 60
    Die((char *)"No such alphabet type");
    }
#line 54
    idx ++;
  }
#line 64
  if (nucleic == nseq) {
#line 64
    type = 2;
  } else
#line 65
  if (amino == nseq) {
#line 65
    type = 3;
  } else
#line 66
  if (nucleic > amino) {
#line 66
    if (nucleic > other) {
#line 67
      Warn((char *)"Looks like nucleic acid sequence, hope that\'s right");
#line 68
      type = 2;
    } else {
#line 66
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 70
  if (amino > nucleic) {
#line 70
    if (amino > other) {
#line 71
      Warn((char *)"Looks like amino acid sequence, hope that\'s right");
#line 72
      type = 3;
    } else {
#line 74
      Die((char *)"Sorry, I can\'t tell if that\'s protein or DNA");
    }
  } else {
#line 74
    Die((char *)"Sorry, I can\'t tell if that\'s protein or DNA");
  }
#line 78
  SetAlphabet(type);
#line 79
  return;
}
}
#line 87 "alphabet.c"
void SetAlphabet(int type ) 
{ 
  int x ;

  {
#line 109
  if (Alphabet_type != 0) {
#line 111
    if (type != Alphabet_type) {
#line 112
      Die((char *)"An alphabet type conflict occurred.\nYou probably mixed a DNA seq file with a protein model, or vice versa.");
    }
#line 118
    return;
  }
#line 121
  switch (type) {
  case 3: 
#line 123
  Alphabet_type = type;
#line 125
  strcpy((char * __restrict  )(Alphabet), (char const   * __restrict  )"ACDEFGHIKLMNPQRSTVWYUBZX");
#line 126
  Alphabet_size = 20;
#line 127
  Alphabet_iupac = 24;
#line 128
  x = 0;
#line 128
  while (x < Alphabet_iupac) {
#line 129
    memset((void *)(Degenerate[x]), 0, (size_t )Alphabet_size);
#line 128
    x ++;
  }
#line 131
  x = 0;
#line 131
  while (x < Alphabet_size) {
#line 132
    Degenerate[x][x] = (char)1;
#line 133
    DegenCount[x] = 1;
#line 131
    x ++;
  }
#line 135
  set_degenerate((char )'U', (char *)"S");
#line 136
  set_degenerate((char )'B', (char *)"ND");
#line 137
  set_degenerate((char )'Z', (char *)"QE");
#line 138
  set_degenerate((char )'X', (char *)"ACDEFGHIKLMNPQRSTVWY");
#line 139
  break;
  case 2: 
#line 141
  Alphabet_type = type;
#line 143
  strcpy((char * __restrict  )(Alphabet), (char const   * __restrict  )"ACGTUNRYMKSWHBVDX");
#line 144
  Alphabet_size = 4;
#line 145
  Alphabet_iupac = 17;
#line 146
  x = 0;
#line 146
  while (x < Alphabet_iupac) {
#line 147
    memset((void *)(Degenerate[x]), 0, (size_t )Alphabet_size);
#line 146
    x ++;
  }
#line 149
  x = 0;
#line 149
  while (x < Alphabet_size) {
#line 150
    Degenerate[x][x] = (char)1;
#line 151
    DegenCount[x] = 1;
#line 149
    x ++;
  }
#line 153
  set_degenerate((char )'U', (char *)"T");
#line 154
  set_degenerate((char )'N', (char *)"ACGT");
#line 155
  set_degenerate((char )'X', (char *)"ACGT");
#line 156
  set_degenerate((char )'R', (char *)"AG");
#line 157
  set_degenerate((char )'Y', (char *)"CT");
#line 158
  set_degenerate((char )'M', (char *)"AC");
#line 159
  set_degenerate((char )'K', (char *)"GT");
#line 160
  set_degenerate((char )'S', (char *)"CG");
#line 161
  set_degenerate((char )'W', (char *)"AT");
#line 162
  set_degenerate((char )'H', (char *)"ACT");
#line 163
  set_degenerate((char )'B', (char *)"CGT");
#line 164
  set_degenerate((char )'V', (char *)"ACG");
#line 165
  set_degenerate((char )'D', (char *)"AGT");
#line 166
  break;
  default: 
#line 167
  Die((char *)"No support for non-nucleic or protein alphabets");
  }
#line 174
  return;
}
}
#line 183 "alphabet.c"
int SymbolIndex(char sym ) 
{ 
  char *s___0 ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 187
  tmp___1 = toupper((int )sym);
#line 187
  s___0 = strchr((char const   *)(Alphabet), (int )((char )tmp___1));
#line 187
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 187
    tmp___0 = (long )(Alphabet_iupac - 1);
  } else {
#line 187
    tmp___0 = s___0 - Alphabet;
  }
#line 187
  return ((int )tmp___0);
}
}
#line 209 "alphabet.c"
char *DigitizeSequence(char *seq , int L ) 
{ 
  char *dsq ;
  int i___0 ;
  void *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 215
  tmp = sre_malloc((char *)"alphabet.c", 215, sizeof(char ) * (unsigned long )(L + 2));
#line 215
  dsq = (char *)tmp;
#line 216
  tmp___0 = (char )Alphabet_iupac;
#line 216
  *(dsq + (L + 1)) = tmp___0;
#line 216
  *(dsq + 0) = tmp___0;
#line 217
  i___0 = 1;
#line 217
  while (i___0 <= L) {
#line 218
    tmp___1 = SymbolIndex(*(seq + (i___0 - 1)));
#line 218
    *(dsq + i___0) = (char )tmp___1;
#line 217
    i___0 ++;
  }
#line 219
  return (dsq);
}
}
#line 229 "alphabet.c"
char *DedigitizeSequence(char *dsq , int L ) 
{ 
  char *seq ;
  int i___0 ;
  void *tmp ;

  {
#line 235
  tmp = sre_malloc((char *)"alphabet.c", 235, sizeof(char ) * (unsigned long )(L + 1));
#line 235
  seq = (char *)tmp;
#line 236
  i___0 = 0;
#line 236
  while (i___0 < L) {
#line 237
    *(seq + i___0) = Alphabet[(int )*(dsq + (i___0 + 1))];
#line 236
    i___0 ++;
  }
#line 238
  *(seq + L) = (char )'\000';
#line 239
  return (seq);
}
}
#line 256 "alphabet.c"
void DigitizeAlignment(MSA *msa , char ***ret_dsqs ) 
{ 
  char **dsq ;
  int idx ;
  int dpos ;
  int apos ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 264
  tmp = sre_malloc((char *)"alphabet.c", 264, sizeof(char *) * (unsigned long )msa->nseq);
#line 264
  dsq = (char **)tmp;
#line 265
  idx = 0;
#line 265
  while (idx < msa->nseq) {
#line 266
    tmp___0 = sre_malloc((char *)"alphabet.c", 266, sizeof(char ) * (unsigned long )(msa->alen + 2));
#line 266
    *(dsq + idx) = (char *)tmp___0;
#line 268
    *(*(dsq + idx) + 0) = (char )Alphabet_iupac;
#line 270
    apos = 0;
#line 270
    dpos = 1;
#line 270
    while (apos < msa->alen) {
#line 271
      if (! ((int )*(*(msa->aseq + idx) + apos) == 32)) {
#line 271
        if (! ((int )*(*(msa->aseq + idx) + apos) == 46)) {
#line 271
          if (! ((int )*(*(msa->aseq + idx) + apos) == 95)) {
#line 271
            if (! ((int )*(*(msa->aseq + idx) + apos) == 45)) {
#line 271
              if (! ((int )*(*(msa->aseq + idx) + apos) == 126)) {
#line 272
                tmp___1 = dpos;
#line 272
                dpos ++;
#line 272
                tmp___2 = SymbolIndex(*(*(msa->aseq + idx) + apos));
#line 272
                *(*(dsq + idx) + tmp___1) = (char )tmp___2;
              }
            }
          }
        }
      }
#line 270
      apos ++;
    }
#line 274
    *(*(dsq + idx) + dpos) = (char )Alphabet_iupac;
#line 265
    idx ++;
  }
#line 276
  *ret_dsqs = dsq;
#line 277
  return;
}
}
#line 292 "alphabet.c"
void P7CountSymbol(float *counters , char symidx , float wt ) 
{ 
  int x ;

  {
#line 297
  if ((int )symidx < Alphabet_size) {
#line 298
    *(counters + (int )symidx) += wt;
  } else {
#line 300
    x = 0;
#line 300
    while (x < Alphabet_size) {
#line 301
      if (Degenerate[(int )symidx][x]) {
#line 302
        *(counters + x) += wt / (float )DegenCount[(int )symidx];
      }
#line 300
      x ++;
    }
  }
#line 304
  return;
}
}
#line 319 "alphabet.c"
void DefaultGeneticCode(int *aacode ) 
{ 
  int x ;
  char *tmp ;

  {
#line 324
  x = 0;
#line 324
  while (x < 64) {
#line 325
    if ((int )*(stdcode1[x]) == 42) {
#line 325
      *(aacode + x) = -1;
    } else {
#line 326
      tmp = strchr((char const   *)(Alphabet), (int )*(stdcode1[x]));
#line 326
      *(aacode + x) = (int )(tmp - Alphabet);
    }
#line 324
    x ++;
  }
#line 328
  return;
}
}
#line 342 "alphabet.c"
void DefaultCodonBias(float *codebias ) 
{ 


  {
#line 345
  *(codebias + 0) = (float )(1. / 2.);
#line 346
  *(codebias + 1) = (float )(1. / 2.);
#line 347
  *(codebias + 2) = (float )(1. / 2.);
#line 348
  *(codebias + 3) = (float )(1. / 2.);
#line 349
  *(codebias + 4) = (float )(1. / 4.);
#line 350
  *(codebias + 5) = (float )(1. / 4.);
#line 351
  *(codebias + 6) = (float )(1. / 4.);
#line 352
  *(codebias + 7) = (float )(1. / 4.);
#line 353
  *(codebias + 8) = (float )(1. / 6.);
#line 354
  *(codebias + 9) = (float )(1. / 6.);
#line 355
  *(codebias + 10) = (float )(1. / 6.);
#line 356
  *(codebias + 11) = (float )(1. / 6.);
#line 357
  *(codebias + 12) = (float )(1. / 3.);
#line 358
  *(codebias + 13) = (float )(1. / 3.);
#line 359
  *(codebias + 14) = (float )1.;
#line 360
  *(codebias + 15) = (float )(1. / 3.);
#line 361
  *(codebias + 16) = (float )(1. / 2.);
#line 362
  *(codebias + 17) = (float )(1. / 2.);
#line 363
  *(codebias + 18) = (float )(1. / 2.);
#line 364
  *(codebias + 19) = (float )(1. / 2.);
#line 365
  *(codebias + 20) = (float )(1. / 4.);
#line 366
  *(codebias + 21) = (float )(1. / 4.);
#line 367
  *(codebias + 22) = (float )(1. / 4.);
#line 368
  *(codebias + 23) = (float )(1. / 4.);
#line 369
  *(codebias + 24) = (float )(1. / 6.);
#line 370
  *(codebias + 25) = (float )(1. / 6.);
#line 371
  *(codebias + 26) = (float )(1. / 6.);
#line 372
  *(codebias + 27) = (float )(1. / 6.);
#line 373
  *(codebias + 28) = (float )(1. / 6.);
#line 374
  *(codebias + 29) = (float )(1. / 6.);
#line 375
  *(codebias + 30) = (float )(1. / 6.);
#line 376
  *(codebias + 31) = (float )(1. / 6.);
#line 377
  *(codebias + 32) = (float )(1. / 2.);
#line 378
  *(codebias + 33) = (float )(1. / 2.);
#line 379
  *(codebias + 34) = (float )(1. / 2.);
#line 380
  *(codebias + 35) = (float )(1. / 2.);
#line 381
  *(codebias + 36) = (float )(1. / 4.);
#line 382
  *(codebias + 37) = (float )(1. / 4.);
#line 383
  *(codebias + 38) = (float )(1. / 4.);
#line 384
  *(codebias + 39) = (float )(1. / 4.);
#line 385
  *(codebias + 40) = (float )(1. / 4.);
#line 386
  *(codebias + 41) = (float )(1. / 4.);
#line 387
  *(codebias + 42) = (float )(1. / 4.);
#line 388
  *(codebias + 43) = (float )(1. / 4.);
#line 389
  *(codebias + 44) = (float )(1. / 4.);
#line 390
  *(codebias + 45) = (float )(1. / 4.);
#line 391
  *(codebias + 46) = (float )(1. / 4.);
#line 392
  *(codebias + 47) = (float )(1. / 4.);
#line 393
  *(codebias + 48) = (float )0.;
#line 394
  *(codebias + 49) = (float )(1. / 2.);
#line 395
  *(codebias + 50) = (float )0.;
#line 396
  *(codebias + 51) = (float )(1. / 2.);
#line 397
  *(codebias + 52) = (float )(1. / 6.);
#line 398
  *(codebias + 53) = (float )(1. / 6.);
#line 399
  *(codebias + 54) = (float )(1. / 6.);
#line 400
  *(codebias + 55) = (float )(1. / 6.);
#line 401
  *(codebias + 56) = (float )0.;
#line 402
  *(codebias + 57) = (float )(1. / 2.);
#line 403
  *(codebias + 58) = (float )1.;
#line 404
  *(codebias + 59) = (float )(1. / 2.);
#line 405
  *(codebias + 60) = (float )(1. / 6.);
#line 406
  *(codebias + 61) = (float )(1. / 2.);
#line 407
  *(codebias + 62) = (float )(1. / 6.);
#line 408
  *(codebias + 63) = (float )(1. / 2.);
#line 409
  return;
}
}
#line 418 "alphabet.c"
static void set_degenerate(char iupac___0 , char *syms ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 421
  tmp = strchr((char const   *)(Alphabet), (int )iupac___0);
#line 421
  tmp___0 = strlen((char const   *)syms);
#line 421
  DegenCount[tmp - Alphabet] = (int )tmp___0;
#line 422
  while (*syms) {
#line 423
    tmp___1 = strchr((char const   *)(Alphabet), (int )iupac___0);
#line 423
    tmp___2 = strchr((char const   *)(Alphabet), (int )*syms);
#line 423
    Degenerate[tmp___1 - Alphabet][tmp___2 - Alphabet] = (char)1;
#line 425
    syms ++;
  }
#line 427
  return;
}
}
#line 1 "core_algorithms.o"
#pragma merger("0","/tmp/cil-hTI650l8.i","")
#line 104 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 221 "./sqfuncs.h"
void *sre_realloc(char *file , int line , void *p , size_t size ) ;
#line 9 "./vectorops.h"
void FSet(float *vec , int n , float value ) ;
#line 11
void FScale(float *vec , int n , float scale ) ;
#line 13
float FSum(float *vec , int n ) ;
#line 25
int FArgMax(float *vec , int n ) ;
#line 41 "./funcs.h"
struct dpmatrix_s *CreatePlan7Matrix(int N , int M , int padN , int padM ) ;
#line 42
void ResizePlan7Matrix(struct dpmatrix_s *mx , int N , int M , int ***xmx , int ***mmx ,
                       int ***imx , int ***dmx ) ;
#line 44
struct dpmatrix_s *AllocPlan7Matrix(int rows , int M , int ***xmx , int ***mmx , int ***imx ,
                                    int ***dmx ) ;
#line 46
struct dpshadow_s *AllocShadowMatrix(int rows , int M , char ***xtb , char ***mtb ,
                                     char ***itb , char ***dtb ) ;
#line 48
void FreePlan7Matrix(struct dpmatrix_s *mx ) ;
#line 49
void FreeShadowMatrix(struct dpshadow_s *tb ) ;
#line 50
int P7ViterbiSize(int L , int M ) ;
#line 51
int P7SmallViterbiSize(int L , int M ) ;
#line 52
int P7WeeViterbiSize(int L , int M ) ;
#line 53
float P7Forward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
#line 55
float P7Viterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                struct p7trace_s **ret_tr ) ;
#line 57
void P7ViterbiTrace(struct plan7_s *hmm , char *dsq , int N , struct dpmatrix_s *mx ,
                    struct p7trace_s **ret_tr ) ;
#line 59
float P7SmallViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                     struct p7trace_s **ret_tr ) ;
#line 60
float P7ParsingViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
#line 62
float P7WeeViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
#line 64
float Plan7ESTViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
#line 66
struct p7trace_s *P7ViterbiAlignAlignment(MSA *msa , struct plan7_s *hmm ) ;
#line 67
struct p7trace_s *ShadowTrace(struct dpshadow_s *tb , struct plan7_s *hmm , int L ) ;
#line 68
float PostprocessSignificantHit(struct tophit_s *ghit , struct tophit_s *dhit , struct p7trace_s *tr ,
                                struct plan7_s *hmm , char *dsq , int L , char *seqname ,
                                char *seqacc , char *seqdesc , int do_forward , float sc_override ,
                                int do_null2 , struct threshold_s *thresh___0 , int hmmpfam_mode ) ;
#line 74
char *Statetype(char st ) ;
#line 161
float TraceScoreCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) ;
#line 166
int Prob2Score(float p , float null ) ;
#line 168
float Scorify(int sc ) ;
#line 169
double PValue(struct plan7_s *hmm , float sc ) ;
#line 171
int ILogsum(int p1 , int p2 ) ;
#line 304
void RegisterHit(struct tophit_s *h___0 , double key , double pvalue , float score ,
                 double motherp , float mothersc , char *name , char *acc , char *desc ,
                 int sqfrom , int sqto , int sqlen , int hmmfrom , int hmmto , int hmmlen ,
                 int domidx , int ndom , struct fancyali_s *ali ) ;
#line 327
void P7AllocTrace(int tlen , struct p7trace_s **ret_tr ) ;
#line 328
void P7ReallocTrace(struct p7trace_s *tr , int tlen ) ;
#line 329
void P7FreeTrace(struct p7trace_s *tr ) ;
#line 332
void P7ReverseTrace(struct p7trace_s *tr ) ;
#line 335
float P7TraceScore(struct plan7_s *hmm , char *dsq , struct p7trace_s *tr ) ;
#line 341
struct fancyali_s *CreateFancyAli(struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ,
                                  char *name ) ;
#line 344
void TraceDecompose(struct p7trace_s *otr , struct p7trace_s ***ret_tr , int *ret_ntr ) ;
#line 347
void TraceSimpleBounds(struct p7trace_s *tr , int *ret_i1 , int *ret_i2 , int *ret_k1 ,
                       int *ret_k2 ) ;
#line 29 "core_algorithms.c"
static float get_wee_midpt(struct plan7_s *hmm , char *dsq , int L , int k1 , char t1 ,
                           int s1 , int k3 , char t3 , int s3 , int *ret_k2 , char *ret_t2 ,
                           int *ret_s2 ) ;
#line 60 "core_algorithms.c"
struct dpmatrix_s *CreatePlan7Matrix(int N , int M , int padN , int padM ) 
{ 
  struct dpmatrix_s *mx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 66
  tmp = sre_malloc((char *)"core_algorithms.c", 66, sizeof(struct dpmatrix_s ));
#line 66
  mx = (struct dpmatrix_s *)tmp;
#line 67
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 67, sizeof(int *) * (unsigned long )(N + 1));
#line 67
  mx->xmx = (int **)tmp___0;
#line 68
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 68, sizeof(int *) * (unsigned long )(N + 1));
#line 68
  mx->mmx = (int **)tmp___1;
#line 69
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 69, sizeof(int *) * (unsigned long )(N + 1));
#line 69
  mx->imx = (int **)tmp___2;
#line 70
  tmp___3 = sre_malloc((char *)"core_algorithms.c", 70, sizeof(int *) * (unsigned long )(N + 1));
#line 70
  mx->dmx = (int **)tmp___3;
#line 71
  tmp___4 = sre_malloc((char *)"core_algorithms.c", 71, sizeof(int ) * (unsigned long )((N + 1) * 5));
#line 71
  mx->xmx_mem = tmp___4;
#line 72
  tmp___5 = sre_malloc((char *)"core_algorithms.c", 72, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 72
  mx->mmx_mem = tmp___5;
#line 73
  tmp___6 = sre_malloc((char *)"core_algorithms.c", 73, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 73
  mx->imx_mem = tmp___6;
#line 74
  tmp___7 = sre_malloc((char *)"core_algorithms.c", 74, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 74
  mx->dmx_mem = tmp___7;
#line 80
  *(mx->xmx + 0) = (int *)mx->xmx_mem;
#line 81
  *(mx->mmx + 0) = (int *)mx->mmx_mem;
#line 82
  *(mx->imx + 0) = (int *)mx->imx_mem;
#line 83
  *(mx->dmx + 0) = (int *)mx->dmx_mem;
#line 84
  i___0 = 1;
#line 84
  while (i___0 <= N) {
#line 86
    *(mx->xmx + i___0) = *(mx->xmx + 0) + i___0 * 5;
#line 87
    *(mx->mmx + i___0) = *(mx->mmx + 0) + i___0 * (M + 2);
#line 88
    *(mx->imx + i___0) = *(mx->imx + 0) + i___0 * (M + 2);
#line 89
    *(mx->dmx + i___0) = *(mx->dmx + 0) + i___0 * (M + 2);
#line 84
    i___0 ++;
  }
#line 92
  if (padM > 0) {
#line 92
    if (padN > 0) {
#line 92
      Die((char *)"there\'s trouble with RAMLIMIT if you grow in both M and N.");
    }
  }
#line 93
  mx->maxN = N;
#line 94
  mx->maxM = M;
#line 95
  mx->padN = padN;
#line 96
  mx->padM = padM;
#line 98
  return (mx);
}
}
#line 122 "core_algorithms.c"
void ResizePlan7Matrix(struct dpmatrix_s *mx , int N , int M , int ***xmx , int ***mmx ,
                       int ***imx , int ***dmx ) 
{ 
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 128
  if (N <= mx->maxN) {
#line 128
    if (M <= mx->maxM) {
#line 128
      goto DONE;
    }
  }
#line 130
  if (N > mx->maxN) {
#line 131
    N += mx->padN;
#line 132
    mx->maxN = N;
#line 133
    tmp = sre_realloc((char *)"core_algorithms.c", 133, (void *)mx->xmx, sizeof(int *) * (unsigned long )(N + 1));
#line 133
    mx->xmx = (int **)tmp;
#line 134
    tmp___0 = sre_realloc((char *)"core_algorithms.c", 134, (void *)mx->mmx, sizeof(int *) * (unsigned long )(N + 1));
#line 134
    mx->mmx = (int **)tmp___0;
#line 135
    tmp___1 = sre_realloc((char *)"core_algorithms.c", 135, (void *)mx->imx, sizeof(int *) * (unsigned long )(N + 1));
#line 135
    mx->imx = (int **)tmp___1;
#line 136
    tmp___2 = sre_realloc((char *)"core_algorithms.c", 136, (void *)mx->dmx, sizeof(int *) * (unsigned long )(N + 1));
#line 136
    mx->dmx = (int **)tmp___2;
  }
#line 139
  if (M > mx->maxM) {
#line 140
    M += mx->padM;
#line 141
    mx->maxM = M;
  }
#line 144
  tmp___3 = sre_realloc((char *)"core_algorithms.c", 144, mx->xmx_mem, sizeof(int ) * (unsigned long )((N + 1) * 5));
#line 144
  mx->xmx_mem = tmp___3;
#line 145
  tmp___4 = sre_realloc((char *)"core_algorithms.c", 145, mx->mmx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 145
  mx->mmx_mem = tmp___4;
#line 146
  tmp___5 = sre_realloc((char *)"core_algorithms.c", 146, mx->imx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 146
  mx->imx_mem = tmp___5;
#line 147
  tmp___6 = sre_realloc((char *)"core_algorithms.c", 147, mx->dmx_mem, sizeof(int ) * (unsigned long )((N + 1) * (M + 2)));
#line 147
  mx->dmx_mem = tmp___6;
#line 149
  *(mx->xmx + 0) = (int *)mx->xmx_mem;
#line 150
  *(mx->mmx + 0) = (int *)mx->mmx_mem;
#line 151
  *(mx->imx + 0) = (int *)mx->imx_mem;
#line 152
  *(mx->dmx + 0) = (int *)mx->dmx_mem;
#line 154
  i___0 = 1;
#line 154
  while (i___0 <= N) {
#line 156
    *(mx->xmx + i___0) = *(mx->xmx + 0) + i___0 * 5;
#line 157
    *(mx->mmx + i___0) = *(mx->mmx + 0) + i___0 * (M + 2);
#line 158
    *(mx->imx + i___0) = *(mx->imx + 0) + i___0 * (M + 2);
#line 159
    *(mx->dmx + i___0) = *(mx->dmx + 0) + i___0 * (M + 2);
#line 154
    i___0 ++;
  }
  DONE: 
#line 163
  if ((unsigned long )xmx != (unsigned long )((void *)0)) {
#line 163
    *xmx = mx->xmx;
  }
#line 164
  if ((unsigned long )mmx != (unsigned long )((void *)0)) {
#line 164
    *mmx = mx->mmx;
  }
#line 165
  if ((unsigned long )imx != (unsigned long )((void *)0)) {
#line 165
    *imx = mx->imx;
  }
#line 166
  if ((unsigned long )dmx != (unsigned long )((void *)0)) {
#line 166
    *dmx = mx->dmx;
  }
#line 167
  return;
}
}
#line 191 "core_algorithms.c"
struct dpmatrix_s *AllocPlan7Matrix(int rows , int M , int ***xmx , int ***mmx , int ***imx ,
                                    int ***dmx ) 
{ 
  struct dpmatrix_s *mx ;

  {
#line 195
  mx = CreatePlan7Matrix(rows - 1, M, 0, 0);
#line 196
  if ((unsigned long )xmx != (unsigned long )((void *)0)) {
#line 196
    *xmx = mx->xmx;
  }
#line 197
  if ((unsigned long )mmx != (unsigned long )((void *)0)) {
#line 197
    *mmx = mx->mmx;
  }
#line 198
  if ((unsigned long )imx != (unsigned long )((void *)0)) {
#line 198
    *imx = mx->imx;
  }
#line 199
  if ((unsigned long )dmx != (unsigned long )((void *)0)) {
#line 199
    *dmx = mx->dmx;
  }
#line 200
  return (mx);
}
}
#line 210 "core_algorithms.c"
void FreePlan7Matrix(struct dpmatrix_s *mx ) 
{ 


  {
#line 213
  free(mx->xmx_mem);
#line 214
  free(mx->mmx_mem);
#line 215
  free(mx->imx_mem);
#line 216
  free(mx->dmx_mem);
#line 217
  free((void *)mx->xmx);
#line 218
  free((void *)mx->mmx);
#line 219
  free((void *)mx->imx);
#line 220
  free((void *)mx->dmx);
#line 221
  free((void *)mx);
#line 222
  return;
}
}
#line 238 "core_algorithms.c"
struct dpshadow_s *AllocShadowMatrix(int rows , int M , char ***xtb , char ***mtb ,
                                     char ***itb , char ***dtb ) 
{ 
  struct dpshadow_s *tb ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 244
  tmp = sre_malloc((char *)"core_algorithms.c", 244, sizeof(struct dpshadow_s ));
#line 244
  tb = (struct dpshadow_s *)tmp;
#line 245
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 245, sizeof(char *) * (unsigned long )rows);
#line 245
  tb->xtb = (char **)tmp___0;
#line 246
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 246, sizeof(char *) * (unsigned long )rows);
#line 246
  tb->mtb = (char **)tmp___1;
#line 247
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 247, sizeof(char *) * (unsigned long )rows);
#line 247
  tb->itb = (char **)tmp___2;
#line 248
  tmp___3 = sre_malloc((char *)"core_algorithms.c", 248, sizeof(char *) * (unsigned long )rows);
#line 248
  tb->dtb = (char **)tmp___3;
#line 249
  tmp___4 = sre_malloc((char *)"core_algorithms.c", 249, sizeof(int ) * (unsigned long )rows);
#line 249
  tb->esrc = (int *)tmp___4;
#line 250
  tmp___5 = sre_malloc((char *)"core_algorithms.c", 250, sizeof(char ) * (unsigned long )(rows * 5));
#line 250
  *(tb->xtb + 0) = (char *)tmp___5;
#line 251
  tmp___6 = sre_malloc((char *)"core_algorithms.c", 251, sizeof(char ) * (unsigned long )(rows * (M + 2)));
#line 251
  *(tb->mtb + 0) = (char *)tmp___6;
#line 252
  tmp___7 = sre_malloc((char *)"core_algorithms.c", 252, sizeof(char ) * (unsigned long )(rows * (M + 2)));
#line 252
  *(tb->itb + 0) = (char *)tmp___7;
#line 253
  tmp___8 = sre_malloc((char *)"core_algorithms.c", 253, sizeof(char ) * (unsigned long )(rows * (M + 2)));
#line 253
  *(tb->dtb + 0) = (char *)tmp___8;
#line 254
  i___0 = 1;
#line 254
  while (i___0 < rows) {
#line 256
    *(tb->xtb + i___0) = *(tb->xtb + 0) + i___0 * 5;
#line 257
    *(tb->mtb + i___0) = *(tb->mtb + 0) + i___0 * (M + 2);
#line 258
    *(tb->itb + i___0) = *(tb->itb + 0) + i___0 * (M + 2);
#line 259
    *(tb->dtb + i___0) = *(tb->dtb + 0) + i___0 * (M + 2);
#line 254
    i___0 ++;
  }
#line 262
  if ((unsigned long )xtb != (unsigned long )((void *)0)) {
#line 262
    *xtb = tb->xtb;
  }
#line 263
  if ((unsigned long )mtb != (unsigned long )((void *)0)) {
#line 263
    *mtb = tb->mtb;
  }
#line 264
  if ((unsigned long )itb != (unsigned long )((void *)0)) {
#line 264
    *itb = tb->itb;
  }
#line 265
  if ((unsigned long )dtb != (unsigned long )((void *)0)) {
#line 265
    *dtb = tb->dtb;
  }
#line 266
  return (tb);
}
}
#line 275 "core_algorithms.c"
void FreeShadowMatrix(struct dpshadow_s *tb ) 
{ 


  {
#line 278
  free((void *)*(tb->xtb + 0));
#line 279
  free((void *)*(tb->mtb + 0));
#line 280
  free((void *)*(tb->itb + 0));
#line 281
  free((void *)*(tb->dtb + 0));
#line 282
  free((void *)tb->esrc);
#line 283
  free((void *)tb->xtb);
#line 284
  free((void *)tb->mtb);
#line 285
  free((void *)tb->itb);
#line 286
  free((void *)tb->dtb);
#line 287
  free((void *)tb);
#line 288
  return;
}
}
#line 306 "core_algorithms.c"
int P7ViterbiSize(int L , int M ) 
{ 
  float Mbytes ;

  {
#line 318
  Mbytes = (float )sizeof(struct dpmatrix_s );
#line 319
  Mbytes = (float )((double )Mbytes + ((3. * (double )((float )(L + 1))) * (double )((float )(M + 2))) * (double )((float )sizeof(int )));
#line 320
  Mbytes = (float )((double )Mbytes + (4. * (double )((float )(L + 1))) * (double )((float )sizeof(int *)));
#line 321
  Mbytes = (float )((double )Mbytes + (5. * (double )((float )(L + 1))) * (double )((float )sizeof(int )));
#line 322
  Mbytes = (float )((double )Mbytes / 1048576.);
#line 323
  return ((int )Mbytes);
}
}
#line 346 "core_algorithms.c"
int P7SmallViterbiSize(int L , int M ) 
{ 


  {
#line 349
  return ((int )(((((2UL * sizeof(struct dpmatrix_s ) + (unsigned long )(12 * (M + 2)) * sizeof(int )) + 16UL * sizeof(int *)) + 20UL * sizeof(int )) + (unsigned long )(2 * (L + 1)) * sizeof(int )) / 1000000UL));
}
}
#line 369 "core_algorithms.c"
int P7WeeViterbiSize(int L , int M ) 
{ 


  {
#line 372
  return ((int )(((((((2UL * sizeof(struct dpmatrix_s ) + (unsigned long )(12 * (M + 2)) * sizeof(int )) + 16UL * sizeof(int *)) + 20UL * sizeof(int )) + (unsigned long )(2 * (L + 2)) * sizeof(int )) + (unsigned long )(L + 2) * sizeof(int )) + (unsigned long )(L + 2) * sizeof(char )) / 1000000UL));
}
}
#line 396 "core_algorithms.c"
float P7Forward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  float tmp___9 ;

  {
#line 409
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 416
  *(*(xmx + 0) + 4) = 0;
#line 417
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
#line 418
  tmp___0 = -987654321;
#line 418
  *(*(xmx + 0) + 3) = tmp___0;
#line 418
  tmp = tmp___0;
#line 418
  *(*(xmx + 0) + 2) = tmp;
#line 418
  *(*(xmx + 0) + 1) = tmp;
#line 419
  k = 0;
#line 419
  while (k <= hmm->M) {
#line 420
    tmp___2 = -987654321;
#line 420
    *(*(dmx + 0) + k) = tmp___2;
#line 420
    tmp___1 = tmp___2;
#line 420
    *(*(imx + 0) + k) = tmp___1;
#line 420
    *(*(mmx + 0) + k) = tmp___1;
#line 419
    k ++;
  }
#line 427
  i___0 = 1;
#line 427
  while (i___0 <= L) {
#line 429
    tmp___4 = -987654321;
#line 429
    *(*(dmx + i___0) + 0) = tmp___4;
#line 429
    tmp___3 = tmp___4;
#line 429
    *(*(imx + i___0) + 0) = tmp___3;
#line 429
    *(*(mmx + i___0) + 0) = tmp___3;
#line 430
    k = 1;
#line 430
    while (k < hmm->M) {
#line 432
      tmp___5 = ILogsum(*(*(xmx + (i___0 - 1)) + 0) + *(hmm->bsc + k), *(*(dmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1)));
#line 432
      tmp___6 = ILogsum(*(*(mmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1)),
                        *(*(imx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1)));
#line 432
      *(*(mmx + i___0) + k) = ILogsum(tmp___6, tmp___5);
#line 436
      *(*(mmx + i___0) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
#line 438
      *(*(dmx + i___0) + k) = ILogsum(*(*(mmx + i___0) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1)),
                                      *(*(dmx + i___0) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1)));
#line 440
      *(*(imx + i___0) + k) = ILogsum(*(*(mmx + (i___0 - 1)) + k) + *(*(hmm->tsc + 1) + k),
                                      *(*(imx + (i___0 - 1)) + k) + *(*(hmm->tsc + 4) + k));
#line 442
      *(*(imx + i___0) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
#line 430
      k ++;
    }
#line 444
    tmp___7 = ILogsum(*(*(xmx + (i___0 - 1)) + 0) + *(hmm->bsc + (hmm->M - 1)), *(*(dmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 5) + (hmm->M - 1)));
#line 444
    tmp___8 = ILogsum(*(*(mmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 0) + (hmm->M - 1)),
                      *(*(imx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 3) + (hmm->M - 1)));
#line 444
    *(*(mmx + i___0) + hmm->M) = ILogsum(tmp___8, tmp___7);
#line 448
    *(*(mmx + i___0) + hmm->M) += *(*(hmm->msc + (int )*(dsq + i___0)) + hmm->M);
#line 453
    *(*(xmx + i___0) + 4) = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
#line 455
    *(*(xmx + i___0) + 1) = -987654321;
#line 456
    k = 1;
#line 456
    while (k <= hmm->M) {
#line 457
      *(*(xmx + i___0) + 1) = ILogsum(*(*(xmx + i___0) + 1), *(*(mmx + i___0) + k) + *(hmm->esc + k));
#line 456
      k ++;
    }
#line 459
    *(*(xmx + i___0) + 3) = ILogsum(*(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1],
                                    *(*(xmx + i___0) + 1) + hmm->xsc[1][1]);
#line 462
    *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 4) + hmm->xsc[0][0], *(*(xmx + i___0) + 3) + hmm->xsc[3][0]);
#line 465
    *(*(xmx + i___0) + 2) = ILogsum(*(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1],
                                    *(*(xmx + i___0) + 1) + hmm->xsc[1][0]);
#line 427
    i___0 ++;
  }
#line 469
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
#line 471
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
#line 471
    *ret_mx = mx;
  } else {
#line 472
    FreePlan7Matrix(mx);
  }
#line 474
  tmp___9 = Scorify(sc);
#line 474
  return (tmp___9);
}
}
#line 627 "core_algorithms.c"
void P7ViterbiTrace(struct plan7_s *hmm , char *dsq , int N , struct dpmatrix_s *mx ,
                    struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int dk ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 643
  curralloc = N * 2 + 6;
#line 644
  P7AllocTrace(curralloc, & tr);
#line 646
  xmx = mx->xmx;
#line 647
  mmx = mx->mmx;
#line 648
  imx = mx->imx;
#line 649
  dmx = mx->dmx;
#line 654
  *(tr->statetype + 0) = (char)9;
#line 655
  *(tr->nodeidx + 0) = 0;
#line 656
  *(tr->pos + 0) = 0;
#line 657
  *(tr->statetype + 1) = (char)8;
#line 658
  *(tr->nodeidx + 1) = 0;
#line 659
  *(tr->pos + 1) = 0;
#line 660
  tpos = 2;
#line 661
  i___0 = N;
#line 665
  while ((int )*(tr->statetype + (tpos - 1)) != 4) {
#line 666
    switch ((int )*(tr->statetype + (tpos - 1))) {
    case 1: 
#line 668
    sc = *(*(mmx + (i___0 + 1)) + (k + 1)) - *(*(hmm->msc + (int )*(dsq + (i___0 + 1))) + (k + 1));
#line 669
    if (sc <= -987654321) {
#line 669
      P7FreeTrace(tr);
#line 669
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 669
      return;
    } else
#line 670
    if (sc == *(*(xmx + i___0) + 0) + *(hmm->bsc + (k + 1))) {
#line 673
      tmp___0 = Prob2Score(*(hmm->begin + (k + 1)), hmm->p1);
#line 673
      if ((double )tmp___0 + (double )1 * 1000.0 <= (double )*(hmm->bsc + (k + 1))) {
#line 674
        while (k > 0) {
#line 676
          *(tr->statetype + tpos) = (char)2;
#line 677
          tmp = k;
#line 677
          k --;
#line 677
          *(tr->nodeidx + tpos) = tmp;
#line 678
          *(tr->pos + tpos) = 0;
#line 679
          tpos ++;
#line 680
          if (tpos == curralloc) {
#line 682
            curralloc += N;
#line 683
            P7ReallocTrace(tr, curralloc);
          }
        }
      }
#line 687
      *(tr->statetype + tpos) = (char)6;
#line 688
      *(tr->nodeidx + tpos) = 0;
#line 689
      *(tr->pos + tpos) = 0;
    } else
#line 691
    if (sc == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 0) + k)) {
#line 693
      *(tr->statetype + tpos) = (char)1;
#line 694
      tmp___1 = k;
#line 694
      k --;
#line 694
      *(tr->nodeidx + tpos) = tmp___1;
#line 695
      tmp___2 = i___0;
#line 695
      i___0 --;
#line 695
      *(tr->pos + tpos) = tmp___2;
    } else
#line 697
    if (sc == *(*(imx + i___0) + k) + *(*(hmm->tsc + 3) + k)) {
#line 699
      *(tr->statetype + tpos) = (char)3;
#line 700
      *(tr->nodeidx + tpos) = k;
#line 701
      tmp___3 = i___0;
#line 701
      i___0 --;
#line 701
      *(tr->pos + tpos) = tmp___3;
    } else
#line 703
    if (sc == *(*(dmx + i___0) + k) + *(*(hmm->tsc + 5) + k)) {
#line 705
      *(tr->statetype + tpos) = (char)2;
#line 706
      tmp___4 = k;
#line 706
      k --;
#line 706
      *(tr->nodeidx + tpos) = tmp___4;
#line 707
      *(tr->pos + tpos) = 0;
    } else {
#line 710
      Die((char *)"traceback failed");
    }
#line 711
    break;
    case 2: 
#line 714
    if (*(*(dmx + i___0) + (k + 1)) <= -987654321) {
#line 714
      P7FreeTrace(tr);
#line 714
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 714
      return;
    } else
#line 715
    if (*(*(dmx + i___0) + (k + 1)) == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 2) + k)) {
#line 717
      *(tr->statetype + tpos) = (char)1;
#line 718
      tmp___5 = k;
#line 718
      k --;
#line 718
      *(tr->nodeidx + tpos) = tmp___5;
#line 719
      tmp___6 = i___0;
#line 719
      i___0 --;
#line 719
      *(tr->pos + tpos) = tmp___6;
    } else
#line 721
    if (*(*(dmx + i___0) + (k + 1)) == *(*(dmx + i___0) + k) + *(*(hmm->tsc + 6) + k)) {
#line 723
      *(tr->statetype + tpos) = (char)2;
#line 724
      tmp___7 = k;
#line 724
      k --;
#line 724
      *(tr->nodeidx + tpos) = tmp___7;
#line 725
      *(tr->pos + tpos) = 0;
    } else {
#line 727
      Die((char *)"traceback failed");
    }
#line 728
    break;
    case 3: 
#line 731
    sc = *(*(imx + (i___0 + 1)) + k) - *(*(hmm->isc + (int )*(dsq + (i___0 + 1))) + k);
#line 732
    if (sc <= -987654321) {
#line 732
      P7FreeTrace(tr);
#line 732
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 732
      return;
    } else
#line 733
    if (sc == *(*(mmx + i___0) + k) + *(*(hmm->tsc + 1) + k)) {
#line 735
      *(tr->statetype + tpos) = (char)1;
#line 736
      tmp___8 = k;
#line 736
      k --;
#line 736
      *(tr->nodeidx + tpos) = tmp___8;
#line 737
      tmp___9 = i___0;
#line 737
      i___0 --;
#line 737
      *(tr->pos + tpos) = tmp___9;
    } else
#line 739
    if (sc == *(*(imx + i___0) + k) + *(*(hmm->tsc + 4) + k)) {
#line 741
      *(tr->statetype + tpos) = (char)3;
#line 742
      *(tr->nodeidx + tpos) = k;
#line 743
      tmp___10 = i___0;
#line 743
      i___0 --;
#line 743
      *(tr->pos + tpos) = tmp___10;
    } else {
#line 745
      Die((char *)"traceback failed");
    }
#line 746
    break;
    case 5: 
#line 749
    if (i___0 == 0) {
#line 749
      if (*(*(xmx + i___0) + 4) == 0) {
#line 751
        *(tr->statetype + tpos) = (char)4;
#line 752
        *(tr->nodeidx + tpos) = 0;
#line 753
        *(tr->pos + tpos) = 0;
      } else {
#line 749
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 755
    if (i___0 > 0) {
#line 755
      if (*(*(xmx + (i___0 + 1)) + 4) == *(*(xmx + i___0) + 4) + hmm->xsc[0][1]) {
#line 757
        *(tr->statetype + tpos) = (char)5;
#line 758
        *(tr->nodeidx + tpos) = 0;
#line 759
        *(tr->pos + tpos) = 0;
#line 760
        tmp___11 = i___0;
#line 760
        i___0 --;
#line 760
        *(tr->pos + (tpos - 1)) = tmp___11;
      } else {
#line 762
        Die((char *)"traceback failed");
      }
    } else {
#line 762
      Die((char *)"traceback failed");
    }
#line 763
    break;
    case 6: 
#line 766
    if (*(*(xmx + i___0) + 0) <= -987654321) {
#line 766
      P7FreeTrace(tr);
#line 766
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 766
      return;
    } else
#line 767
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 4) + hmm->xsc[0][0]) {
#line 769
      *(tr->statetype + tpos) = (char)5;
#line 770
      *(tr->nodeidx + tpos) = 0;
#line 771
      *(tr->pos + tpos) = 0;
    } else
#line 773
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 3) + hmm->xsc[3][0]) {
#line 775
      *(tr->statetype + tpos) = (char)10;
#line 776
      *(tr->nodeidx + tpos) = 0;
#line 777
      *(tr->pos + tpos) = 0;
    } else {
#line 780
      Die((char *)"traceback failed");
    }
#line 781
    break;
    case 7: 
#line 784
    if (*(*(xmx + i___0) + 1) <= -987654321) {
#line 784
      P7FreeTrace(tr);
#line 784
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 784
      return;
    }
#line 785
    k = hmm->M;
#line 785
    while (k >= 1) {
#line 786
      if (*(*(xmx + i___0) + 1) == *(*(mmx + i___0) + k) + *(hmm->esc + k)) {
#line 789
        tmp___12 = Prob2Score(*(hmm->end + k), (float )1.);
#line 789
        if ((double )tmp___12 + (double )1 * 1000.0 <= (double )*(hmm->esc + k)) {
#line 792
          dk = hmm->M;
#line 792
          while (dk > k) {
#line 794
            *(tr->statetype + tpos) = (char)2;
#line 795
            *(tr->nodeidx + tpos) = dk;
#line 796
            *(tr->pos + tpos) = 0;
#line 797
            tpos ++;
#line 798
            if (tpos == curralloc) {
#line 800
              curralloc += N;
#line 801
              P7ReallocTrace(tr, curralloc);
            }
#line 792
            dk --;
          }
        }
#line 806
        *(tr->statetype + tpos) = (char)1;
#line 807
        tmp___13 = k;
#line 807
        k --;
#line 807
        *(tr->nodeidx + tpos) = tmp___13;
#line 808
        tmp___14 = i___0;
#line 808
        i___0 --;
#line 808
        *(tr->pos + tpos) = tmp___14;
#line 809
        break;
      }
#line 785
      k --;
    }
#line 811
    if (k < 0) {
#line 811
      Die((char *)"traceback failed");
    }
#line 812
    break;
    case 8: 
#line 815
    if (*(*(xmx + i___0) + 2) <= -987654321) {
#line 815
      P7FreeTrace(tr);
#line 815
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 815
      return;
    } else
#line 816
    if (*(*(xmx + i___0) + 2) == *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1]) {
#line 818
      *(tr->statetype + tpos) = (char)8;
#line 819
      *(tr->nodeidx + tpos) = 0;
#line 820
      *(tr->pos + tpos) = 0;
#line 821
      tmp___15 = i___0;
#line 821
      i___0 --;
#line 821
      *(tr->pos + (tpos - 1)) = tmp___15;
    } else
#line 823
    if (*(*(xmx + i___0) + 2) == *(*(xmx + i___0) + 1) + hmm->xsc[1][0]) {
#line 825
      *(tr->statetype + tpos) = (char)7;
#line 826
      *(tr->nodeidx + tpos) = 0;
#line 827
      *(tr->pos + tpos) = 0;
    } else {
#line 830
      Die((char *)"Traceback failed.");
    }
#line 831
    break;
    case 10: 
#line 834
    if (*(*(xmx + i___0) + 3) <= -987654321) {
#line 834
      P7FreeTrace(tr);
#line 834
      *ret_tr = (struct p7trace_s *)((void *)0);
#line 834
      return;
    } else
#line 835
    if (*(*(xmx + i___0) + 3) == *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1]) {
#line 837
      *(tr->statetype + tpos) = (char)10;
#line 838
      *(tr->nodeidx + tpos) = 0;
#line 839
      *(tr->pos + tpos) = 0;
#line 840
      tmp___16 = i___0;
#line 840
      i___0 --;
#line 840
      *(tr->pos + (tpos - 1)) = tmp___16;
    } else
#line 842
    if (*(*(xmx + i___0) + 3) == *(*(xmx + i___0) + 1) + hmm->xsc[1][1]) {
#line 844
      *(tr->statetype + tpos) = (char)7;
#line 845
      *(tr->nodeidx + tpos) = 0;
#line 846
      *(tr->pos + tpos) = 0;
    } else {
#line 849
      Die((char *)"Traceback failed.");
    }
#line 850
    break;
    default: 
#line 853
    Die((char *)"traceback failed");
    }
#line 857
    tpos ++;
#line 858
    if (tpos == curralloc) {
#line 860
      curralloc += N;
#line 861
      P7ReallocTrace(tr, curralloc);
    }
  }
#line 865
  tr->tlen = tpos;
#line 866
  P7ReverseTrace(tr);
#line 867
  *ret_tr = tr;
#line 868
  return;
}
}
#line 895 "core_algorithms.c"
float P7SmallViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                     struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *ctr ;
  struct p7trace_s *tr ;
  struct p7trace_s **tarr ;
  int ndom ;
  int i___0 ;
  int pos ;
  int tpos ;
  int tlen ;
  int sqlen ;
  int totlen ;
  float sc ;
  int t2 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 915
  sc = P7ParsingViterbi(dsq, L, hmm, & ctr);
#line 919
  if ((unsigned long )ctr == (unsigned long )((void *)0)) {
#line 921
    P7FreeTrace(ctr);
#line 922
    return (sc);
  } else
#line 919
  if ((unsigned long )ret_tr == (unsigned long )((void *)0)) {
#line 921
    P7FreeTrace(ctr);
#line 922
    return (sc);
  }
#line 929
  ndom = ctr->tlen / 2 - 1;
#line 930
  tmp = sre_malloc((char *)"core_algorithms.c", 930, sizeof(struct p7trace_s *) * (unsigned long )ndom);
#line 930
  tarr = (struct p7trace_s **)tmp;
#line 931
  totlen = 0;
#line 931
  tlen = totlen;
#line 932
  i___0 = 0;
#line 932
  while (i___0 < ndom) {
#line 934
    sqlen = *(ctr->pos + (i___0 * 2 + 2)) - *(ctr->pos + (i___0 * 2 + 1));
#line 936
    tmp___0 = P7ViterbiSize(sqlen, hmm->M);
#line 936
    if (tmp___0 > 1000) {
#line 937
      P7WeeViterbi(dsq + *(ctr->pos + (i___0 * 2 + 1)), sqlen, hmm, tarr + i___0);
    } else {
#line 939
      P7Viterbi(dsq + *(ctr->pos + (i___0 * 2 + 1)), sqlen, hmm, mx, tarr + i___0);
    }
#line 941
    tlen += (*(tarr + i___0))->tlen - 4;
#line 942
    totlen += sqlen;
#line 932
    i___0 ++;
  }
#line 957
  tlen += (4 + (ndom - 1)) + (L - totlen);
#line 958
  P7AllocTrace(tlen, & tr);
#line 959
  tr->tlen = tlen;
#line 963
  *(tr->statetype + 0) = (char)4;
#line 964
  *(tr->nodeidx + 0) = 0;
#line 965
  *(tr->pos + 0) = 0;
#line 966
  *(tr->statetype + 1) = (char)5;
#line 967
  *(tr->nodeidx + 1) = 0;
#line 968
  *(tr->pos + 1) = 0;
#line 969
  tpos = 2;
#line 971
  pos = 1;
#line 971
  while (pos <= *(ctr->pos + 1)) {
#line 973
    *(tr->statetype + tpos) = (char)5;
#line 974
    *(tr->nodeidx + tpos) = 0;
#line 975
    *(tr->pos + tpos) = pos;
#line 976
    tpos ++;
#line 971
    pos ++;
  }
#line 982
  i___0 = 0;
#line 982
  while (i___0 < ndom) {
#line 984
    t2 = 2;
#line 984
    while (t2 < (*(tarr + i___0))->tlen - 2) {
#line 986
      *(tr->statetype + tpos) = *((*(tarr + i___0))->statetype + t2);
#line 987
      *(tr->nodeidx + tpos) = *((*(tarr + i___0))->nodeidx + t2);
#line 988
      if (*((*(tarr + i___0))->pos + t2) > 0) {
#line 989
        *(tr->pos + tpos) = *((*(tarr + i___0))->pos + t2) + *(ctr->pos + (i___0 * 2 + 1));
      } else {
#line 991
        *(tr->pos + tpos) = 0;
      }
#line 992
      tpos ++;
#line 984
      t2 ++;
    }
#line 995
    if (i___0 == ndom - 1) {
#line 995
      *(tr->statetype + tpos) = (char)8;
    } else {
#line 995
      *(tr->statetype + tpos) = (char)10;
    }
#line 996
    *(tr->nodeidx + tpos) = 0;
#line 997
    *(tr->pos + tpos) = 0;
#line 998
    tpos ++;
#line 1000
    if (i___0 != ndom - 1) {
#line 1001
      pos = *(ctr->pos + (i___0 * 2 + 2)) + 1;
#line 1001
      while (pos <= *(ctr->pos + ((i___0 + 1) * 2 + 1))) {
#line 1003
        *(tr->statetype + tpos) = (char)10;
#line 1004
        *(tr->nodeidx + tpos) = 0;
#line 1005
        *(tr->pos + tpos) = pos;
#line 1006
        tpos ++;
#line 1001
        pos ++;
      }
    }
#line 982
    i___0 ++;
  }
#line 1011
  pos = *(ctr->pos + ndom * 2) + 1;
#line 1011
  while (pos <= L) {
#line 1013
    *(tr->statetype + tpos) = (char)8;
#line 1014
    *(tr->nodeidx + tpos) = 0;
#line 1015
    *(tr->pos + tpos) = pos;
#line 1016
    tpos ++;
#line 1011
    pos ++;
  }
#line 1019
  *(tr->statetype + tpos) = (char)9;
#line 1020
  *(tr->nodeidx + tpos) = 0;
#line 1021
  *(tr->pos + tpos) = 0;
#line 1022
  tpos ++;
#line 1024
  i___0 = 0;
#line 1024
  while (i___0 < ndom) {
#line 1024
    P7FreeTrace(*(tarr + i___0));
#line 1024
    i___0 ++;
  }
#line 1025
  free((void *)tarr);
#line 1026
  P7FreeTrace(ctr);
#line 1028
  *ret_tr = tr;
#line 1029
  return (sc);
}
}
#line 1063 "core_algorithms.c"
float P7ParsingViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  struct dpmatrix_s *mx ;
  struct dpmatrix_s *tmx ;
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **dmx ;
  int **imx ;
  int **xtr ;
  int **mtr ;
  int **dtr ;
  int **itr ;
  int *btr ;
  int *etr ;
  int sc ;
  int i___0 ;
  int k ;
  int tpos ;
  int cur ;
  int prv ;
  int curralloc ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  float tmp___7 ;

  {
#line 1081
  mx = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 1082
  tmx = AllocPlan7Matrix(2, hmm->M, & xtr, & mtr, & itr, & dtr);
#line 1083
  tmp = sre_malloc((char *)"core_algorithms.c", 1083, sizeof(int ) * (unsigned long )(L + 1));
#line 1083
  btr = (int *)tmp;
#line 1084
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 1084, sizeof(int ) * (unsigned long )(L + 1));
#line 1084
  etr = (int *)tmp___0;
#line 1088
  *(*(xmx + 0) + 4) = 0;
#line 1089
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
#line 1090
  *(btr + 0) = 0;
#line 1091
  tmp___2 = -987654321;
#line 1091
  *(*(xmx + 0) + 3) = tmp___2;
#line 1091
  tmp___1 = tmp___2;
#line 1091
  *(*(xmx + 0) + 2) = tmp___1;
#line 1091
  *(*(xmx + 0) + 1) = tmp___1;
#line 1092
  *(etr + 0) = -1;
#line 1093
  k = 0;
#line 1093
  while (k <= hmm->M) {
#line 1094
    tmp___4 = -987654321;
#line 1094
    *(*(dmx + 0) + k) = tmp___4;
#line 1094
    tmp___3 = tmp___4;
#line 1094
    *(*(imx + 0) + k) = tmp___3;
#line 1094
    *(*(mmx + 0) + k) = tmp___3;
#line 1093
    k ++;
  }
#line 1111
  i___0 = 1;
#line 1111
  while (i___0 <= L) {
#line 1112
    cur = i___0 % 2;
#line 1113
    prv = ! cur;
#line 1115
    tmp___6 = -987654321;
#line 1115
    *(*(dmx + cur) + 0) = tmp___6;
#line 1115
    tmp___5 = tmp___6;
#line 1115
    *(*(imx + cur) + 0) = tmp___5;
#line 1115
    *(*(mmx + cur) + 0) = tmp___5;
#line 1117
    k = 1;
#line 1117
    while (k <= hmm->M) {
#line 1119
      *(*(mmx + cur) + k) = -987654321;
#line 1120
      sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
#line 1120
      if (sc > -987654321) {
#line 1121
        *(*(mmx + cur) + k) = sc;
#line 1121
        *(*(mtr + cur) + k) = *(*(mtr + prv) + (k - 1));
      }
#line 1122
      sc = *(*(imx + prv) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
#line 1122
      if (sc > *(*(mmx + cur) + k)) {
#line 1123
        *(*(mmx + cur) + k) = sc;
#line 1123
        *(*(mtr + cur) + k) = *(*(itr + prv) + (k - 1));
      }
#line 1124
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
#line 1124
      if (sc > *(*(mmx + cur) + k)) {
#line 1125
        *(*(mmx + cur) + k) = sc;
#line 1125
        *(*(mtr + cur) + k) = i___0 - 1;
      }
#line 1126
      sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
#line 1126
      if (sc > *(*(mmx + cur) + k)) {
#line 1127
        *(*(mmx + cur) + k) = sc;
#line 1127
        *(*(mtr + cur) + k) = *(*(dtr + prv) + (k - 1));
      }
#line 1128
      if (*(*(hmm->msc + (int )*(dsq + i___0)) + k) != -987654321) {
#line 1129
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      } else {
#line 1131
        *(*(mmx + cur) + k) = -987654321;
      }
#line 1134
      *(*(dmx + cur) + k) = -987654321;
#line 1135
      sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
#line 1135
      if (sc > -987654321) {
#line 1136
        *(*(dmx + cur) + k) = sc;
#line 1136
        *(*(dtr + cur) + k) = *(*(mtr + cur) + (k - 1));
      }
#line 1137
      sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
#line 1137
      if (sc > *(*(dmx + cur) + k)) {
#line 1138
        *(*(dmx + cur) + k) = sc;
#line 1138
        *(*(dtr + cur) + k) = *(*(dtr + cur) + (k - 1));
      }
#line 1141
      if (k < hmm->M) {
#line 1142
        *(*(imx + cur) + k) = -987654321;
#line 1143
        sc = *(*(mmx + prv) + k) + *(*(hmm->tsc + 1) + k);
#line 1143
        if (sc > -987654321) {
#line 1144
          *(*(imx + cur) + k) = sc;
#line 1144
          *(*(itr + cur) + k) = *(*(mtr + prv) + k);
        }
#line 1145
        sc = *(*(imx + prv) + k) + *(*(hmm->tsc + 4) + k);
#line 1145
        if (sc > *(*(imx + cur) + k)) {
#line 1146
          *(*(imx + cur) + k) = sc;
#line 1146
          *(*(itr + cur) + k) = *(*(itr + prv) + k);
        }
#line 1147
        if (*(*(hmm->isc + (int )*(dsq + i___0)) + k) != -987654321) {
#line 1148
          *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
        } else {
#line 1150
          *(*(imx + cur) + k) = -987654321;
        }
      }
#line 1117
      k ++;
    }
#line 1158
    *(*(xmx + cur) + 4) = -987654321;
#line 1159
    sc = *(*(xmx + prv) + 4) + hmm->xsc[0][1];
#line 1159
    if (sc > -987654321) {
#line 1160
      *(*(xmx + cur) + 4) = sc;
    }
#line 1162
    *(*(xmx + cur) + 1) = -987654321;
#line 1163
    k = 1;
#line 1163
    while (k <= hmm->M) {
#line 1164
      sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
#line 1164
      if (sc > *(*(xmx + cur) + 1)) {
#line 1165
        *(*(xmx + cur) + 1) = sc;
#line 1165
        *(etr + i___0) = *(*(mtr + cur) + k);
      }
#line 1163
      k ++;
    }
#line 1167
    *(*(xmx + cur) + 3) = -987654321;
#line 1168
    sc = *(*(xmx + prv) + 3) + hmm->xsc[3][1];
#line 1168
    if (sc > -987654321) {
#line 1169
      *(*(xmx + cur) + 3) = sc;
#line 1169
      *(*(xtr + cur) + 3) = *(*(xtr + prv) + 3);
    }
#line 1170
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][1];
#line 1170
    if (sc > *(*(xmx + cur) + 3)) {
#line 1171
      *(*(xmx + cur) + 3) = sc;
#line 1171
      *(*(xtr + cur) + 3) = i___0;
    }
#line 1173
    *(*(xmx + cur) + 0) = -987654321;
#line 1174
    sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
#line 1174
    if (sc > -987654321) {
#line 1175
      *(*(xmx + cur) + 0) = sc;
#line 1175
      *(btr + i___0) = 0;
    }
#line 1176
    sc = *(*(xmx + cur) + 3) + hmm->xsc[3][0];
#line 1176
    if (sc > *(*(xmx + cur) + 0)) {
#line 1177
      *(*(xmx + cur) + 0) = sc;
#line 1177
      *(btr + i___0) = *(*(xtr + cur) + 3);
    }
#line 1179
    *(*(xmx + cur) + 2) = -987654321;
#line 1180
    sc = *(*(xmx + prv) + 2) + hmm->xsc[2][1];
#line 1180
    if (sc > -987654321) {
#line 1181
      *(*(xmx + cur) + 2) = sc;
#line 1181
      *(*(xtr + cur) + 2) = *(*(xtr + prv) + 2);
    }
#line 1182
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
#line 1182
    if (sc > *(*(xmx + cur) + 2)) {
#line 1183
      *(*(xmx + cur) + 2) = sc;
#line 1183
      *(*(xtr + cur) + 2) = i___0;
    }
#line 1111
    i___0 ++;
  }
#line 1186
  sc = *(*(xmx + cur) + 2) + hmm->xsc[2][0];
#line 1196
  curralloc = 2;
#line 1197
  P7AllocTrace(curralloc, & tr);
#line 1201
  tpos = 0;
#line 1202
  *(tr->statetype + tpos) = (char)9;
#line 1203
  *(tr->pos + tpos) = 0;
#line 1204
  i___0 = *(*(xtr + L % 2) + 2);
#line 1205
  while (i___0 > 0) {
#line 1207
    curralloc += 2;
#line 1208
    P7ReallocTrace(tr, curralloc);
#line 1210
    tpos ++;
#line 1211
    *(tr->statetype + tpos) = (char)7;
#line 1212
    *(tr->pos + tpos) = i___0;
#line 1213
    i___0 = *(etr + i___0);
#line 1215
    tpos ++;
#line 1216
    *(tr->statetype + tpos) = (char)6;
#line 1217
    *(tr->pos + tpos) = i___0;
#line 1218
    i___0 = *(btr + i___0);
  }
#line 1221
  tpos ++;
#line 1222
  *(tr->statetype + tpos) = (char)4;
#line 1223
  *(tr->pos + tpos) = 0;
#line 1224
  tr->tlen = tpos + 1;
#line 1225
  P7ReverseTrace(tr);
#line 1227
  FreePlan7Matrix(mx);
#line 1228
  FreePlan7Matrix(tmx);
#line 1229
  free((void *)btr);
#line 1230
  free((void *)etr);
#line 1232
  *ret_tr = tr;
#line 1233
  tmp___7 = Scorify(sc);
#line 1233
  return (tmp___7);
}
}
#line 1262 "core_algorithms.c"
float P7WeeViterbi(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int *kassign ;
  char *tassign ;
  int *endlist ;
  int *startlist ;
  int lpos ;
  int k1 ;
  int k2 ;
  int k3 ;
  char t1 ;
  char t2 ;
  char t3 ;
  int s1 ;
  int s2 ;
  int s3 ;
  float sc ;
  float ret_sc ;
  int tlen ;
  int i___0 ;
  int k ;
  int tpos ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 1282
  tmp = sre_malloc((char *)"core_algorithms.c", 1282, sizeof(int ) * (unsigned long )(L + 1));
#line 1282
  kassign = (int *)tmp;
#line 1283
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 1283, sizeof(char ) * (unsigned long )(L + 1));
#line 1283
  tassign = (char *)tmp___0;
#line 1284
  tmp___1 = sre_malloc((char *)"core_algorithms.c", 1284, sizeof(int ) * (unsigned long )(L + 1));
#line 1284
  endlist = (int *)tmp___1;
#line 1285
  tmp___2 = sre_malloc((char *)"core_algorithms.c", 1285, sizeof(int ) * (unsigned long )(L + 1));
#line 1285
  startlist = (int *)tmp___2;
#line 1287
  lpos = 0;
#line 1288
  *(startlist + lpos) = 1;
#line 1289
  *(endlist + lpos) = L;
#line 1290
  *(kassign + 1) = 1;
#line 1291
  *(kassign + L) = hmm->M;
#line 1292
  *(tassign + 1) = (char)4;
#line 1293
  *(tassign + L) = (char)9;
#line 1297
  while (lpos >= 0) {
#line 1300
    s1 = *(startlist + lpos);
#line 1301
    k1 = *(kassign + s1);
#line 1302
    t1 = *(tassign + s1);
#line 1303
    s3 = *(endlist + lpos);
#line 1304
    k3 = *(kassign + s3);
#line 1305
    t3 = *(tassign + s3);
#line 1306
    lpos --;
#line 1308
    sc = get_wee_midpt(hmm, dsq, L, k1, t1, s1, k3, t3, s3, & k2, & t2, & s2);
#line 1309
    *(kassign + s2) = k2;
#line 1310
    *(tassign + s2) = t2;
#line 1312
    if ((int )t1 == 4) {
#line 1312
      if ((int )t3 == 9) {
#line 1312
        ret_sc = sc;
      }
    }
#line 1315
    if ((int )t2 != 5) {
#line 1315
      if (s2 - s1 > 1) {
#line 1317
        lpos ++;
#line 1318
        *(startlist + lpos) = s1;
#line 1319
        *(endlist + lpos) = s2;
      } else
#line 1315
      if (s2 - s1 == 1) {
#line 1315
        if ((int )t1 == 4) {
#line 1317
          lpos ++;
#line 1318
          *(startlist + lpos) = s1;
#line 1319
          *(endlist + lpos) = s2;
        }
      }
    }
#line 1322
    if ((int )t2 != 8) {
#line 1322
      if (s3 - s2 > 1) {
#line 1324
        lpos ++;
#line 1325
        *(startlist + lpos) = s2;
#line 1326
        *(endlist + lpos) = s3;
      } else
#line 1322
      if (s3 - s2 == 1) {
#line 1322
        if ((int )t3 == 9) {
#line 1324
          lpos ++;
#line 1325
          *(startlist + lpos) = s2;
#line 1326
          *(endlist + lpos) = s3;
        }
      }
    }
#line 1329
    if ((int )t2 == 5) {
#line 1331
      while (s2 >= s1) {
#line 1332
        *(kassign + s2) = 1;
#line 1333
        *(tassign + s2) = (char)5;
#line 1331
        s2 --;
      }
    }
#line 1336
    if ((int )t2 == 8) {
#line 1338
      while (s2 <= s3) {
#line 1339
        *(kassign + s2) = hmm->M;
#line 1340
        *(tassign + s2) = (char)8;
#line 1338
        s2 ++;
      }
    }
  }
#line 1357
  tlen = L + 6;
#line 1358
  i___0 = 1;
#line 1358
  while (i___0 < L) {
#line 1360
    if ((int )*(tassign + i___0) == 1) {
#line 1360
      if ((int )*(tassign + (i___0 + 1)) == 1) {
#line 1361
        tlen += (*(kassign + (i___0 + 1)) - *(kassign + i___0)) - 1;
      }
    }
#line 1362
    if ((int )*(tassign + i___0) == 5) {
#line 1362
      if ((int )*(tassign + (i___0 + 1)) == 1) {
#line 1363
        tlen += *(kassign + (i___0 + 1)) - 1;
      }
    }
#line 1364
    if ((int )*(tassign + i___0) == 1) {
#line 1364
      if ((int )*(tassign + (i___0 + 1)) == 8) {
#line 1365
        tlen += hmm->M - *(kassign + i___0);
      }
    }
#line 1358
    i___0 ++;
  }
#line 1367
  if ((int )*(tassign + 1) == 1) {
#line 1367
    tlen += *(kassign + 1) - 1;
  }
#line 1368
  if ((int )*(tassign + L) == 1) {
#line 1368
    tlen += hmm->M - *(kassign + L);
  }
#line 1369
  P7AllocTrace(tlen, & tr);
#line 1371
  *(tr->statetype + 0) = (char)4;
#line 1372
  *(tr->nodeidx + 0) = 0;
#line 1373
  *(tr->pos + 0) = 0;
#line 1374
  *(tr->statetype + 1) = (char)5;
#line 1375
  *(tr->nodeidx + 1) = 0;
#line 1376
  *(tr->pos + 1) = 0;
#line 1377
  tpos = 2;
#line 1379
  i___0 = 1;
#line 1379
  while (i___0 <= L) {
#line 1381
    switch ((int )*(tassign + i___0)) {
    case 1: 
#line 1384
    if ((int )*(tr->statetype + (tpos - 1)) == 5) {
#line 1385
      *(tr->statetype + tpos) = (char)6;
#line 1386
      *(tr->nodeidx + tpos) = 0;
#line 1387
      *(tr->pos + tpos) = 0;
#line 1388
      tpos ++;
#line 1390
      tmp___3 = Prob2Score(*(hmm->begin + *(kassign + i___0)), hmm->p1);
#line 1390
      if ((double )tmp___3 + 1000.0 <= (double )*(hmm->bsc + *(kassign + i___0))) {
#line 1391
        k = 1;
#line 1391
        while (k < *(kassign + i___0)) {
#line 1392
          *(tr->statetype + tpos) = (char)2;
#line 1393
          *(tr->nodeidx + tpos) = k;
#line 1394
          *(tr->pos + tpos) = 0;
#line 1395
          tpos ++;
#line 1391
          k ++;
        }
      }
    }
#line 1399
    *(tr->statetype + tpos) = (char)1;
#line 1400
    *(tr->nodeidx + tpos) = *(kassign + i___0);
#line 1401
    *(tr->pos + tpos) = i___0;
#line 1402
    tpos ++;
#line 1404
    if (i___0 < L) {
#line 1404
      if ((int )*(tassign + (i___0 + 1)) == 1) {
#line 1404
        if (*(kassign + (i___0 + 1)) - *(kassign + i___0) > 1) {
#line 1405
          k = *(kassign + i___0) + 1;
#line 1405
          while (k < *(kassign + (i___0 + 1))) {
#line 1407
            *(tr->statetype + tpos) = (char)2;
#line 1408
            *(tr->nodeidx + tpos) = k;
#line 1409
            *(tr->pos + tpos) = 0;
#line 1410
            tpos ++;
#line 1405
            k ++;
          }
        }
      }
    }
#line 1413
    if (i___0 == L) {
#line 1413
      goto _L;
    } else
#line 1413
    if ((int )*(tassign + (i___0 + 1)) == 8) {
      _L: /* CIL Label */ 
#line 1415
      tmp___4 = Prob2Score(*(hmm->end + *(kassign + (i___0 - 1))), (float )1.);
#line 1415
      if ((double )tmp___4 + 1000.0 <= (double )*(hmm->esc + *(kassign + (i___0 - 1)))) {
#line 1416
        k = *(kassign + i___0) + 1;
#line 1416
        while (k <= hmm->M) {
#line 1418
          *(tr->statetype + tpos) = (char)2;
#line 1419
          *(tr->nodeidx + tpos) = k;
#line 1420
          *(tr->pos + tpos) = 0;
#line 1421
          tpos ++;
#line 1416
          k ++;
        }
      }
#line 1424
      *(tr->statetype + tpos) = (char)7;
#line 1425
      *(tr->nodeidx + tpos) = 0;
#line 1426
      *(tr->pos + tpos) = 0;
#line 1427
      tpos ++;
#line 1429
      *(tr->statetype + tpos) = (char)8;
#line 1430
      *(tr->nodeidx + tpos) = 0;
#line 1431
      *(tr->pos + tpos) = 0;
#line 1432
      tpos ++;
    }
#line 1434
    break;
    case 3: 
#line 1437
    *(tr->statetype + tpos) = (char)3;
#line 1438
    *(tr->nodeidx + tpos) = *(kassign + i___0);
#line 1439
    *(tr->pos + tpos) = i___0;
#line 1440
    tpos ++;
#line 1441
    break;
    case 5: 
#line 1444
    *(tr->statetype + tpos) = (char)5;
#line 1445
    *(tr->nodeidx + tpos) = 0;
#line 1446
    *(tr->pos + tpos) = i___0;
#line 1447
    tpos ++;
#line 1448
    break;
    case 8: 
#line 1451
    *(tr->statetype + tpos) = (char)8;
#line 1452
    *(tr->nodeidx + tpos) = 0;
#line 1453
    *(tr->pos + tpos) = i___0;
#line 1454
    tpos ++;
#line 1455
    break;
    default: 
#line 1457
    tmp___5 = Statetype(*(tassign + i___0));
#line 1457
    Die((char *)"Bogus state %s", tmp___5);
    }
#line 1379
    i___0 ++;
  }
#line 1461
  *(tr->statetype + tpos) = (char)9;
#line 1462
  *(tr->nodeidx + tpos) = 0;
#line 1463
  *(tr->pos + tpos) = 0;
#line 1464
  tr->tlen = tpos + 1;
#line 1466
  *ret_tr = tr;
#line 1468
  free((void *)kassign);
#line 1469
  free((void *)tassign);
#line 1470
  free((void *)startlist);
#line 1471
  free((void *)endlist);
#line 1472
  return (ret_sc);
}
}
#line 1482 "core_algorithms.c"
float Plan7ESTViterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int codon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  float tmp___9 ;

  {
#line 1496
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 1503
  *(*(xmx + 0) + 4) = 0;
#line 1504
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
#line 1505
  tmp___0 = -987654321;
#line 1505
  *(*(xmx + 0) + 3) = tmp___0;
#line 1505
  tmp = tmp___0;
#line 1505
  *(*(xmx + 0) + 2) = tmp;
#line 1505
  *(*(xmx + 0) + 1) = tmp;
#line 1506
  k = 0;
#line 1506
  while (k <= hmm->M) {
#line 1507
    tmp___2 = -987654321;
#line 1507
    *(*(dmx + 0) + k) = tmp___2;
#line 1507
    tmp___1 = tmp___2;
#line 1507
    *(*(imx + 0) + k) = tmp___1;
#line 1507
    *(*(mmx + 0) + k) = tmp___1;
#line 1506
    k ++;
  }
#line 1512
  *(*(xmx + 1) + 4) = *(*(xmx + 0) + 4) + hmm->xsc[0][1];
#line 1513
  *(*(xmx + 1) + 0) = *(*(xmx + 1) + 4) + hmm->xsc[0][0];
#line 1514
  tmp___4 = -987654321;
#line 1514
  *(*(xmx + 0) + 3) = tmp___4;
#line 1514
  tmp___3 = tmp___4;
#line 1514
  *(*(xmx + 0) + 2) = tmp___3;
#line 1514
  *(*(xmx + 0) + 1) = tmp___3;
#line 1515
  k = 0;
#line 1515
  while (k <= hmm->M) {
#line 1516
    tmp___6 = -987654321;
#line 1516
    *(*(dmx + 0) + k) = tmp___6;
#line 1516
    tmp___5 = tmp___6;
#line 1516
    *(*(imx + 0) + k) = tmp___5;
#line 1516
    *(*(mmx + 0) + k) = tmp___5;
#line 1515
    k ++;
  }
#line 1523
  i___0 = 2;
#line 1523
  while (i___0 <= L) {
#line 1524
    tmp___8 = -987654321;
#line 1524
    *(*(dmx + i___0) + 0) = tmp___8;
#line 1524
    tmp___7 = tmp___8;
#line 1524
    *(*(imx + i___0) + 0) = tmp___7;
#line 1524
    *(*(mmx + i___0) + 0) = tmp___7;
#line 1527
    if (i___0 > 2) {
#line 1528
      if ((int )*(dsq + (i___0 - 2)) < 4) {
#line 1528
        if ((int )*(dsq + (i___0 - 1)) < 4) {
#line 1528
          if ((int )*(dsq + i___0) < 4) {
#line 1529
            codon = ((int )*(dsq + (i___0 - 2)) * 16 + (int )*(dsq + (i___0 - 1)) * 4) + (int )*(dsq + i___0);
          } else {
#line 1531
            codon = 64;
          }
        } else {
#line 1531
          codon = 64;
        }
      } else {
#line 1531
        codon = 64;
      }
    }
#line 1534
    k = 1;
#line 1534
    while (k <= hmm->M) {
#line 1536
      if (i___0 > 2) {
#line 1537
        *(*(mmx + i___0) + k) = *(*(mmx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
#line 1538
        sc = *(*(imx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
#line 1538
        if (sc > *(*(mmx + i___0) + k)) {
#line 1539
          *(*(mmx + i___0) + k) = sc;
        }
#line 1540
        sc = *(*(xmx + (i___0 - 3)) + 0) + *(hmm->bsc + k);
#line 1540
        if (sc > *(*(mmx + i___0) + k)) {
#line 1541
          *(*(mmx + i___0) + k) = sc;
        }
#line 1542
        sc = *(*(dmx + (i___0 - 3)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
#line 1542
        if (sc > *(*(mmx + i___0) + k)) {
#line 1543
          *(*(mmx + i___0) + k) = sc;
        }
#line 1544
        *(*(mmx + i___0) + k) += *(*(hmm->dnam + codon) + k);
      }
#line 1547
      sc = (*(*(mmx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1))) + hmm->dna2;
#line 1547
      if (sc > *(*(mmx + i___0) + k)) {
#line 1548
        *(*(mmx + i___0) + k) = sc;
      }
#line 1549
      sc = (*(*(imx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) + hmm->dna2;
#line 1549
      if (sc > *(*(mmx + i___0) + k)) {
#line 1550
        *(*(mmx + i___0) + k) = sc;
      }
#line 1551
      sc = (*(*(xmx + (i___0 - 2)) + 0) + *(hmm->bsc + k)) + hmm->dna2;
#line 1551
      if (sc > *(*(mmx + i___0) + k)) {
#line 1552
        *(*(mmx + i___0) + k) = sc;
      }
#line 1553
      sc = (*(*(dmx + (i___0 - 2)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1))) + hmm->dna2;
#line 1553
      if (sc > *(*(mmx + i___0) + k)) {
#line 1554
        *(*(mmx + i___0) + k) = sc;
      }
#line 1557
      if (i___0 > 3) {
#line 1558
        sc = (*(*(mmx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1))) + hmm->dna4;
#line 1558
        if (sc > *(*(mmx + i___0) + k)) {
#line 1559
          *(*(mmx + i___0) + k) = sc;
        }
#line 1560
        sc = (*(*(imx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) + hmm->dna4;
#line 1560
        if (sc > *(*(mmx + i___0) + k)) {
#line 1561
          *(*(mmx + i___0) + k) = sc;
        }
#line 1562
        sc = (*(*(xmx + (i___0 - 4)) + 0) + *(hmm->bsc + k)) + hmm->dna4;
#line 1562
        if (sc > *(*(mmx + i___0) + k)) {
#line 1563
          *(*(mmx + i___0) + k) = sc;
        }
#line 1564
        sc = (*(*(dmx + (i___0 - 4)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1))) + hmm->dna4;
#line 1564
        if (sc > *(*(mmx + i___0) + k)) {
#line 1565
          *(*(mmx + i___0) + k) = sc;
        }
      }
#line 1568
      *(*(dmx + i___0) + k) = *(*(mmx + i___0) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
#line 1569
      sc = *(*(dmx + i___0) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
#line 1569
      if (sc > *(*(dmx + i___0) + k)) {
#line 1570
        *(*(dmx + i___0) + k) = sc;
      }
#line 1573
      if (i___0 > 2) {
#line 1574
        *(*(imx + i___0) + k) = *(*(mmx + (i___0 - 3)) + k) + *(*(hmm->tsc + 1) + k);
#line 1575
        sc = *(*(imx + (i___0 - 3)) + k) + *(*(hmm->tsc + 4) + k);
#line 1575
        if (sc > *(*(imx + i___0) + k)) {
#line 1576
          *(*(imx + i___0) + k) = sc;
        }
#line 1577
        *(*(imx + i___0) + k) += *(*(hmm->dnai + codon) + k);
      }
#line 1581
      sc = (*(*(mmx + (i___0 - 2)) + k) + *(*(hmm->tsc + 1) + k)) + hmm->dna2;
#line 1581
      if (sc > *(*(imx + i___0) + k)) {
#line 1582
        *(*(imx + i___0) + k) = sc;
      }
#line 1583
      sc = (*(*(imx + (i___0 - 2)) + k) + *(*(hmm->tsc + 4) + k)) + hmm->dna2;
#line 1583
      if (sc > *(*(imx + i___0) + k)) {
#line 1584
        *(*(imx + i___0) + k) = sc;
      }
#line 1587
      if (i___0 > 4) {
#line 1588
        sc = (*(*(mmx + (i___0 - 4)) + k) + *(*(hmm->tsc + 1) + k)) + hmm->dna4;
#line 1588
        if (sc > *(*(imx + i___0) + k)) {
#line 1589
          *(*(imx + i___0) + k) = sc;
        }
#line 1590
        sc = (*(*(imx + (i___0 - 4)) + k) + *(*(hmm->tsc + 4) + k)) + hmm->dna4;
#line 1590
        if (sc > *(*(imx + i___0) + k)) {
#line 1591
          *(*(imx + i___0) + k) = sc;
        }
      }
#line 1534
      k ++;
    }
#line 1598
    *(*(xmx + i___0) + 4) = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
#line 1600
    *(*(xmx + i___0) + 1) = *(*(dmx + i___0) + hmm->M);
#line 1601
    k = 1;
#line 1601
    while (k <= hmm->M) {
#line 1602
      sc = *(*(mmx + i___0) + k) + *(hmm->esc + k);
#line 1602
      if (sc > *(*(xmx + i___0) + 1)) {
#line 1603
        *(*(xmx + i___0) + 1) = sc;
      }
#line 1601
      k ++;
    }
#line 1605
    *(*(xmx + i___0) + 3) = *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1];
#line 1606
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][1];
#line 1606
    if (sc > *(*(xmx + i___0) + 3)) {
#line 1607
      *(*(xmx + i___0) + 3) = sc;
    }
#line 1609
    *(*(xmx + i___0) + 0) = *(*(xmx + i___0) + 4) + hmm->xsc[0][0];
#line 1610
    sc = *(*(xmx + i___0) + 3) + hmm->xsc[3][0];
#line 1610
    if (sc > *(*(xmx + i___0) + 0)) {
#line 1611
      *(*(xmx + i___0) + 0) = sc;
    }
#line 1613
    *(*(xmx + i___0) + 2) = *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1];
#line 1614
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][0];
#line 1614
    if (sc > *(*(xmx + i___0) + 2)) {
#line 1615
      *(*(xmx + i___0) + 2) = sc;
    }
#line 1523
    i___0 ++;
  }
#line 1618
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
#line 1620
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
#line 1620
    *ret_mx = mx;
  } else {
#line 1621
    FreePlan7Matrix(mx);
  }
#line 1623
  tmp___9 = Scorify(sc);
#line 1623
  return (tmp___9);
}
}
#line 1652 "core_algorithms.c"
static float get_wee_midpt(struct plan7_s *hmm , char *dsq , int L , int k1 , char t1 ,
                           int s1 , int k3 , char t3 , int s3 , int *ret_k2 , char *ret_t2 ,
                           int *ret_s2 ) 
{ 
  struct dpmatrix_s *fwd ;
  struct dpmatrix_s *bck ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int k2 ;
  char t2 ;
  int s2 ;
  int cur ;
  int prv ;
  int nxt ;
  int i___0 ;
  int k ;
  int sc ;
  int max ;
  int start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  float tmp___13 ;

  {
#line 1679
  s2 = s1 + (s3 - s1) / 2;
#line 1680
  if (s3 - s1 == 1) {
#line 1680
    if ((int )t1 == 4) {
#line 1680
      s2 = s1;
    }
  }
#line 1681
  if (s3 - s1 == 1) {
#line 1681
    if ((int )t3 == 9) {
#line 1681
      s2 = s3;
    }
  }
#line 1687
  if ((int )t1 == 4) {
#line 1687
    start = 0;
  } else {
#line 1687
    start = s1;
  }
#line 1692
  fwd = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 1693
  cur = start % 2;
#line 1694
  tmp = -987654321;
#line 1694
  *(*(xmx + cur) + 0) = tmp;
#line 1694
  *(*(xmx + cur) + 4) = tmp;
#line 1695
  tmp___0 = -987654321;
#line 1695
  *(*(xmx + cur) + 2) = tmp___0;
#line 1695
  *(*(xmx + cur) + 1) = tmp___0;
#line 1696
  k = k1;
#line 1696
  while (k <= k3) {
#line 1697
    tmp___2 = -987654321;
#line 1697
    *(*(dmx + cur) + k) = tmp___2;
#line 1697
    tmp___1 = tmp___2;
#line 1697
    *(*(imx + cur) + k) = tmp___1;
#line 1697
    *(*(mmx + cur) + k) = tmp___1;
#line 1696
    k ++;
  }
#line 1702
  switch ((int )t1) {
  case 1: 
#line 1703
  *(*(mmx + cur) + k1) = 0;
#line 1703
  break;
  case 3: 
#line 1704
  *(*(imx + cur) + k1) = 0;
#line 1704
  break;
  case 5: 
#line 1705
  *(*(xmx + cur) + 4) = 0;
#line 1705
  break;
  case 8: 
#line 1706
  *(*(xmx + cur) + 2) = 0;
#line 1706
  break;
  case 4: 
#line 1707
  *(*(xmx + cur) + 4) = 0;
#line 1707
  break;
  default: 
#line 1708
  tmp___3 = Statetype(t1);
#line 1708
  Die((char *)"you can\'t init get_wee_midpt with a %s\n", tmp___3);
  }
#line 1722
  if ((int )t1 == 1) {
#line 1724
    k = k1 + 1;
#line 1724
    while (k <= k3) {
#line 1726
      *(*(dmx + cur) + k) = -987654321;
#line 1727
      sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
#line 1727
      if (sc > -987654321) {
#line 1728
        *(*(dmx + cur) + k) = sc;
      }
#line 1729
      sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
#line 1729
      if (sc > *(*(dmx + cur) + k)) {
#line 1730
        *(*(dmx + cur) + k) = sc;
      }
#line 1724
      k ++;
    }
#line 1733
    *(*(xmx + cur) + 1) = -987654321;
#line 1734
    sc = *(*(mmx + cur) + k1) + *(hmm->esc + k1);
#line 1734
    if (sc > -987654321) {
#line 1735
      *(*(xmx + cur) + 1) = sc;
    }
  }
#line 1738
  *(*(xmx + cur) + 0) = -987654321;
#line 1739
  sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
#line 1739
  if (sc > -987654321) {
#line 1740
    *(*(xmx + cur) + 0) = sc;
  }
#line 1742
  *(*(xmx + cur) + 2) = -987654321;
#line 1743
  sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
#line 1743
  if (sc > -987654321) {
#line 1744
    *(*(xmx + cur) + 2) = sc;
  }
#line 1749
  i___0 = start + 1;
#line 1749
  while (i___0 <= s2) {
#line 1750
    cur = i___0 % 2;
#line 1751
    prv = ! cur;
#line 1753
    tmp___5 = -987654321;
#line 1753
    *(*(dmx + cur) + k1) = tmp___5;
#line 1753
    tmp___4 = tmp___5;
#line 1753
    *(*(imx + cur) + k1) = tmp___4;
#line 1753
    *(*(mmx + cur) + k1) = tmp___4;
#line 1757
    if (k1 < hmm->M) {
#line 1758
      *(*(imx + cur) + k1) = -987654321;
#line 1759
      sc = *(*(mmx + prv) + k1) + *(*(hmm->tsc + 1) + k1);
#line 1759
      if (sc > -987654321) {
#line 1760
        *(*(imx + cur) + k1) = sc;
      }
#line 1761
      sc = *(*(imx + prv) + k1) + *(*(hmm->tsc + 4) + k1);
#line 1761
      if (sc > *(*(imx + cur) + k1)) {
#line 1762
        *(*(imx + cur) + k1) = sc;
      }
#line 1763
      if (*(*(hmm->isc + (int )*(dsq + i___0)) + k1) != -987654321) {
#line 1764
        *(*(imx + cur) + k1) += *(*(hmm->isc + (int )*(dsq + i___0)) + k1);
      } else {
#line 1766
        *(*(imx + cur) + k1) = -987654321;
      }
    }
#line 1768
    sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k1);
#line 1768
    if (sc > -987654321) {
#line 1769
      *(*(mmx + cur) + k1) = sc;
    }
#line 1770
    if (*(*(hmm->msc + (int )*(dsq + i___0)) + k1) != -987654321) {
#line 1771
      *(*(mmx + cur) + k1) += *(*(hmm->msc + (int )*(dsq + i___0)) + k1);
    } else {
#line 1773
      *(*(mmx + cur) + k1) = -987654321;
    }
#line 1777
    k = k1 + 1;
#line 1777
    while (k <= k3) {
#line 1779
      *(*(mmx + cur) + k) = -987654321;
#line 1780
      sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
#line 1780
      if (sc > -987654321) {
#line 1781
        *(*(mmx + cur) + k) = sc;
      }
#line 1782
      sc = *(*(imx + prv) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1));
#line 1782
      if (sc > *(*(mmx + cur) + k)) {
#line 1783
        *(*(mmx + cur) + k) = sc;
      }
#line 1784
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
#line 1784
      if (sc > *(*(mmx + cur) + k)) {
#line 1785
        *(*(mmx + cur) + k) = sc;
      }
#line 1786
      sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
#line 1786
      if (sc > *(*(mmx + cur) + k)) {
#line 1787
        *(*(mmx + cur) + k) = sc;
      }
#line 1788
      if (*(*(hmm->msc + (int )*(dsq + i___0)) + k) != -987654321) {
#line 1789
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      } else {
#line 1791
        *(*(mmx + cur) + k) = -987654321;
      }
#line 1794
      *(*(dmx + cur) + k) = -987654321;
#line 1795
      if (k < hmm->M) {
#line 1796
        sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
#line 1796
        if (sc > -987654321) {
#line 1797
          *(*(dmx + cur) + k) = sc;
        }
#line 1798
        sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
#line 1798
        if (sc > *(*(dmx + cur) + k)) {
#line 1799
          *(*(dmx + cur) + k) = sc;
        }
      }
#line 1803
      *(*(imx + cur) + k) = -987654321;
#line 1804
      if (k < hmm->M) {
#line 1805
        sc = *(*(mmx + prv) + k) + *(*(hmm->tsc + 1) + k);
#line 1805
        if (sc > -987654321) {
#line 1806
          *(*(imx + cur) + k) = sc;
        }
#line 1807
        sc = *(*(imx + prv) + k) + *(*(hmm->tsc + 4) + k);
#line 1807
        if (sc > *(*(imx + cur) + k)) {
#line 1808
          *(*(imx + cur) + k) = sc;
        }
#line 1809
        if (*(*(hmm->isc + (int )*(dsq + i___0)) + k) != -987654321) {
#line 1810
          *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
        } else {
#line 1812
          *(*(imx + cur) + k) = -987654321;
        }
      }
#line 1777
      k ++;
    }
#line 1816
    *(*(xmx + cur) + 4) = -987654321;
#line 1817
    sc = *(*(xmx + prv) + 4) + hmm->xsc[0][1];
#line 1817
    if (sc > -987654321) {
#line 1818
      *(*(xmx + cur) + 4) = sc;
    }
#line 1820
    *(*(xmx + cur) + 1) = -987654321;
#line 1821
    k = k1;
#line 1821
    while (1) {
#line 1821
      if (k <= k3) {
#line 1821
        if (! (k <= hmm->M)) {
#line 1821
          break;
        }
      } else {
#line 1821
        break;
      }
#line 1822
      sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
#line 1822
      if (sc > *(*(xmx + cur) + 1)) {
#line 1823
        *(*(xmx + cur) + 1) = sc;
      }
#line 1821
      k ++;
    }
#line 1825
    *(*(xmx + cur) + 0) = -987654321;
#line 1826
    sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
#line 1826
    if (sc > -987654321) {
#line 1827
      *(*(xmx + cur) + 0) = sc;
    }
#line 1829
    *(*(xmx + cur) + 2) = -987654321;
#line 1830
    sc = *(*(xmx + prv) + 2) + hmm->xsc[2][1];
#line 1830
    if (sc > -987654321) {
#line 1831
      *(*(xmx + cur) + 2) = sc;
    }
#line 1832
    sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
#line 1832
    if (sc > *(*(xmx + cur) + 2)) {
#line 1833
      *(*(xmx + cur) + 2) = sc;
    }
#line 1749
    i___0 ++;
  }
#line 1846
  bck = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 1847
  nxt = s3 % 2;
#line 1848
  tmp___6 = -987654321;
#line 1848
  *(*(xmx + nxt) + 0) = tmp___6;
#line 1848
  *(*(xmx + nxt) + 4) = tmp___6;
#line 1849
  tmp___7 = -987654321;
#line 1849
  *(*(xmx + nxt) + 2) = tmp___7;
#line 1849
  *(*(xmx + nxt) + 1) = tmp___7;
#line 1850
  k = k1;
#line 1850
  while (k <= k3 + 1) {
#line 1851
    tmp___9 = -987654321;
#line 1851
    *(*(dmx + nxt) + k) = tmp___9;
#line 1851
    tmp___8 = tmp___9;
#line 1851
    *(*(imx + nxt) + k) = tmp___8;
#line 1851
    *(*(mmx + nxt) + k) = tmp___8;
#line 1850
    k ++;
  }
#line 1852
  cur = ! nxt;
#line 1853
  tmp___11 = -987654321;
#line 1853
  *(*(dmx + cur) + (k3 + 1)) = tmp___11;
#line 1853
  tmp___10 = tmp___11;
#line 1853
  *(*(imx + cur) + (k3 + 1)) = tmp___10;
#line 1853
  *(*(mmx + cur) + (k3 + 1)) = tmp___10;
#line 1857
  switch ((int )t3) {
  case 1: 
#line 1858
  *(*(mmx + nxt) + k3) = 0;
#line 1858
  break;
  case 3: 
#line 1859
  *(*(imx + nxt) + k3) = 0;
#line 1859
  break;
  case 5: 
#line 1860
  *(*(xmx + nxt) + 4) = 0;
#line 1860
  break;
  case 8: 
#line 1861
  *(*(xmx + nxt) + 2) = 0;
#line 1861
  break;
  case 9: 
#line 1862
  *(*(xmx + nxt) + 2) = hmm->xsc[2][0];
#line 1862
  break;
  default: 
#line 1863
  tmp___12 = Statetype(t3);
#line 1863
  Die((char *)"you can\'t init get_wee_midpt with a %s\n", tmp___12);
  }
#line 1871
  if ((int )t3 == 9) {
#line 1873
    *(*(xmx + nxt) + 1) = *(*(xmx + nxt) + 2) + hmm->xsc[1][0];
#line 1875
    k = k3;
#line 1875
    while (k >= k1) {
#line 1876
      *(*(mmx + nxt) + k) = *(*(xmx + nxt) + 1) + *(hmm->esc + k);
#line 1877
      if (s3 != s2) {
#line 1878
        *(*(mmx + nxt) + k) += *(*(hmm->msc + (int )*(dsq + s3)) + k);
      }
#line 1875
      k --;
    }
  }
#line 1886
  i___0 = s3 - 1;
#line 1886
  while (i___0 >= s2) {
#line 1888
    cur = i___0 % 2;
#line 1889
    nxt = ! cur;
#line 1891
    *(*(xmx + cur) + 2) = -987654321;
#line 1892
    sc = *(*(xmx + nxt) + 2) + hmm->xsc[2][1];
#line 1892
    if (sc > -987654321) {
#line 1893
      *(*(xmx + cur) + 2) = sc;
    }
#line 1895
    *(*(xmx + cur) + 0) = -987654321;
#line 1896
    k = k1;
#line 1896
    while (k <= k3) {
#line 1897
      sc = *(*(mmx + nxt) + k) + *(hmm->bsc + k);
#line 1897
      if (sc > *(*(xmx + cur) + 0)) {
#line 1898
        *(*(xmx + cur) + 0) = sc;
      }
#line 1896
      k ++;
    }
#line 1900
    *(*(xmx + cur) + 1) = -987654321;
#line 1901
    sc = *(*(xmx + cur) + 2) + hmm->xsc[1][0];
#line 1901
    if (sc > -987654321) {
#line 1902
      *(*(xmx + cur) + 1) = sc;
    }
#line 1904
    *(*(xmx + cur) + 4) = -987654321;
#line 1905
    sc = *(*(xmx + cur) + 0) + hmm->xsc[0][0];
#line 1905
    if (sc > -987654321) {
#line 1906
      *(*(xmx + cur) + 4) = sc;
    }
#line 1907
    sc = *(*(xmx + nxt) + 4) + hmm->xsc[0][1];
#line 1907
    if (sc > *(*(xmx + cur) + 4)) {
#line 1908
      *(*(xmx + cur) + 4) = sc;
    }
#line 1912
    k = k3;
#line 1912
    while (k >= k1) {
#line 1914
      if (k == hmm->M) {
#line 1915
        *(*(mmx + cur) + k) = *(*(xmx + cur) + 1);
#line 1916
        *(*(dmx + cur) + k) = -987654321;
#line 1917
        *(*(imx + cur) + k) = -987654321;
#line 1918
        if (i___0 != s2) {
#line 1919
          *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
        }
#line 1920
        goto __Cont;
      }
#line 1924
      *(*(mmx + cur) + k) = -987654321;
#line 1925
      sc = *(*(xmx + cur) + 1) + *(hmm->esc + k);
#line 1925
      if (sc > -987654321) {
#line 1926
        *(*(mmx + cur) + k) = sc;
      }
#line 1927
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 0) + k);
#line 1927
      if (sc > *(*(mmx + cur) + k)) {
#line 1928
        *(*(mmx + cur) + k) = sc;
      }
#line 1929
      sc = *(*(imx + nxt) + k) + *(*(hmm->tsc + 1) + k);
#line 1929
      if (sc > *(*(mmx + cur) + k)) {
#line 1930
        *(*(mmx + cur) + k) = sc;
      }
#line 1931
      sc = *(*(dmx + cur) + (k + 1)) + *(*(hmm->tsc + 2) + k);
#line 1931
      if (sc > *(*(mmx + cur) + k)) {
#line 1932
        *(*(mmx + cur) + k) = sc;
      }
#line 1933
      if (i___0 != s2) {
#line 1934
        *(*(mmx + cur) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
      }
#line 1937
      *(*(dmx + cur) + k) = -987654321;
#line 1938
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 5) + k);
#line 1938
      if (sc > -987654321) {
#line 1939
        *(*(dmx + cur) + k) = sc;
      }
#line 1940
      sc = *(*(dmx + cur) + (k + 1)) + *(*(hmm->tsc + 6) + k);
#line 1940
      if (sc > *(*(dmx + cur) + k)) {
#line 1941
        *(*(dmx + cur) + k) = sc;
      }
#line 1943
      *(*(imx + cur) + k) = -987654321;
#line 1944
      sc = *(*(mmx + nxt) + (k + 1)) + *(*(hmm->tsc + 3) + k);
#line 1944
      if (sc > -987654321) {
#line 1945
        *(*(imx + cur) + k) = sc;
      }
#line 1946
      sc = *(*(imx + nxt) + k) + *(*(hmm->tsc + 4) + k);
#line 1946
      if (sc > *(*(imx + cur) + k)) {
#line 1947
        *(*(imx + cur) + k) = sc;
      }
#line 1948
      if (i___0 != s2) {
#line 1949
        *(*(imx + cur) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
      }
      __Cont: /* CIL Label */ 
#line 1912
      k --;
    }
#line 1886
    i___0 --;
  }
#line 1959
  cur = s2 % 2;
#line 1960
  max = -987654321;
#line 1961
  k = k1;
#line 1961
  while (k <= k3) {
#line 1963
    sc = *(*(fwd->mmx + cur) + k) + *(*(bck->mmx + cur) + k);
#line 1963
    if (sc > max) {
#line 1964
      k2 = k;
#line 1964
      t2 = (char)1;
#line 1964
      max = sc;
    }
#line 1965
    sc = *(*(fwd->imx + cur) + k) + *(*(bck->imx + cur) + k);
#line 1965
    if (sc > max) {
#line 1966
      k2 = k;
#line 1966
      t2 = (char)3;
#line 1966
      max = sc;
    }
#line 1961
    k ++;
  }
#line 1968
  sc = *(*(fwd->xmx + cur) + 4) + *(*(bck->xmx + cur) + 4);
#line 1968
  if (sc > max) {
#line 1969
    k2 = 1;
#line 1969
    t2 = (char)5;
#line 1969
    max = sc;
  }
#line 1970
  sc = *(*(fwd->xmx + cur) + 2) + *(*(bck->xmx + cur) + 2);
#line 1970
  if (sc > max) {
#line 1971
    k2 = hmm->M;
#line 1971
    t2 = (char)8;
#line 1971
    max = sc;
  }
#line 1977
  FreePlan7Matrix(fwd);
#line 1978
  FreePlan7Matrix(bck);
#line 1979
  *ret_k2 = k2;
#line 1980
  *ret_t2 = t2;
#line 1981
  *ret_s2 = s2;
#line 1982
  tmp___13 = Scorify(max);
#line 1982
  return (tmp___13);
}
}
#line 2021 "core_algorithms.c"
struct p7trace_s *P7ViterbiAlignAlignment(MSA *msa , struct plan7_s *hmm ) 
{ 
  struct dpmatrix_s *mx ;
  struct dpshadow_s *tb ;
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  char **xtb ;
  char **mtb ;
  char **itb ;
  char **dtb ;
  float **con ;
  float *mocc ;
  int i___0 ;
  int k ;
  int idx ;
  int sym ;
  int sc ;
  float denom ;
  int cur ;
  int prv ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char tmp___12 ;
  char tmp___13 ;

  {
#line 2044
  tmp = sre_malloc((char *)"core_algorithms.c", 2044, sizeof(float *) * (unsigned long )(msa->alen + 1));
#line 2044
  con = (float **)tmp;
#line 2045
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 2045, sizeof(float ) * (unsigned long )(msa->alen + 1));
#line 2045
  mocc = (float *)tmp___0;
#line 2046
  i___0 = 1;
#line 2046
  while (i___0 <= msa->alen) {
#line 2047
    tmp___1 = sre_malloc((char *)"core_algorithms.c", 2047, sizeof(float ) * (unsigned long )Alphabet_size);
#line 2047
    *(con + i___0) = (float *)tmp___1;
#line 2048
    FSet(*(con + i___0), Alphabet_size, (float )0.0);
#line 2046
    i___0 ++;
  }
#line 2050
  *(mocc + 0) = (float )(- 9999.);
#line 2054
  denom = FSum(msa->wgt, msa->nseq);
#line 2055
  i___0 = 1;
#line 2055
  while (i___0 <= msa->alen) {
#line 2057
    idx = 0;
#line 2057
    while (idx < msa->nseq) {
#line 2058
      if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32)) {
#line 2058
        if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46)) {
#line 2058
          if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95)) {
#line 2058
            if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45)) {
#line 2058
              if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126)) {
#line 2059
                tmp___2 = strchr((char const   *)(Alphabet), (int )*(*(msa->aseq + idx) + (i___0 - 1)));
#line 2059
                P7CountSymbol(*(con + i___0), (char )(tmp___2 - Alphabet), *(msa->wgt + idx));
              }
            }
          }
        }
      }
#line 2057
      idx ++;
    }
#line 2060
    FScale(*(con + i___0), Alphabet_size, (float )(1. / (double )denom));
#line 2061
    *(mocc + i___0) = FSum(*(con + i___0), Alphabet_size);
#line 2055
    i___0 ++;
  }
#line 2067
  mx = AllocPlan7Matrix(2, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 2068
  tb = AllocShadowMatrix(msa->alen + 1, hmm->M, & xtb, & mtb, & itb, & dtb);
#line 2072
  *(*(xmx + 0) + 4) = 0;
#line 2073
  *(*(xtb + 0) + 4) = (char)4;
#line 2074
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
#line 2075
  *(*(xtb + 0) + 0) = (char)5;
#line 2076
  tmp___4 = -987654321;
#line 2076
  *(*(xmx + 0) + 3) = tmp___4;
#line 2076
  tmp___3 = tmp___4;
#line 2076
  *(*(xmx + 0) + 2) = tmp___3;
#line 2076
  *(*(xmx + 0) + 1) = tmp___3;
#line 2077
  *(tb->esrc + 0) = 0;
#line 2078
  tmp___5 = (char)0;
#line 2078
  *(*(xtb + 0) + 3) = tmp___5;
#line 2078
  *(*(xtb + 0) + 2) = tmp___5;
#line 2079
  k = 0;
#line 2079
  while (k <= hmm->M) {
#line 2080
    tmp___7 = -987654321;
#line 2080
    *(*(dmx + 0) + k) = tmp___7;
#line 2080
    tmp___6 = tmp___7;
#line 2080
    *(*(imx + 0) + k) = tmp___6;
#line 2080
    *(*(mmx + 0) + k) = tmp___6;
#line 2081
    tmp___9 = (char)0;
#line 2081
    *(*(dtb + 0) + k) = tmp___9;
#line 2081
    tmp___8 = tmp___9;
#line 2081
    *(*(itb + 0) + k) = tmp___8;
#line 2081
    *(*(mtb + 0) + k) = tmp___8;
#line 2079
    k ++;
  }
#line 2089
  i___0 = 1;
#line 2089
  while (i___0 <= msa->alen) {
#line 2090
    cur = i___0 % 2;
#line 2091
    prv = ! cur;
#line 2093
    tmp___11 = -987654321;
#line 2093
    *(*(dmx + cur) + 0) = tmp___11;
#line 2093
    tmp___10 = tmp___11;
#line 2093
    *(*(imx + cur) + 0) = tmp___10;
#line 2093
    *(*(mmx + cur) + 0) = tmp___10;
#line 2094
    tmp___13 = (char)0;
#line 2094
    *(*(dtb + i___0) + 0) = tmp___13;
#line 2094
    tmp___12 = tmp___13;
#line 2094
    *(*(itb + i___0) + 0) = tmp___12;
#line 2094
    *(*(mtb + i___0) + 0) = tmp___12;
#line 2096
    k = 1;
#line 2096
    while (k <= hmm->M) {
#line 2098
      *(*(mmx + cur) + k) = -987654321;
#line 2099
      *(*(mtb + i___0) + k) = (char)0;
#line 2100
      if (*(*(mmx + prv) + (k - 1)) > -987654321) {
#line 2100
        if (*(*(hmm->tsc + 0) + (k - 1)) > -987654321) {
#line 2100
          sc = *(*(mmx + prv) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1));
#line 2100
          if (sc > *(*(mmx + cur) + k)) {
#line 2102
            *(*(mmx + cur) + k) = sc;
#line 2102
            *(*(mtb + i___0) + k) = (char)1;
          }
        }
      }
#line 2103
      if (*(*(imx + prv) + (k - 1)) > -987654321) {
#line 2103
        if (*(*(hmm->tsc + 3) + (k - 1)) > -987654321) {
#line 2103
          sc = (int )((float )*(*(imx + prv) + (k - 1)) + (float )*(*(hmm->tsc + 3) + (k - 1)) * *(mocc + (i___0 - 1)));
#line 2103
          if (sc > *(*(mmx + cur) + k)) {
#line 2105
            *(*(mmx + cur) + k) = sc;
#line 2105
            *(*(mtb + i___0) + k) = (char)3;
          }
        }
      }
#line 2106
      sc = *(*(xmx + prv) + 0) + *(hmm->bsc + k);
#line 2106
      if (sc > *(*(mmx + cur) + k)) {
#line 2107
        *(*(mmx + cur) + k) = sc;
#line 2107
        *(*(mtb + i___0) + k) = (char)6;
      }
#line 2108
      if (*(*(dmx + prv) + (k - 1)) > -987654321) {
#line 2108
        if (*(*(hmm->tsc + 5) + (k - 1)) > -987654321) {
#line 2108
          sc = *(*(dmx + prv) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1));
#line 2108
          if (sc > *(*(mmx + cur) + k)) {
#line 2110
            *(*(mmx + cur) + k) = sc;
#line 2110
            *(*(mtb + i___0) + k) = (char)2;
          }
        }
      }
#line 2112
      sym = 0;
#line 2112
      while (sym < Alphabet_size) {
#line 2114
        if (*(*(con + i___0) + sym) > (float )0) {
#line 2114
          if (*(*(hmm->msc + sym) + k) == -987654321) {
#line 2114
            *(*(mmx + cur) + k) = -987654321;
#line 2114
            break;
          }
        }
#line 2115
        *(*(mmx + cur) + k) = (int )((float )*(*(mmx + cur) + k) + (float )*(*(hmm->msc + sym) + k) * *(*(con + i___0) + sym));
#line 2112
        sym ++;
      }
#line 2119
      *(*(dmx + cur) + k) = -987654321;
#line 2120
      *(*(dtb + i___0) + k) = (char)0;
#line 2121
      if (*(*(mmx + cur) + (k - 1)) > -987654321) {
#line 2121
        if (*(*(hmm->tsc + 2) + (k - 1)) > -987654321) {
#line 2121
          sc = *(*(mmx + cur) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1));
#line 2121
          if (sc > *(*(dmx + cur) + k)) {
#line 2123
            *(*(dmx + cur) + k) = sc;
#line 2123
            *(*(dtb + i___0) + k) = (char)1;
          }
        }
      }
#line 2124
      if (*(*(dmx + cur) + (k - 1)) > -987654321) {
#line 2124
        if (*(*(hmm->tsc + 6) + (k - 1)) > -987654321) {
#line 2124
          sc = *(*(dmx + cur) + (k - 1)) + *(*(hmm->tsc + 6) + (k - 1));
#line 2124
          if (sc > *(*(dmx + cur) + k)) {
#line 2126
            *(*(dmx + cur) + k) = sc;
#line 2126
            *(*(dtb + i___0) + k) = (char)2;
          }
        }
      }
#line 2129
      if (k < hmm->M) {
#line 2130
        *(*(imx + cur) + k) = -987654321;
#line 2131
        *(*(itb + i___0) + k) = (char)0;
#line 2132
        if (*(*(mmx + prv) + k) > -987654321) {
#line 2132
          if (*(*(hmm->tsc + 1) + k) > -987654321) {
#line 2132
            sc = (int )((float )*(*(mmx + prv) + k) + (float )*(*(hmm->tsc + 1) + k) * *(mocc + i___0));
#line 2132
            if (sc > *(*(imx + cur) + k)) {
#line 2134
              *(*(imx + cur) + k) = sc;
#line 2134
              *(*(itb + i___0) + k) = (char)1;
            }
          }
        }
#line 2135
        if (*(*(imx + prv) + k) > -987654321) {
#line 2135
          if (*(*(hmm->tsc + 4) + k) > -987654321) {
#line 2135
            sc = (int )((float )*(*(imx + prv) + k) + ((float )*(*(hmm->tsc + 4) + k) * *(mocc + (i___0 - 1))) * *(mocc + i___0));
#line 2135
            if (sc > *(*(imx + cur) + k)) {
#line 2137
              *(*(imx + cur) + k) = sc;
#line 2137
              *(*(itb + i___0) + k) = (char)3;
            }
          }
        }
#line 2139
        sym = 0;
#line 2139
        while (sym < Alphabet_size) {
#line 2141
          if (*(*(con + i___0) + sym) > (float )0) {
#line 2141
            if (*(*(hmm->isc + sym) + k) == -987654321) {
#line 2141
              *(*(imx + cur) + k) = -987654321;
#line 2141
              break;
            }
          }
#line 2142
          *(*(imx + cur) + k) = (int )((float )*(*(imx + cur) + k) + (float )*(*(hmm->isc + sym) + k) * *(*(con + i___0) + sym));
#line 2139
          sym ++;
        }
      }
#line 2096
      k ++;
    }
#line 2151
    *(*(xmx + cur) + 4) = -987654321;
#line 2152
    *(*(xtb + i___0) + 4) = (char)0;
#line 2153
    if (*(*(xmx + prv) + 4) > -987654321) {
#line 2153
      if (hmm->xsc[0][1] > -987654321) {
#line 2153
        sc = (int )((float )*(*(xmx + prv) + 4) + (float )hmm->xsc[0][1] * *(mocc + i___0));
#line 2153
        if (sc > -987654321) {
#line 2155
          *(*(xmx + cur) + 4) = sc;
#line 2155
          *(*(xtb + i___0) + 4) = (char)5;
        }
      }
    }
#line 2157
    *(*(xmx + cur) + 1) = -987654321;
#line 2158
    *(*(xtb + i___0) + 1) = (char)0;
#line 2159
    k = 1;
#line 2159
    while (k <= hmm->M) {
#line 2160
      if (*(*(mmx + cur) + k) > -987654321) {
#line 2160
        if (*(hmm->esc + k) > -987654321) {
#line 2160
          sc = *(*(mmx + cur) + k) + *(hmm->esc + k);
#line 2160
          if (sc > *(*(xmx + cur) + 1)) {
#line 2162
            *(*(xmx + cur) + 1) = sc;
#line 2162
            *(tb->esrc + i___0) = k;
          }
        }
      }
#line 2159
      k ++;
    }
#line 2166
    *(*(xmx + cur) + 0) = -987654321;
#line 2167
    *(*(xtb + i___0) + 0) = (char)0;
#line 2168
    if (*(*(xmx + cur) + 4) > -987654321) {
#line 2168
      if (hmm->xsc[0][0] > -987654321) {
#line 2168
        sc = *(*(xmx + cur) + 4) + hmm->xsc[0][0];
#line 2168
        if (sc > *(*(xmx + cur) + 0)) {
#line 2170
          *(*(xmx + cur) + 0) = sc;
#line 2170
          *(*(xtb + i___0) + 0) = (char)5;
        }
      }
    }
#line 2173
    *(*(xmx + cur) + 2) = -987654321;
#line 2174
    *(*(xtb + i___0) + 2) = (char)0;
#line 2175
    if (*(*(xmx + prv) + 2) > -987654321) {
#line 2175
      if (hmm->xsc[2][1] > -987654321) {
#line 2175
        sc = (int )((float )*(*(xmx + prv) + 2) + (float )hmm->xsc[2][1] * *(mocc + i___0));
#line 2175
        if (sc > -987654321) {
#line 2177
          *(*(xmx + cur) + 2) = sc;
#line 2177
          *(*(xtb + i___0) + 2) = (char)8;
        }
      }
    }
#line 2178
    if (*(*(xmx + cur) + 1) > -987654321) {
#line 2178
      if (hmm->xsc[1][0] > -987654321) {
#line 2178
        sc = *(*(xmx + cur) + 1) + hmm->xsc[1][0];
#line 2178
        if (sc > *(*(xmx + cur) + 2)) {
#line 2180
          *(*(xmx + cur) + 2) = sc;
#line 2180
          *(*(xtb + i___0) + 2) = (char)7;
        }
      }
    }
#line 2089
    i___0 ++;
  }
#line 2183
  sc = *(*(xmx + msa->alen % 2) + 2) + hmm->xsc[2][0];
#line 2186
  tr = ShadowTrace(tb, hmm, msa->alen);
#line 2188
  FreePlan7Matrix(mx);
#line 2189
  FreeShadowMatrix(tb);
#line 2190
  i___0 = 1;
#line 2190
  while (i___0 <= msa->alen) {
#line 2191
    free((void *)*(con + i___0));
#line 2190
    i___0 ++;
  }
#line 2192
  free((void *)con);
#line 2193
  free((void *)mocc);
#line 2195
  return (tr);
}
}
#line 2212 "core_algorithms.c"
struct p7trace_s *ShadowTrace(struct dpshadow_s *tb , struct plan7_s *hmm , int L ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  char nxtstate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int dk ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 2226
  curralloc = L * 2 + 6;
#line 2227
  P7AllocTrace(curralloc, & tr);
#line 2232
  *(tr->statetype + 0) = (char)9;
#line 2233
  *(tr->nodeidx + 0) = 0;
#line 2234
  *(tr->pos + 0) = 0;
#line 2235
  tpos = 1;
#line 2236
  i___0 = L;
#line 2237
  k = 0;
#line 2238
  nxtstate = (char)8;
#line 2242
  while ((int )nxtstate != 4) {
#line 2243
    switch ((int )nxtstate) {
    case 1: 
#line 2245
    *(tr->statetype + tpos) = (char)1;
#line 2246
    nxtstate = *(*(tb->mtb + i___0) + k);
#line 2247
    tmp = k;
#line 2247
    k --;
#line 2247
    *(tr->nodeidx + tpos) = tmp;
#line 2248
    tmp___0 = i___0;
#line 2248
    i___0 --;
#line 2248
    *(tr->pos + tpos) = tmp___0;
#line 2249
    tpos ++;
#line 2250
    break;
    case 3: 
#line 2253
    *(tr->statetype + tpos) = (char)3;
#line 2254
    nxtstate = *(*(tb->itb + i___0) + k);
#line 2255
    *(tr->nodeidx + tpos) = k;
#line 2256
    tmp___1 = i___0;
#line 2256
    i___0 --;
#line 2256
    *(tr->pos + tpos) = tmp___1;
#line 2257
    tpos ++;
#line 2258
    break;
    case 2: 
#line 2261
    *(tr->statetype + tpos) = (char)2;
#line 2262
    nxtstate = *(*(tb->dtb + i___0) + k);
#line 2263
    tmp___2 = k;
#line 2263
    k --;
#line 2263
    *(tr->nodeidx + tpos) = tmp___2;
#line 2264
    *(tr->pos + tpos) = 0;
#line 2265
    tpos ++;
#line 2266
    break;
    case 5: 
#line 2269
    *(tr->statetype + tpos) = (char)5;
#line 2270
    nxtstate = *(*(tb->xtb + i___0) + 4);
#line 2271
    *(tr->nodeidx + tpos) = 0;
#line 2272
    if ((int )nxtstate == 5) {
#line 2272
      tmp___3 = i___0;
#line 2272
      i___0 --;
#line 2272
      *(tr->pos + tpos) = tmp___3;
    } else {
#line 2272
      *(tr->pos + tpos) = 0;
    }
#line 2273
    tpos ++;
#line 2274
    break;
    case 6: 
#line 2278
    tmp___5 = Prob2Score(*(hmm->begin + (k + 1)), hmm->p1);
#line 2278
    if ((double )tmp___5 + (double )1 * 1000.0 <= (double )*(hmm->bsc + (k + 1))) {
#line 2279
      while (k > 0) {
#line 2281
        *(tr->statetype + tpos) = (char)2;
#line 2282
        tmp___4 = k;
#line 2282
        k --;
#line 2282
        *(tr->nodeidx + tpos) = tmp___4;
#line 2283
        *(tr->pos + tpos) = 0;
#line 2284
        tpos ++;
#line 2285
        if (tpos == curralloc) {
#line 2287
          curralloc += L;
#line 2288
          P7ReallocTrace(tr, curralloc);
        }
      }
    }
#line 2292
    *(tr->statetype + tpos) = (char)6;
#line 2293
    nxtstate = *(*(tb->xtb + i___0) + 0);
#line 2294
    *(tr->nodeidx + tpos) = 0;
#line 2295
    *(tr->pos + tpos) = 0;
#line 2296
    tpos ++;
#line 2297
    break;
    case 10: 
#line 2300
    *(tr->statetype + tpos) = (char)10;
#line 2301
    nxtstate = *(*(tb->xtb + i___0) + 3);
#line 2302
    *(tr->nodeidx + tpos) = 0;
#line 2303
    if ((int )nxtstate == 10) {
#line 2303
      tmp___6 = i___0;
#line 2303
      i___0 --;
#line 2303
      *(tr->pos + tpos) = tmp___6;
    } else {
#line 2303
      *(tr->pos + tpos) = 0;
    }
#line 2304
    tpos ++;
#line 2305
    break;
    case 7: 
#line 2308
    *(tr->statetype + tpos) = (char)7;
#line 2309
    *(tr->nodeidx + tpos) = 0;
#line 2310
    *(tr->pos + tpos) = 0;
#line 2311
    k = *(tb->esrc + i___0);
#line 2312
    nxtstate = (char)1;
#line 2313
    tpos ++;
#line 2315
    tmp___7 = Prob2Score(*(hmm->end + k), (float )1.);
#line 2315
    if ((double )tmp___7 + (double )1 * 1000.0 <= (double )*(hmm->esc + k)) {
#line 2318
      dk = hmm->M;
#line 2318
      while (dk > k) {
#line 2320
        *(tr->statetype + tpos) = (char)2;
#line 2321
        *(tr->nodeidx + tpos) = dk;
#line 2322
        *(tr->pos + tpos) = 0;
#line 2323
        tpos ++;
#line 2324
        if (tpos == curralloc) {
#line 2326
          curralloc += L;
#line 2327
          P7ReallocTrace(tr, curralloc);
        }
#line 2318
        dk --;
      }
    }
#line 2331
    break;
    case 8: 
#line 2334
    *(tr->statetype + tpos) = (char)8;
#line 2335
    nxtstate = *(*(tb->xtb + i___0) + 2);
#line 2336
    *(tr->nodeidx + tpos) = 0;
#line 2337
    if ((int )nxtstate == 8) {
#line 2337
      tmp___8 = i___0;
#line 2337
      i___0 --;
#line 2337
      *(tr->pos + tpos) = tmp___8;
    } else {
#line 2337
      *(tr->pos + tpos) = 0;
    }
#line 2338
    tpos ++;
#line 2339
    break;
    default: 
#line 2342
    tmp___9 = Statetype(nxtstate);
#line 2342
    Die((char *)"HMMER: Bad state (%s) in ShadowTrace()\n", tmp___9);
    }
#line 2346
    if (tpos == curralloc) {
#line 2348
      curralloc += L;
#line 2349
      P7ReallocTrace(tr, curralloc);
    }
  }
#line 2354
  *(tr->statetype + tpos) = (char)4;
#line 2355
  *(tr->nodeidx + tpos) = 0;
#line 2356
  *(tr->pos + tpos) = 0;
#line 2357
  tr->tlen = tpos + 1;
#line 2359
  P7ReverseTrace(tr);
#line 2360
  return (tr);
}
}
#line 2435 "core_algorithms.c"
float PostprocessSignificantHit(struct tophit_s *ghit , struct tophit_s *dhit , struct p7trace_s *tr ,
                                struct plan7_s *hmm , char *dsq , int L , char *seqname ,
                                char *seqacc , char *seqdesc , int do_forward , float sc_override ,
                                int do_null2 , struct threshold_s *thresh___0 , int hmmpfam_mode ) 
{ 
  struct p7trace_s **tarr ;
  struct fancyali_s *ali ;
  int ntr ;
  int tidx ;
  int ndom ;
  int didx ;
  int k1 ;
  int k2 ;
  int i1 ;
  int i2 ;
  float whole_sc ;
  float *score ;
  int *usedomain ;
  double whole_pval ;
  double pvalue ;
  double sortkey ;
  void *tmp ;
  void *tmp___0 ;
  float tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 2469
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
#line 2469
    return (sc_override);
  }
#line 2473
  TraceDecompose(tr, & tarr, & ntr);
#line 2474
  if (ntr == 0) {
#line 2474
    Die((char *)"TraceDecompose() screwup");
  }
#line 2480
  tmp = sre_malloc((char *)"core_algorithms.c", 2480, sizeof(float ) * (unsigned long )ntr);
#line 2480
  score = (float *)tmp;
#line 2481
  tmp___0 = sre_malloc((char *)"core_algorithms.c", 2481, sizeof(int ) * (unsigned long )ntr);
#line 2481
  usedomain = (int *)tmp___0;
#line 2482
  ndom = 0;
#line 2483
  whole_sc = (float )0.;
#line 2484
  tidx = 0;
#line 2484
  while (tidx < ntr) {
#line 2486
    *(score + tidx) = P7TraceScore(hmm, dsq, *(tarr + tidx));
#line 2487
    if (do_null2) {
#line 2487
      tmp___1 = TraceScoreCorrection(hmm, *(tarr + tidx), dsq);
#line 2487
      *(score + tidx) -= tmp___1;
    }
#line 2488
    if ((double )*(score + tidx) > 0.0) {
#line 2489
      *(usedomain + tidx) = 1;
#line 2490
      ndom ++;
#line 2491
      whole_sc += *(score + tidx);
    } else {
#line 2493
      *(usedomain + tidx) = 0;
    }
#line 2484
    tidx ++;
  }
#line 2502
  if (ndom == 0) {
#line 2503
    tidx = FArgMax(score, ntr);
#line 2504
    *(usedomain + tidx) = 1;
#line 2505
    whole_sc = *(score + tidx);
#line 2506
    ndom = 1;
  }
#line 2514
  if (do_forward) {
#line 2514
    whole_sc = sc_override;
  }
#line 2518
  whole_pval = PValue(hmm, whole_sc);
#line 2519
  tidx = 0;
#line 2519
  didx = 1;
#line 2519
  while (tidx < ntr) {
#line 2520
    if (! *(usedomain + tidx)) {
#line 2520
      goto __Cont;
    }
#line 2522
    TraceSimpleBounds(*(tarr + tidx), & i1, & i2, & k1, & k2);
#line 2523
    pvalue = PValue(hmm, *(score + tidx));
#line 2525
    if (pvalue <= thresh___0->domE) {
#line 2525
      if (*(score + tidx) >= thresh___0->domT) {
#line 2526
        ali = CreateFancyAli(*(tarr + tidx), hmm, dsq, seqname);
#line 2528
        if (hmmpfam_mode) {
#line 2529
          sortkey = - 1. * (double )i1;
        } else {
#line 2531
          sortkey = (double )*(score + tidx);
        }
#line 2533
        if (hmmpfam_mode) {
#line 2533
          tmp___2 = hmm->desc;
        } else {
#line 2533
          tmp___2 = seqdesc;
        }
#line 2533
        if (hmmpfam_mode) {
#line 2533
          tmp___3 = hmm->acc;
        } else {
#line 2533
          tmp___3 = seqacc;
        }
#line 2533
        if (hmmpfam_mode) {
#line 2533
          tmp___4 = hmm->name;
        } else {
#line 2533
          tmp___4 = seqname;
        }
#line 2533
        RegisterHit(dhit, sortkey, pvalue, *(score + tidx), whole_pval, whole_sc,
                    tmp___4, tmp___3, tmp___2, i1, i2, L, k1, k2, hmm->M, didx, ndom,
                    ali);
      }
    }
#line 2543
    didx ++;
    __Cont: /* CIL Label */ 
#line 2519
    tidx ++;
  }
#line 2559
  if (hmmpfam_mode) {
#line 2560
    if (whole_pval > 0.0) {
#line 2560
      tmp___5 = log(whole_pval);
#line 2560
      sortkey = - 1. * tmp___5;
    } else {
#line 2560
      sortkey = 100000. + (double )whole_sc;
    }
  } else {
#line 2562
    sortkey = (double )whole_sc;
  }
#line 2576
  if (whole_sc >= thresh___0->globT) {
#line 2577
    if (hmmpfam_mode) {
#line 2577
      tmp___6 = hmm->desc;
    } else {
#line 2577
      tmp___6 = seqdesc;
    }
#line 2577
    if (hmmpfam_mode) {
#line 2577
      tmp___7 = hmm->acc;
    } else {
#line 2577
      tmp___7 = seqacc;
    }
#line 2577
    if (hmmpfam_mode) {
#line 2577
      tmp___8 = hmm->name;
    } else {
#line 2577
      tmp___8 = seqname;
    }
#line 2577
    RegisterHit(ghit, sortkey, whole_pval, whole_sc, 0., (float )0., tmp___8, tmp___7,
                tmp___6, 0, 0, 0, 0, 0, 0, 0, ndom, (struct fancyali_s *)((void *)0));
  }
#line 2591
  tidx = 0;
#line 2591
  while (tidx < ntr) {
#line 2592
    P7FreeTrace(*(tarr + tidx));
#line 2591
    tidx ++;
  }
#line 2593
  free((void *)tarr);
#line 2594
  free((void *)score);
#line 2595
  free((void *)usedomain);
#line 2596
  return (whole_sc);
}
}
#line 1 "debug.o"
#pragma merger("0","/tmp/cil-wUyp9MLg.i","")
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 75 "./funcs.h"
char *AlphabetType2String(int type ) ;
#line 76
void P7PrintTrace(FILE *fp , struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ) ;
#line 78
void P7PrintPrior(FILE *fp , struct p7prior_s *pri ) ;
#line 79
int TraceCompare(struct p7trace_s *t1 , struct p7trace_s *t2 ) ;
#line 80
int TraceVerify(struct p7trace_s *tr , int M , int N ) ;
#line 339
int TransitionScoreLookup(struct plan7_s *hmm , char st1 , int k1 , char st2 , int k2 ) ;
#line 37 "debug.c"
char *Statetype(char st ) 
{ 


  {
#line 40
  switch ((int )st) {
  case 4: 
#line 41
  return ((char *)"S");
  case 5: 
#line 42
  return ((char *)"N");
  case 6: 
#line 43
  return ((char *)"B");
  case 1: 
#line 44
  return ((char *)"M");
  case 2: 
#line 45
  return ((char *)"D");
  case 3: 
#line 46
  return ((char *)"I");
  case 7: 
#line 47
  return ((char *)"E");
  case 10: 
#line 48
  return ((char *)"J");
  case 8: 
#line 49
  return ((char *)"C");
  case 9: 
#line 50
  return ((char *)"T");
  default: 
#line 51
  return ((char *)"BOGUS");
  }
}
}
#line 66 "debug.c"
char *AlphabetType2String(int type ) 
{ 


  {
#line 69
  switch (type) {
  case 3: 
#line 70
  return ((char *)"protein");
  case 2: 
#line 71
  return ((char *)"nucleic acid");
  case 0: 
#line 72
  return ((char *)"unknown");
  default: 
#line 73
  return ((char *)"BOGUS");
  }
}
}
#line 88 "debug.c"
void P7PrintTrace(FILE *fp , struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ) 
{ 
  int tpos ;
  int sym ;
  int sc ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 95
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
#line 96
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" [ trace is NULL ]\n");
#line 97
    return;
  }
#line 100
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 101
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"st  node   rpos  - traceback len %d\n",
            tr->tlen);
#line 102
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"--  ---- ------\n");
#line 103
    tpos = 0;
#line 103
    while (tpos < tr->tlen) {
#line 104
      tmp = Statetype(*(tr->statetype + tpos));
#line 104
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%1s  %4d %6d\n",
              tmp, *(tr->nodeidx + tpos), *(tr->pos + tpos));
#line 103
      tpos ++;
    }
  } else {
#line 110
    if (! (hmm->flags & 1)) {
#line 111
      Die((char *)"oi, you can\'t print scores from that hmm, it\'s not ready.");
    }
#line 113
    sc = 0;
#line 114
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"st  node   rpos  transit emission - traceback len %d\n",
            tr->tlen);
#line 115
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"--  ---- ------  ------- --------\n");
#line 116
    tpos = 0;
#line 116
    while (tpos < tr->tlen) {
#line 117
      if ((unsigned long )dsq != (unsigned long )((void *)0)) {
#line 117
        sym = (int )*(dsq + *(tr->pos + tpos));
      }
#line 119
      if (tpos < tr->tlen - 1) {
#line 119
        tmp___0 = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                        *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
#line 119
        tmp___1 = tmp___0;
      } else {
#line 119
        tmp___1 = 0;
      }
#line 119
      tmp___2 = Statetype(*(tr->statetype + tpos));
#line 119
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%1s  %4d %6d  %7d",
              tmp___2, *(tr->nodeidx + tpos), *(tr->pos + tpos), tmp___1);
#line 127
      if (tpos < tr->tlen - 1) {
#line 128
        tmp___3 = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                        *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
#line 128
        sc += tmp___3;
      }
#line 131
      if ((unsigned long )dsq != (unsigned long )((void *)0)) {
#line 132
        if ((int )*(tr->statetype + tpos) == 1) {
#line 134
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8d %c",
                  *(*(hmm->msc + sym) + *(tr->nodeidx + tpos)), (int )Alphabet[sym]);
#line 136
          sc += *(*(hmm->msc + sym) + *(tr->nodeidx + tpos));
        } else
#line 138
        if ((int )*(tr->statetype + tpos) == 3) {
#line 140
          tmp___4 = tolower((int )Alphabet[sym]);
#line 140
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8d %c",
                  *(*(hmm->isc + sym) + *(tr->nodeidx + tpos)), (int )((char )tmp___4));
#line 142
          sc += *(*(hmm->isc + sym) + *(tr->nodeidx + tpos));
        } else
#line 144
        if ((int )*(tr->statetype + tpos) == 5) {
#line 144
          if ((int )*(tr->statetype + (tpos - 1)) == 5) {
#line 148
            tmp___5 = tolower((int )Alphabet[sym]);
#line 148
            fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8d %c",
                    0, (int )((char )tmp___5));
          } else {
#line 144
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 144
        if ((int )*(tr->statetype + tpos) == 8) {
#line 144
          if ((int )*(tr->statetype + (tpos - 1)) == 8) {
#line 148
            tmp___5 = tolower((int )Alphabet[sym]);
#line 148
            fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8d %c",
                    0, (int )((char )tmp___5));
          } else {
#line 144
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 144
        if ((int )*(tr->statetype + tpos) == 10) {
#line 144
          if ((int )*(tr->statetype + (tpos - 1)) == 10) {
#line 148
            tmp___5 = tolower((int )Alphabet[sym]);
#line 148
            fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8d %c",
                    0, (int )((char )tmp___5));
          }
        }
      } else {
#line 151
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8s %c", "-",
                '-');
      }
#line 155
      fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 116
      tpos ++;
    }
#line 157
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                 ------- --------\n");
#line 158
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"           total: %6d\n\n",
            sc);
  }
#line 160
  return;
}
}
#line 166 "debug.c"
void P7PrintPrior(FILE *fp , struct p7prior_s *pri ) 
{ 
  int q ;
  int x ;

  {
#line 171
  if (pri->strategy == 0) {
#line 171
    fputs((char const   * __restrict  )"Dirichlet\n", (FILE * __restrict  )fp);
  } else
#line 172
  if (pri->strategy == 1) {
#line 172
    fputs((char const   * __restrict  )"PAM\n", (FILE * __restrict  )fp);
  } else {
#line 173
    Die((char *)"No such strategy.");
  }
#line 175
  if (Alphabet_type == 3) {
#line 175
    fputs((char const   * __restrict  )"Amino\n", (FILE * __restrict  )fp);
  } else
#line 176
  if (Alphabet_type == 2) {
#line 176
    fputs((char const   * __restrict  )"Nucleic\n", (FILE * __restrict  )fp);
  }
#line 180
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n%d\n", pri->tnum);
#line 181
  q = 0;
#line 181
  while (q < pri->tnum) {
#line 183
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f\n", (double )pri->tq[q]);
#line 184
    x = 0;
#line 184
    while (x < 7) {
#line 185
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f ", (double )pri->t[q][x]);
#line 184
      x ++;
    }
#line 186
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 181
    q ++;
  }
#line 191
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n%d\n", pri->mnum);
#line 192
  q = 0;
#line 192
  while (q < pri->mnum) {
#line 194
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f\n", (double )pri->mq[q]);
#line 195
    x = 0;
#line 195
    while (x < Alphabet_size) {
#line 196
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f ", (double )pri->m[q][x]);
#line 195
      x ++;
    }
#line 197
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 192
    q ++;
  }
#line 202
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n%d\n", pri->inum);
#line 203
  q = 0;
#line 203
  while (q < pri->inum) {
#line 205
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f\n", (double )pri->iq[q]);
#line 206
    x = 0;
#line 206
    while (x < Alphabet_size) {
#line 207
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%.4f ", (double )pri->i[q][x]);
#line 206
      x ++;
    }
#line 208
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 203
    q ++;
  }
#line 210
  return;
}
}
#line 224 "debug.c"
int TraceVerify(struct p7trace_s *tr , int M , int N ) 
{ 
  int tpos ;
  int k ;
  int i___0 ;
  int nn ;
  int nc ;
  int nj ;
  int nm ;

  {
#line 235
  if ((int )*(tr->statetype + 0) != 4) {
#line 235
    return (0);
  }
#line 236
  if ((int )*(tr->statetype + 1) != 5) {
#line 236
    return (0);
  }
#line 237
  if ((int )*(tr->statetype + (tr->tlen - 2)) != 8) {
#line 237
    return (0);
  }
#line 238
  if ((int )*(tr->statetype + (tr->tlen - 1)) != 9) {
#line 238
    return (0);
  }
#line 239
  if (*(tr->pos + 1) != 0) {
#line 239
    return (0);
  }
#line 243
  nm = 0;
#line 243
  nj = nm;
#line 243
  nc = nj;
#line 243
  nn = nc;
#line 243
  i___0 = nn;
#line 243
  k = i___0;
#line 244
  tpos = 0;
#line 244
  while (tpos < tr->tlen) {
#line 246
    switch ((int )*(tr->statetype + tpos)) {
    case 4: 
#line 248
    if (*(tr->nodeidx + tpos) != 0) {
#line 248
      return (0);
    }
#line 249
    if (*(tr->pos + tpos) != 0) {
#line 249
      return (0);
    }
#line 250
    if (k != 0) {
#line 250
      return (0);
    }
#line 251
    if (i___0 != 0) {
#line 251
      return (0);
    }
#line 252
    if (tpos != 0) {
#line 252
      return (0);
    }
#line 253
    break;
    case 5: 
#line 256
    if (*(tr->nodeidx + tpos) != 0) {
#line 256
      return (0);
    }
#line 257
    if (k != 0) {
#line 257
      return (0);
    }
#line 258
    if (nn > 0) {
#line 260
      if (*(tr->pos + tpos) != i___0 + 1) {
#line 260
        return (0);
      }
#line 261
      i___0 ++;
    } else {
#line 265
      if (*(tr->pos + tpos) != 0) {
#line 265
        return (0);
      }
#line 266
      if (i___0 != 0) {
#line 266
        return (0);
      }
    }
#line 268
    nn ++;
#line 269
    break;
    case 6: 
#line 272
    if (*(tr->nodeidx + tpos) != 0) {
#line 272
      return (0);
    }
#line 273
    if (*(tr->pos + tpos) != 0) {
#line 273
      return (0);
    }
#line 274
    nm = 0;
#line 275
    break;
    case 1: 
#line 278
    if (*(tr->pos + tpos) != i___0 + 1) {
#line 278
      return (0);
    }
#line 279
    if (*(tr->nodeidx + tpos) < 1) {
#line 279
      return (0);
    } else
#line 279
    if (*(tr->nodeidx + tpos) > M) {
#line 279
      return (0);
    }
#line 280
    i___0 ++;
#line 281
    if (nm == 0) {
#line 281
      k = *(tr->nodeidx + tpos);
    } else {
#line 283
      if (*(tr->nodeidx + tpos) != k + 1) {
#line 283
        return (0);
      }
#line 284
      k ++;
    }
#line 286
    nm ++;
#line 287
    break;
    case 3: 
#line 290
    if (*(tr->pos + tpos) != i___0 + 1) {
#line 290
      return (0);
    }
#line 291
    if (*(tr->nodeidx + tpos) != k) {
#line 291
      return (0);
    }
#line 292
    if (*(tr->nodeidx + tpos) < 1) {
#line 292
      return (0);
    } else
#line 292
    if (*(tr->nodeidx + tpos) > M - 1) {
#line 292
      return (0);
    }
#line 293
    if (k >= M) {
#line 293
      return (0);
    }
#line 294
    i___0 ++;
#line 295
    break;
    case 2: 
#line 298
    if (*(tr->pos + tpos) != 0) {
#line 298
      return (0);
    }
#line 299
    if (*(tr->nodeidx + tpos) != k + 1) {
#line 299
      return (0);
    }
#line 300
    if (*(tr->nodeidx + tpos) < 1) {
#line 300
      return (0);
    } else
#line 300
    if (*(tr->nodeidx + tpos) > M) {
#line 300
      return (0);
    }
#line 301
    k ++;
#line 302
    break;
    case 7: 
#line 305
    if (*(tr->nodeidx + tpos) != 0) {
#line 305
      return (0);
    }
#line 306
    if (*(tr->pos + tpos) != 0) {
#line 306
      return (0);
    }
#line 307
    nj = 0;
#line 308
    break;
    case 10: 
#line 311
    if (*(tr->nodeidx + tpos) != 0) {
#line 311
      return (0);
    }
#line 312
    if (nj > 0) {
#line 314
      if (*(tr->pos + tpos) != i___0 + 1) {
#line 314
        return (0);
      }
#line 315
      i___0 ++;
    } else
#line 317
    if (*(tr->pos + tpos) != 0) {
#line 317
      return (0);
    }
#line 318
    nj ++;
#line 319
    break;
    case 8: 
#line 322
    if (*(tr->nodeidx + tpos) != 0) {
#line 322
      return (0);
    }
#line 323
    if (nc > 0) {
#line 325
      if (*(tr->pos + tpos) != i___0 + 1) {
#line 325
        return (0);
      }
#line 326
      i___0 ++;
    } else
#line 328
    if (*(tr->pos + tpos) != 0) {
#line 328
      return (0);
    }
#line 329
    nc ++;
#line 330
    break;
    case 9: 
#line 333
    if (tpos != tr->tlen - 1) {
#line 333
      return (0);
    }
#line 334
    if (*(tr->nodeidx + tpos) != 0) {
#line 334
      return (0);
    }
#line 335
    if (*(tr->pos + tpos) != 0) {
#line 335
      return (0);
    }
#line 336
    if (i___0 != N) {
#line 336
      return (0);
    }
#line 337
    break;
    default: 
#line 341
    return (0);
    }
#line 244
    tpos ++;
  }
#line 345
  return (1);
}
}
#line 360 "debug.c"
int TraceCompare(struct p7trace_s *t1 , struct p7trace_s *t2 ) 
{ 
  int tpos ;

  {
#line 365
  if (t1->tlen != t2->tlen) {
#line 365
    return (0);
  }
#line 367
  tpos = 0;
#line 367
  while (tpos < t1->tlen) {
#line 369
    if ((int )*(t1->statetype + tpos) != (int )*(t2->statetype + tpos)) {
#line 369
      return (0);
    }
#line 370
    if (*(t1->nodeidx + tpos) != *(t2->nodeidx + tpos)) {
#line 370
      return (0);
    }
#line 371
    if (*(t1->pos + tpos) != *(t2->pos + tpos)) {
#line 371
      return (0);
    }
#line 367
    tpos ++;
  }
#line 373
  return (1);
}
}
#line 1 "display.o"
#pragma merger("0","/tmp/cil-JCNWW9ds.i","")
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 87 "./funcs.h"
void DisplayPlan7Matrix(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ) ;
#line 89
void DisplayPlan7Posteriors(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                            struct dpmatrix_s *backward , struct p7trace_s *viterbi ,
                            struct p7trace_s *optacc ) ;
#line 92
void DisplayPlan7PostAlign(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                           struct dpmatrix_s *backward , struct p7trace_s **alignment ,
                           int A ) ;
#line 167
float Score2Prob(int sc , float null ) ;
#line 29 "display.c"
void PrintIscore(int sc ) ;
#line 31
void PrintTransition(char src , int isrc , int ksrc , char dest , int idest , int kdest ,
                     int sc , struct p7trace_s **alignment , int *min , int *max ,
                     int *on , int A ) ;
#line 62 "display.c"
void DisplayPlan7Posteriors(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                            struct dpmatrix_s *backward , struct p7trace_s *viterbi ,
                            struct p7trace_s *optacc ) 
{ 
  struct p7trace_s *alignment[2] ;

  {
#line 69
  alignment[0] = viterbi;
#line 70
  alignment[1] = optacc;
#line 71
  DisplayPlan7PostAlign(L, hmm, forward, backward, alignment, 2);
#line 72
  return;
}
}
#line 90 "display.c"
void DisplayPlan7PostAlign(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                           struct dpmatrix_s *backward , struct p7trace_s **alignment ,
                           int A ) 
{ 
  int sc ;
  int i___0 ;
  int j ;
  int k ;
  int kmin ;
  int kmax ;
  int *min ;
  int *max ;
  int *on ;
  char state ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 107
  sc = *(*(forward->xmx + L) + 2) + hmm->xsc[2][0];
#line 109
  tmp = calloc((size_t )A, sizeof(int ));
#line 109
  min = (int *)tmp;
#line 110
  tmp___0 = calloc((size_t )A, sizeof(int ));
#line 110
  max = (int *)tmp___0;
#line 111
  tmp___1 = calloc((size_t )A, sizeof(int ));
#line 111
  on = (int *)tmp___1;
#line 113
  i___0 = 0;
#line 113
  while (i___0 <= L) {
#line 115
    j = 0;
#line 115
    while (j < A) {
#line 116
      while (1) {
#line 116
        if (*((*(alignment + j))->pos + *(min + j)) < i___0 - 1) {
#line 116
          if (! (*(min + j) < (*(alignment + j))->tlen - 1)) {
#line 116
            break;
          }
        } else {
#line 116
          break;
        }
#line 117
        (*(min + j)) ++;
      }
#line 119
      while (1) {
#line 119
        if (*((*(alignment + j))->pos + *(max + j)) <= i___0 + 1) {
#line 119
          if (! (*(max + j) < (*(alignment + j))->tlen - 1)) {
#line 119
            break;
          }
        } else {
#line 119
          break;
        }
#line 120
        (*(max + j)) ++;
      }
#line 115
      j ++;
    }
#line 123
    state = (char)1;
#line 123
    while ((int )state <= 10) {
#line 125
      if ((int )state == 1) {
#line 127
        kmin = 1;
#line 128
        kmax = hmm->M;
      } else
#line 125
      if ((int )state == 6) {
#line 127
        kmin = 1;
#line 128
        kmax = hmm->M;
      } else
#line 130
      if ((int )state == 2) {
#line 132
        kmin = 2;
#line 133
        kmax = hmm->M - 1;
      } else
#line 135
      if ((int )state == 3) {
#line 137
        kmin = 1;
#line 138
        kmax = hmm->M - 1;
      } else {
#line 141
        kmax = 0;
#line 141
        kmin = kmax;
      }
#line 143
      k = kmin;
#line 143
      while (k <= kmax) {
#line 145
        switch ((int )state) {
        case 1: 
#line 148
        if (i___0 < L) {
#line 148
          if (k < hmm->M) {
#line 149
            PrintTransition((char)1, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 0) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                            alignment, min, max, on, A);
          }
        }
#line 153
        if (i___0 < L) {
#line 153
          if (k < hmm->M) {
#line 154
            PrintTransition((char)1, i___0, k, (char)3, i___0 + 1, k, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 1) + k)) + *(*(backward->imx + (i___0 + 1)) + k)) - sc,
                            alignment, min, max, on, A);
          }
        }
#line 158
        if (k < hmm->M - 1) {
#line 159
          PrintTransition((char)1, i___0, k, (char)2, i___0, k + 1, ((*(*(forward->mmx + i___0) + k) + *(*(hmm->tsc + 2) + k)) + *(*(backward->dmx + i___0) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
#line 163
        PrintTransition((char)1, i___0, k, (char)7, i___0, 0, ((*(*(forward->mmx + i___0) + k) + *(hmm->esc + k)) + *(*(backward->xmx + i___0) + 1)) - sc,
                        alignment, min, max, on, A);
#line 166
        break;
        case 2: 
#line 169
        if (i___0 < L) {
#line 170
          PrintTransition((char)2, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->dmx + i___0) + k) + *(*(hmm->tsc + 5) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
#line 174
        PrintTransition((char)2, i___0, k, (char)2, i___0, k + 1, ((*(*(forward->dmx + i___0) + k) + *(*(hmm->tsc + 6) + k)) + *(*(backward->dmx + i___0) + (k + 1))) - sc,
                        alignment, min, max, on, A);
#line 178
        break;
        case 3: 
#line 181
        if (i___0 < L) {
#line 182
          PrintTransition((char)3, i___0, k, (char)1, i___0 + 1, k + 1, ((*(*(forward->imx + i___0) + k) + *(*(hmm->tsc + 3) + k)) + *(*(backward->mmx + (i___0 + 1)) + (k + 1))) - sc,
                          alignment, min, max, on, A);
        }
#line 186
        if (i___0 < L) {
#line 187
          PrintTransition((char)3, i___0, k, (char)3, i___0 + 1, k, ((*(*(forward->imx + i___0) + k) + *(*(hmm->tsc + 4) + k)) + *(*(backward->imx + (i___0 + 1)) + k)) - sc,
                          alignment, min, max, on, A);
        }
#line 191
        break;
        case 6: 
#line 194
        if (i___0 < L) {
#line 195
          PrintTransition((char)6, i___0, 0, (char)1, i___0 + 1, k, ((*(*(forward->xmx + i___0) + 0) + *(hmm->bsc + k)) + *(*(backward->mmx + (i___0 + 1)) + k)) - sc,
                          alignment, min, max, on, A);
        }
#line 198
        break;
        default: 
#line 201
        break;
        }
#line 143
        k ++;
      }
#line 206
      switch ((int )state) {
      case 5: 
#line 209
      PrintTransition((char)5, i___0, 0, (char)6, i___0, 0, ((*(*(forward->xmx + i___0) + 4) + hmm->xsc[0][0]) + *(*(backward->xmx + i___0) + 0)) - sc,
                      alignment, min, max, on, A);
#line 213
      if (i___0 < L) {
#line 214
        PrintTransition((char)5, i___0, 0, (char)5, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 4) + hmm->xsc[0][1]) + *(*(backward->xmx + (i___0 + 1)) + 4)) - sc,
                        alignment, min, max, on, A);
      }
#line 217
      break;
      case 10: 
#line 220
      PrintTransition((char)10, i___0, 0, (char)6, i___0, 0, ((*(*(forward->xmx + i___0) + 3) + hmm->xsc[3][0]) + *(*(backward->xmx + i___0) + 0)) - sc,
                      alignment, min, max, on, A);
#line 224
      if (i___0 < L) {
#line 225
        PrintTransition((char)10, i___0, 0, (char)10, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 3) + hmm->xsc[3][1]) + *(*(backward->xmx + (i___0 + 1)) + 3)) - sc,
                        alignment, min, max, on, A);
      }
#line 228
      break;
      case 8: 
#line 231
      PrintTransition((char)8, i___0, 0, (char)9, i___0, 0, (*(*(forward->xmx + i___0) + 2) + hmm->xsc[2][0]) - sc,
                      alignment, min, max, on, A);
#line 235
      if (i___0 < L) {
#line 236
        PrintTransition((char)8, i___0, 0, (char)8, i___0 + 1, 0, ((*(*(forward->xmx + i___0) + 2) + hmm->xsc[2][1]) + *(*(backward->xmx + (i___0 + 1)) + 2)) - sc,
                        alignment, min, max, on, A);
      }
#line 239
      break;
      case 7: 
#line 242
      PrintTransition((char)7, i___0, 0, (char)8, i___0, 0, ((*(*(forward->xmx + i___0) + 1) + hmm->xsc[1][0]) + *(*(backward->xmx + i___0) + 2)) - sc,
                      alignment, min, max, on, A);
#line 246
      PrintTransition((char)7, i___0, 0, (char)10, i___0, 0, ((*(*(forward->xmx + i___0) + 1) + hmm->xsc[1][1]) + *(*(backward->xmx + i___0) + 3)) - sc,
                      alignment, min, max, on, A);
#line 249
      break;
      case 4: 
#line 252
      if (i___0 == 0) {
#line 253
        PrintTransition((char)4, i___0, 0, (char)5, i___0, 0, *(*(backward->xmx + i___0) + 4) - sc,
                        alignment, min, max, on, A);
      }
#line 256
      break;
      case 9: 
      case 6: 
      case 3: 
      case 2: 
      case 1: 
#line 263
      break;
      default: 
#line 266
      Die((char *)"unknown state");
      }
#line 123
      state = (char )((int )state + 1);
    }
#line 113
    i___0 ++;
  }
#line 272
  free((void *)min);
#line 273
  free((void *)max);
#line 274
  free((void *)on);
#line 276
  return;
}
}
#line 297 "display.c"
void DisplayPlan7Matrix(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ) 
{ 
  int i___0 ;
  int k ;

  {
#line 303
  printf((char const   * __restrict  )"         *      ");
#line 304
  i___0 = 1;
#line 304
  while (i___0 <= L) {
#line 304
    printf((char const   * __restrict  )"    %c      ", (int )Alphabet[(int )*(dsq + i___0)]);
#line 304
    i___0 ++;
  }
#line 305
  printf((char const   * __restrict  )"\nN    ");
#line 306
  i___0 = 0;
#line 306
  while (i___0 <= L) {
#line 306
    PrintIscore(*(*(mx->xmx + i___0) + 4));
#line 306
    i___0 ++;
  }
#line 307
  k = 1;
#line 307
  while (k <= hmm->M) {
#line 308
    printf((char const   * __restrict  )"\nM%-3d ", k);
#line 309
    i___0 = 0;
#line 309
    while (i___0 <= L) {
#line 309
      PrintIscore(*(*(mx->mmx + i___0) + k));
#line 309
      i___0 ++;
    }
#line 307
    k ++;
  }
#line 311
  k = 1;
#line 311
  while (k < hmm->M) {
#line 312
    printf((char const   * __restrict  )"\nI%-3d ", k);
#line 313
    i___0 = 0;
#line 313
    while (i___0 <= L) {
#line 313
      PrintIscore(*(*(mx->imx + i___0) + k));
#line 313
      i___0 ++;
    }
#line 311
    k ++;
  }
#line 315
  printf((char const   * __restrict  )"\nE    ");
#line 316
  i___0 = 0;
#line 316
  while (i___0 <= L) {
#line 316
    PrintIscore(*(*(mx->xmx + i___0) + 1));
#line 316
    i___0 ++;
  }
#line 317
  printf((char const   * __restrict  )"\nC    ");
#line 318
  i___0 = 0;
#line 318
  while (i___0 <= L) {
#line 318
    PrintIscore(*(*(mx->xmx + i___0) + 2));
#line 318
    i___0 ++;
  }
#line 319
  printf((char const   * __restrict  )"\nJ    ");
#line 320
  i___0 = 0;
#line 320
  while (i___0 <= L) {
#line 320
    PrintIscore(*(*(mx->xmx + i___0) + 3));
#line 320
    i___0 ++;
  }
#line 321
  printf((char const   * __restrict  )"\nB    ");
#line 322
  i___0 = 0;
#line 322
  while (i___0 <= L) {
#line 322
    PrintIscore(*(*(mx->xmx + i___0) + 0));
#line 322
    i___0 ++;
  }
#line 323
  k = 2;
#line 323
  while (k < hmm->M) {
#line 324
    printf((char const   * __restrict  )"\nD%-3d ", k);
#line 325
    i___0 = 0;
#line 325
    while (i___0 <= L) {
#line 325
      PrintIscore(*(*(mx->dmx + i___0) + k));
#line 325
      i___0 ++;
    }
#line 323
    k ++;
  }
#line 327
  printf((char const   * __restrict  )"\n\n");
#line 328
  return;
}
}
#line 331 "display.c"
void PrintIscore(int sc ) 
{ 
  double dsc ;
  double div___0 ;

  {
#line 334
  dsc = (double )sc;
#line 335
  div___0 = 1000.0 / 0.693147180559945;
#line 336
  dsc /= div___0;
#line 337
  printf((char const   * __restrict  )"%- #11.3e", dsc);
#line 338
  return;
}
}
#line 341 "display.c"
void PrintTransition(char src , int isrc , int ksrc , char dest , int idest , int kdest ,
                     int sc , struct p7trace_s **alignment , int *min , int *max ,
                     int *on , int A ) 
{ 
  char src_str[6] ;
  char dest_str[6] ;
  int j ;
  int tpos ;
  int tnext ;
  int pos ;
  int next ;
  int near ;
  float tmp ;

  {
#line 363
  near = 0;
#line 365
  j = 0;
#line 365
  while (j < A) {
#line 366
    *(on + j) = 0;
#line 367
    pos = 0;
#line 367
    tpos = *(min + j);
#line 367
    while (tpos <= *(max + j)) {
#line 369
      if (*((*(alignment + j))->pos + tpos) != 0) {
#line 370
        pos = *((*(alignment + j))->pos + tpos);
      }
#line 372
      if ((int )src == (int )*((*(alignment + j))->statetype + tpos)) {
#line 372
        if (ksrc == *((*(alignment + j))->nodeidx + tpos)) {
#line 372
          if (isrc == pos) {
#line 375
            near = 1;
          }
        }
      }
#line 377
      if ((int )dest == (int )*((*(alignment + j))->statetype + tpos)) {
#line 377
        if (kdest == *((*(alignment + j))->nodeidx + tpos)) {
#line 377
          if (idest == pos) {
#line 380
            near = 1;
          }
        }
      }
#line 382
      if (tpos < (*(alignment + j))->tlen - 1) {
#line 384
        tnext = tpos + 1;
#line 388
        if ((int )*((*(alignment + j))->statetype + tpos) == 6) {
#line 389
          while (1) {
#line 389
            if ((int )*((*(alignment + j))->statetype + tnext) == 2) {
#line 389
              if (! (tnext < (*(alignment + j))->tlen - 1)) {
#line 389
                break;
              }
            } else {
#line 389
              break;
            }
#line 390
            tnext ++;
          }
        }
#line 392
        next = *((*(alignment + j))->pos + tnext);
#line 393
        if (next == 0) {
#line 394
          next = pos;
        }
#line 396
        if ((int )src == (int )*((*(alignment + j))->statetype + tpos)) {
#line 396
          if (ksrc == *((*(alignment + j))->nodeidx + tpos)) {
#line 396
            if (isrc == pos) {
#line 396
              if ((int )dest == (int )*((*(alignment + j))->statetype + tnext)) {
#line 396
                if (kdest == *((*(alignment + j))->nodeidx + tnext)) {
#line 396
                  if (idest == next) {
#line 402
                    *(on + j) = 1;
                  }
                }
              }
            }
          }
        }
      }
#line 367
      tpos ++;
    }
#line 365
    j ++;
  }
#line 407
  if (! near) {
#line 407
    return;
  }
#line 409
  switch ((int )src) {
  case 1: 
#line 411
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"M%d", ksrc);
#line 411
  break;
  case 2: 
#line 412
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"D%d", ksrc);
#line 412
  break;
  case 3: 
#line 413
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"I%d", ksrc);
#line 413
  break;
  case 4: 
#line 414
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"S");
#line 414
  break;
  case 5: 
#line 415
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"N");
#line 415
  break;
  case 6: 
#line 416
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"B");
#line 416
  break;
  case 7: 
#line 417
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"E");
#line 417
  break;
  case 8: 
#line 418
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"C");
#line 418
  break;
  case 10: 
#line 419
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"J");
#line 419
  break;
  case 9: 
#line 420
  sprintf((char * __restrict  )(src_str), (char const   * __restrict  )"T");
#line 420
  break;
  default: 
#line 421
  Die((char *)"bad transition");
  }
#line 424
  switch ((int )dest) {
  case 1: 
#line 426
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"M%d", kdest);
#line 426
  break;
  case 2: 
#line 427
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"D%d", kdest);
#line 427
  break;
  case 3: 
#line 428
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"I%d", kdest);
#line 428
  break;
  case 4: 
#line 429
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"S");
#line 429
  break;
  case 5: 
#line 430
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"N");
#line 430
  break;
  case 6: 
#line 431
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"B");
#line 431
  break;
  case 7: 
#line 432
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"E");
#line 432
  break;
  case 8: 
#line 433
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"C");
#line 433
  break;
  case 10: 
#line 434
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"J");
#line 434
  break;
  case 9: 
#line 435
  sprintf((char * __restrict  )(dest_str), (char const   * __restrict  )"T");
#line 435
  break;
  default: 
#line 436
  Die((char *)"bad transition");
  }
#line 439
  tmp = Score2Prob(sc, (float )1.);
#line 439
  printf((char const   * __restrict  )"%d\t%s\t%d\t%s\t%-14.7g\t", isrc, src_str,
         idest, dest_str, (double )tmp);
#line 441
  j = 0;
#line 441
  while (j < A) {
#line 442
    if (*(on + j)) {
#line 442
      printf((char const   * __restrict  )"*");
    }
#line 443
    if (j < A - 1) {
#line 443
      printf((char const   * __restrict  )"\t");
    }
#line 441
    j ++;
  }
#line 446
  printf((char const   * __restrict  )"\n");
#line 448
  return;
}
}
#line 1 "emit.o"
#pragma merger("0","/tmp/cil-yvd0e2iF.i","")
#line 14 "./sre_random.h"
int FChoose(float *p , int N ) ;
#line 17 "./vectorops.h"
void FCopy(float *vec1 , float *vec2 , int n ) ;
#line 100 "./funcs.h"
void EmitSequence(struct plan7_s *hmm , char **ret_dsq , int *ret_L , struct p7trace_s **ret_tr ) ;
#line 101
void EmitConsensusSequence(struct plan7_s *hmm , char **ret_seq , char **ret_dsq ,
                           int *ret_L , struct p7trace_s **ret_tr ) ;
#line 102
void StateOccupancy(struct plan7_s *hmm , float **ret_mp , float **ret_ip , float **ret_dp ) ;
#line 330
void TraceSet(struct p7trace_s *tr , int tpos , char type , int idx , int pos ) ;
#line 41 "emit.c"
void EmitSequence(struct plan7_s *hmm , char **ret_dsq , int *ret_L , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  char type ;
  int k ;
  char *dsq ;
  int L ;
  int alloc_tlen ;
  int alloc_L ;
  int tpos ;
  int sym ;
  float t___0[4] ;
  void *tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
#line 57
  P7AllocTrace(64, & tr);
#line 58
  alloc_tlen = 64;
#line 59
  tmp = sre_malloc((char *)"emit.c", 59, sizeof(char ) * 64UL);
#line 59
  dsq = (char *)tmp;
#line 60
  alloc_L = 64;
#line 62
  TraceSet(tr, 0, (char)4, 0, 0);
#line 63
  TraceSet(tr, 1, (char)5, 0, 0);
#line 64
  *(dsq + 0) = (char )Alphabet_iupac;
#line 65
  L = 1;
#line 66
  k = 0;
#line 67
  type = (char)5;
#line 68
  tpos = 2;
#line 70
  while ((int )type != 9) {
#line 74
    switch ((int )type) {
    case 6: 
#line 76
    *(hmm->begin + 0) = hmm->tbd1;
#line 77
    k = FChoose(hmm->begin, hmm->M + 1);
#line 78
    if (k == 0) {
#line 78
      type = (char)2;
#line 78
      k = 1;
    } else {
#line 78
      type = (char)1;
    }
#line 79
    break;
    case 3: 
#line 81
    tmp___1 = FChoose(*(hmm->t + k) + 3, 2);
#line 81
    if (tmp___1 == 0) {
#line 81
      type = (char)1;
    } else {
#line 81
      type = (char)3;
    }
#line 81
    if ((int )type == 1) {
#line 81
      k ++;
    }
#line 81
    break;
    case 5: 
#line 82
    tmp___3 = FChoose(hmm->xt[0], 2);
#line 82
    if (tmp___3 == 1) {
#line 82
      type = (char)5;
    } else {
#line 82
      type = (char)6;
    }
#line 82
    k = 0;
#line 82
    break;
    case 7: 
#line 83
    tmp___5 = FChoose(hmm->xt[1], 2);
#line 83
    if (tmp___5 == 1) {
#line 83
      type = (char)10;
    } else {
#line 83
      type = (char)8;
    }
#line 83
    k = 0;
#line 83
    break;
    case 8: 
#line 84
    tmp___7 = FChoose(hmm->xt[2], 2);
#line 84
    if (tmp___7 == 1) {
#line 84
      type = (char)8;
    } else {
#line 84
      type = (char)9;
    }
#line 84
    k = 0;
#line 84
    break;
    case 10: 
#line 85
    tmp___9 = FChoose(hmm->xt[3], 2);
#line 85
    if (tmp___9 == 1) {
#line 85
      type = (char)10;
    } else {
#line 85
      type = (char)6;
    }
#line 85
    k = 0;
#line 85
    break;
    case 2: 
#line 88
    if (k < hmm->M) {
#line 89
      tmp___11 = FChoose(*(hmm->t + k) + 5, 2);
#line 89
      if (tmp___11 == 0) {
#line 89
        type = (char)1;
      } else {
#line 89
        type = (char)2;
      }
#line 90
      k ++;
    } else {
#line 92
      type = (char)7;
#line 93
      k = 0;
    }
#line 95
    break;
    case 1: 
#line 98
    if (k < hmm->M) {
#line 99
      FCopy(t___0, *(hmm->t + k), 3);
#line 100
      t___0[3] = *(hmm->end + k);
#line 101
      tmp___12 = FChoose(t___0, 4);
#line 101
      switch (tmp___12) {
      case 0: 
#line 102
      k ++;
#line 102
      type = (char)1;
#line 102
      break;
      case 1: 
#line 103
      type = (char)3;
#line 103
      break;
      case 2: 
#line 104
      k ++;
#line 104
      type = (char)2;
#line 104
      break;
      case 3: 
#line 105
      k = 0;
#line 105
      type = (char)7;
#line 105
      break;
      default: 
#line 106
      Die((char *)"never happens");
      }
    } else {
#line 109
      k = 0;
#line 110
      type = (char)7;
    }
#line 112
    break;
    default: 
#line 117
    Die((char *)"can\'t happen.");
    }
#line 122
    sym = -1;
#line 123
    if ((int )type == 1) {
#line 123
      sym = FChoose(*(hmm->mat + k), Alphabet_size);
    } else
#line 124
    if ((int )type == 3) {
#line 124
      sym = FChoose(*(hmm->ins + k), Alphabet_size);
    } else
#line 125
    if ((int )type == 5) {
#line 125
      if ((int )*(tr->statetype + (tpos - 1)) == 5) {
#line 128
        sym = FChoose(hmm->null, Alphabet_size);
      } else {
#line 125
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 125
    if ((int )type == 8) {
#line 125
      if ((int )*(tr->statetype + (tpos - 1)) == 8) {
#line 128
        sym = FChoose(hmm->null, Alphabet_size);
      } else {
#line 125
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 125
    if ((int )type == 10) {
#line 125
      if ((int )*(tr->statetype + (tpos - 1)) == 10) {
#line 128
        sym = FChoose(hmm->null, Alphabet_size);
      }
    }
#line 132
    if (sym != -1) {
#line 132
      tmp___13 = L;
    } else {
#line 132
      tmp___13 = 0;
    }
#line 132
    TraceSet(tr, tpos, type, k, tmp___13);
#line 133
    tpos ++;
#line 134
    if (tpos == alloc_tlen) {
#line 135
      alloc_tlen += 64;
#line 136
      P7ReallocTrace(tr, alloc_tlen);
    }
#line 141
    if (sym != -1) {
#line 142
      *(dsq + L) = (char )sym;
#line 143
      L ++;
#line 144
      if (L + 1 == alloc_L) {
#line 145
        alloc_L += 64;
#line 146
        tmp___14 = sre_realloc((char *)"emit.c", 146, (void *)dsq, sizeof(char ) * (unsigned long )alloc_L);
#line 146
        dsq = (char *)tmp___14;
      }
    }
  }
#line 153
  tr->tlen = tpos;
#line 158
  *(dsq + L) = (char )Alphabet_iupac;
#line 159
  *(dsq + (L + 1)) = (char )'\000';
#line 160
  L --;
#line 164
  if ((unsigned long )ret_dsq != (unsigned long )((void *)0)) {
#line 164
    *ret_dsq = dsq;
  } else {
#line 164
    free((void *)dsq);
  }
#line 165
  if ((unsigned long )ret_L != (unsigned long )((void *)0)) {
#line 165
    *ret_L = L;
  }
#line 166
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
#line 166
    *ret_tr = tr;
  } else {
#line 166
    P7FreeTrace(tr);
  }
#line 167
  return;
}
}
#line 295 "emit.c"
void EmitConsensusSequence(struct plan7_s *hmm , char **ret_seq , char **ret_dsq ,
                           int *ret_L , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  char *dsq ;
  char *seq ;
  float *mp ;
  float *ip ;
  float *dp ;
  int nmat ;
  int ndel ;
  int nins ;
  int k ;
  int tpos ;
  int i___0 ;
  int x ;
  float mthresh___0 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 308
  if (Alphabet_type == 3) {
#line 308
    mthresh___0 = (float )0.5;
  } else {
#line 309
    mthresh___0 = (float )0.9;
  }
#line 311
  StateOccupancy(hmm, & mp, & ip, & dp);
#line 316
  nins = 0;
#line 316
  ndel = nins;
#line 316
  nmat = ndel;
#line 317
  k = 1;
#line 317
  while (k <= hmm->M) {
#line 319
    if ((double )*(mp + k) >= 0.5) {
#line 319
      nmat ++;
    } else {
#line 319
      ndel ++;
    }
#line 320
    if (k < hmm->M) {
#line 320
      if ((double )*(ip + k) >= 0.5) {
#line 321
        nins += (int )(1.0f / (1.0f - *(*(hmm->t + k) + 4)));
      }
    }
#line 317
    k ++;
  }
#line 326
  P7AllocTrace(((6 + nmat) + ndel) + nins, & tr);
#line 327
  tmp = sre_malloc((char *)"emit.c", 327, sizeof(char ) * (unsigned long )((nmat + nins) + 3));
#line 327
  dsq = (char *)tmp;
#line 328
  tmp___0 = sre_malloc((char *)"emit.c", 328, sizeof(char ) * (unsigned long )((nmat + nins) + 1));
#line 328
  seq = (char *)tmp___0;
#line 333
  TraceSet(tr, 0, (char)4, 0, 0);
#line 334
  TraceSet(tr, 1, (char)5, 0, 0);
#line 335
  TraceSet(tr, 2, (char)6, 0, 0);
#line 336
  *(dsq + 0) = (char )Alphabet_iupac;
#line 337
  tpos = 3;
#line 338
  i___0 = 0;
#line 339
  k = 1;
#line 339
  while (k <= hmm->M) {
#line 341
    if ((double )*(mp + k) >= 0.5) {
#line 343
      x = FArgMax(*(hmm->mat + k), Alphabet_size);
#line 344
      TraceSet(tr, tpos, (char)1, k, i___0 + 1);
#line 345
      *(seq + i___0) = Alphabet[x];
#line 346
      *(dsq + (i___0 + 1)) = (char )x;
#line 347
      if (*(*(hmm->mat + k) + x) < mthresh___0) {
#line 348
        tmp___1 = tolower((int )*(seq + i___0));
#line 348
        *(seq + i___0) = (char )tmp___1;
      }
#line 349
      i___0 ++;
#line 350
      tpos ++;
    } else {
#line 354
      TraceSet(tr, tpos, (char)2, k, 0);
#line 355
      tpos ++;
    }
#line 358
    if (k < hmm->M) {
#line 358
      if ((double )*(ip + k) >= 0.5) {
#line 360
        x = (int )(1.f / (1.f - *(*(hmm->t + k) + 4)));
#line 361
        while (1) {
#line 361
          tmp___2 = x;
#line 361
          x --;
#line 361
          if (! tmp___2) {
#line 361
            break;
          }
#line 363
          TraceSet(tr, tpos, (char)3, k, i___0 + 1);
#line 364
          *(seq + i___0) = (char )'x';
#line 365
          *(dsq + (i___0 + 1)) = (char )(Alphabet_iupac - 1);
#line 366
          i___0 ++;
#line 367
          tpos ++;
        }
      }
    }
#line 339
    k ++;
  }
#line 371
  TraceSet(tr, tpos, (char)7, 0, 0);
#line 371
  tpos ++;
#line 372
  TraceSet(tr, tpos, (char)8, 0, 0);
#line 372
  tpos ++;
#line 373
  TraceSet(tr, tpos, (char)9, 0, 0);
#line 373
  tpos ++;
#line 374
  *(dsq + (i___0 + 1)) = (char )Alphabet_iupac;
#line 376
  free((void *)mp);
#line 377
  free((void *)ip);
#line 378
  free((void *)dp);
#line 379
  if ((unsigned long )ret_seq != (unsigned long )((void *)0)) {
#line 379
    *ret_seq = seq;
  } else {
#line 379
    free((void *)seq);
  }
#line 380
  if ((unsigned long )ret_dsq != (unsigned long )((void *)0)) {
#line 380
    *ret_dsq = dsq;
  } else {
#line 380
    free((void *)dsq);
  }
#line 381
  if ((unsigned long )ret_L != (unsigned long )((void *)0)) {
#line 381
    *ret_L = i___0;
  }
#line 382
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
#line 382
    *ret_tr = tr;
  } else {
#line 382
    P7FreeTrace(tr);
  }
#line 383
  return;
}
}
#line 406 "emit.c"
void StateOccupancy(struct plan7_s *hmm , float **ret_mp , float **ret_ip , float **ret_dp ) 
{ 
  float *fmp ;
  float *fip ;
  float *fdp ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 414
  tmp = sre_malloc((char *)"emit.c", 414, sizeof(float ) * (unsigned long )(hmm->M + 1));
#line 414
  fmp = (float *)tmp;
#line 415
  tmp___0 = sre_malloc((char *)"emit.c", 415, sizeof(float ) * (unsigned long )hmm->M);
#line 415
  fip = (float *)tmp___0;
#line 416
  tmp___1 = sre_malloc((char *)"emit.c", 416, sizeof(float ) * (unsigned long )(hmm->M + 1));
#line 416
  fdp = (float *)tmp___1;
#line 420
  *(fdp + 1) = hmm->tbd1;
#line 421
  *(fmp + 1) = *(hmm->begin + 1);
#line 422
  *(fip + 1) = *(fmp + 1) * *(*(hmm->t + 1) + 1);
#line 423
  k = 2;
#line 423
  while (k <= hmm->M) {
#line 426
    *(fmp + k) = ((*(fmp + (k - 1)) * *(*(hmm->t + (k - 1)) + 0) + *(fip + (k - 1))) + *(fdp + (k - 1)) * *(*(hmm->t + (k - 1)) + 5)) + *(hmm->begin + k);
#line 431
    *(fdp + k) = *(fmp + (k - 1)) * *(*(hmm->t + (k - 1)) + 2) + *(fdp + (k - 1)) * *(*(hmm->t + (k - 1)) + 6);
#line 434
    if (k < hmm->M) {
#line 435
      *(fip + k) = *(fmp + k) * *(*(hmm->t + k) + 1);
    }
#line 439
    *(fmp + k) /= *(fmp + k) + *(fdp + k);
#line 440
    *(fdp + k) /= *(fmp + k) + *(fdp + k);
#line 423
    k ++;
  }
#line 454
  *ret_mp = fmp;
#line 455
  *ret_dp = fdp;
#line 456
  *ret_ip = fip;
#line 457
  return;
}
}
#line 1 "emulation.o"
#pragma merger("0","/tmp/cil-bkOsXcyb.i","")
#line 108 "./funcs.h"
void WriteProfile(FILE *fp , struct plan7_s *hmm , int do_xsw ) ;
#line 215
void P7Logoddsify(struct plan7_s *hmm , int viterbi_mode ) ;
#line 90 "emulation.c"
void WriteProfile(FILE *fp , struct plan7_s *hmm , int do_xsw ) 
{ 
  int k ;
  int x ;
  int sc ;
  float nx ;
  int gap ;
  int len ;
  int qgap ;
  int qlen ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 99
  P7Logoddsify(hmm, 1);
#line 105
  if (hmm->M > 1000) {
#line 105
    if (! do_xsw) {
#line 106
      Warn((char *)"Profile %s will have more than 1000 positions. GCG won\'t read it; Compugen will.",
           hmm->name);
    }
  }
#line 115
  if (Alphabet_type == 3) {
#line 115
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"!!AA_PROFILE 1.0\n");
  } else
#line 116
  if (Alphabet_type == 2) {
#line 116
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"!!NA_PROFILE 1.0\n");
  } else {
#line 117
    Die((char *)"No support for profiles with non-biological alphabets");
  }
#line 119
  if (Alphabet_type == 3) {
#line 119
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"(Peptide) ");
  } else
#line 120
  if (Alphabet_type == 2) {
#line 120
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"(Nucleotide) ");
  }
#line 121
  if (hmm->flags & (1 << 1)) {
#line 121
    tmp = (char const   *)hmm->desc;
  } else {
#line 121
    tmp = "";
  }
#line 121
  if (hmm->flags & (1 << 9)) {
#line 121
    tmp___0 = (char const   *)hmm->acc;
  } else {
#line 121
    tmp___0 = "";
  }
#line 121
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"HMMCONVERT v%s Length: %d %s|%s|%s\n",
          "2.3", hmm->M, hmm->name, tmp___0, tmp);
#line 128
  if (do_xsw) {
#line 130
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   Profile converted from a profile HMM using HMMER v%s emulation.\n",
            "2.3");
#line 131
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   Compugen XSW extended profile format.\n");
#line 132
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   Use -model=xsw.model -nonor -noave -gapop=10 -gapext=1 -qgapop=10 -qgapext=1\n");
#line 133
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      with om on the Compugen BIC to get the closest approximation to HMMER bit scores.\n");
#line 134
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   WARNING: There is a loss of information in this conversion.\n");
#line 135
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      Neither the scores nor even the rank order of hits will be precisely\n");
#line 136
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
#line 137
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  } else {
#line 141
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   Profile converted from a profile HMM using HMMER v%s emulation.\n",
            "2.3");
#line 142
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   Use -nonor -noave -gap=10 -len=1 with profilesearch and friends\n");
#line 143
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      to get the closest approximation to HMMER bit scores.\n");
#line 144
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"   WARNING: There is a loss of information in this conversion.\n");
#line 145
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      Neither the scores nor even the rank order of hits will be precisely\n");
#line 146
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      preserved in a comparison of HMMER hmmsearch to GCG profilesearch.\n");
#line 147
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"      The profile score is an approximation of the (single-hit) HMMER score.\n\n");
  }
#line 153
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Cons");
#line 154
  x = 0;
#line 154
  while (x < Alphabet_iupac) {
#line 155
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"    %c ", (int )Alphabet[x]);
#line 154
    x ++;
  }
#line 156
  if (do_xsw) {
#line 157
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  Gap   Len  QGap  Qlen ..\n");
  } else {
#line 159
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  Gap   Len ..\n");
  }
#line 163
  k = 1;
#line 163
  while (k <= hmm->M) {
#line 166
    if ((k - 1) % 10 == 0) {
#line 166
      if (k > 10) {
#line 167
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"! %d\n", k);
      }
    }
#line 170
    x = FArgMax(*(hmm->mat + k), Alphabet_size);
#line 171
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %c  ", (int )Alphabet[x]);
#line 175
    x = 0;
#line 175
    while (x < Alphabet_iupac) {
#line 177
      sc = *(*(hmm->msc + x) + k);
#line 178
      if (k < hmm->M) {
#line 178
        sc += *(*(hmm->tsc + 0) + k);
      }
#line 179
      sc = (int )((double )(sc * 100) / 1000.0);
#line 180
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", sc);
#line 175
      x ++;
    }
#line 187
    if (k > 1) {
#line 189
      gap = -1 * (((*(*(hmm->tsc + 1) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1))) - *(*(hmm->tsc + 0) + (k - 1))) - *(*(hmm->tsc + 4) + (k - 1)));
#line 190
      gap = (int )((double )(gap * 100) / (10.0 * 1000.0));
    } else {
#line 192
      gap = 100;
    }
#line 195
    if (k > 1) {
#line 197
      len = -1 * *(*(hmm->tsc + 4) + (k - 1));
#line 198
      len = (int )((double )(len * 100) / (1.0 * 1000.0));
    } else {
#line 200
      len = 100;
    }
#line 203
    if (k > 1) {
#line 205
      qgap = -1 * (((*(*(hmm->tsc + 5) + (k - 1)) + *(*(hmm->tsc + 2) + (k - 1))) - *(*(hmm->tsc + 0) + (k - 1))) - *(*(hmm->tsc + 6) + (k - 1)));
#line 206
      qgap = (int )((double )(qgap * 100) / (10.0 * 1000.0));
    } else {
#line 208
      qgap = 100;
    }
#line 210
    if (k > 1) {
#line 212
      qlen = -1 * *(*(hmm->tsc + 6) + (k - 1));
#line 213
      qlen = (int )((double )(qlen * 100) / (1.0 * 1000.0));
    } else {
#line 215
      qlen = 100;
    }
#line 218
    if (do_xsw) {
#line 219
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d %5d %5d %5d\n",
              gap, len, qgap, qlen);
    } else {
#line 221
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d %5d\n", gap,
              len);
    }
#line 163
    k ++;
  }
#line 229
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" *  ");
#line 230
  x = 0;
#line 230
  while (x < Alphabet_size) {
#line 232
    nx = (float )0.0;
#line 233
    k = 1;
#line 233
    while (k <= hmm->M) {
#line 234
      nx += *(*(hmm->mat + k) + x);
#line 233
      k ++;
    }
#line 235
    nx *= (float )hmm->nseq;
#line 236
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", (int )nx);
#line 230
    x ++;
  }
#line 238
  while (x < Alphabet_iupac) {
#line 239
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", 0);
#line 238
    x ++;
  }
#line 240
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 241
  return;
}
}
#line 1 "fast_algorithms.o"
#pragma merger("0","/tmp/cil-Aydckby7.i","")
#line 68 "fast_algorithms.c"
float P7Viterbi(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s *mx ,
                struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int *mc ;
  int *dc ;
  int *ic ;
  int *ms ;
  int *is ;
  int *mpp ;
  int *mpc ;
  int *ip ;
  int *bp ;
  int *ep ;
  int xmb ;
  int xme ;
  int *dpp ;
  int *tpmm ;
  int *tpmi ;
  int *tpmd ;
  int *tpim ;
  int *tpii ;
  int *tpdm ;
  int *tpdd ;
  int M ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  float tmp___3 ;

  {
#line 91
  ResizePlan7Matrix(mx, L, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 95
  *(*(xmx + 0) + 4) = 0;
#line 96
  *(*(xmx + 0) + 0) = hmm->xsc[0][0];
#line 97
  tmp___0 = -987654321;
#line 97
  *(*(xmx + 0) + 3) = tmp___0;
#line 97
  tmp = tmp___0;
#line 97
  *(*(xmx + 0) + 2) = tmp;
#line 97
  *(*(xmx + 0) + 1) = tmp;
#line 98
  k = 0;
#line 98
  while (k <= hmm->M) {
#line 99
    tmp___2 = -987654321;
#line 99
    *(*(dmx + 0) + k) = tmp___2;
#line 99
    tmp___1 = tmp___2;
#line 99
    *(*(imx + 0) + k) = tmp___1;
#line 99
    *(*(mmx + 0) + k) = tmp___1;
#line 98
    k ++;
  }
#line 103
  M = hmm->M;
#line 111
  tpmm = *(hmm->tsc + 0);
#line 112
  tpim = *(hmm->tsc + 3);
#line 113
  tpdm = *(hmm->tsc + 5);
#line 114
  tpmd = *(hmm->tsc + 2);
#line 115
  tpdd = *(hmm->tsc + 6);
#line 116
  tpmi = *(hmm->tsc + 1);
#line 117
  tpii = *(hmm->tsc + 4);
#line 118
  bp = hmm->bsc;
#line 119
  i___0 = 1;
#line 119
  while (i___0 <= L) {
#line 120
    mc = *(mmx + i___0);
#line 121
    dc = *(dmx + i___0);
#line 122
    ic = *(imx + i___0);
#line 123
    mpp = *(mmx + (i___0 - 1));
#line 124
    dpp = *(dmx + (i___0 - 1));
#line 125
    ip = *(imx + (i___0 - 1));
#line 126
    xmb = *(*(xmx + (i___0 - 1)) + 0);
#line 127
    ms = *(hmm->msc + (int )*(dsq + i___0));
#line 128
    is = *(hmm->isc + (int )*(dsq + i___0));
#line 129
    *(mc + 0) = -987654321;
#line 130
    *(dc + 0) = -987654321;
#line 131
    *(ic + 0) = -987654321;
#line 133
    k = 1;
#line 133
    while (k <= M) {
#line 134
      *(mc + k) = *(mpp + (k - 1)) + *(tpmm + (k - 1));
#line 135
      sc = *(ip + (k - 1)) + *(tpim + (k - 1));
#line 135
      if (sc > *(mc + k)) {
#line 135
        *(mc + k) = sc;
      }
#line 136
      sc = *(dpp + (k - 1)) + *(tpdm + (k - 1));
#line 136
      if (sc > *(mc + k)) {
#line 136
        *(mc + k) = sc;
      }
#line 137
      sc = xmb + *(bp + k);
#line 137
      if (sc > *(mc + k)) {
#line 137
        *(mc + k) = sc;
      }
#line 138
      *(mc + k) += *(ms + k);
#line 139
      if (*(mc + k) < -987654321) {
#line 139
        *(mc + k) = -987654321;
      }
#line 141
      *(dc + k) = *(dc + (k - 1)) + *(tpdd + (k - 1));
#line 142
      sc = *(mc + (k - 1)) + *(tpmd + (k - 1));
#line 142
      if (sc > *(dc + k)) {
#line 142
        *(dc + k) = sc;
      }
#line 143
      if (*(dc + k) < -987654321) {
#line 143
        *(dc + k) = -987654321;
      }
#line 145
      if (k < M) {
#line 146
        *(ic + k) = *(mpp + k) + *(tpmi + k);
#line 147
        sc = *(ip + k) + *(tpii + k);
#line 147
        if (sc > *(ic + k)) {
#line 147
          *(ic + k) = sc;
        }
#line 148
        *(ic + k) += *(is + k);
#line 149
        if (*(ic + k) < -987654321) {
#line 149
          *(ic + k) = -987654321;
        }
      }
#line 133
      k ++;
    }
#line 157
    *(*(xmx + i___0) + 4) = -987654321;
#line 158
    sc = *(*(xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1];
#line 158
    if (sc > -987654321) {
#line 159
      *(*(xmx + i___0) + 4) = sc;
    }
#line 162
    xme = -987654321;
#line 163
    mpc = *(mmx + i___0);
#line 164
    ep = hmm->esc;
#line 165
    k = 1;
#line 165
    while (k <= hmm->M) {
#line 166
      sc = *(mpc + k) + *(ep + k);
#line 166
      if (sc > xme) {
#line 166
        xme = sc;
      }
#line 165
      k ++;
    }
#line 167
    *(*(xmx + i___0) + 1) = xme;
#line 169
    *(*(xmx + i___0) + 3) = -987654321;
#line 170
    sc = *(*(xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1];
#line 170
    if (sc > -987654321) {
#line 171
      *(*(xmx + i___0) + 3) = sc;
    }
#line 172
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][1];
#line 172
    if (sc > *(*(xmx + i___0) + 3)) {
#line 173
      *(*(xmx + i___0) + 3) = sc;
    }
#line 176
    *(*(xmx + i___0) + 0) = -987654321;
#line 177
    sc = *(*(xmx + i___0) + 4) + hmm->xsc[0][0];
#line 177
    if (sc > -987654321) {
#line 178
      *(*(xmx + i___0) + 0) = sc;
    }
#line 179
    sc = *(*(xmx + i___0) + 3) + hmm->xsc[3][0];
#line 179
    if (sc > *(*(xmx + i___0) + 0)) {
#line 180
      *(*(xmx + i___0) + 0) = sc;
    }
#line 183
    *(*(xmx + i___0) + 2) = -987654321;
#line 184
    sc = *(*(xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1];
#line 184
    if (sc > -987654321) {
#line 185
      *(*(xmx + i___0) + 2) = sc;
    }
#line 186
    sc = *(*(xmx + i___0) + 1) + hmm->xsc[1][0];
#line 186
    if (sc > *(*(xmx + i___0) + 2)) {
#line 187
      *(*(xmx + i___0) + 2) = sc;
    }
#line 119
    i___0 ++;
  }
#line 190
  sc = *(*(xmx + L) + 2) + hmm->xsc[2][0];
#line 192
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
#line 193
    P7ViterbiTrace(hmm, dsq, L, mx, & tr);
#line 194
    *ret_tr = tr;
  }
#line 197
  tmp___3 = Scorify(sc);
#line 197
  return (tmp___3);
}
}
#line 1 "histogram.o"
#pragma merger("0","/tmp/cil-fFJpbVfq.i","")
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 197 "./sqfuncs.h"
int Linefit(float *x , float *y___0 , int N , float *ret_a , float *ret_b , float *ret_r ) ;
#line 207
double IncompleteGamma(double a___0 , double x ) ;
#line 8 "./sre_random.h"
double sre_random(void) ;
#line 114 "./funcs.h"
struct histogram_s *AllocHistogram(int min , int max , int lumpsize ) ;
#line 115
void FreeHistogram(struct histogram_s *h___0 ) ;
#line 116
void UnfitHistogram(struct histogram_s *h___0 ) ;
#line 117
void AddToHistogram(struct histogram_s *h___0 , float sc ) ;
#line 118
void PrintASCIIHistogram(FILE *fp , struct histogram_s *h___0 ) ;
#line 119
void PrintXMGRHistogram(FILE *fp , struct histogram_s *h___0 ) ;
#line 120
void PrintXMGRDistribution(FILE *fp , struct histogram_s *h___0 ) ;
#line 121
void PrintXMGRRegressionLine(FILE *fp , struct histogram_s *h___0 ) ;
#line 122
void EVDBasicFit(struct histogram_s *h___0 ) ;
#line 123
int ExtremeValueFitHistogram(struct histogram_s *h___0 , int censor , float high_hint ) ;
#line 125
void ExtremeValueSetHistogram(struct histogram_s *h___0 , float mu , float lambda ,
                              float lowbound , float highbound , int ndegrees ) ;
#line 127
int GaussianFitHistogram(struct histogram_s *h___0 , float high_hint ) ;
#line 128
void GaussianSetHistogram(struct histogram_s *h___0 , float mean , float sd ) ;
#line 129
double EVDDensity(float x , float mu , float lambda ) ;
#line 130
double EVDDistribution(float x , float mu , float lambda ) ;
#line 131
double ExtremeValueP(float x , float mu , float lambda ) ;
#line 132
double ExtremeValueP2(float x , float mu , float lambda , int N ) ;
#line 133
double ExtremeValueE(float x , float mu , float lambda , int N ) ;
#line 134
float EVDrandom(float mu , float lambda ) ;
#line 135
int EVDMaxLikelyFit(float *x , int *c , int n , float *ret_mu , float *ret_lambda ) ;
#line 137
int EVDCensoredFit(float *x , int *y___0 , int n , int z , float c , float *ret_mu ,
                   float *ret_lambda ) ;
#line 139
void Lawless416(float *x , int *y___0 , int n , float lambda , float *ret_f , float *ret_df ) ;
#line 141
void Lawless422(float *x , int *y___0 , int n , int z , float c , float lambda , float *ret_f ,
                float *ret_df ) ;
#line 59 "histogram.c"
struct histogram_s *AllocHistogram(int min , int max , int lumpsize ) 
{ 
  struct histogram_s *h___0 ;
  int newsize ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 66
  newsize = (max - min) + 1;
#line 68
  tmp = sre_malloc((char *)"histogram.c", 68, sizeof(struct histogram_s ));
#line 68
  h___0 = (struct histogram_s *)tmp;
#line 69
  h___0->min = min;
#line 70
  h___0->max = max;
#line 71
  h___0->total = 0;
#line 72
  h___0->lowscore = 2147483647;
#line 73
  h___0->highscore = (-0x7FFFFFFF-1);
#line 74
  h___0->lumpsize = lumpsize;
#line 75
  tmp___0 = sre_malloc((char *)"histogram.c", 75, sizeof(int ) * (unsigned long )newsize);
#line 75
  h___0->histogram = (int *)tmp___0;
#line 76
  i___0 = 0;
#line 76
  while (i___0 < newsize) {
#line 76
    *(h___0->histogram + i___0) = 0;
#line 76
    i___0 ++;
  }
#line 78
  h___0->expect = (float *)((void *)0);
#line 79
  h___0->fit_type = 0;
#line 81
  return (h___0);
}
}
#line 89 "histogram.c"
void FreeHistogram(struct histogram_s *h___0 ) 
{ 


  {
#line 92
  free((void *)h___0->histogram);
#line 93
  if ((unsigned long )h___0->expect != (unsigned long )((void *)0)) {
#line 93
    free((void *)h___0->expect);
  }
#line 94
  free((void *)h___0);
#line 95
  return;
}
}
#line 101 "histogram.c"
void UnfitHistogram(struct histogram_s *h___0 ) 
{ 


  {
#line 104
  if ((unsigned long )h___0->expect != (unsigned long )((void *)0)) {
#line 104
    free((void *)h___0->expect);
  }
#line 105
  h___0->expect = (float *)((void *)0);
#line 106
  h___0->fit_type = 0;
#line 107
  return;
}
}
#line 117 "histogram.c"
void AddToHistogram(struct histogram_s *h___0 , float sc ) 
{ 
  int score ;
  int moveby ;
  int prevsize ;
  int newsize ;
  int i___0 ;
  double tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 129
  if (h___0->fit_type != 0) {
#line 130
    Die((char *)"AddToHistogram(): Can\'t add to a fitted histogram\n");
  }
#line 137
  tmp = floor((double )sc);
#line 137
  score = (int )tmp;
#line 141
  if (score < h___0->min) {
#line 143
    prevsize = (h___0->max - h___0->min) + 1;
#line 144
    moveby = (h___0->min - score) + h___0->lumpsize;
#line 145
    newsize = prevsize + moveby;
#line 146
    h___0->min -= moveby;
#line 148
    tmp___0 = sre_realloc((char *)"histogram.c", 148, (void *)h___0->histogram, sizeof(int ) * (unsigned long )newsize);
#line 148
    h___0->histogram = (int *)tmp___0;
#line 149
    memmove((void *)(h___0->histogram + moveby), (void const   *)h___0->histogram,
            sizeof(int ) * (unsigned long )prevsize);
#line 150
    i___0 = 0;
#line 150
    while (i___0 < moveby) {
#line 151
      *(h___0->histogram + i___0) = 0;
#line 150
      i___0 ++;
    }
  } else
#line 153
  if (score > h___0->max) {
#line 155
    prevsize = (h___0->max - h___0->min) + 1;
#line 156
    h___0->max = h___0->lumpsize + score;
#line 157
    newsize = (h___0->max - h___0->min) + 1;
#line 159
    tmp___1 = sre_realloc((char *)"histogram.c", 159, (void *)h___0->histogram, sizeof(int ) * (unsigned long )newsize);
#line 159
    h___0->histogram = (int *)tmp___1;
#line 160
    i___0 = prevsize;
#line 160
    while (i___0 < newsize) {
#line 161
      *(h___0->histogram + i___0) = 0;
#line 160
      i___0 ++;
    }
  }
#line 167
  (*(h___0->histogram + (score - h___0->min))) ++;
#line 168
  (h___0->total) ++;
#line 169
  if (score < h___0->lowscore) {
#line 169
    h___0->lowscore = score;
  }
#line 170
  if (score > h___0->highscore) {
#line 170
    h___0->highscore = score;
  }
#line 174
  return;
}
}
#line 188 "histogram.c"
void PrintASCIIHistogram(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int units ;
  int maxbar ;
  int num ;
  int i___0 ;
  int idx ;
  char buffer___1[81] ;
  int pos ;
  int lowbound ;
  int lowcount ;
  int highbound ;
  int highcount ;
  int emptybins ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 199
  emptybins = 3;
#line 207
  maxbar = 0;
#line 208
  i___0 = h___0->lowscore - h___0->min;
#line 208
  while (i___0 <= h___0->highscore - h___0->min) {
#line 209
    if (*(h___0->histogram + i___0) > maxbar) {
#line 211
      maxbar = *(h___0->histogram + i___0);
#line 212
      lowbound = i___0 + h___0->min;
    }
#line 208
    i___0 ++;
  }
#line 219
  highbound = lowbound;
#line 220
  num = 0;
#line 220
  while (lowbound > h___0->lowscore) {
#line 222
    i___0 = lowbound - h___0->min;
#line 223
    if (*(h___0->histogram + i___0) > 0) {
#line 223
      num = 0;
#line 223
      goto __Cont;
    }
#line 224
    num ++;
#line 224
    if (num == emptybins) {
#line 224
      lowbound += emptybins;
#line 224
      break;
    }
    __Cont: /* CIL Label */ 
#line 220
    lowbound --;
  }
#line 226
  num = 0;
#line 226
  while (highbound < h___0->highscore) {
#line 228
    i___0 = highbound - h___0->min;
#line 229
    if (*(h___0->histogram + i___0) > 0) {
#line 229
      num = 0;
#line 229
      goto __Cont___0;
    }
#line 230
    num ++;
#line 230
    if (num == emptybins) {
#line 230
      highbound -= emptybins;
#line 230
      break;
    }
    __Cont___0: /* CIL Label */ 
#line 226
    highbound ++;
  }
#line 233
  lowcount = 0;
#line 233
  i___0 = h___0->lowscore - h___0->min;
#line 233
  while (i___0 <= lowbound - h___0->min) {
#line 234
    lowcount += *(h___0->histogram + i___0);
#line 233
    i___0 ++;
  }
#line 235
  highcount = 0;
#line 235
  i___0 = h___0->highscore - h___0->min;
#line 235
  while (i___0 >= highbound - h___0->min) {
#line 236
    highcount += *(h___0->histogram + i___0);
#line 235
    i___0 --;
  }
#line 239
  if (lowcount > maxbar) {
#line 239
    maxbar = lowcount;
  }
#line 240
  if (highcount > maxbar) {
#line 240
    maxbar = highcount;
  }
#line 241
  units = (maxbar - 1) / 59 + 1;
#line 246
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5s %6s %6s  (one = represents %d sequences)\n",
          "score", "obs", "exp", units);
#line 248
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5s %6s %6s\n", "-----",
          "---", "---");
#line 249
  buffer___1[80] = (char )'\000';
#line 250
  buffer___1[79] = (char )'\n';
#line 251
  i___0 = h___0->lowscore;
#line 251
  while (i___0 <= h___0->highscore) {
#line 253
    memset((void *)(buffer___1), ' ', 79UL * sizeof(char ));
#line 254
    idx = i___0 - h___0->min;
#line 258
    if (i___0 < lowbound) {
#line 258
      goto __Cont___1;
    } else
#line 259
    if (i___0 > highbound) {
#line 259
      goto __Cont___1;
    } else
#line 260
    if (i___0 == lowbound) {
#line 260
      if (i___0 != h___0->lowscore) {
#line 262
        sprintf((char * __restrict  )(buffer___1), (char const   * __restrict  )"<%4d %6d %6s|",
                i___0 + 1, lowcount, "-");
#line 263
        if (lowcount > 0) {
#line 264
          num = 1 + (lowcount - 1) / units;
#line 265
          if (num > 60) {
#line 265
            Die((char *)"oops");
          }
#line 266
          pos = 20;
#line 266
          while (num > 0) {
#line 266
            tmp = pos;
#line 266
            pos ++;
#line 266
            buffer___1[tmp] = (char )'=';
#line 266
            num --;
          }
        }
#line 268
        fputs((char const   * __restrict  )(buffer___1), (FILE * __restrict  )fp);
#line 269
        goto __Cont___1;
      } else {
#line 260
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 271
    if (i___0 == highbound) {
#line 271
      if (i___0 != h___0->highscore) {
#line 273
        sprintf((char * __restrict  )(buffer___1), (char const   * __restrict  )">%4d %6d %6s|",
                i___0, highcount, "-");
#line 274
        if (highcount > 0) {
#line 275
          num = 1 + (highcount - 1) / units;
#line 276
          pos = 20;
#line 276
          while (num > 0) {
#line 276
            tmp___0 = pos;
#line 276
            pos ++;
#line 276
            buffer___1[tmp___0] = (char )'=';
#line 276
            num --;
          }
        }
#line 278
        fputs((char const   * __restrict  )(buffer___1), (FILE * __restrict  )fp);
#line 279
        goto __Cont___1;
      }
    }
#line 284
    if (h___0->fit_type != 0) {
#line 285
      sprintf((char * __restrict  )(buffer___1), (char const   * __restrict  )"%5d %6d %6d|",
              i___0, *(h___0->histogram + idx), (int )*(h___0->expect + idx));
    } else {
#line 288
      sprintf((char * __restrict  )(buffer___1), (char const   * __restrict  )"%5d %6d %6s|",
              i___0, *(h___0->histogram + idx), "-");
    }
#line 289
    buffer___1[20] = (char )' ';
#line 293
    if (*(h___0->histogram + idx) > 0) {
#line 294
      num = 1 + (*(h___0->histogram + idx) - 1) / units;
#line 295
      pos = 20;
#line 295
      while (num > 0) {
#line 295
        tmp___1 = pos;
#line 295
        pos ++;
#line 295
        buffer___1[tmp___1] = (char )'=';
#line 295
        num --;
      }
    }
#line 300
    if (h___0->fit_type != 0) {
#line 300
      if ((int )*(h___0->expect + idx) > 0) {
#line 302
        pos = 20 + (int )(*(h___0->expect + idx) - (float )1) / units;
#line 303
        if (pos >= 78) {
#line 303
          pos = 78;
        }
#line 304
        buffer___1[pos] = (char )'*';
      }
    }
#line 309
    fputs((char const   * __restrict  )(buffer___1), (FILE * __restrict  )fp);
    __Cont___1: /* CIL Label */ 
#line 251
    i___0 ++;
  }
#line 314
  switch (h___0->fit_type) {
  case 0: 
#line 316
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n\n%% No statistical fit available\n");
#line 317
  break;
  case 1: 
#line 320
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n\n%% Statistical details of theoretical EVD fit:\n");
#line 321
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"              mu = %10.4f\n",
          (double )h___0->param[0]);
#line 322
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"          lambda = %10.4f\n",
          (double )h___0->param[1]);
#line 323
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"chi-sq statistic = %10.4f\n",
          (double )h___0->chisq);
#line 324
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  P(chi-square)  = %10.4g\n",
          (double )h___0->chip);
#line 325
  break;
  case 2: 
#line 328
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n\n%% Statistical details of theoretical Gaussian fit:\n");
#line 329
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"            mean = %10.4f\n",
          (double )h___0->param[0]);
#line 330
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"              sd = %10.4f\n",
          (double )h___0->param[1]);
#line 331
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"chi-sq statistic = %10.4f\n",
          (double )h___0->chisq);
#line 332
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  P(chi-square)  = %10.4g\n",
          (double )h___0->chip);
#line 333
  break;
  }
#line 335
  return;
}
}
#line 347 "histogram.c"
void PrintXMGRHistogram(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  double val ;
  double tmp ;
  double tmp___0 ;

  {
#line 355
  sc = h___0->lowscore;
#line 355
  while (sc <= h___0->highscore) {
#line 356
    if (*(h___0->histogram + (sc - h___0->min)) > 0) {
#line 357
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc,
              (double )((float )*(h___0->histogram + (sc - h___0->min)) / (float )h___0->total));
    }
#line 355
    sc ++;
  }
#line 359
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
#line 363
  if (h___0->fit_type != 0) {
#line 365
    sc = h___0->lowscore;
#line 365
    while (sc <= h___0->highscore) {
#line 367
      tmp = ExtremeValueP((float )sc + (float )1, h___0->param[0], h___0->param[1]);
#line 367
      tmp___0 = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
#line 367
      val = (1. - tmp) - (1. - tmp___0);
#line 370
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc,
              val);
#line 365
      sc ++;
    }
#line 372
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
  }
#line 374
  return;
}
}
#line 383 "histogram.c"
void PrintXMGRDistribution(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  int cum ;
  double val ;
  double tmp ;

  {
#line 394
  cum = 0;
#line 394
  sc = h___0->lowscore;
#line 394
  while (sc <= h___0->highscore) {
#line 396
    cum += *(h___0->histogram + (sc - h___0->min));
#line 397
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc + 1,
            (double )((float )cum / (float )h___0->total));
#line 394
    sc ++;
  }
#line 399
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
#line 403
  if (h___0->fit_type != 0) {
#line 405
    sc = h___0->lowscore;
#line 405
    while (sc <= h___0->highscore) {
#line 407
      tmp = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
#line 407
      val = 1. - tmp;
#line 409
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc,
              val);
#line 405
      sc ++;
    }
#line 411
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
  }
#line 413
  return;
}
}
#line 422 "histogram.c"
void PrintXMGRRegressionLine(FILE *fp , struct histogram_s *h___0 ) 
{ 
  int sc ;
  int cum ;
  double val ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 433
  cum = 0;
#line 433
  sc = h___0->lowscore;
#line 433
  while (sc <= h___0->highscore) {
#line 435
    cum += *(h___0->histogram + (sc - h___0->min));
#line 436
    tmp = log((double )cum / (double )h___0->total);
#line 436
    val = log(- 1. * tmp);
#line 437
    if (cum < h___0->total) {
#line 438
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc + 1,
              val);
    }
#line 433
    sc ++;
  }
#line 440
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
#line 444
  if (h___0->fit_type != 0) {
#line 446
    sc = h___0->lowscore;
#line 446
    while (sc <= h___0->highscore) {
#line 448
      tmp___0 = ExtremeValueP((float )sc, h___0->param[0], h___0->param[1]);
#line 448
      tmp___1 = log(1. - tmp___0);
#line 448
      val = log(- 1. * tmp___1);
#line 450
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-6d %f\n", sc,
              val);
#line 446
      sc ++;
    }
#line 452
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"&\n");
  }
#line 454
  return;
}
}
#line 475 "histogram.c"
void EVDBasicFit(struct histogram_s *h___0 ) 
{ 
  float *d___0 ;
  float *x ;
  int hsize ;
  int sum ;
  int sc ;
  int idx ;
  float slope ;
  float intercept ;
  float corr ;
  float lambda ;
  float mu ;
  void *tmp ;
  void *tmp___0 ;
  float tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 491
  hsize = (h___0->highscore - h___0->lowscore) + 1;
#line 492
  tmp = sre_malloc((char *)"histogram.c", 492, sizeof(float ) * (unsigned long )hsize);
#line 492
  d___0 = (float *)tmp;
#line 493
  tmp___0 = sre_malloc((char *)"histogram.c", 493, sizeof(float ) * (unsigned long )hsize);
#line 493
  x = (float *)tmp___0;
#line 494
  idx = 0;
#line 494
  while (idx < hsize) {
#line 495
    tmp___1 = (float )0.;
#line 495
    *(x + idx) = tmp___1;
#line 495
    *(d___0 + idx) = tmp___1;
#line 494
    idx ++;
  }
#line 501
  sum = 0;
#line 502
  sc = h___0->lowscore;
#line 502
  while (sc <= h___0->highscore) {
#line 504
    sum += *(h___0->histogram + (sc - h___0->min));
#line 505
    *(d___0 + (sc - h___0->lowscore)) = (float )sum / (float )h___0->total;
#line 506
    *(x + (sc - h___0->lowscore)) = (float )(sc + 1);
#line 502
    sc ++;
  }
#line 514
  sc = h___0->lowscore;
#line 514
  while (sc < h___0->highscore) {
#line 515
    tmp___2 = log((double )*(d___0 + (sc - h___0->lowscore)));
#line 515
    tmp___3 = log(- 1. * tmp___2);
#line 515
    *(d___0 + (sc - h___0->lowscore)) = (float )tmp___3;
#line 514
    sc ++;
  }
#line 518
  Linefit(x, d___0, hsize - 1, & intercept, & slope, & corr);
#line 520
  lambda = (float )(- 1. * (double )slope);
#line 521
  mu = intercept / lambda;
#line 526
  ExtremeValueSetHistogram(h___0, mu, lambda, (float )h___0->lowscore, (float )h___0->highscore,
                           2);
#line 528
  free((void *)x);
#line 529
  free((void *)d___0);
#line 530
  return;
}
}
#line 554 "histogram.c"
int ExtremeValueFitHistogram(struct histogram_s *h___0 , int censor , float high_hint ) 
{ 
  float *x ;
  int *y___0 ;
  int n ;
  int z ;
  int hsize ;
  float lambda ;
  float mu ;
  int sc ;
  int lowbound ;
  int highbound ;
  int new_highbound ;
  int iteration ;
  int max ;
  void *tmp ;
  void *tmp___0 ;
  double psx ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 573
  lowbound = h___0->lowscore;
#line 574
  if (censor) {
#line 576
    max = -1;
#line 577
    sc = h___0->lowscore;
#line 577
    while (sc <= h___0->highscore) {
#line 578
      if (*(h___0->histogram + (sc - h___0->min)) > max) {
#line 580
        max = *(h___0->histogram + (sc - h___0->min));
#line 581
        lowbound = sc;
      }
#line 577
      sc ++;
    }
  }
#line 587
  if (high_hint < (float )h___0->highscore) {
#line 587
    highbound = (int )high_hint;
  } else {
#line 587
    highbound = h___0->highscore;
  }
#line 591
  iteration = 0;
#line 591
  while (iteration < 100) {
#line 595
    x = (float *)((void *)0);
#line 596
    y___0 = (int *)((void *)0);
#line 597
    hsize = (highbound - lowbound) + 1;
#line 598
    if (hsize < 5) {
#line 598
      goto FITFAILED;
    }
#line 600
    tmp = sre_malloc((char *)"histogram.c", 600, sizeof(float ) * (unsigned long )hsize);
#line 600
    x = (float *)tmp;
#line 601
    tmp___0 = sre_malloc((char *)"histogram.c", 601, sizeof(int ) * (unsigned long )hsize);
#line 601
    y___0 = (int *)tmp___0;
#line 602
    n = 0;
#line 603
    sc = lowbound;
#line 603
    while (sc <= highbound) {
#line 605
      *(x + (sc - lowbound)) = (float )((double )((float )sc) + 0.5);
#line 606
      *(y___0 + (sc - lowbound)) = *(h___0->histogram + (sc - h___0->min));
#line 607
      n += *(h___0->histogram + (sc - h___0->min));
#line 603
      sc ++;
    }
#line 610
    if (n < 100) {
#line 610
      goto FITFAILED;
    }
#line 618
    if (censor) {
#line 620
      if (iteration == 0) {
#line 621
        if (h___0->total - n < (int )(0.58198 * (double )((float )n))) {
#line 621
          z = h___0->total - n;
        } else {
#line 621
          z = (int )(0.58198 * (double )((float )n));
        }
      } else {
#line 625
        psx = EVDDistribution((float )lowbound, mu, lambda);
#line 626
        if (h___0->total - n < (int )(((double )n * psx) / (1. - psx))) {
#line 626
          z = h___0->total - n;
        } else {
#line 626
          z = (int )(((double )n * psx) / (1. - psx));
        }
      }
    }
#line 632
    if (censor) {
#line 633
      tmp___1 = EVDCensoredFit(x, y___0, hsize, z, (float )lowbound, & mu, & lambda);
#line 633
      if (! tmp___1) {
#line 634
        goto FITFAILED;
      }
    } else {
#line 636
      tmp___2 = EVDMaxLikelyFit(x, y___0, hsize, & mu, & lambda);
#line 636
      if (! tmp___2) {
#line 637
        goto FITFAILED;
      }
    }
#line 642
    tmp___3 = log((double )((n + z) - 1) / (double )(n + z));
#line 642
    tmp___4 = log(- 1. * tmp___3);
#line 642
    new_highbound = (int )((double )mu - tmp___4 / (double )lambda);
#line 645
    free((void *)x);
#line 646
    free((void *)y___0);
#line 647
    if (new_highbound >= highbound) {
#line 647
      break;
    }
#line 648
    highbound = new_highbound;
#line 591
    iteration ++;
  }
#line 656
  ExtremeValueSetHistogram(h___0, mu, lambda, (float )lowbound, (float )highbound,
                           1);
#line 657
  return (1);
  FITFAILED: 
#line 660
  UnfitHistogram(h___0);
#line 661
  if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 661
    free((void *)x);
  }
#line 662
  if ((unsigned long )y___0 != (unsigned long )((void *)0)) {
#line 662
    free((void *)y___0);
  }
#line 663
  return (0);
}
}
#line 681 "histogram.c"
void ExtremeValueSetHistogram(struct histogram_s *h___0 , float mu , float lambda ,
                              float lowbound , float highbound , int ndegrees ) 
{ 
  int sc ;
  int hsize ;
  int idx ;
  int nbins ;
  float delta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 690
  UnfitHistogram(h___0);
#line 691
  h___0->fit_type = 1;
#line 692
  h___0->param[1] = lambda;
#line 693
  h___0->param[0] = mu;
#line 695
  hsize = (h___0->max - h___0->min) + 1;
#line 696
  tmp = sre_malloc((char *)"histogram.c", 696, sizeof(float ) * (unsigned long )hsize);
#line 696
  h___0->expect = (float *)tmp;
#line 697
  idx = 0;
#line 697
  while (idx < hsize) {
#line 698
    *(h___0->expect + idx) = (float )0.;
#line 697
    idx ++;
  }
#line 702
  sc = h___0->min;
#line 702
  while (sc <= h___0->max) {
#line 703
    tmp___0 = ExtremeValueE((float )sc, h___0->param[0], h___0->param[1], h___0->total);
#line 703
    tmp___1 = ExtremeValueE((float )(sc + 1), h___0->param[0], h___0->param[1], h___0->total);
#line 703
    *(h___0->expect + (sc - h___0->min)) = (float )(tmp___0 - tmp___1);
#line 702
    sc ++;
  }
#line 711
  h___0->chisq = (float )0.;
#line 712
  nbins = 0;
#line 713
  sc = (int )lowbound;
#line 713
  while ((float )sc <= highbound) {
#line 714
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
#line 714
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
#line 716
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
#line 717
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
#line 718
        nbins ++;
      }
    }
#line 713
    sc ++;
  }
#line 724
  if (nbins > 1 + ndegrees) {
#line 725
    tmp___2 = IncompleteGamma((double )((nbins - 1) - ndegrees) / 2., (double )h___0->chisq / 2.);
#line 725
    h___0->chip = (float )tmp___2;
  } else {
#line 728
    h___0->chip = (float )0.;
  }
#line 729
  return;
}
}
#line 746 "histogram.c"
int GaussianFitHistogram(struct histogram_s *h___0 , float high_hint ) 
{ 
  float sum ;
  float sqsum ;
  float delta ;
  int sc ;
  int nbins ;
  int hsize ;
  int idx ;
  double tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 758
  UnfitHistogram(h___0);
#line 763
  if (h___0->total < 1000) {
#line 763
    h___0->fit_type = 0;
#line 763
    return (0);
  }
#line 772
  sqsum = (float )0.;
#line 772
  sum = sqsum;
#line 773
  sc = h___0->lowscore;
#line 773
  while (sc <= h___0->highscore) {
#line 775
    delta = (float )((double )((float )sc) + 0.5);
#line 776
    sum += (float )*(h___0->histogram + (sc - h___0->min)) * delta;
#line 777
    sqsum += ((float )*(h___0->histogram + (sc - h___0->min)) * delta) * delta;
#line 773
    sc ++;
  }
#line 779
  h___0->fit_type = 2;
#line 780
  h___0->param[0] = sum / (float )h___0->total;
#line 781
  tmp = sqrt((double )((sqsum - (sum * sum) / (float )h___0->total) / (float )(h___0->total - 1)));
#line 781
  h___0->param[1] = (float )tmp;
#line 789
  hsize = (h___0->max - h___0->min) + 1;
#line 790
  tmp___0 = sre_malloc((char *)"histogram.c", 790, sizeof(float ) * (unsigned long )hsize);
#line 790
  h___0->expect = (float *)tmp___0;
#line 791
  idx = 0;
#line 791
  while (idx < hsize) {
#line 792
    *(h___0->expect + idx) = (float )0.;
#line 791
    idx ++;
  }
#line 794
  sc = h___0->min;
#line 794
  while (sc <= h___0->max) {
#line 796
    delta = (float )(((double )((float )sc) + 0.5) - (double )h___0->param[0]);
#line 797
    tmp___1 = sqrt(2. * 3.14159);
#line 797
    tmp___2 = exp(((- 1. * (double )delta) * (double )delta) / ((2. * (double )h___0->param[1]) * (double )h___0->param[1]));
#line 797
    *(h___0->expect + (sc - h___0->min)) = (float )((double )((float )h___0->total) * ((1. / ((double )h___0->param[1] * tmp___1)) * tmp___2));
#line 794
    sc ++;
  }
#line 804
  h___0->chisq = (float )0.;
#line 805
  nbins = 0;
#line 806
  sc = h___0->lowscore;
#line 806
  while (sc <= h___0->highscore) {
#line 807
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
#line 807
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
#line 809
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
#line 810
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
#line 811
        nbins ++;
      }
    }
#line 806
    sc ++;
  }
#line 814
  if (nbins > 3) {
#line 815
    tmp___3 = IncompleteGamma((double )(nbins - 3) / 2., (double )h___0->chisq / 2.);
#line 815
    h___0->chip = (float )tmp___3;
  } else {
#line 818
    h___0->chip = (float )0.;
  }
#line 820
  return (1);
}
}
#line 829 "histogram.c"
void GaussianSetHistogram(struct histogram_s *h___0 , float mean , float sd ) 
{ 
  int sc ;
  int hsize ;
  int idx ;
  int nbins ;
  float delta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 837
  UnfitHistogram(h___0);
#line 838
  h___0->fit_type = 2;
#line 839
  h___0->param[0] = mean;
#line 840
  h___0->param[1] = sd;
#line 844
  hsize = (h___0->max - h___0->min) + 1;
#line 845
  tmp = sre_malloc((char *)"histogram.c", 845, sizeof(float ) * (unsigned long )hsize);
#line 845
  h___0->expect = (float *)tmp;
#line 846
  idx = 0;
#line 846
  while (idx < hsize) {
#line 847
    *(h___0->expect + idx) = (float )0.;
#line 846
    idx ++;
  }
#line 854
  sc = h___0->min;
#line 854
  while (sc <= h___0->max) {
#line 856
    delta = (float )(((double )((float )sc) + 0.5) - (double )h___0->param[0]);
#line 857
    tmp___0 = sqrt(2. * 3.14159);
#line 857
    tmp___1 = exp(((- 1. * (double )delta) * (double )delta) / ((2. * (double )h___0->param[1]) * (double )h___0->param[1]));
#line 857
    *(h___0->expect + (sc - h___0->min)) = (float )((double )((float )h___0->total) * ((1. / ((double )h___0->param[1] * tmp___0)) * tmp___1));
#line 854
    sc ++;
  }
#line 864
  h___0->chisq = (float )0.;
#line 865
  nbins = 0;
#line 866
  sc = h___0->lowscore;
#line 866
  while (sc <= h___0->highscore) {
#line 867
    if ((double )*(h___0->expect + (sc - h___0->min)) >= 5.) {
#line 867
      if (*(h___0->histogram + (sc - h___0->min)) >= 5) {
#line 869
        delta = (float )*(h___0->histogram + (sc - h___0->min)) - *(h___0->expect + (sc - h___0->min));
#line 870
        h___0->chisq += (delta * delta) / *(h___0->expect + (sc - h___0->min));
#line 871
        nbins ++;
      }
    }
#line 866
    sc ++;
  }
#line 874
  if (nbins > 1) {
#line 875
    tmp___2 = IncompleteGamma((double )(nbins - 1) / 2., (double )h___0->chisq / 2.);
#line 875
    h___0->chip = (float )tmp___2;
  } else {
#line 878
    h___0->chip = (float )0.;
  }
#line 879
  return;
}
}
#line 890 "histogram.c"
double EVDDensity(float x , float mu , float lambda ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 893
  tmp = exp((- 1. * (double )lambda) * (double )(x - mu));
#line 893
  tmp___0 = exp((- 1. * (double )lambda) * (double )(x - mu) - tmp);
#line 893
  return ((double )lambda * tmp___0);
}
}
#line 904 "histogram.c"
double EVDDistribution(float x , float mu , float lambda ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 907
  tmp = exp((- 1. * (double )lambda) * (double )(x - mu));
#line 907
  tmp___0 = exp(- 1. * tmp);
#line 907
  return (tmp___0);
}
}
#line 927 "histogram.c"
double ExtremeValueP(float x , float mu , float lambda ) 
{ 
  double y___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 933
  tmp = log(2.2204460492503131e-16);
#line 933
  tmp___0 = log(- 1. * tmp);
#line 933
  if ((double )(lambda * (x - mu)) <= - 1. * tmp___0) {
#line 933
    return (1.0);
  }
#line 935
  if ((double )(lambda * (x - mu)) >= 2.3 * (double )308) {
#line 935
    return (0.0);
  }
#line 937
  y___0 = exp((- 1. * (double )lambda) * (double )(x - mu));
#line 938
  if (y___0 < 1e-7) {
#line 938
    return (y___0);
  } else {
#line 939
    tmp___1 = exp(- 1. * y___0);
#line 939
    return (1.0 - tmp___1);
  }
}
}
#line 956 "histogram.c"
double ExtremeValueP2(float x , float mu , float lambda , int N ) 
{ 
  double y___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 960
  tmp = ExtremeValueP(x, mu, lambda);
#line 960
  y___0 = (double )N * tmp;
#line 961
  if (y___0 < 1e-7) {
#line 961
    return (y___0);
  } else {
#line 962
    tmp___0 = exp(- 1. * y___0);
#line 962
    return (1.0 - tmp___0);
  }
}
}
#line 977 "histogram.c"
double ExtremeValueE(float x , float mu , float lambda , int N ) 
{ 
  double tmp ;

  {
#line 980
  tmp = ExtremeValueP(x, mu, lambda);
#line 980
  return ((double )N * tmp);
}
}
#line 992 "histogram.c"
float EVDrandom(float mu , float lambda ) 
{ 
  float p ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 995
  p = (float )0.0;
#line 1000
  while (1) {
#line 1000
    if (! ((double )p == 0.)) {
#line 1000
      if (! ((double )p == 1.)) {
#line 1000
        break;
      }
    }
#line 1000
    tmp = sre_random();
#line 1000
    p = (float )tmp;
  }
#line 1001
  tmp___0 = log((double )p);
#line 1001
  tmp___1 = log(- 1. * tmp___0);
#line 1001
  return ((float )((double )mu - tmp___1 / (double )lambda));
}
}
#line 1027 "histogram.c"
void Lawless416(float *x , int *y___0 , int n , float lambda , float *ret_f , float *ret_df ) 
{ 
  double esum ;
  double xesum ;
  double xxesum ;
  double xsum ;
  double mult ;
  double total ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 1040
  total = 0.;
#line 1040
  xxesum = total;
#line 1040
  xsum = xxesum;
#line 1040
  xesum = xsum;
#line 1040
  esum = xesum;
#line 1041
  i___0 = 0;
#line 1041
  while (i___0 < n) {
#line 1043
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
#line 1043
      mult = 1.;
    } else {
#line 1043
      mult = (double )*(y___0 + i___0);
    }
#line 1044
    xsum += mult * (double )*(x + i___0);
#line 1045
    tmp = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1045
    xesum += (mult * (double )*(x + i___0)) * tmp;
#line 1046
    tmp___0 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1046
    xxesum += ((mult * (double )*(x + i___0)) * (double )*(x + i___0)) * tmp___0;
#line 1047
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1047
    esum += mult * tmp___1;
#line 1048
    total += mult;
#line 1041
    i___0 ++;
  }
#line 1050
  *ret_f = (float )((1. / (double )lambda - xsum / total) + xesum / esum);
#line 1051
  *ret_df = (float )(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double )(lambda * lambda));
#line 1055
  return;
}
}
#line 1084 "histogram.c"
void Lawless422(float *x , int *y___0 , int n , int z , float c , float lambda , float *ret_f ,
                float *ret_df ) 
{ 
  double esum ;
  double xesum ;
  double xxesum ;
  double xsum ;
  double mult ;
  double total ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 1096
  total = 0.;
#line 1096
  xxesum = total;
#line 1096
  xsum = xxesum;
#line 1096
  xesum = xsum;
#line 1096
  esum = xesum;
#line 1097
  i___0 = 0;
#line 1097
  while (i___0 < n) {
#line 1099
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
#line 1099
      mult = 1.;
    } else {
#line 1099
      mult = (double )*(y___0 + i___0);
    }
#line 1100
    xsum += mult * (double )*(x + i___0);
#line 1101
    tmp = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1101
    esum += mult * tmp;
#line 1102
    tmp___0 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1102
    xesum += (mult * (double )*(x + i___0)) * tmp___0;
#line 1103
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1103
    xxesum += ((mult * (double )*(x + i___0)) * (double )*(x + i___0)) * tmp___1;
#line 1104
    total += mult;
#line 1097
    i___0 ++;
  }
#line 1109
  tmp___2 = exp((- 1. * (double )lambda) * (double )c);
#line 1109
  esum += (double )z * tmp___2;
#line 1110
  tmp___3 = exp((- 1. * (double )lambda) * (double )c);
#line 1110
  xesum += ((double )z * (double )c) * tmp___3;
#line 1111
  tmp___4 = exp((- 1. * (double )lambda) * (double )c);
#line 1111
  xxesum += (((double )z * (double )c) * (double )c) * tmp___4;
#line 1113
  *ret_f = (float )((1. / (double )lambda - xsum / total) + xesum / esum);
#line 1114
  *ret_df = (float )(((xesum / esum) * (xesum / esum) - xxesum / esum) - 1. / (double )(lambda * lambda));
#line 1118
  return;
}
}
#line 1146 "histogram.c"
int EVDMaxLikelyFit(float *x , int *c , int n , float *ret_mu , float *ret_lambda ) 
{ 
  float lambda ;
  float mu ;
  float fx ;
  float dfx ;
  double esum ;
  double mult ;
  double total ;
  float tol ;
  int i___0 ;
  double tmp ;
  float left ;
  float right ;
  float mid ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 1155
  tol = (float )1e-5;
#line 1160
  lambda = (float )0.2;
#line 1164
  i___0 = 0;
#line 1164
  while (i___0 < 100) {
#line 1166
    Lawless416(x, c, n, lambda, & fx, & dfx);
#line 1167
    tmp = fabs((double )fx);
#line 1167
    if (tmp < (double )tol) {
#line 1167
      break;
    }
#line 1168
    lambda -= fx / dfx;
#line 1169
    if ((double )lambda <= 0.) {
#line 1169
      lambda = (float )0.001;
    }
#line 1164
    i___0 ++;
  }
#line 1179
  if (i___0 == 100) {
#line 1185
    left = (float )0.2;
#line 1185
    right = left;
#line 1185
    lambda = right;
#line 1186
    Lawless416(x, c, n, lambda, & fx, & dfx);
#line 1187
    if ((double )fx < 0.) {
#line 1189
      while (1) {
#line 1190
        left = (float )((double )left - 0.1);
#line 1191
        if ((double )left < 0.) {
#line 1193
          return (0);
        }
#line 1195
        Lawless416(x, c, n, left, & fx, & dfx);
#line 1189
        if (! ((double )fx < 0.)) {
#line 1189
          break;
        }
      }
    } else {
#line 1200
      while (1) {
#line 1201
        right = (float )((double )right + 0.1);
#line 1202
        Lawless416(x, c, n, right, & fx, & dfx);
#line 1203
        if ((double )right > 100.) {
#line 1205
          return (0);
        }
#line 1200
        if (! ((double )fx > 0.)) {
#line 1200
          break;
        }
      }
    }
#line 1210
    i___0 = 0;
#line 1210
    while (i___0 < 100) {
#line 1212
      mid = (float )((double )(left + right) / 2.);
#line 1213
      Lawless416(x, c, n, mid, & fx, & dfx);
#line 1214
      tmp___0 = fabs((double )fx);
#line 1214
      if (tmp___0 < (double )tol) {
#line 1214
        break;
      }
#line 1215
      if ((double )fx > 0.) {
#line 1215
        left = mid;
      } else {
#line 1216
        right = mid;
      }
#line 1210
      i___0 ++;
    }
#line 1218
    if (i___0 == 100) {
#line 1220
      return (0);
    }
#line 1222
    lambda = mid;
  }
#line 1227
  esum = 0.;
#line 1228
  total = 0.;
#line 1229
  i___0 = 0;
#line 1229
  while (i___0 < n) {
#line 1231
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1231
      mult = 1.;
    } else {
#line 1231
      mult = (double )*(c + i___0);
    }
#line 1232
    tmp___1 = exp((double )(((float )-1 * lambda) * *(x + i___0)));
#line 1232
    esum += mult * tmp___1;
#line 1233
    total += mult;
#line 1229
    i___0 ++;
  }
#line 1235
  tmp___2 = log(esum / total);
#line 1235
  mu = (float )((- 1. * tmp___2) / (double )lambda);
#line 1237
  *ret_lambda = lambda;
#line 1238
  *ret_mu = mu;
#line 1239
  return (1);
}
}
#line 1270 "histogram.c"
int EVDCensoredFit(float *x , int *y___0 , int n , int z , float c , float *ret_mu ,
                   float *ret_lambda ) 
{ 
  float lambda ;
  float mu ;
  float fx ;
  float dfx ;
  double esum ;
  double mult ;
  double total ;
  float tol ;
  int i___0 ;
  double tmp ;
  float left ;
  float right ;
  float mid ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 1280
  tol = (float )1e-5;
#line 1285
  lambda = (float )0.2;
#line 1289
  i___0 = 0;
#line 1289
  while (i___0 < 100) {
#line 1291
    Lawless422(x, y___0, n, z, c, lambda, & fx, & dfx);
#line 1292
    tmp = fabs((double )fx);
#line 1292
    if (tmp < (double )tol) {
#line 1292
      break;
    }
#line 1293
    lambda -= fx / dfx;
#line 1294
    if ((double )lambda <= 0.) {
#line 1294
      lambda = (float )0.001;
    }
#line 1289
    i___0 ++;
  }
#line 1304
  if (i___0 == 100) {
#line 1309
    left = (float )0.2;
#line 1309
    right = left;
#line 1309
    lambda = right;
#line 1310
    Lawless422(x, y___0, n, z, c, lambda, & fx, & dfx);
#line 1311
    if ((double )fx < 0.) {
#line 1313
      while (1) {
#line 1314
        left = (float )((double )left - 0.03);
#line 1315
        if ((double )left < 0.) {
#line 1317
          return (0);
        }
#line 1319
        Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
#line 1313
        if (! ((double )fx < 0.)) {
#line 1313
          break;
        }
      }
    } else {
#line 1324
      while (1) {
#line 1325
        right = (float )((double )right + 0.1);
#line 1326
        Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
#line 1327
        if ((double )right > 100.) {
#line 1329
          return (0);
        }
#line 1324
        if (! ((double )fx > 0.)) {
#line 1324
          break;
        }
      }
    }
#line 1334
    i___0 = 0;
#line 1334
    while (i___0 < 100) {
#line 1336
      mid = (float )((double )(left + right) / 2.);
#line 1337
      Lawless422(x, y___0, n, z, c, left, & fx, & dfx);
#line 1338
      tmp___0 = fabs((double )fx);
#line 1338
      if (tmp___0 < (double )tol) {
#line 1338
        break;
      }
#line 1339
      if ((double )fx > 0.) {
#line 1339
        left = mid;
      } else {
#line 1340
        right = mid;
      }
#line 1334
      i___0 ++;
    }
#line 1342
    if (i___0 == 100) {
#line 1344
      return (0);
    }
#line 1346
    lambda = mid;
  }
#line 1351
  total = 0.;
#line 1351
  esum = total;
#line 1352
  i___0 = 0;
#line 1352
  while (i___0 < n) {
#line 1354
    if ((unsigned long )y___0 == (unsigned long )((void *)0)) {
#line 1354
      mult = 1.;
    } else {
#line 1354
      mult = (double )*(y___0 + i___0);
    }
#line 1355
    tmp___1 = exp((- 1. * (double )lambda) * (double )*(x + i___0));
#line 1355
    esum += mult * tmp___1;
#line 1356
    total += mult;
#line 1352
    i___0 ++;
  }
#line 1358
  tmp___2 = exp((- 1. * (double )lambda) * (double )c);
#line 1358
  esum += (double )z * tmp___2;
#line 1359
  tmp___3 = log(esum / total);
#line 1359
  mu = (float )((- 1. * tmp___3) / (double )lambda);
#line 1361
  *ret_lambda = lambda;
#line 1362
  *ret_mu = mu;
#line 1363
  return (1);
}
}
#line 1 "hmmio.o"
#pragma merger("0","/tmp/cil-zxpshlPZ.i","")
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 101 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 335
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 157 "./ssi.h"
int SSIOpen(char *filename , SSIFILE **ret_sfp ) ;
#line 158
int SSIGetOffsetByName(SSIFILE *sfp , char *key , int *ret_fh , SSIOFFSET *ret_offset ) ;
#line 160
int SSIGetOffsetByNumber(SSIFILE *sfp , int n , int *ret_fh , SSIOFFSET *ret_offset ) ;
#line 165
int SSISetFilePosition(FILE *fp , SSIOFFSET *offset ) ;
#line 167
void SSIClose(SSIFILE *sfp ) ;
#line 171
int SSIRecommendMode(char *file ) ;
#line 173
int SSIGetFilePosition(FILE *fp , int mode , SSIOFFSET *ret_offset ) ;
#line 79 "./sqfuncs.h"
char *FileConcat(char *dir , char *file ) ;
#line 81
FILE *EnvFileOpen(char *fname , char *env , char **ret_dir ) ;
#line 193
int sre_toupper(int c ) ;
#line 214
char *Strdup(char *s___0 ) ;
#line 215
void StringChop(char *s___0 ) ;
#line 219
void s2upper(char *s___0 ) ;
#line 147 "./funcs.h"
HMMFILE *HMMFileOpen(char *hmmfile , char *env ) ;
#line 148
int HMMFileRead(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 149
void HMMFileClose(HMMFILE *hmmfp ) ;
#line 151
void HMMFileRewind(HMMFILE *hmmfp ) ;
#line 152
int HMMFilePositionByName(HMMFILE *hmmfp , char *name ) ;
#line 153
int HMMFilePositionByIndex(HMMFILE *hmmfp , int idx ) ;
#line 154
void WriteAscHMM(FILE *fp , struct plan7_s *hmm ) ;
#line 155
void WriteBinHMM(FILE *fp , struct plan7_s *hmm ) ;
#line 183
char *Getword(FILE *fp , int type ) ;
#line 205
struct plan7_s *AllocPlan7Shell(void) ;
#line 206
void AllocPlan7Body(struct plan7_s *hmm , int M ) ;
#line 207
void FreePlan7(struct plan7_s *hmm ) ;
#line 208
void ZeroPlan7(struct plan7_s *hmm ) ;
#line 209
void Plan7SetName(struct plan7_s *hmm , char *name ) ;
#line 210
void Plan7SetAccession(struct plan7_s *hmm , char *acc ) ;
#line 211
void Plan7SetDescription(struct plan7_s *hmm , char *desc ) ;
#line 213
void Plan7SetCtime(struct plan7_s *hmm ) ;
#line 216
void Plan7Renormalize(struct plan7_s *hmm ) ;
#line 220
void Plan7LSConfig(struct plan7_s *hmm ) ;
#line 226
void Plan9toPlan7(struct plan9_s *hmm , struct plan7_s **ret_plan7 ) ;
#line 232
struct plan9_s *P9AllocHMM(int M ) ;
#line 234
int P9FreeHMM(struct plan9_s *hmm ) ;
#line 235
void P9Renormalize(struct plan9_s *hmm ) ;
#line 236
void P9DefaultNullModel(float *null ) ;
#line 93 "hmmio.c"
static unsigned int v10magic  =    3907906993U;
#line 94 "hmmio.c"
static unsigned int v10swap  =    2985160168U;
#line 95 "hmmio.c"
static unsigned int v11magic  =    3907906994U;
#line 96 "hmmio.c"
static unsigned int v11swap  =    3001937384U;
#line 97 "hmmio.c"
static unsigned int v17magic  =    3907906995U;
#line 98 "hmmio.c"
static unsigned int v17swap  =    3018714600U;
#line 99 "hmmio.c"
static unsigned int v19magic  =    3907906996U;
#line 100 "hmmio.c"
static unsigned int v19swap  =    3035491816U;
#line 101 "hmmio.c"
static unsigned int v20magic  =    3907906997U;
#line 102 "hmmio.c"
static unsigned int v20swap  =    3052269032U;
#line 115
static int read_asc20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 116
static int read_bin20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 117
static int read_asc19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 118
static int read_bin19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 119
static int read_asc17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 120
static int read_bin17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 121
static int read_asc11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 122
static int read_bin11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 123
static int read_asc10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 124
static int read_bin10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) ;
#line 126
static void byteswap(char *swap , int nbytes ) ;
#line 127
static char *prob2ascii(float p , float null ) ;
#line 128
static float ascii2prob(char *s___0 , float null ) ;
#line 129
static void write_bin_string(FILE *fp , char *s___0 ) ;
#line 130
static int read_bin_string(FILE *fp , int doswap , char **ret_s ) ;
#line 131
static void multiline(FILE *fp , char *pfx , char *s___0 ) ;
#line 133
static struct plan9_s *read_plan9_binhmm(FILE *fp , int version , int swapped ) ;
#line 134
static struct plan9_s *read_plan9_aschmm(FILE *fp , int version ) ;
#line 154 "hmmio.c"
HMMFILE *HMMFileOpen(char *hmmfile , char *env ) 
{ 
  HMMFILE *hmmfp ;
  unsigned int magic ;
  char buf[512] ;
  char *ssifile ;
  char *dir ;
  int status ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *full ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  FILE *tmp___7 ;
  FILE *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 164
  tmp = sre_malloc((char *)"hmmio.c", 164, sizeof(HMMFILE ));
#line 164
  hmmfp = (HMMFILE *)tmp;
#line 165
  hmmfp->f = (FILE *)((void *)0);
#line 166
  hmmfp->parser = (int (*)(struct hmmfile_s * , struct plan7_s ** ))((void *)0);
#line 167
  hmmfp->is_binary = 0;
#line 168
  hmmfp->byteswap = 0;
#line 169
  hmmfp->is_seekable = 1;
#line 177
  hmmfp->f = (FILE *)((void *)0);
#line 178
  hmmfp->ssi = (SSIFILE *)((void *)0);
#line 179
  tmp___8 = fopen((char const   * __restrict  )hmmfile, (char const   * __restrict  )"r");
#line 179
  hmmfp->f = tmp___8;
#line 179
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 181
    tmp___0 = strlen((char const   *)hmmfile);
#line 181
    tmp___1 = sre_malloc((char *)"hmmio.c", 181, sizeof(char ) * (tmp___0 + 5UL));
#line 181
    ssifile = (char *)tmp___1;
#line 182
    sprintf((char * __restrict  )ssifile, (char const   * __restrict  )"%s.ssi", hmmfile);
#line 184
    tmp___2 = SSIRecommendMode(hmmfile);
#line 184
    hmmfp->mode = tmp___2;
#line 184
    if (tmp___2 == -1) {
#line 185
      Die((char *)"SSIRecommendMode() failed");
    }
  } else {
#line 187
    tmp___7 = EnvFileOpen(hmmfile, env, & dir);
#line 187
    hmmfp->f = tmp___7;
#line 187
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 190
      full = FileConcat(dir, hmmfile);
#line 192
      tmp___3 = strlen((char const   *)full);
#line 192
      tmp___4 = strlen((char const   *)hmmfile);
#line 192
      tmp___5 = sre_malloc((char *)"hmmio.c", 192, sizeof(char ) * ((tmp___3 + tmp___4) + 5UL));
#line 192
      ssifile = (char *)tmp___5;
#line 193
      sprintf((char * __restrict  )ssifile, (char const   * __restrict  )"%s.ssi",
              full);
#line 195
      tmp___6 = SSIRecommendMode(full);
#line 195
      hmmfp->mode = tmp___6;
#line 195
      if (tmp___6 == -1) {
#line 196
        Die((char *)"SSIRecommendMode() failed");
      }
#line 198
      free((void *)full);
#line 199
      free((void *)dir);
    } else {
#line 201
      return ((HMMFILE *)((void *)0));
    }
  }
#line 207
  SSIOpen(ssifile, & hmmfp->ssi);
#line 208
  free((void *)ssifile);
#line 212
  status = SSIGetFilePosition(hmmfp->f, hmmfp->mode, & hmmfp->offset);
#line 213
  if (status != 0) {
#line 213
    Die((char *)"SSIGetFilePosition() failed");
  }
#line 218
  tmp___9 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 218
  if (! tmp___9) {
#line 219
    HMMFileClose(hmmfp);
#line 220
    return ((HMMFILE *)((void *)0));
  }
#line 222
  rewind(hmmfp->f);
#line 224
  if (magic == v20magic) {
#line 225
    hmmfp->parser = & read_bin20hmm;
#line 226
    hmmfp->is_binary = 1;
#line 227
    return (hmmfp);
  } else
#line 229
  if (magic == v20swap) {
#line 231
    hmmfp->parser = & read_bin20hmm;
#line 232
    hmmfp->is_binary = 1;
#line 233
    hmmfp->byteswap = 1;
#line 234
    return (hmmfp);
  } else
#line 236
  if (magic == v19magic) {
#line 237
    hmmfp->parser = & read_bin19hmm;
#line 238
    hmmfp->is_binary = 1;
#line 239
    return (hmmfp);
  } else
#line 241
  if (magic == v19swap) {
#line 242
    hmmfp->parser = & read_bin19hmm;
#line 243
    hmmfp->is_binary = 1;
#line 244
    hmmfp->byteswap = 1;
#line 245
    return (hmmfp);
  } else
#line 247
  if (magic == v17magic) {
#line 248
    hmmfp->parser = & read_bin17hmm;
#line 249
    hmmfp->is_binary = 1;
#line 250
    return (hmmfp);
  } else
#line 252
  if (magic == v17swap) {
#line 253
    hmmfp->parser = & read_bin17hmm;
#line 254
    hmmfp->is_binary = 1;
#line 255
    hmmfp->byteswap = 1;
#line 256
    return (hmmfp);
  } else
#line 258
  if (magic == v11magic) {
#line 259
    hmmfp->parser = & read_bin11hmm;
#line 260
    hmmfp->is_binary = 1;
#line 261
    return (hmmfp);
  } else
#line 263
  if (magic == v11swap) {
#line 264
    hmmfp->parser = & read_bin11hmm;
#line 265
    hmmfp->is_binary = 1;
#line 266
    hmmfp->byteswap = 1;
#line 267
    return (hmmfp);
  } else
#line 269
  if (magic == v10magic) {
#line 270
    hmmfp->parser = & read_bin10hmm;
#line 271
    hmmfp->is_binary = 1;
#line 272
    return (hmmfp);
  } else
#line 274
  if (magic == v10swap) {
#line 275
    hmmfp->parser = & read_bin10hmm;
#line 276
    hmmfp->is_binary = 1;
#line 277
    hmmfp->byteswap = 1;
#line 278
    return (hmmfp);
  }
#line 284
  if (magic & 2147483648U) {
#line 285
    Warn((char *)"%s appears to be a binary but format is not recognized\nIt may be from a HMMER version more recent than yours,\nor may be a different kind of binary altogether.\n",
         hmmfile);
#line 289
    HMMFileClose(hmmfp);
#line 290
    return ((HMMFILE *)((void *)0));
  }
#line 295
  tmp___10 = fgets((char * __restrict  )(buf), 512, (FILE * __restrict  )hmmfp->f);
#line 295
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 296
    HMMFileClose(hmmfp);
#line 297
    return ((HMMFILE *)((void *)0));
  }
#line 299
  rewind(hmmfp->f);
#line 301
  tmp___15 = strncmp("HMMER2.0", (char const   *)(buf), (size_t )8);
#line 301
  if (tmp___15 == 0) {
#line 302
    hmmfp->parser = & read_asc20hmm;
#line 303
    return (hmmfp);
  } else {
#line 304
    tmp___14 = strncmp("HMMER v1.9", (char const   *)(buf), (size_t )10);
#line 304
    if (tmp___14 == 0) {
#line 305
      hmmfp->parser = & read_asc19hmm;
#line 306
      return (hmmfp);
    } else {
#line 307
      tmp___13 = strncmp("# HMM v1.7", (char const   *)(buf), (size_t )10);
#line 307
      if (tmp___13 == 0) {
#line 308
        hmmfp->parser = & read_asc17hmm;
#line 309
        return (hmmfp);
      } else {
#line 310
        tmp___12 = strncmp("# HMM v1.1", (char const   *)(buf), (size_t )10);
#line 310
        if (tmp___12 == 0) {
#line 311
          hmmfp->parser = & read_asc11hmm;
#line 312
          return (hmmfp);
        } else {
#line 313
          tmp___11 = strncmp("# HMM v1.0", (char const   *)(buf), (size_t )10);
#line 313
          if (tmp___11 == 0) {
#line 314
            hmmfp->parser = & read_asc10hmm;
#line 315
            return (hmmfp);
          }
        }
      }
    }
  }
#line 320
  HMMFileClose(hmmfp);
#line 321
  return ((HMMFILE *)((void *)0));
}
}
#line 323 "hmmio.c"
int HMMFileRead(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  int status ;
  int tmp ;

  {
#line 328
  if (hmmfp->is_seekable) {
#line 329
    status = SSIGetFilePosition(hmmfp->f, hmmfp->mode, & hmmfp->offset);
#line 330
    if (status != 0) {
#line 330
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
#line 333
  tmp = (*(hmmfp->parser))(hmmfp, ret_hmm);
#line 333
  return (tmp);
}
}
#line 335 "hmmio.c"
void HMMFileClose(HMMFILE *hmmfp ) 
{ 


  {
#line 338
  if ((unsigned long )hmmfp->f != (unsigned long )((void *)0)) {
#line 338
    fclose(hmmfp->f);
  }
#line 339
  if ((unsigned long )hmmfp->ssi != (unsigned long )((void *)0)) {
#line 339
    SSIClose(hmmfp->ssi);
  }
#line 340
  free((void *)hmmfp);
#line 341
  return;
}
}
#line 342 "hmmio.c"
void HMMFileRewind(HMMFILE *hmmfp ) 
{ 


  {
#line 345
  rewind(hmmfp->f);
#line 346
  return;
}
}
#line 347 "hmmio.c"
int HMMFilePositionByName(HMMFILE *hmmfp , char *name ) 
{ 
  SSIOFFSET offset ;
  int fh ;
  int tmp ;
  int tmp___0 ;

  {
#line 353
  if ((unsigned long )hmmfp->ssi == (unsigned long )((void *)0)) {
#line 353
    return (0);
  }
#line 354
  tmp = SSIGetOffsetByName(hmmfp->ssi, name, & fh, & offset);
#line 354
  if (tmp != 0) {
#line 354
    return (0);
  }
#line 355
  tmp___0 = SSISetFilePosition(hmmfp->f, & offset);
#line 355
  if (tmp___0 != 0) {
#line 355
    return (0);
  }
#line 356
  return (1);
}
}
#line 358 "hmmio.c"
int HMMFilePositionByIndex(HMMFILE *hmmfp , int idx ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
#line 364
  if ((unsigned long )hmmfp->ssi == (unsigned long )((void *)0)) {
#line 364
    return (0);
  }
#line 365
  tmp = SSIGetOffsetByNumber(hmmfp->ssi, idx, & fh, & offset);
#line 365
  if (tmp != 0) {
#line 365
    return (0);
  }
#line 366
  tmp___0 = SSISetFilePosition(hmmfp->f, & offset);
#line 366
  if (tmp___0 != 0) {
#line 366
    return (0);
  }
#line 367
  return (1);
}
}
#line 384 "hmmio.c"
void WriteAscHMM(FILE *fp , struct plan7_s *hmm ) 
{ 
  int k ;
  int x ;
  int ts ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 391
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"HMMER2.0  [%s]\n",
          "2.3");
#line 395
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"NAME  %s\n", hmm->name);
#line 396
  if (hmm->flags & (1 << 9)) {
#line 397
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ACC   %s\n", hmm->acc);
  }
#line 398
  if (hmm->flags & (1 << 1)) {
#line 399
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"DESC  %s\n", hmm->desc);
  }
#line 400
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"LENG  %d\n", hmm->M);
#line 401
  if (Alphabet_type == 3) {
#line 401
    tmp = "Amino";
  } else {
#line 401
    tmp = "Nucleic";
  }
#line 401
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ALPH  %s\n", tmp);
#line 403
  if (hmm->flags & (1 << 2)) {
#line 403
    tmp___0 = "yes";
  } else {
#line 403
    tmp___0 = "no";
  }
#line 403
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"RF    %s\n", tmp___0);
#line 404
  if (hmm->flags & (1 << 3)) {
#line 404
    tmp___1 = "yes";
  } else {
#line 404
    tmp___1 = "no";
  }
#line 404
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"CS    %s\n", tmp___1);
#line 405
  if (hmm->flags & (1 << 8)) {
#line 405
    tmp___2 = "yes";
  } else {
#line 405
    tmp___2 = "no";
  }
#line 405
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"MAP   %s\n", tmp___2);
#line 406
  multiline(fp, (char *)"COM   ", hmm->comlog);
#line 407
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"NSEQ  %d\n", hmm->nseq);
#line 408
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"DATE  %s\n", hmm->ctime);
#line 409
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"CKSUM %d\n", hmm->checksum);
#line 410
  if (hmm->flags & (1 << 10)) {
#line 411
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"GA    %.1f %.1f\n",
            (double )hmm->ga1, (double )hmm->ga2);
  }
#line 412
  if (hmm->flags & (1 << 11)) {
#line 413
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"TC    %.1f %.1f\n",
            (double )hmm->tc1, (double )hmm->tc2);
  }
#line 414
  if (hmm->flags & (1 << 12)) {
#line 415
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"NC    %.1f %.1f\n",
            (double )hmm->nc1, (double )hmm->nc2);
  }
#line 419
  fputs((char const   * __restrict  )"XT     ", (FILE * __restrict  )fp);
#line 420
  k = 0;
#line 420
  while (k < 4) {
#line 421
    x = 0;
#line 421
    while (x < 2) {
#line 422
      tmp___3 = prob2ascii(hmm->xt[k][x], (float )1.0);
#line 422
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___3);
#line 421
      x ++;
    }
#line 420
    k ++;
  }
#line 423
  fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 429
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"NULT  ");
#line 430
  tmp___4 = prob2ascii(hmm->p1, (float )1.0);
#line 430
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___4);
#line 431
  tmp___5 = prob2ascii((float )(1.0 - (double )hmm->p1), (float )1.0);
#line 431
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s\n", tmp___5);
#line 432
  fputs((char const   * __restrict  )"NULE  ", (FILE * __restrict  )fp);
#line 433
  x = 0;
#line 433
  while (x < Alphabet_size) {
#line 434
    tmp___6 = prob2ascii(hmm->null[x], (float )1 / (float )Alphabet_size);
#line 434
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___6);
#line 433
    x ++;
  }
#line 435
  fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 439
  if (hmm->flags & (1 << 7)) {
#line 440
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"EVD   %10f %10f\n",
            (double )hmm->mu, (double )hmm->lambda);
  }
#line 444
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"HMM      ");
#line 445
  x = 0;
#line 445
  while (x < Alphabet_size) {
#line 445
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %c    ", (int )Alphabet[x]);
#line 445
    x ++;
  }
#line 446
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 447
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"       %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
          "m->m", "m->i", "m->d", "i->m", "i->i", "d->m", "d->d", "b->m", "m->e");
#line 452
  tmp___7 = prob2ascii((float )1 - hmm->tbd1, (float )1.0);
#line 452
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"       %6s %6s ",
          tmp___7, "*");
#line 453
  tmp___8 = prob2ascii(hmm->tbd1, (float )1.0);
#line 453
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s\n", tmp___8);
#line 454
  k = 1;
#line 454
  while (k <= hmm->M) {
#line 457
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d ", k);
#line 458
    x = 0;
#line 458
    while (x < Alphabet_size) {
#line 459
      tmp___9 = prob2ascii(*(*(hmm->mat + k) + x), hmm->null[x]);
#line 459
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___9);
#line 458
      x ++;
    }
#line 460
    if (hmm->flags & (1 << 8)) {
#line 460
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d", *(hmm->map + k));
    }
#line 461
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 463
    if (hmm->flags & (1 << 2)) {
#line 463
      tmp___10 = (int )*(hmm->rf + k);
    } else {
#line 463
      tmp___10 = '-';
    }
#line 463
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5c ", tmp___10);
#line 464
    x = 0;
#line 464
    while (x < Alphabet_size) {
#line 465
      if (k < hmm->M) {
#line 465
        tmp___11 = prob2ascii(*(*(hmm->ins + k) + x), hmm->null[x]);
#line 465
        tmp___12 = (char const   *)tmp___11;
      } else {
#line 465
        tmp___12 = "*";
      }
#line 465
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___12);
#line 464
      x ++;
    }
#line 466
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 468
    if (hmm->flags & (1 << 3)) {
#line 468
      tmp___13 = (int )*(hmm->cs + k);
    } else {
#line 468
      tmp___13 = '-';
    }
#line 468
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5c ", tmp___13);
#line 469
    ts = 0;
#line 469
    while (ts < 7) {
#line 470
      if (k < hmm->M) {
#line 470
        tmp___14 = prob2ascii(*(*(hmm->t + k) + ts), (float )1.0);
#line 470
        tmp___15 = (char const   *)tmp___14;
      } else {
#line 470
        tmp___15 = "*";
      }
#line 470
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___15);
#line 469
      ts ++;
    }
#line 471
    tmp___16 = prob2ascii(*(hmm->begin + k), (float )1.0);
#line 471
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___16);
#line 472
    tmp___17 = prob2ascii(*(hmm->end + k), (float )1.0);
#line 472
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s ", tmp___17);
#line 474
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )fp);
#line 454
    k ++;
  }
#line 476
  fputs((char const   * __restrict  )"//\n", (FILE * __restrict  )fp);
#line 477
  return;
}
}
#line 483 "hmmio.c"
void WriteBinHMM(FILE *fp , struct plan7_s *hmm ) 
{ 
  int k ;

  {
#line 489
  fwrite((void const   * __restrict  )((char *)(& v20magic)), sizeof(unsigned int ),
         (size_t )1, (FILE * __restrict  )fp);
#line 493
  fwrite((void const   * __restrict  )((char *)(& hmm->flags)), sizeof(int ), (size_t )1,
         (FILE * __restrict  )fp);
#line 494
  write_bin_string(fp, hmm->name);
#line 495
  if (hmm->flags & (1 << 9)) {
#line 495
    write_bin_string(fp, hmm->acc);
  }
#line 496
  if (hmm->flags & (1 << 1)) {
#line 496
    write_bin_string(fp, hmm->desc);
  }
#line 497
  fwrite((void const   * __restrict  )((char *)(& hmm->M)), sizeof(int ), (size_t )1,
         (FILE * __restrict  )fp);
#line 498
  fwrite((void const   * __restrict  )((char *)(& Alphabet_type)), sizeof(int ), (size_t )1,
         (FILE * __restrict  )fp);
#line 499
  if (hmm->flags & (1 << 2)) {
#line 499
    fwrite((void const   * __restrict  )hmm->rf, sizeof(char ), (size_t )(hmm->M + 1),
           (FILE * __restrict  )fp);
  }
#line 500
  if (hmm->flags & (1 << 3)) {
#line 500
    fwrite((void const   * __restrict  )hmm->cs, sizeof(char ), (size_t )(hmm->M + 1),
           (FILE * __restrict  )fp);
  }
#line 501
  if (hmm->flags & (1 << 8)) {
#line 501
    fwrite((void const   * __restrict  )((char *)hmm->map), sizeof(int ), (size_t )(hmm->M + 1),
           (FILE * __restrict  )fp);
  }
#line 502
  write_bin_string(fp, hmm->comlog);
#line 503
  fwrite((void const   * __restrict  )((char *)(& hmm->nseq)), sizeof(int ), (size_t )1,
         (FILE * __restrict  )fp);
#line 504
  write_bin_string(fp, hmm->ctime);
#line 505
  fwrite((void const   * __restrict  )((char *)(& hmm->checksum)), sizeof(int ), (size_t )1,
         (FILE * __restrict  )fp);
#line 506
  if (hmm->flags & (1 << 10)) {
#line 507
    fwrite((void const   * __restrict  )((char *)(& hmm->ga1)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
#line 508
    fwrite((void const   * __restrict  )((char *)(& hmm->ga2)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
  }
#line 510
  if (hmm->flags & (1 << 11)) {
#line 511
    fwrite((void const   * __restrict  )((char *)(& hmm->tc1)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
#line 512
    fwrite((void const   * __restrict  )((char *)(& hmm->tc2)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
  }
#line 514
  if (hmm->flags & (1 << 12)) {
#line 515
    fwrite((void const   * __restrict  )((char *)(& hmm->nc1)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
#line 516
    fwrite((void const   * __restrict  )((char *)(& hmm->nc2)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
  }
#line 520
  k = 0;
#line 520
  while (k < 4) {
#line 521
    fwrite((void const   * __restrict  )((char *)(hmm->xt[k])), sizeof(float ), (size_t )2,
           (FILE * __restrict  )fp);
#line 520
    k ++;
  }
#line 524
  fwrite((void const   * __restrict  )((char *)(& hmm->p1)), sizeof(float ), (size_t )1,
         (FILE * __restrict  )fp);
#line 525
  fwrite((void const   * __restrict  )((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
         (FILE * __restrict  )fp);
#line 528
  if (hmm->flags & (1 << 7)) {
#line 529
    fwrite((void const   * __restrict  )((char *)(& hmm->mu)), sizeof(float ), (size_t )1,
           (FILE * __restrict  )fp);
#line 530
    fwrite((void const   * __restrict  )((char *)(& hmm->lambda)), sizeof(float ),
           (size_t )1, (FILE * __restrict  )fp);
  }
#line 535
  fwrite((void const   * __restrict  )((char *)(& hmm->tbd1)), sizeof(float ), (size_t )1,
         (FILE * __restrict  )fp);
#line 536
  fwrite((void const   * __restrict  )((char *)hmm->begin), sizeof(float ), (size_t )(hmm->M + 1),
         (FILE * __restrict  )fp);
#line 537
  fwrite((void const   * __restrict  )((char *)hmm->end), sizeof(float ), (size_t )(hmm->M + 1),
         (FILE * __restrict  )fp);
#line 541
  k = 1;
#line 541
  while (k <= hmm->M) {
#line 542
    fwrite((void const   * __restrict  )((char *)*(hmm->mat + k)), sizeof(float ),
           (size_t )Alphabet_size, (FILE * __restrict  )fp);
#line 541
    k ++;
  }
#line 543
  k = 1;
#line 543
  while (k < hmm->M) {
#line 544
    fwrite((void const   * __restrict  )((char *)*(hmm->ins + k)), sizeof(float ),
           (size_t )Alphabet_size, (FILE * __restrict  )fp);
#line 543
    k ++;
  }
#line 545
  k = 1;
#line 545
  while (k < hmm->M) {
#line 546
    fwrite((void const   * __restrict  )((char *)*(hmm->t + k)), sizeof(float ), (size_t )7,
           (FILE * __restrict  )fp);
#line 545
    k ++;
  }
#line 547
  return;
}
}
#line 566 "hmmio.c"
static int read_asc20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  char buffer___1[512] ;
  char *s___0 ;
  int M ;
  float p ;
  int k ;
  int x ;
  int atype ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  float tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 577
  hmm = (struct plan7_s *)((void *)0);
#line 578
  tmp = feof(hmmfp->f);
#line 578
  if (tmp) {
#line 578
    return (0);
  } else {
#line 578
    tmp___0 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 578
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 578
      return (0);
    }
  }
#line 579
  tmp___1 = strncmp((char const   *)(buffer___1), "HMMER2.0", (size_t )8);
#line 579
  if (tmp___1 != 0) {
#line 579
    goto FAILURE;
  }
#line 585
  hmm = AllocPlan7Shell();
#line 586
  M = -1;
#line 587
  while (1) {
#line 587
    tmp___41 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 587
    if (! ((unsigned long )tmp___41 != (unsigned long )((void *)0))) {
#line 587
      break;
    }
#line 588
    tmp___40 = strncmp((char const   *)(buffer___1), "NAME ", (size_t )5);
#line 588
    if (tmp___40 == 0) {
#line 588
      Plan7SetName(hmm, buffer___1 + 6);
    } else {
#line 589
      tmp___39 = strncmp((char const   *)(buffer___1), "ACC  ", (size_t )5);
#line 589
      if (tmp___39 == 0) {
#line 589
        Plan7SetAccession(hmm, buffer___1 + 6);
      } else {
#line 590
        tmp___38 = strncmp((char const   *)(buffer___1), "DESC ", (size_t )5);
#line 590
        if (tmp___38 == 0) {
#line 590
          Plan7SetDescription(hmm, buffer___1 + 6);
        } else {
#line 591
          tmp___37 = strncmp((char const   *)(buffer___1), "LENG ", (size_t )5);
#line 591
          if (tmp___37 == 0) {
#line 591
            M = atoi((char const   *)(buffer___1 + 6));
          } else {
#line 592
            tmp___36 = strncmp((char const   *)(buffer___1), "NSEQ ", (size_t )5);
#line 592
            if (tmp___36 == 0) {
#line 592
              hmm->nseq = atoi((char const   *)(buffer___1 + 6));
            } else {
#line 593
              tmp___35 = strncmp((char const   *)(buffer___1), "ALPH ", (size_t )5);
#line 593
              if (tmp___35 == 0) {
#line 595
                s2upper(buffer___1 + 6);
#line 596
                tmp___3 = strncmp((char const   *)(buffer___1 + 6), "AMINO", (size_t )5);
#line 596
                if (tmp___3 == 0) {
#line 596
                  atype = 3;
                } else {
#line 597
                  tmp___2 = strncmp((char const   *)(buffer___1 + 6), "NUCLEIC", (size_t )7);
#line 597
                  if (tmp___2 == 0) {
#line 597
                    atype = 2;
                  } else {
#line 598
                    goto FAILURE;
                  }
                }
#line 600
                if (Alphabet_type == 0) {
#line 600
                  SetAlphabet(atype);
                } else
#line 601
                if (atype != Alphabet_type) {
#line 602
                  tmp___4 = AlphabetType2String(atype);
#line 602
                  tmp___5 = AlphabetType2String(Alphabet_type);
#line 602
                  Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
                      tmp___5, tmp___4);
                }
              } else {
#line 604
                tmp___34 = strncmp((char const   *)(buffer___1), "RF   ", (size_t )5);
#line 604
                if (tmp___34 == 0) {
#line 606
                  tmp___6 = sre_toupper((int )*(buffer___1 + 6));
#line 606
                  if (tmp___6 == 89) {
#line 606
                    hmm->flags |= 1 << 2;
                  }
                } else {
#line 608
                  tmp___33 = strncmp((char const   *)(buffer___1), "CS   ", (size_t )5);
#line 608
                  if (tmp___33 == 0) {
#line 610
                    tmp___7 = sre_toupper((int )*(buffer___1 + 6));
#line 610
                    if (tmp___7 == 89) {
#line 610
                      hmm->flags |= 1 << 3;
                    }
                  } else {
#line 612
                    tmp___32 = strncmp((char const   *)(buffer___1), "MAP  ", (size_t )5);
#line 612
                    if (tmp___32 == 0) {
#line 614
                      tmp___8 = sre_toupper((int )*(buffer___1 + 6));
#line 614
                      if (tmp___8 == 89) {
#line 614
                        hmm->flags |= 1 << 8;
                      }
                    } else {
#line 616
                      tmp___31 = strncmp((char const   *)(buffer___1), "COM  ", (size_t )5);
#line 616
                      if (tmp___31 == 0) {
#line 618
                        StringChop(buffer___1 + 6);
#line 619
                        if ((unsigned long )hmm->comlog == (unsigned long )((void *)0)) {
#line 620
                          hmm->comlog = Strdup(buffer___1 + 6);
                        } else {
#line 623
                          tmp___9 = strlen((char const   *)hmm->comlog);
#line 623
                          tmp___10 = strlen((char const   *)(buffer___1 + 6));
#line 623
                          tmp___11 = sre_realloc((char *)"hmmio.c", 624, (void *)hmm->comlog,
                                                 sizeof(char *) * ((tmp___9 + 1UL) + tmp___10));
#line 623
                          hmm->comlog = (char *)tmp___11;
#line 625
                          strcat((char * __restrict  )hmm->comlog, (char const   * __restrict  )"\n");
#line 626
                          strcat((char * __restrict  )hmm->comlog, (char const   * __restrict  )(buffer___1 + 6));
                        }
                      } else {
#line 629
                        tmp___30 = strncmp((char const   *)(buffer___1), "DATE ",
                                           (size_t )5);
#line 629
                        if (tmp___30 == 0) {
#line 631
                          StringChop(buffer___1 + 6);
#line 632
                          hmm->ctime = Strdup(buffer___1 + 6);
                        } else {
#line 634
                          tmp___29 = strncmp((char const   *)(buffer___1), "GA   ",
                                             (size_t )5);
#line 634
                          if (tmp___29 == 0) {
#line 636
                            s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                           (char const   * __restrict  )" \t\n");
#line 636
                            if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 636
                              goto FAILURE;
                            }
#line 637
                            tmp___12 = atof((char const   *)s___0);
#line 637
                            hmm->ga1 = (float )tmp___12;
#line 638
                            s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 638
                            if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 638
                              goto FAILURE;
                            }
#line 639
                            tmp___13 = atof((char const   *)s___0);
#line 639
                            hmm->ga2 = (float )tmp___13;
#line 640
                            hmm->flags |= 1 << 10;
                          } else {
#line 642
                            tmp___28 = strncmp((char const   *)(buffer___1), "TC   ",
                                               (size_t )5);
#line 642
                            if (tmp___28 == 0) {
#line 644
                              s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                             (char const   * __restrict  )" \t\n");
#line 644
                              if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 644
                                goto FAILURE;
                              }
#line 645
                              tmp___14 = atof((char const   *)s___0);
#line 645
                              hmm->tc1 = (float )tmp___14;
#line 646
                              s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 646
                              if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 646
                                goto FAILURE;
                              }
#line 647
                              tmp___15 = atof((char const   *)s___0);
#line 647
                              hmm->tc2 = (float )tmp___15;
#line 648
                              hmm->flags |= 1 << 11;
                            } else {
#line 650
                              tmp___27 = strncmp((char const   *)(buffer___1), "NC   ",
                                                 (size_t )5);
#line 650
                              if (tmp___27 == 0) {
#line 652
                                s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                               (char const   * __restrict  )" \t\n");
#line 652
                                if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 652
                                  goto FAILURE;
                                }
#line 653
                                tmp___16 = atof((char const   *)s___0);
#line 653
                                hmm->nc1 = (float )tmp___16;
#line 654
                                s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 654
                                if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 654
                                  goto FAILURE;
                                }
#line 655
                                tmp___17 = atof((char const   *)s___0);
#line 655
                                hmm->nc2 = (float )tmp___17;
#line 656
                                hmm->flags |= 1 << 12;
                              } else {
#line 658
                                tmp___26 = strncmp((char const   *)(buffer___1), "XT   ",
                                                   (size_t )5);
#line 658
                                if (tmp___26 == 0) {
#line 660
                                  s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                                 (char const   * __restrict  )" \t\n");
#line 660
                                  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 660
                                    goto FAILURE;
                                  }
#line 661
                                  k = 0;
#line 661
                                  while (k < 4) {
#line 662
                                    x = 0;
#line 662
                                    while (x < 2) {
#line 664
                                      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 664
                                        goto FAILURE;
                                      }
#line 665
                                      hmm->xt[k][x] = ascii2prob(s___0, (float )1.0);
#line 666
                                      s___0 = strtok((char * __restrict  )((void *)0),
                                                     (char const   * __restrict  )" \t\n");
#line 662
                                      x ++;
                                    }
#line 661
                                    k ++;
                                  }
                                } else {
#line 669
                                  tmp___25 = strncmp((char const   *)(buffer___1),
                                                     "NULT ", (size_t )5);
#line 669
                                  if (tmp___25 == 0) {
#line 671
                                    s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                                   (char const   * __restrict  )" \t\n");
#line 671
                                    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 671
                                      goto FAILURE;
                                    }
#line 672
                                    hmm->p1 = ascii2prob(s___0, (float )1.);
#line 673
                                    s___0 = strtok((char * __restrict  )((void *)0),
                                                   (char const   * __restrict  )" \t\n");
#line 673
                                    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 673
                                      goto FAILURE;
                                    }
#line 674
                                    tmp___18 = ascii2prob(s___0, (float )1.0);
#line 674
                                    hmm->p1 /= hmm->p1 + tmp___18;
                                  } else {
#line 676
                                    tmp___24 = strncmp((char const   *)(buffer___1),
                                                       "NULE ", (size_t )5);
#line 676
                                    if (tmp___24 == 0) {
#line 678
                                      if (Alphabet_type == 0) {
#line 679
                                        Die((char *)"ALPH must precede NULE in HMM save files");
                                      }
#line 680
                                      s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                                     (char const   * __restrict  )" \t\n");
#line 681
                                      x = 0;
#line 681
                                      while (x < Alphabet_size) {
#line 682
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 682
                                          goto FAILURE;
                                        }
#line 683
                                        hmm->null[x] = ascii2prob(s___0, (float )(1. / (double )((float )Alphabet_size)));
#line 684
                                        s___0 = strtok((char * __restrict  )((void *)0),
                                                       (char const   * __restrict  )" \t\n");
#line 681
                                        x ++;
                                      }
                                    } else {
#line 687
                                      tmp___23 = strncmp((char const   *)(buffer___1),
                                                         "EVD  ", (size_t )5);
#line 687
                                      if (tmp___23 == 0) {
#line 689
                                        hmm->flags |= 1 << 7;
#line 690
                                        s___0 = strtok((char * __restrict  )(buffer___1 + 6),
                                                       (char const   * __restrict  )" \t\n");
#line 690
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 690
                                          goto FAILURE;
                                        }
#line 691
                                        tmp___19 = atof((char const   *)s___0);
#line 691
                                        hmm->mu = (float )tmp___19;
#line 692
                                        s___0 = strtok((char * __restrict  )((void *)0),
                                                       (char const   * __restrict  )" \t\n");
#line 692
                                        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 692
                                          goto FAILURE;
                                        }
#line 693
                                        tmp___20 = atof((char const   *)s___0);
#line 693
                                        hmm->lambda = (float )tmp___20;
                                      } else {
#line 695
                                        tmp___22 = strncmp((char const   *)(buffer___1),
                                                           "CKSUM", (size_t )5);
#line 695
                                        if (tmp___22 == 0) {
#line 695
                                          hmm->checksum = atoi((char const   *)(buffer___1 + 6));
                                        } else {
#line 696
                                          tmp___21 = strncmp((char const   *)(buffer___1),
                                                             "HMM  ", (size_t )5);
#line 696
                                          if (tmp___21 == 0) {
#line 696
                                            break;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 700
  tmp___42 = feof(hmmfp->f);
#line 700
  if (tmp___42) {
#line 700
    goto FAILURE;
  }
#line 701
  if (M < 1) {
#line 701
    goto FAILURE;
  }
#line 702
  if ((unsigned long )hmm->name == (unsigned long )((void *)0)) {
#line 702
    goto FAILURE;
  }
#line 703
  if (Alphabet_type == 0) {
#line 703
    goto FAILURE;
  }
#line 708
  AllocPlan7Body(hmm, M);
#line 710
  tmp___43 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 710
  if ((unsigned long )tmp___43 == (unsigned long )((void *)0)) {
#line 710
    goto FAILURE;
  }
#line 712
  tmp___44 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 712
  if ((unsigned long )tmp___44 == (unsigned long )((void *)0)) {
#line 712
    goto FAILURE;
  }
#line 713
  s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 713
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 713
    goto FAILURE;
  }
#line 714
  p = ascii2prob(s___0, (float )1.0);
#line 715
  s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 715
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 715
    goto FAILURE;
  }
#line 716
  s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 716
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 716
    goto FAILURE;
  }
#line 717
  hmm->tbd1 = ascii2prob(s___0, (float )1.0);
#line 718
  hmm->tbd1 /= p + hmm->tbd1;
#line 721
  k = 1;
#line 721
  while (k <= hmm->M) {
#line 723
    tmp___45 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 723
    if ((unsigned long )tmp___45 == (unsigned long )((void *)0)) {
#line 723
      goto FAILURE;
    }
#line 724
    s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 724
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 724
      goto FAILURE;
    }
#line 725
    tmp___46 = atoi((char const   *)s___0);
#line 725
    if (tmp___46 != k) {
#line 725
      goto FAILURE;
    }
#line 726
    x = 0;
#line 726
    while (x < Alphabet_size) {
#line 727
      s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 727
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 727
        goto FAILURE;
      }
#line 728
      *(*(hmm->mat + k) + x) = ascii2prob(s___0, hmm->null[x]);
#line 726
      x ++;
    }
#line 730
    if (hmm->flags & (1 << 8)) {
#line 731
      s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 731
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 731
        goto FAILURE;
      }
#line 732
      *(hmm->map + k) = atoi((char const   *)s___0);
    }
#line 735
    tmp___47 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 735
    if ((unsigned long )tmp___47 == (unsigned long )((void *)0)) {
#line 735
      goto FAILURE;
    }
#line 736
    s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 736
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 736
      goto FAILURE;
    }
#line 737
    if (hmm->flags & (1 << 2)) {
#line 737
      *(hmm->rf + k) = *s___0;
    }
#line 738
    if (k < hmm->M) {
#line 739
      x = 0;
#line 739
      while (x < Alphabet_size) {
#line 740
        s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 740
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 740
          goto FAILURE;
        }
#line 741
        *(*(hmm->ins + k) + x) = ascii2prob(s___0, hmm->null[x]);
#line 739
        x ++;
      }
    }
#line 745
    tmp___48 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 745
    if ((unsigned long )tmp___48 == (unsigned long )((void *)0)) {
#line 745
      goto FAILURE;
    }
#line 746
    s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 746
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 746
      goto FAILURE;
    }
#line 747
    if (hmm->flags & (1 << 3)) {
#line 747
      *(hmm->cs + k) = *s___0;
    }
#line 748
    x = 0;
#line 748
    while (x < 7) {
#line 749
      s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 749
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 749
        goto FAILURE;
      }
#line 750
      if (k < hmm->M) {
#line 750
        *(*(hmm->t + k) + x) = ascii2prob(s___0, (float )1.0);
      }
#line 748
      x ++;
    }
#line 752
    s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 752
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 752
      goto FAILURE;
    }
#line 753
    *(hmm->begin + k) = ascii2prob(s___0, (float )1.0);
#line 754
    s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 754
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 754
      goto FAILURE;
    }
#line 755
    *(hmm->end + k) = ascii2prob(s___0, (float )1.0);
#line 721
    k ++;
  }
#line 761
  while (1) {
#line 761
    tmp___50 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 761
    if (! ((unsigned long )tmp___50 != (unsigned long )((void *)0))) {
#line 761
      break;
    }
#line 762
    tmp___49 = strncmp((char const   *)(buffer___1), "//", (size_t )2);
#line 762
    if (tmp___49 == 0) {
#line 762
      break;
    }
  }
#line 764
  Plan7Renormalize(hmm);
#line 768
  hmm->flags |= 1 << 5;
#line 769
  hmm->flags &= -2;
#line 771
  *ret_hmm = hmm;
#line 772
  return (1);
  FAILURE: 
#line 775
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
#line 775
    FreePlan7(hmm);
  }
#line 776
  *ret_hmm = (struct plan7_s *)((void *)0);
#line 777
  return (1);
}
}
#line 781 "hmmio.c"
static int read_bin20hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  int k ;
  int x ;
  int type ;
  unsigned int magic ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;

  {
#line 789
  hmm = (struct plan7_s *)((void *)0);
#line 793
  tmp = feof(hmmfp->f);
#line 793
  if (tmp) {
#line 793
    return (0);
  }
#line 794
  tmp___0 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 794
  if (! tmp___0) {
#line 794
    return (0);
  }
#line 796
  if (hmmfp->byteswap) {
#line 796
    byteswap((char *)(& magic), (int )sizeof(unsigned int ));
  }
#line 797
  if (magic != v20magic) {
#line 797
    goto FAILURE;
  }
#line 799
  hmm = AllocPlan7Shell();
#line 801
  tmp___1 = fread((void * __restrict  )((char *)(& hmm->flags)), sizeof(int ), (size_t )1,
                  (FILE * __restrict  )hmmfp->f);
#line 801
  if (! tmp___1) {
#line 801
    goto FAILURE;
  }
#line 802
  if (hmmfp->byteswap) {
#line 802
    byteswap((char *)(& hmm->flags), (int )sizeof(int ));
  }
#line 804
  tmp___2 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->name);
#line 804
  if (! tmp___2) {
#line 804
    goto FAILURE;
  }
#line 807
  if (hmm->flags & (1 << 9)) {
#line 807
    tmp___3 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->acc);
#line 807
    if (! tmp___3) {
#line 808
      goto FAILURE;
    }
  }
#line 810
  if (hmm->flags & (1 << 1)) {
#line 810
    tmp___4 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->desc);
#line 810
    if (! tmp___4) {
#line 811
      goto FAILURE;
    }
  }
#line 813
  tmp___5 = fread((void * __restrict  )((char *)(& hmm->M)), sizeof(int ), (size_t )1,
                  (FILE * __restrict  )hmmfp->f);
#line 813
  if (! tmp___5) {
#line 813
    goto FAILURE;
  }
#line 814
  if (hmmfp->byteswap) {
#line 814
    byteswap((char *)(& hmm->M), (int )sizeof(int ));
  }
#line 816
  tmp___6 = fread((void * __restrict  )((char *)(& type)), sizeof(int ), (size_t )1,
                  (FILE * __restrict  )hmmfp->f);
#line 816
  if (! tmp___6) {
#line 816
    goto FAILURE;
  }
#line 817
  if (hmmfp->byteswap) {
#line 817
    byteswap((char *)(& type), (int )sizeof(int ));
  }
#line 818
  if (Alphabet_type == 0) {
#line 818
    SetAlphabet(type);
  } else
#line 819
  if (type != Alphabet_type) {
#line 820
    tmp___7 = AlphabetType2String(type);
#line 820
    tmp___8 = AlphabetType2String(Alphabet_type);
#line 820
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___8, tmp___7);
  }
#line 823
  AllocPlan7Body(hmm, hmm->M);
#line 826
  if (hmm->flags & (1 << 2)) {
#line 826
    tmp___9 = fread((void * __restrict  )hmm->rf, sizeof(char ), (size_t )(hmm->M + 1),
                    (FILE * __restrict  )hmmfp->f);
#line 826
    if (! tmp___9) {
#line 827
      goto FAILURE;
    }
  }
#line 828
  *(hmm->rf + (hmm->M + 1)) = (char )'\000';
#line 830
  if (hmm->flags & (1 << 3)) {
#line 830
    tmp___10 = fread((void * __restrict  )hmm->cs, sizeof(char ), (size_t )(hmm->M + 1),
                     (FILE * __restrict  )hmmfp->f);
#line 830
    if (! tmp___10) {
#line 831
      goto FAILURE;
    }
  }
#line 832
  *(hmm->cs + (hmm->M + 1)) = (char )'\000';
#line 834
  if (hmm->flags & (1 << 8)) {
#line 834
    tmp___11 = fread((void * __restrict  )((char *)hmm->map), sizeof(int ), (size_t )(hmm->M + 1),
                     (FILE * __restrict  )hmmfp->f);
#line 834
    if (! tmp___11) {
#line 835
      goto FAILURE;
    }
  }
#line 836
  if (hmmfp->byteswap) {
#line 837
    k = 1;
#line 837
    while (k <= hmm->M) {
#line 838
      byteswap((char *)(hmm->map + k), (int )sizeof(int ));
#line 837
      k ++;
    }
  }
#line 840
  tmp___12 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->comlog);
#line 840
  if (! tmp___12) {
#line 840
    goto FAILURE;
  }
#line 842
  tmp___13 = fread((void * __restrict  )((char *)(& hmm->nseq)), sizeof(int ), (size_t )1,
                   (FILE * __restrict  )hmmfp->f);
#line 842
  if (! tmp___13) {
#line 842
    goto FAILURE;
  }
#line 843
  if (hmmfp->byteswap) {
#line 843
    byteswap((char *)(& hmm->nseq), (int )sizeof(int ));
  }
#line 845
  tmp___14 = read_bin_string(hmmfp->f, hmmfp->byteswap, & hmm->ctime);
#line 845
  if (! tmp___14) {
#line 845
    goto FAILURE;
  }
#line 847
  tmp___15 = fread((void * __restrict  )((char *)(& hmm->checksum)), sizeof(int ),
                   (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 847
  if (! tmp___15) {
#line 847
    goto FAILURE;
  }
#line 848
  if (hmmfp->byteswap) {
#line 848
    byteswap((char *)(& hmm->checksum), (int )sizeof(int ));
  }
#line 851
  if (hmm->flags & (1 << 10)) {
#line 852
    tmp___16 = fread((void * __restrict  )((char *)(& hmm->ga1)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 852
    if (! tmp___16) {
#line 852
      goto FAILURE;
    }
#line 853
    tmp___17 = fread((void * __restrict  )((char *)(& hmm->ga2)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 853
    if (! tmp___17) {
#line 853
      goto FAILURE;
    }
#line 854
    if (hmmfp->byteswap) {
#line 855
      byteswap((char *)(& hmm->ga1), (int )sizeof(float ));
#line 856
      byteswap((char *)(& hmm->ga2), (int )sizeof(float ));
    }
  }
#line 860
  if (hmm->flags & (1 << 11)) {
#line 861
    tmp___18 = fread((void * __restrict  )((char *)(& hmm->tc1)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 861
    if (! tmp___18) {
#line 861
      goto FAILURE;
    }
#line 862
    tmp___19 = fread((void * __restrict  )((char *)(& hmm->tc2)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 862
    if (! tmp___19) {
#line 862
      goto FAILURE;
    }
#line 863
    if (hmmfp->byteswap) {
#line 864
      byteswap((char *)(& hmm->tc1), (int )sizeof(float ));
#line 865
      byteswap((char *)(& hmm->tc2), (int )sizeof(float ));
    }
  }
#line 869
  if (hmm->flags & (1 << 12)) {
#line 870
    tmp___20 = fread((void * __restrict  )((char *)(& hmm->nc1)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 870
    if (! tmp___20) {
#line 870
      goto FAILURE;
    }
#line 871
    tmp___21 = fread((void * __restrict  )((char *)(& hmm->nc2)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 871
    if (! tmp___21) {
#line 871
      goto FAILURE;
    }
#line 872
    if (hmmfp->byteswap) {
#line 873
      byteswap((char *)(& hmm->nc1), (int )sizeof(float ));
#line 874
      byteswap((char *)(& hmm->nc2), (int )sizeof(float ));
    }
  }
#line 879
  k = 0;
#line 879
  while (k < 4) {
#line 881
    tmp___22 = fread((void * __restrict  )((char *)(hmm->xt[k])), sizeof(float ),
                     (size_t )2, (FILE * __restrict  )hmmfp->f);
#line 881
    if (! tmp___22) {
#line 881
      goto FAILURE;
    }
#line 882
    if (hmmfp->byteswap) {
#line 883
      x = 0;
#line 883
      while (x < 2) {
#line 884
        byteswap((char *)(& hmm->xt[k][x]), (int )sizeof(float ));
#line 883
        x ++;
      }
    }
#line 879
    k ++;
  }
#line 889
  tmp___23 = fread((void * __restrict  )((char *)(& hmm->p1)), sizeof(float ), (size_t )1,
                   (FILE * __restrict  )hmmfp->f);
#line 889
  if (! tmp___23) {
#line 889
    goto FAILURE;
  }
#line 890
  tmp___24 = fread((void * __restrict  )((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
                   (FILE * __restrict  )hmmfp->f);
#line 890
  if (! tmp___24) {
#line 890
    goto FAILURE;
  }
#line 893
  if (hmm->flags & (1 << 7)) {
#line 894
    tmp___25 = fread((void * __restrict  )((char *)(& hmm->mu)), sizeof(float ), (size_t )1,
                     (FILE * __restrict  )hmmfp->f);
#line 894
    if (! tmp___25) {
#line 894
      goto FAILURE;
    }
#line 895
    tmp___26 = fread((void * __restrict  )((char *)(& hmm->lambda)), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 895
    if (! tmp___26) {
#line 895
      goto FAILURE;
    }
#line 897
    if (hmmfp->byteswap) {
#line 898
      byteswap((char *)(& hmm->mu), (int )sizeof(float ));
#line 899
      byteswap((char *)(& hmm->lambda), (int )sizeof(float ));
    }
  }
#line 905
  tmp___27 = fread((void * __restrict  )((char *)(& hmm->tbd1)), sizeof(float ), (size_t )1,
                   (FILE * __restrict  )hmmfp->f);
#line 905
  if (! tmp___27) {
#line 905
    goto FAILURE;
  }
#line 906
  tmp___28 = fread((void * __restrict  )((char *)hmm->begin), sizeof(float ), (size_t )(hmm->M + 1),
                   (FILE * __restrict  )hmmfp->f);
#line 906
  if (! tmp___28) {
#line 906
    goto FAILURE;
  }
#line 907
  tmp___29 = fread((void * __restrict  )((char *)hmm->end), sizeof(float ), (size_t )(hmm->M + 1),
                   (FILE * __restrict  )hmmfp->f);
#line 907
  if (! tmp___29) {
#line 907
    goto FAILURE;
  }
#line 910
  k = 1;
#line 910
  while (k <= hmm->M) {
#line 911
    tmp___30 = fread((void * __restrict  )((char *)*(hmm->mat + k)), sizeof(float ),
                     (size_t )Alphabet_size, (FILE * __restrict  )hmmfp->f);
#line 911
    if (! tmp___30) {
#line 911
      goto FAILURE;
    }
#line 910
    k ++;
  }
#line 912
  k = 1;
#line 912
  while (k < hmm->M) {
#line 913
    tmp___31 = fread((void * __restrict  )((char *)*(hmm->ins + k)), sizeof(float ),
                     (size_t )Alphabet_size, (FILE * __restrict  )hmmfp->f);
#line 913
    if (! tmp___31) {
#line 913
      goto FAILURE;
    }
#line 912
    k ++;
  }
#line 914
  k = 1;
#line 914
  while (k < hmm->M) {
#line 915
    tmp___32 = fread((void * __restrict  )((char *)*(hmm->t + k)), sizeof(float ),
                     (size_t )7, (FILE * __restrict  )hmmfp->f);
#line 915
    if (! tmp___32) {
#line 915
      goto FAILURE;
    }
#line 914
    k ++;
  }
#line 919
  if (hmmfp->byteswap) {
#line 920
    x = 0;
#line 920
    while (x < Alphabet_size) {
#line 921
      byteswap((char *)(& hmm->null[x]), (int )sizeof(float ));
#line 920
      x ++;
    }
#line 922
    byteswap((char *)(& hmm->p1), (int )sizeof(float ));
#line 923
    byteswap((char *)(& hmm->tbd1), (int )sizeof(float ));
#line 925
    k = 1;
#line 925
    while (k <= hmm->M) {
#line 927
      x = 0;
#line 927
      while (x < Alphabet_size) {
#line 928
        byteswap((char *)(*(hmm->mat + k) + x), (int )sizeof(float ));
#line 927
        x ++;
      }
#line 929
      if (k < hmm->M) {
#line 930
        x = 0;
#line 930
        while (x < Alphabet_size) {
#line 931
          byteswap((char *)(*(hmm->ins + k) + x), (int )sizeof(float ));
#line 930
          x ++;
        }
      }
#line 932
      byteswap((char *)(hmm->begin + k), (int )sizeof(float ));
#line 933
      byteswap((char *)(hmm->end + k), (int )sizeof(float ));
#line 934
      if (k < hmm->M) {
#line 935
        x = 0;
#line 935
        while (x < 7) {
#line 936
          byteswap((char *)(*(hmm->t + k) + x), (int )sizeof(float ));
#line 935
          x ++;
        }
      }
#line 925
      k ++;
    }
  }
#line 943
  hmm->flags |= 1 << 5;
#line 944
  hmm->flags &= -2;
#line 945
  *ret_hmm = hmm;
#line 946
  return (1);
  FAILURE: 
#line 949
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
#line 949
    FreePlan7(hmm);
  }
#line 950
  *ret_hmm = (struct plan7_s *)((void *)0);
#line 951
  return (1);
}
}
#line 967 "hmmio.c"
static int read_asc19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  FILE *fp ;
  char buffer___1[512] ;
  char *s___0 ;
  int M ;
  int k ;
  int x ;
  int atype ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;

  {
#line 979
  hmm = (struct plan7_s *)((void *)0);
#line 980
  fp = hmmfp->f;
#line 981
  tmp = feof(fp);
#line 981
  if (tmp) {
#line 981
    return (0);
  } else {
#line 981
    tmp___0 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 981
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 981
      return (0);
    }
  }
#line 982
  tmp___1 = strncmp((char const   *)(buffer___1), "HMMER v1.9", (size_t )10);
#line 982
  if (tmp___1 != 0) {
#line 982
    goto FAILURE;
  }
#line 984
  hmm = AllocPlan7Shell();
#line 986
  s___0 = Getword(fp, 1);
#line 986
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 986
    goto FAILURE;
  }
#line 986
  M = atoi((char const   *)s___0);
#line 987
  s___0 = Getword(fp, 1);
#line 987
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 987
    goto FAILURE;
  }
#line 988
  s___0 = Getword(fp, 4);
#line 988
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 988
    goto FAILURE;
  }
#line 988
  Plan7SetName(hmm, s___0);
#line 989
  s___0 = Getword(fp, 4);
#line 989
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 989
    goto FAILURE;
  }
#line 990
  s2upper(s___0);
#line 991
  tmp___3 = strcmp((char const   *)s___0, "AMINO");
#line 991
  if (tmp___3 == 0) {
#line 991
    atype = 3;
  } else {
#line 992
    tmp___2 = strcmp((char const   *)s___0, "NUCLEIC");
#line 992
    if (tmp___2 == 0) {
#line 992
      atype = 2;
    } else {
#line 993
      goto FAILURE;
    }
  }
#line 995
  if (Alphabet_type == 0) {
#line 995
    SetAlphabet(atype);
  } else
#line 996
  if (atype != Alphabet_type) {
#line 997
    tmp___4 = AlphabetType2String(atype);
#line 997
    tmp___5 = AlphabetType2String(Alphabet_type);
#line 997
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___5, tmp___4);
  }
#line 1000
  s___0 = Getword(fp, 4);
#line 1000
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1000
    goto FAILURE;
  }
#line 1001
  tmp___6 = strncmp((char const   *)s___0, (char const   *)(Alphabet), (size_t )Alphabet_size);
#line 1001
  if (tmp___6 != 0) {
#line 1001
    goto FAILURE;
  }
#line 1004
  s___0 = Getword(fp, 4);
#line 1004
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1004
    goto FAILURE;
  }
#line 1005
  tmp___7 = strcmp((char const   *)s___0, "yes");
#line 1005
  if (tmp___7 == 0) {
#line 1005
    hmm->flags |= 1 << 2;
  }
#line 1006
  s___0 = Getword(fp, 4);
#line 1006
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1006
    goto FAILURE;
  }
#line 1007
  tmp___8 = strcmp((char const   *)s___0, "yes");
#line 1007
  if (tmp___8 == 0) {
#line 1007
    hmm->flags |= 1 << 3;
  }
#line 1010
  s___0 = Getword(fp, 4);
#line 1010
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1010
    goto FAILURE;
  }
#line 1011
  tmp___9 = strcmp((char const   *)s___0, "null");
#line 1011
  if (tmp___9 != 0) {
#line 1011
    goto FAILURE;
  }
#line 1012
  x = 0;
#line 1012
  while (x < Alphabet_size) {
#line 1013
    s___0 = Getword(fp, 1);
#line 1013
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1013
      goto FAILURE;
    }
#line 1014
    hmm->null[x] = ascii2prob(s___0, (float )1.0);
#line 1012
    x ++;
  }
#line 1016
  if (Alphabet_type == 3) {
#line 1016
    hmm->p1 = (float )(350. / 351.);
  } else {
#line 1016
    hmm->p1 = (float )(1000. / 1001.);
  }
#line 1020
  tmp___10 = feof(hmmfp->f);
#line 1020
  if (tmp___10) {
#line 1020
    goto FAILURE;
  }
#line 1021
  if (M < 1) {
#line 1021
    goto FAILURE;
  }
#line 1022
  if ((unsigned long )hmm->name == (unsigned long )((void *)0)) {
#line 1022
    goto FAILURE;
  }
#line 1023
  if (Alphabet_type == 0) {
#line 1023
    goto FAILURE;
  }
#line 1028
  AllocPlan7Body(hmm, M);
#line 1029
  ZeroPlan7(hmm);
#line 1030
  Plan7LSConfig(hmm);
#line 1037
  s___0 = Getword(fp, 1);
#line 1037
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1037
    goto FAILURE;
  }
#line 1038
  x = 0;
#line 1038
  while (x < Alphabet_size) {
#line 1039
    s___0 = Getword(fp, 1);
#line 1039
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1039
      goto FAILURE;
    }
#line 1038
    x ++;
  }
#line 1040
  s___0 = Getword(fp, 1);
#line 1040
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1040
    goto FAILURE;
  }
#line 1041
  *(hmm->begin + 1) = ascii2prob(s___0, (float )1.0);
#line 1042
  s___0 = Getword(fp, 1);
#line 1042
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1042
    goto FAILURE;
  }
#line 1043
  hmm->tbd1 = ascii2prob(s___0, (float )1.0);
#line 1045
  *(hmm->begin + 1) /= *(hmm->begin + 1) + hmm->tbd1;
#line 1046
  hmm->tbd1 /= *(hmm->begin + 1) + hmm->tbd1;
#line 1048
  x = 0;
#line 1048
  while (x < 7) {
#line 1049
    s___0 = Getword(fp, 1);
#line 1049
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1049
      goto FAILURE;
    }
#line 1048
    x ++;
  }
#line 1050
  s___0 = Getword(fp, 4);
#line 1050
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1050
    goto FAILURE;
  }
#line 1051
  s___0 = Getword(fp, 4);
#line 1051
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1051
    goto FAILURE;
  }
#line 1054
  k = 1;
#line 1054
  while (k <= hmm->M) {
#line 1057
    s___0 = Getword(fp, 1);
#line 1057
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1057
      goto FAILURE;
    }
#line 1059
    x = 0;
#line 1059
    while (x < Alphabet_size) {
#line 1060
      s___0 = Getword(fp, 1);
#line 1060
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1060
        goto FAILURE;
      }
#line 1061
      *(*(hmm->mat + k) + x) = ascii2prob(s___0, hmm->null[x]);
#line 1059
      x ++;
    }
#line 1064
    s___0 = Getword(fp, 1);
#line 1064
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1064
      goto FAILURE;
    }
#line 1065
    if (k < hmm->M) {
#line 1065
      *(*(hmm->t + k) + 0) = ascii2prob(s___0, (float )1.0);
    }
#line 1066
    s___0 = Getword(fp, 1);
#line 1066
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1066
      goto FAILURE;
    }
#line 1067
    if (k < hmm->M) {
#line 1067
      if (k == hmm->M) {
#line 1067
        *(*(hmm->t + k) + 2) = (float )0.0;
      } else {
#line 1067
        tmp___11 = ascii2prob(s___0, (float )1.0);
#line 1067
        *(*(hmm->t + k) + 2) = tmp___11;
      }
    }
#line 1068
    s___0 = Getword(fp, 1);
#line 1068
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1068
      goto FAILURE;
    }
#line 1069
    if (k < hmm->M) {
#line 1069
      *(*(hmm->t + k) + 1) = ascii2prob(s___0, (float )1.0);
    }
#line 1071
    s___0 = Getword(fp, 1);
#line 1071
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1071
      goto FAILURE;
    }
#line 1072
    if (k < hmm->M) {
#line 1072
      *(*(hmm->t + k) + 5) = ascii2prob(s___0, (float )1.0);
    }
#line 1073
    s___0 = Getword(fp, 1);
#line 1073
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1073
      goto FAILURE;
    }
#line 1074
    if (k < hmm->M) {
#line 1074
      if (k == hmm->M) {
#line 1074
        *(*(hmm->t + k) + 6) = (float )0.0;
      } else {
#line 1074
        tmp___12 = ascii2prob(s___0, (float )1.0);
#line 1074
        *(*(hmm->t + k) + 6) = tmp___12;
      }
    }
#line 1075
    s___0 = Getword(fp, 1);
#line 1075
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1075
      goto FAILURE;
    }
#line 1078
    s___0 = Getword(fp, 1);
#line 1078
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1078
      goto FAILURE;
    }
#line 1079
    if (k < hmm->M) {
#line 1079
      *(*(hmm->t + k) + 3) = ascii2prob(s___0, (float )1.0);
    }
#line 1080
    s___0 = Getword(fp, 1);
#line 1080
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1080
      goto FAILURE;
    }
#line 1081
    s___0 = Getword(fp, 1);
#line 1081
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1081
      goto FAILURE;
    }
#line 1082
    if (k < hmm->M) {
#line 1082
      *(*(hmm->t + k) + 4) = ascii2prob(s___0, (float )1.0);
    }
#line 1085
    s___0 = Getword(fp, 4);
#line 1085
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1085
      goto FAILURE;
    }
#line 1086
    if (hmm->flags & (1 << 2)) {
#line 1086
      *(hmm->rf + k) = *s___0;
    }
#line 1087
    s___0 = Getword(fp, 4);
#line 1087
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1087
      goto FAILURE;
    }
#line 1088
    if (hmm->flags & (1 << 3)) {
#line 1088
      *(hmm->cs + k) = *s___0;
    }
#line 1054
    k ++;
  }
#line 1092
  k = 0;
#line 1092
  while (k <= hmm->M) {
#line 1094
    s___0 = Getword(fp, 1);
#line 1094
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1094
      goto FAILURE;
    }
#line 1095
    x = 0;
#line 1095
    while (x < Alphabet_size) {
#line 1096
      s___0 = Getword(fp, 1);
#line 1096
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1096
        goto FAILURE;
      }
#line 1097
      if (k > 0) {
#line 1097
        if (k < hmm->M) {
#line 1098
          *(*(hmm->ins + k) + x) = ascii2prob(s___0, hmm->null[x]);
        }
      }
#line 1095
      x ++;
    }
#line 1092
    k ++;
  }
#line 1104
  hmm->flags |= 1 << 5;
#line 1105
  hmm->flags &= -2;
#line 1106
  Plan7Renormalize(hmm);
#line 1107
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1108
  Plan7SetCtime(hmm);
#line 1109
  *ret_hmm = hmm;
#line 1110
  return (1);
  FAILURE: 
#line 1113
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
#line 1113
    FreePlan7(hmm);
  }
#line 1114
  *ret_hmm = (struct plan7_s *)((void *)0);
#line 1115
  return (1);
}
}
#line 1118 "hmmio.c"
static int read_bin19hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1128
  tmp = feof(hmmfp->f);
#line 1128
  if (tmp) {
#line 1128
    return (0);
  }
#line 1129
  tmp___0 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 1129
  if (! tmp___0) {
#line 1129
    return (0);
  }
#line 1131
  p9hmm = read_plan9_binhmm(hmmfp->f, 7, hmmfp->byteswap);
#line 1132
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
#line 1132
    *ret_hmm = (struct plan7_s *)((void *)0);
#line 1132
    return (1);
  }
#line 1134
  Plan9toPlan7(p9hmm, & hmm);
#line 1136
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1137
  Plan7SetCtime(hmm);
#line 1139
  P9FreeHMM(p9hmm);
#line 1140
  *ret_hmm = hmm;
#line 1141
  return (1);
}
}
#line 1143 "hmmio.c"
static int read_asc17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  char buffer___1[512] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 1153
  tmp = feof(hmmfp->f);
#line 1153
  if (tmp) {
#line 1153
    return (0);
  } else {
#line 1153
    tmp___0 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )hmmfp->f);
#line 1153
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 1153
      return (0);
    }
  }
#line 1155
  p9hmm = read_plan9_aschmm(hmmfp->f, 6);
#line 1156
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
#line 1156
    *ret_hmm = (struct plan7_s *)((void *)0);
#line 1156
    return (1);
  }
#line 1158
  Plan9toPlan7(p9hmm, & hmm);
#line 1160
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1161
  Plan7SetCtime(hmm);
#line 1163
  P9FreeHMM(p9hmm);
#line 1164
  Plan7Renormalize(hmm);
#line 1165
  *ret_hmm = hmm;
#line 1166
  return (1);
}
}
#line 1169 "hmmio.c"
static int read_bin17hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1179
  tmp = feof(hmmfp->f);
#line 1179
  if (tmp) {
#line 1179
    return (0);
  }
#line 1180
  tmp___0 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 1180
  if (! tmp___0) {
#line 1180
    return (0);
  }
#line 1182
  p9hmm = read_plan9_binhmm(hmmfp->f, 5, hmmfp->byteswap);
#line 1183
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
#line 1183
    *ret_hmm = (struct plan7_s *)((void *)0);
#line 1183
    return (1);
  }
#line 1185
  Plan9toPlan7(p9hmm, & hmm);
#line 1187
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1188
  Plan7SetCtime(hmm);
#line 1190
  P9FreeHMM(p9hmm);
#line 1191
  *ret_hmm = hmm;
#line 1192
  return (1);
}
}
#line 1195 "hmmio.c"
static int read_asc11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 


  {
#line 1198
  Die((char *)"1.1 ASCII HMMs unsupported");
#line 1199
  return (1);
}
}
#line 1201 "hmmio.c"
static int read_bin11hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1211
  tmp = feof(hmmfp->f);
#line 1211
  if (tmp) {
#line 1211
    return (0);
  }
#line 1212
  tmp___0 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 1212
  if (! tmp___0) {
#line 1212
    return (0);
  }
#line 1214
  p9hmm = read_plan9_binhmm(hmmfp->f, 3, hmmfp->byteswap);
#line 1215
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
#line 1215
    *ret_hmm = (struct plan7_s *)((void *)0);
#line 1215
    return (1);
  }
#line 1217
  Plan9toPlan7(p9hmm, & hmm);
#line 1219
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1220
  Plan7SetCtime(hmm);
#line 1222
  P9FreeHMM(p9hmm);
#line 1223
  *ret_hmm = hmm;
#line 1224
  return (1);
}
}
#line 1227 "hmmio.c"
static int read_asc10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 


  {
#line 1230
  Die((char *)"1.0 ASCII HMMs unsupported");
#line 1231
  return (1);
}
}
#line 1234 "hmmio.c"
static int read_bin10hmm(HMMFILE *hmmfp , struct plan7_s **ret_hmm ) 
{ 
  unsigned int magic ;
  struct plan7_s *hmm ;
  struct plan9_s *p9hmm ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 1244
  tmp = feof(hmmfp->f);
#line 1244
  if (tmp) {
#line 1244
    return (0);
  }
#line 1245
  tmp___0 = fread((void * __restrict  )((char *)(& magic)), sizeof(unsigned int ),
                  (size_t )1, (FILE * __restrict  )hmmfp->f);
#line 1245
  if (! tmp___0) {
#line 1245
    return (0);
  }
#line 1247
  p9hmm = read_plan9_binhmm(hmmfp->f, 1, hmmfp->byteswap);
#line 1248
  if ((unsigned long )p9hmm == (unsigned long )((void *)0)) {
#line 1248
    *ret_hmm = (struct plan7_s *)((void *)0);
#line 1248
    return (1);
  }
#line 1250
  Plan9toPlan7(p9hmm, & hmm);
#line 1252
  hmm->comlog = Strdup((char *)"[converted from an old Plan9 HMM]");
#line 1253
  Plan7SetCtime(hmm);
#line 1255
  P9FreeHMM(p9hmm);
#line 1256
  *ret_hmm = hmm;
#line 1257
  return (1);
}
}
#line 1273 "hmmio.c"
static char buffer[8]  ;
#line 1270 "hmmio.c"
static char *prob2ascii(float p , float null ) 
{ 
  int tmp ;

  {
#line 1275
  if ((double )p == 0.0) {
#line 1275
    return ((char *)"*");
  }
#line 1276
  tmp = Prob2Score(p, null);
#line 1276
  sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"%6d", tmp);
#line 1277
  return (buffer);
}
}
#line 1285 "hmmio.c"
static float ascii2prob(char *s___0 , float null ) 
{ 
  int tmp ;
  float tmp___0 ;
  double tmp___1 ;

  {
#line 1288
  if ((int )*s___0 == 42) {
#line 1288
    tmp___1 = 0.;
  } else {
#line 1288
    tmp = atoi((char const   *)s___0);
#line 1288
    tmp___0 = Score2Prob(tmp, null);
#line 1288
    tmp___1 = (double )tmp___0;
  }
#line 1288
  return ((float )tmp___1);
}
}
#line 1312 "hmmio.c"
static void byteswap(char *swap , int nbytes ) 
{ 
  int x ;
  char byte ;

  {
#line 1318
  x = 0;
#line 1318
  while (x < nbytes / 2) {
#line 1320
    byte = *(swap + ((nbytes - x) - 1));
#line 1321
    *(swap + ((nbytes - x) - 1)) = *(swap + x);
#line 1322
    *(swap + x) = byte;
#line 1318
    x ++;
  }
#line 1324
  return;
}
}
#line 1333 "hmmio.c"
static void write_bin_string(FILE *fp , char *s___0 ) 
{ 
  int len ;
  size_t tmp ;

  {
#line 1337
  if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 1339
    tmp = strlen((char const   *)s___0);
#line 1339
    len = (int )(tmp + 1UL);
#line 1340
    fwrite((void const   * __restrict  )((char *)(& len)), sizeof(int ), (size_t )1,
           (FILE * __restrict  )fp);
#line 1341
    fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )len, (FILE * __restrict  )fp);
  } else {
#line 1345
    len = 0;
#line 1346
    fwrite((void const   * __restrict  )((char *)(& len)), sizeof(int ), (size_t )1,
           (FILE * __restrict  )fp);
  }
#line 1348
  return;
}
}
#line 1362 "hmmio.c"
static int read_bin_string(FILE *fp , int doswap , char **ret_s ) 
{ 
  char *s___0 ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1368
  tmp = fread((void * __restrict  )((char *)(& len)), sizeof(int ), (size_t )1, (FILE * __restrict  )fp);
#line 1368
  if (! tmp) {
#line 1368
    return (0);
  }
#line 1369
  if (doswap) {
#line 1369
    byteswap((char *)(& len), (int )sizeof(int ));
  }
#line 1370
  tmp___0 = sre_malloc((char *)"hmmio.c", 1370, sizeof(char ) * (unsigned long )len);
#line 1370
  s___0 = (char *)tmp___0;
#line 1371
  tmp___1 = fread((void * __restrict  )s___0, sizeof(char ), (size_t )len, (FILE * __restrict  )fp);
#line 1371
  if (! tmp___1) {
#line 1373
    free((void *)s___0);
#line 1374
    return (0);
  }
#line 1377
  *ret_s = s___0;
#line 1378
  return (1);
}
}
#line 1402 "hmmio.c"
static void multiline(FILE *fp , char *pfx , char *s___0 ) 
{ 
  char *buf ;
  char *sptr___0 ;

  {
#line 1408
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1408
    return;
  }
#line 1409
  buf = Strdup(s___0);
#line 1410
  sptr___0 = strtok((char * __restrict  )buf, (char const   * __restrict  )"\n");
#line 1411
  while ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 1413
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s%s\n", pfx, sptr___0);
#line 1414
    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
  }
#line 1416
  free((void *)buf);
#line 1417
  return;
}
}
#line 1438 "hmmio.c"
static struct plan9_s *read_plan9_binhmm(FILE *fp , int version , int swapped ) 
{ 
  struct plan9_s *hmm ;
  int M ;
  int k ;
  int x ;
  int len ;
  int asize ;
  int atype ;
  char abet[20] ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
#line 1451
  tmp = fread((void * __restrict  )((char *)(& M)), sizeof(int ), (size_t )1, (FILE * __restrict  )fp);
#line 1451
  if (! tmp) {
#line 1451
    return ((struct plan9_s *)((void *)0));
  }
#line 1452
  tmp___0 = fread((void * __restrict  )((char *)(& asize)), sizeof(int ), (size_t )1,
                  (FILE * __restrict  )fp);
#line 1452
  if (! tmp___0) {
#line 1452
    return ((struct plan9_s *)((void *)0));
  }
#line 1453
  if (swapped) {
#line 1454
    byteswap((char *)(& M), (int )sizeof(int ));
#line 1455
    byteswap((char *)(& asize), (int )sizeof(int ));
  }
#line 1460
  if (asize == 4) {
#line 1460
    atype = 2;
  } else
#line 1461
  if (asize == 20) {
#line 1461
    atype = 3;
  } else {
#line 1462
    Die((char *)"A nonbiological alphabet size of %d; so I can\'t convert plan9 to plan7",
        asize);
  }
#line 1463
  if (Alphabet_type == 0) {
#line 1463
    SetAlphabet(atype);
  } else
#line 1464
  if (atype != Alphabet_type) {
#line 1465
    tmp___1 = AlphabetType2String(atype);
#line 1465
    tmp___2 = AlphabetType2String(Alphabet_type);
#line 1465
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___2, tmp___1);
  }
#line 1468
  hmm = P9AllocHMM(M);
#line 1468
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 1469
    Die((char *)"malloc failed for reading hmm in\n");
  }
#line 1472
  if (version == 7) {
#line 1473
    tmp___3 = fread((void * __restrict  )((char *)(& len)), sizeof(int ), (size_t )1,
                    (FILE * __restrict  )fp);
#line 1473
    if (! tmp___3) {
#line 1473
      return ((struct plan9_s *)((void *)0));
    }
#line 1474
    if (swapped) {
#line 1474
      byteswap((char *)(& len), (int )sizeof(int ));
    }
#line 1475
    tmp___4 = sre_realloc((char *)"hmmio.c", 1475, (void *)hmm->name, sizeof(char ) * (unsigned long )(len + 1));
#line 1475
    hmm->name = (char *)tmp___4;
#line 1476
    tmp___5 = fread((void * __restrict  )hmm->name, sizeof(char ), (size_t )len, (FILE * __restrict  )fp);
#line 1476
    if (! tmp___5) {
#line 1476
      return ((struct plan9_s *)((void *)0));
    }
#line 1477
    *(hmm->name + len) = (char )'\000';
  }
#line 1481
  tmp___6 = fread((void * __restrict  )((char *)(& atype)), sizeof(int ), (size_t )1,
                  (FILE * __restrict  )fp);
#line 1481
  if (! tmp___6) {
#line 1481
    return ((struct plan9_s *)((void *)0));
  }
#line 1482
  tmp___7 = fread((void * __restrict  )(abet), sizeof(char ), (size_t )Alphabet_size,
                  (FILE * __restrict  )fp);
#line 1482
  if (! tmp___7) {
#line 1482
    return ((struct plan9_s *)((void *)0));
  }
#line 1485
  if (version == 1) {
#line 1486
    fseek(fp, (long )(sizeof(float ) * (unsigned long )Alphabet_size), 1);
  }
#line 1490
  if (version == 5) {
#line 1490
    goto _L;
  } else
#line 1490
  if (version == 7) {
    _L: /* CIL Label */ 
#line 1492
    tmp___8 = fread((void * __restrict  )((char *)(& hmm->flags)), sizeof(int ), (size_t )1,
                    (FILE * __restrict  )fp);
#line 1492
    if (! tmp___8) {
#line 1492
      return ((struct plan9_s *)((void *)0));
    }
#line 1493
    if (swapped) {
#line 1493
      byteswap((char *)(& hmm->flags), (int )sizeof(int ));
    }
#line 1494
    if (hmm->flags & 1) {
#line 1494
      tmp___9 = fread((void * __restrict  )hmm->ref, sizeof(char ), (size_t )(hmm->M + 1),
                      (FILE * __restrict  )fp);
#line 1494
      if (! tmp___9) {
#line 1495
        return ((struct plan9_s *)((void *)0));
      }
    }
#line 1496
    *(hmm->ref + (hmm->M + 1)) = (char )'\000';
#line 1497
    if (hmm->flags & (1 << 1)) {
#line 1497
      tmp___10 = fread((void * __restrict  )hmm->cs, sizeof(char ), (size_t )(hmm->M + 1),
                       (FILE * __restrict  )fp);
#line 1497
      if (! tmp___10) {
#line 1498
        return ((struct plan9_s *)((void *)0));
      }
    }
#line 1499
    *(hmm->cs + (hmm->M + 1)) = (char )'\000';
  }
#line 1504
  if (version == 7) {
#line 1506
    tmp___11 = fread((void * __restrict  )((char *)(hmm->null)), sizeof(float ), (size_t )Alphabet_size,
                     (FILE * __restrict  )fp);
#line 1506
    if (! tmp___11) {
#line 1506
      return ((struct plan9_s *)((void *)0));
    }
#line 1507
    if (swapped) {
#line 1508
      x = 0;
#line 1508
      while (x < Alphabet_size) {
#line 1509
        byteswap((char *)(& hmm->null[x]), (int )sizeof(float ));
#line 1508
        x ++;
      }
    }
  } else {
#line 1511
    P9DefaultNullModel(hmm->null);
  }
#line 1514
  k = 0;
#line 1514
  while (k <= hmm->M) {
#line 1517
    tmp___12 = fread((void * __restrict  )((char *)(& (hmm->mat + k)->t[0])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1517
    if (! tmp___12) {
#line 1517
      return ((struct plan9_s *)((void *)0));
    }
#line 1518
    tmp___13 = fread((void * __restrict  )((char *)(& (hmm->mat + k)->t[2])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1518
    if (! tmp___13) {
#line 1518
      return ((struct plan9_s *)((void *)0));
    }
#line 1519
    tmp___14 = fread((void * __restrict  )((char *)(& (hmm->mat + k)->t[1])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1519
    if (! tmp___14) {
#line 1519
      return ((struct plan9_s *)((void *)0));
    }
#line 1520
    tmp___15 = fread((void * __restrict  )((char *)((hmm->mat + k)->p)), sizeof(float ),
                     (size_t )Alphabet_size, (FILE * __restrict  )fp);
#line 1520
    if (! tmp___15) {
#line 1520
      return ((struct plan9_s *)((void *)0));
    }
#line 1522
    if (swapped) {
#line 1523
      byteswap((char *)(& (hmm->mat + k)->t[0]), (int )sizeof(float ));
#line 1524
      byteswap((char *)(& (hmm->mat + k)->t[2]), (int )sizeof(float ));
#line 1525
      byteswap((char *)(& (hmm->mat + k)->t[1]), (int )sizeof(float ));
#line 1526
      x = 0;
#line 1526
      while (x < Alphabet_size) {
#line 1527
        byteswap((char *)(& (hmm->mat + k)->p[x]), (int )sizeof(float ));
#line 1526
        x ++;
      }
    }
#line 1531
    if (version == 1) {
#line 1532
      fseek(fp, (long )(sizeof(float ) * (unsigned long )(3 + Alphabet_size)), 1);
    }
#line 1535
    tmp___16 = fread((void * __restrict  )((char *)(& (hmm->del + k)->t[0])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1535
    if (! tmp___16) {
#line 1535
      return ((struct plan9_s *)((void *)0));
    }
#line 1536
    tmp___17 = fread((void * __restrict  )((char *)(& (hmm->del + k)->t[2])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1536
    if (! tmp___17) {
#line 1536
      return ((struct plan9_s *)((void *)0));
    }
#line 1537
    tmp___18 = fread((void * __restrict  )((char *)(& (hmm->del + k)->t[1])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1537
    if (! tmp___18) {
#line 1537
      return ((struct plan9_s *)((void *)0));
    }
#line 1538
    if (swapped) {
#line 1539
      byteswap((char *)(& (hmm->del + k)->t[0]), (int )sizeof(float ));
#line 1540
      byteswap((char *)(& (hmm->del + k)->t[2]), (int )sizeof(float ));
#line 1541
      byteswap((char *)(& (hmm->del + k)->t[1]), (int )sizeof(float ));
    }
#line 1545
    if (version == 1) {
#line 1546
      fseek(fp, (long )(sizeof(float ) * 3UL), 1);
    }
#line 1549
    tmp___19 = fread((void * __restrict  )((char *)(& (hmm->ins + k)->t[0])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1549
    if (! tmp___19) {
#line 1549
      return ((struct plan9_s *)((void *)0));
    }
#line 1550
    tmp___20 = fread((void * __restrict  )((char *)(& (hmm->ins + k)->t[2])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1550
    if (! tmp___20) {
#line 1550
      return ((struct plan9_s *)((void *)0));
    }
#line 1551
    tmp___21 = fread((void * __restrict  )((char *)(& (hmm->ins + k)->t[1])), sizeof(float ),
                     (size_t )1, (FILE * __restrict  )fp);
#line 1551
    if (! tmp___21) {
#line 1551
      return ((struct plan9_s *)((void *)0));
    }
#line 1552
    tmp___22 = fread((void * __restrict  )((char *)((hmm->ins + k)->p)), sizeof(float ),
                     (size_t )Alphabet_size, (FILE * __restrict  )fp);
#line 1552
    if (! tmp___22) {
#line 1552
      return ((struct plan9_s *)((void *)0));
    }
#line 1554
    if (swapped) {
#line 1555
      byteswap((char *)(& (hmm->ins + k)->t[0]), (int )sizeof(float ));
#line 1556
      byteswap((char *)(& (hmm->ins + k)->t[2]), (int )sizeof(float ));
#line 1557
      byteswap((char *)(& (hmm->ins + k)->t[1]), (int )sizeof(float ));
#line 1558
      x = 0;
#line 1558
      while (x < Alphabet_size) {
#line 1559
        byteswap((char *)(& (hmm->ins + k)->p[x]), (int )sizeof(float ));
#line 1558
        x ++;
      }
    }
#line 1563
    if (version == 1) {
#line 1564
      fseek(fp, (long )(sizeof(float ) * (unsigned long )(3 + Alphabet_size)), 1);
    }
#line 1514
    k ++;
  }
#line 1566
  P9Renormalize(hmm);
#line 1567
  return (hmm);
}
}
#line 1584 "hmmio.c"
static struct plan9_s *read_plan9_aschmm(FILE *fp , int version ) 
{ 
  struct plan9_s *hmm ;
  int M ;
  char buffer___1[512] ;
  char *statetype ;
  char *s___0 ;
  int k ;
  int i___0 ;
  int asize ;
  int atype ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  double tmp___15 ;
  char *tmp___16 ;
  double tmp___17 ;
  char *tmp___18 ;
  double tmp___19 ;
  char *tmp___20 ;
  double tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  double tmp___24 ;
  char *tmp___25 ;
  double tmp___26 ;
  char *tmp___27 ;
  double tmp___28 ;
  char *tmp___29 ;
  double tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  double tmp___33 ;
  char *tmp___34 ;
  double tmp___35 ;
  char *tmp___36 ;
  double tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;

  {
#line 1598
  tmp = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1598
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1598
    return ((struct plan9_s *)((void *)0));
  }
#line 1599
  s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1599
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1599
    return ((struct plan9_s *)((void *)0));
  }
#line 1600
  tmp___0 = __ctype_b_loc();
#line 1600
  if (! ((int const   )*(*tmp___0 + (int )*s___0) & 2048)) {
#line 1600
    return ((struct plan9_s *)((void *)0));
  }
#line 1601
  M = atoi((char const   *)s___0);
#line 1603
  tmp___1 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1603
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1603
    return ((struct plan9_s *)((void *)0));
  }
#line 1604
  s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1604
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1604
    return ((struct plan9_s *)((void *)0));
  }
#line 1605
  tmp___2 = __ctype_b_loc();
#line 1605
  if (! ((int const   )*(*tmp___2 + (int )*s___0) & 2048)) {
#line 1605
    return ((struct plan9_s *)((void *)0));
  }
#line 1606
  asize = atoi((char const   *)s___0);
#line 1610
  if (asize == 4) {
#line 1610
    atype = 2;
  } else
#line 1611
  if (asize == 20) {
#line 1611
    atype = 3;
  } else {
#line 1612
    Die((char *)"A nonbiological alphabet size of %d; so I can\'t convert plan9 to plan7",
        asize);
  }
#line 1613
  if (Alphabet_type == 0) {
#line 1613
    SetAlphabet(atype);
  } else
#line 1614
  if (atype != Alphabet_type) {
#line 1615
    tmp___3 = AlphabetType2String(atype);
#line 1615
    tmp___4 = AlphabetType2String(Alphabet_type);
#line 1615
    Die((char *)"Alphabet mismatch error.\nI thought we were working with %s, but tried to read a %s HMM.\n",
        tmp___4, tmp___3);
  }
#line 1618
  hmm = P9AllocHMM(M);
#line 1618
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 1619
    Die((char *)"malloc failed for reading hmm in\n");
  }
#line 1622
  tmp___5 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1622
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 1622
    return ((struct plan9_s *)((void *)0));
  }
#line 1623
  s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1623
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1623
    return ((struct plan9_s *)((void *)0));
  }
#line 1624
  tmp___6 = __ctype_b_loc();
#line 1624
  if (! ((int const   )*(*tmp___6 + (int )*s___0) & 2048)) {
#line 1624
    return ((struct plan9_s *)((void *)0));
  }
#line 1626
  tmp___7 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1626
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 1626
    return ((struct plan9_s *)((void *)0));
  }
#line 1627
  s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1627
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1627
    return ((struct plan9_s *)((void *)0));
  }
#line 1630
  if (version == 2) {
#line 1631
    i___0 = 0;
#line 1631
    while (i___0 < Alphabet_size) {
#line 1632
      tmp___8 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1632
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 1632
        return ((struct plan9_s *)((void *)0));
      }
#line 1631
      i___0 ++;
    }
  }
#line 1636
  if (version == 6) {
#line 1638
    tmp___9 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1638
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 1638
      return ((struct plan9_s *)((void *)0));
    }
#line 1639
    tmp___10 = strncmp((char const   *)(buffer___1), "yes", (size_t )3);
#line 1639
    if (tmp___10 == 0) {
#line 1639
      hmm->flags |= 1;
    }
#line 1640
    tmp___11 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1640
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 1640
      return ((struct plan9_s *)((void *)0));
    }
#line 1641
    tmp___12 = strncmp((char const   *)(buffer___1), "yes", (size_t )3);
#line 1641
    if (tmp___12 == 0) {
#line 1641
      hmm->flags |= 1 << 1;
    }
  }
#line 1645
  while (1) {
#line 1645
    tmp___42 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1645
    if (! ((unsigned long )tmp___42 != (unsigned long )((void *)0))) {
#line 1645
      break;
    }
#line 1648
    statetype = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1648
    if ((unsigned long )statetype == (unsigned long )((void *)0)) {
#line 1648
      return ((struct plan9_s *)((void *)0));
    }
#line 1649
    s___0 = strtok((char * __restrict  )((char *)((void *)0)), (char const   * __restrict  )" \t\n");
#line 1649
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1649
      return ((struct plan9_s *)((void *)0));
    }
#line 1650
    tmp___13 = __ctype_b_loc();
#line 1650
    if (! ((int const   )*(*tmp___13 + (int )*s___0) & 2048)) {
#line 1650
      return ((struct plan9_s *)((void *)0));
    }
#line 1651
    k = atoi((char const   *)s___0);
#line 1652
    if (k < 0) {
#line 1652
      return ((struct plan9_s *)((void *)0));
    } else
#line 1652
    if (k > hmm->M + 1) {
#line 1652
      return ((struct plan9_s *)((void *)0));
    }
#line 1654
    tmp___41 = strcmp((char const   *)statetype, "###MATCH_STATE");
#line 1654
    if (tmp___41 == 0) {
#line 1658
      if (version == 6) {
#line 1660
        s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 1661
        while (1) {
#line 1661
          if ((int )*s___0 != 40) {
#line 1661
            if (! ((int )*s___0 != 0)) {
#line 1661
              break;
            }
          } else {
#line 1661
            break;
          }
#line 1661
          s___0 ++;
        }
#line 1662
        if ((int )*s___0 != 40) {
#line 1662
          return ((struct plan9_s *)((void *)0));
        }
#line 1663
        *(hmm->ref + k) = *(s___0 + 1);
#line 1664
        while (1) {
#line 1664
          if ((int )*s___0 != 40) {
#line 1664
            if (! ((int )*s___0 != 0)) {
#line 1664
              break;
            }
          } else {
#line 1664
            break;
          }
#line 1664
          s___0 ++;
        }
#line 1665
        if ((int )*s___0 != 40) {
#line 1665
          return ((struct plan9_s *)((void *)0));
        }
#line 1666
        *(hmm->cs + k) = *(s___0 + 1);
      }
#line 1669
      tmp___14 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1669
      if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 1669
        return ((struct plan9_s *)((void *)0));
      }
#line 1670
      s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1670
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1670
        return ((struct plan9_s *)((void *)0));
      }
#line 1671
      tmp___15 = atof((char const   *)s___0);
#line 1671
      (hmm->mat + k)->t[0] = (float )tmp___15;
#line 1673
      tmp___16 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1673
      if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 1673
        return ((struct plan9_s *)((void *)0));
      }
#line 1674
      s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1674
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1674
        return ((struct plan9_s *)((void *)0));
      }
#line 1675
      tmp___17 = atof((char const   *)s___0);
#line 1675
      (hmm->mat + k)->t[2] = (float )tmp___17;
#line 1677
      tmp___18 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1677
      if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
#line 1677
        return ((struct plan9_s *)((void *)0));
      }
#line 1678
      s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1678
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1678
        return ((struct plan9_s *)((void *)0));
      }
#line 1679
      tmp___19 = atof((char const   *)s___0);
#line 1679
      (hmm->mat + k)->t[1] = (float )tmp___19;
#line 1681
      i___0 = 0;
#line 1681
      while (i___0 < Alphabet_size) {
#line 1683
        tmp___20 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1683
        if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
#line 1683
          return ((struct plan9_s *)((void *)0));
        }
#line 1684
        s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1684
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1684
          return ((struct plan9_s *)((void *)0));
        }
#line 1685
        tmp___21 = atof((char const   *)s___0);
#line 1685
        (hmm->mat + k)->p[i___0] = (float )tmp___21;
#line 1681
        i___0 ++;
      }
#line 1689
      if (version == 2) {
#line 1690
        i___0 = 0;
#line 1690
        while (i___0 < Alphabet_size + 3) {
#line 1691
          tmp___22 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1691
          if ((unsigned long )tmp___22 == (unsigned long )((void *)0)) {
#line 1691
            return ((struct plan9_s *)((void *)0));
          }
#line 1690
          i___0 ++;
        }
      }
    } else {
#line 1694
      tmp___40 = strcmp((char const   *)statetype, "###INSERT_STATE");
#line 1694
      if (tmp___40 == 0) {
#line 1696
        tmp___23 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1696
        if ((unsigned long )tmp___23 == (unsigned long )((void *)0)) {
#line 1696
          return ((struct plan9_s *)((void *)0));
        }
#line 1697
        s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1697
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1697
          return ((struct plan9_s *)((void *)0));
        }
#line 1698
        tmp___24 = atof((char const   *)s___0);
#line 1698
        (hmm->ins + k)->t[0] = (float )tmp___24;
#line 1700
        tmp___25 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1700
        if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
#line 1700
          return ((struct plan9_s *)((void *)0));
        }
#line 1701
        s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1701
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1701
          return ((struct plan9_s *)((void *)0));
        }
#line 1702
        tmp___26 = atof((char const   *)s___0);
#line 1702
        (hmm->ins + k)->t[2] = (float )tmp___26;
#line 1704
        tmp___27 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1704
        if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
#line 1704
          return ((struct plan9_s *)((void *)0));
        }
#line 1705
        s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1705
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1705
          return ((struct plan9_s *)((void *)0));
        }
#line 1706
        tmp___28 = atof((char const   *)s___0);
#line 1706
        (hmm->ins + k)->t[1] = (float )tmp___28;
#line 1708
        i___0 = 0;
#line 1708
        while (i___0 < Alphabet_size) {
#line 1710
          tmp___29 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1710
          if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
#line 1710
            return ((struct plan9_s *)((void *)0));
          }
#line 1711
          s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1711
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1711
            return ((struct plan9_s *)((void *)0));
          }
#line 1712
          tmp___30 = atof((char const   *)s___0);
#line 1712
          (hmm->ins + k)->p[i___0] = (float )tmp___30;
#line 1708
          i___0 ++;
        }
#line 1716
        if (version == 2) {
#line 1717
          i___0 = 0;
#line 1717
          while (i___0 < Alphabet_size + 3) {
#line 1718
            tmp___31 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1718
            if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
#line 1718
              return ((struct plan9_s *)((void *)0));
            }
#line 1717
            i___0 ++;
          }
        }
      } else {
#line 1721
        tmp___39 = strcmp((char const   *)statetype, "###DELETE_STATE");
#line 1721
        if (tmp___39 == 0) {
#line 1723
          tmp___32 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1723
          if ((unsigned long )tmp___32 == (unsigned long )((void *)0)) {
#line 1723
            return ((struct plan9_s *)((void *)0));
          }
#line 1724
          s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1724
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1724
            return ((struct plan9_s *)((void *)0));
          }
#line 1725
          tmp___33 = atof((char const   *)s___0);
#line 1725
          (hmm->del + k)->t[0] = (float )tmp___33;
#line 1727
          tmp___34 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1727
          if ((unsigned long )tmp___34 == (unsigned long )((void *)0)) {
#line 1727
            return ((struct plan9_s *)((void *)0));
          }
#line 1728
          s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1728
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1728
            return ((struct plan9_s *)((void *)0));
          }
#line 1729
          tmp___35 = atof((char const   *)s___0);
#line 1729
          (hmm->del + k)->t[2] = (float )tmp___35;
#line 1731
          tmp___36 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1731
          if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
#line 1731
            return ((struct plan9_s *)((void *)0));
          }
#line 1732
          s___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 1732
          if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1732
            return ((struct plan9_s *)((void *)0));
          }
#line 1733
          tmp___37 = atof((char const   *)s___0);
#line 1733
          (hmm->del + k)->t[1] = (float )tmp___37;
#line 1736
          if (version == 2) {
#line 1737
            i___0 = 0;
#line 1737
            while (i___0 < 3) {
#line 1738
              tmp___38 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 1738
              if ((unsigned long )tmp___38 == (unsigned long )((void *)0)) {
#line 1738
                return ((struct plan9_s *)((void *)0));
              }
#line 1737
              i___0 ++;
            }
          }
        } else {
#line 1741
          return ((struct plan9_s *)((void *)0));
        }
      }
    }
  }
#line 1744
  P9DefaultNullModel(hmm->null);
#line 1745
  P9Renormalize(hmm);
#line 1746
  return (hmm);
}
}
#line 1 "hmmcalibrate.o"
#pragma merger("0","/tmp/cil-X29dZhjy.i","")
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 82 "./sqfuncs.h"
int FileExists(char *filename ) ;
#line 87
int Getopt(int argc , char **argv , struct opt_s *opt , int nopts , char *usage___1 ,
           int *ret_optind , char **ret_optname , char **ret_optarg ) ;
#line 96
void SqdClean(void) ;
#line 152
void Panic(char *file , int line ) ;
#line 224
char *RandomSequence(char *alphabet , float *p , int n , int len ) ;
#line 9 "./sre_random.h"
void sre_srandom(int seed ) ;
#line 12
double Gaussrandom(double mean , double stddev ) ;
#line 182 "./funcs.h"
void HMMERBanner(FILE *fp , char *banner___1 ) ;
#line 212
void Plan7ComlogAppend(struct plan7_s *hmm , int argc , char **argv ) ;
#line 261
void P7DefaultNullModel(float *null , float *ret_p1 ) ;
#line 48 "hmmcalibrate.c"
static char banner[48]  = 
#line 48 "hmmcalibrate.c"
  {      (char )'h',      (char )'m',      (char )'m',      (char )'c', 
        (char )'a',      (char )'l',      (char )'i',      (char )'b', 
        (char )'r',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'c',      (char )'a',      (char )'l',      (char )'i', 
        (char )'b',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )' ',      (char )'H',      (char )'M', 
        (char )'M',      (char )' ',      (char )'s',      (char )'e', 
        (char )'a',      (char )'r',      (char )'c',      (char )'h', 
        (char )' ',      (char )'s',      (char )'t',      (char )'a', 
        (char )'t',      (char )'i',      (char )'s',      (char )'t', 
        (char )'i',      (char )'c',      (char )'s',      (char )'\000'};
#line 50 "hmmcalibrate.c"
static char usage[130]  = 
#line 50
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'h', 
        (char )'m',      (char )'m',      (char )'c',      (char )'a', 
        (char )'l',      (char )'i',      (char )'b',      (char )'r', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'[',      (char )'-',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )']',      (char )' ',      (char )'<', 
        (char )'h',      (char )'m',      (char )'m',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'>', 
        (char )'\n',      (char )'A',      (char )'v',      (char )'a', 
        (char )'i',      (char )'l',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )':',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'h', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )' ',      (char )'s',      (char )'h',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'u', 
        (char )'s',      (char )'a',      (char )'g',      (char )'e', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )',',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )'n',      (char )' ', 
        (char )'e',      (char )'x',      (char )'i',      (char )'t', 
        (char )'\n',      (char )'\000'};
#line 56 "hmmcalibrate.c"
static char experts[456]  = 
#line 56
  {      (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'c',      (char )'p',      (char )'u',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'r', 
        (char )'u',      (char )'n',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'a', 
        (char )'d',      (char )'s',      (char )' ',      (char )'i', 
        (char )'n',      (char )' ',      (char )'p',      (char )'a', 
        (char )'r',      (char )'a',      (char )'l',      (char )'l', 
        (char )'e',      (char )'l',      (char )' ',      (char )'(', 
        (char )'i',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'d',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'f',      (char )'i',      (char )'x', 
        (char )'e',      (char )'d',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'f',      (char )'i',      (char )'x',      (char )' ', 
        (char )'r',      (char )'a',      (char )'n',      (char )'d', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'l',      (char )'e',      (char )'n',      (char )'g', 
        (char )'t',      (char )'h',      (char )' ',      (char )'a', 
        (char )'t',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'h',      (char )'i', 
        (char )'s',      (char )'t',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'<', 
        (char )'f',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'a',      (char )'v', 
        (char )'e',      (char )' ',      (char )'h',      (char )'i', 
        (char )'s',      (char )'t',      (char )'o',      (char )'g', 
        (char )'r',      (char )'a',      (char )'m',      (char )'(', 
        (char )'s',      (char )')',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'<', 
        (char )'f',      (char )'>',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'m', 
        (char )'e',      (char )'a',      (char )'n',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'r',      (char )'a', 
        (char )'n',      (char )'d',      (char )'o',      (char )'m', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )' ',      (char )'l',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'m',      (char )'e',      (char )'a',      (char )'n', 
        (char )' ',      (char )'a',      (char )'t',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )'[',      (char )'3',      (char )'5',      (char )'0', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'n',      (char )'u', 
        (char )'m',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'s', 
        (char )'a',      (char )'m',      (char )'p',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'<', 
        (char )'n',      (char )'>',      (char )' ',      (char )'[', 
        (char )'5',      (char )'0',      (char )'0',      (char )'0', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'p',      (char )'v', 
        (char )'m',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'n', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'a',      (char )' ',      (char )'P',      (char )'a', 
        (char )'r',      (char )'a',      (char )'l',      (char )'l', 
        (char )'e',      (char )'l',      (char )' ',      (char )'V', 
        (char )'i',      (char )'r',      (char )'t',      (char )'u', 
        (char )'a',      (char )'l',      (char )' ',      (char )'M', 
        (char )'a',      (char )'c',      (char )'h',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'(', 
        (char )'P',      (char )'V',      (char )'M',      (char )')', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'s',      (char )'d',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )' ', 
        (char )'r',      (char )'a',      (char )'n',      (char )'d', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )' ',      (char )'l', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )' ',      (char )'s',      (char )'t', 
        (char )'d',      (char )'.',      (char )' ',      (char )'d', 
        (char )'e',      (char )'v',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )'[',      (char )'3', 
        (char )'5',      (char )'0',      (char )']',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'s',      (char )'e',      (char )'e',      (char )'d', 
        (char )' ',      (char )'<',      (char )'n',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'r', 
        (char )'a',      (char )'n',      (char )'d',      (char )'o', 
        (char )'m',      (char )' ',      (char )'s',      (char )'e', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'<',      (char )'n', 
        (char )'>',      (char )' ',      (char )'[',      (char )'t', 
        (char )'i',      (char )'m',      (char )'e',      (char )'(', 
        (char )')',      (char )']',      (char )'\n',      (char )'\000'};
#line 67 "hmmcalibrate.c"
static struct opt_s OPTIONS[9]  = 
#line 67
  {      {(char *)"-h", 1, 0}, 
        {(char *)"--cpu", 0, 1}, 
        {(char *)"--fixed", 0, 1}, 
        {(char *)"--histfile", 0, 4}, 
        {(char *)"--mean", 0, 2}, 
        {(char *)"--num", 0, 1}, 
        {(char *)"--pvm", 0, 0}, 
        {(char *)"--sd", 0, 2}, 
        {(char *)"--seed", 0, 1}};
#line 81
static void main_loop_serial(struct plan7_s *hmm , int seed , int nsample , float lenmean ,
                             float lensd , int fixedlen , struct histogram_s **ret_hist ,
                             float *ret_max ) ;
#line 140 "hmmcalibrate.c"
int hmmcalibrate(int argc , char **argv ) 
{ 
  char *hmmfile ;
  char *tmpfile___0 ;
  HMMFILE *hmmfp ;
  FILE *outfp ;
  char *mode ;
  struct plan7_s *hmm ;
  int idx ;
  int nhmm ;
  struct histogram_s *hist ;
  float max ;
  char *histfile ;
  FILE *hfp ;
  float *mu ;
  float *lambda ;
  int mu_lumpsize ;
  int nsample ;
  int seed ;
  int fixedlen ;
  float lenmean ;
  float lensd ;
  int do_pvm ;
  int pvm_lumpsize ;
  char *optname ;
  char *optarg___0 ;
  int optind___1 ;
  int num_threads ;
  time_t tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 196
  nsample = 5000;
#line 197
  fixedlen = 0;
#line 198
  lenmean = (float )325.;
#line 199
  lensd = (float )200.;
#line 200
  tmp = time((time_t *)((void *)0));
#line 200
  seed = (int )tmp;
#line 201
  histfile = (char *)((void *)0);
#line 202
  do_pvm = 0;
#line 203
  pvm_lumpsize = 20;
#line 204
  mu_lumpsize = 100;
#line 208
  num_threads = 0;
#line 211
  while (1) {
#line 211
    tmp___11 = Getopt(argc, argv, OPTIONS, (int )(sizeof(OPTIONS) / sizeof(struct opt_s )),
                      usage, & optind___1, & optname, & optarg___0);
#line 211
    if (! tmp___11) {
#line 211
      break;
    }
#line 214
    tmp___10 = strcmp((char const   *)optname, "--cpu");
#line 214
    if (tmp___10 == 0) {
#line 214
      num_threads = atoi((char const   *)optarg___0);
    } else {
#line 215
      tmp___9 = strcmp((char const   *)optname, "--fixed");
#line 215
      if (tmp___9 == 0) {
#line 215
        fixedlen = atoi((char const   *)optarg___0);
      } else {
#line 216
        tmp___8 = strcmp((char const   *)optname, "--histfile");
#line 216
        if (tmp___8 == 0) {
#line 216
          histfile = optarg___0;
        } else {
#line 217
          tmp___7 = strcmp((char const   *)optname, "--mean");
#line 217
          if (tmp___7 == 0) {
#line 217
            tmp___0 = atof((char const   *)optarg___0);
#line 217
            lenmean = (float )tmp___0;
          } else {
#line 218
            tmp___6 = strcmp((char const   *)optname, "--num");
#line 218
            if (tmp___6 == 0) {
#line 218
              nsample = atoi((char const   *)optarg___0);
            } else {
#line 219
              tmp___5 = strcmp((char const   *)optname, "--pvm");
#line 219
              if (tmp___5 == 0) {
#line 219
                do_pvm = 1;
              } else {
#line 220
                tmp___4 = strcmp((char const   *)optname, "--sd");
#line 220
                if (tmp___4 == 0) {
#line 220
                  tmp___1 = atof((char const   *)optarg___0);
#line 220
                  lensd = (float )tmp___1;
                } else {
#line 221
                  tmp___3 = strcmp((char const   *)optname, "--seed");
#line 221
                  if (tmp___3 == 0) {
#line 221
                    seed = atoi((char const   *)optarg___0);
                  } else {
#line 222
                    tmp___2 = strcmp((char const   *)optname, "-h");
#line 222
                    if (tmp___2 == 0) {
#line 224
                      HMMERBanner(stdout, banner);
#line 225
                      puts((char const   *)(usage));
#line 226
                      puts((char const   *)(experts));
#line 227
                      exit(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 231
  if (argc - optind___1 != 1) {
#line 231
    Die((char *)"Incorrect number of arguments.\n%s\n", usage);
  }
#line 232
  tmp___12 = optind___1;
#line 232
  optind___1 ++;
#line 232
  hmmfile = *(argv + tmp___12);
#line 235
  if (do_pvm) {
#line 235
    Die((char *)"PVM support is not compiled into HMMER; --pvm doesn\'t work.");
  }
#line 238
  if (num_threads) {
#line 238
    Die((char *)"Posix threads support is not compiled into HMMER; --cpu doesn\'t have any effect");
  }
#line 246
  hmmfp = HMMFileOpen(hmmfile, (char *)((void *)0));
#line 246
  if ((unsigned long )hmmfp == (unsigned long )((void *)0)) {
#line 247
    Die((char *)"failed to open HMM file %s for reading.", hmmfile);
  }
#line 250
  hfp = (FILE *)((void *)0);
#line 251
  if ((unsigned long )histfile != (unsigned long )((void *)0)) {
#line 252
    hfp = fopen((char const   * __restrict  )histfile, (char const   * __restrict  )"w");
#line 252
    if ((unsigned long )hfp == (unsigned long )((void *)0)) {
#line 253
      Die((char *)"Failed to open histogram save file %s for writing\n", histfile);
    }
  }
#line 265
  tmp___13 = strlen((char const   *)hmmfile);
#line 265
  tmp___14 = sre_malloc((char *)"hmmcalibrate.c", 265, tmp___13 + 5UL);
#line 265
  tmpfile___0 = (char *)tmp___14;
#line 266
  strcpy((char * __restrict  )tmpfile___0, (char const   * __restrict  )hmmfile);
#line 267
  strcat((char * __restrict  )tmpfile___0, (char const   * __restrict  )".new");
#line 268
  tmp___16 = FileExists(tmpfile___0);
#line 268
  if (tmp___16) {
#line 270
    tmp___15 = remove((char const   *)tmpfile___0);
#line 270
    if (tmp___15 != 0) {
#line 270
      Panic((char *)"hmmcalibrate.c", 270);
    }
  }
#line 274
  if (hmmfp->is_binary) {
#line 274
    mode = (char *)"wb";
  } else {
#line 275
    mode = (char *)"w";
  }
#line 281
  HMMERBanner(stdout, banner);
#line 282
  printf((char const   * __restrict  )"HMM file:                 %s\n", hmmfile);
#line 283
  if (fixedlen) {
#line 284
    printf((char const   * __restrict  )"Length fixed to:          %d\n", fixedlen);
  } else {
#line 286
    printf((char const   * __restrict  )"Length distribution mean: %.0f\n", (double )lenmean);
#line 287
    printf((char const   * __restrict  )"Length distribution s.d.: %.0f\n", (double )lensd);
  }
#line 289
  printf((char const   * __restrict  )"Number of samples:        %d\n", nsample);
#line 290
  printf((char const   * __restrict  )"random seed:              %d\n", seed);
#line 291
  if ((unsigned long )histfile != (unsigned long )((void *)0)) {
#line 291
    tmp___17 = (char const   *)histfile;
  } else {
#line 291
    tmp___17 = "[not saved]";
  }
#line 291
  printf((char const   * __restrict  )"histogram(s) saved to:    %s\n", tmp___17);
#line 293
  if (do_pvm) {
#line 294
    printf((char const   * __restrict  )"PVM:                      ACTIVE\n");
  } else
#line 295
  if (num_threads > 0) {
#line 296
    printf((char const   * __restrict  )"POSIX threads:            %d\n", num_threads);
  }
#line 297
  printf((char const   * __restrict  )"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n");
#line 307
  nhmm = 0;
#line 308
  tmp___18 = sre_malloc((char *)"hmmcalibrate.c", 308, sizeof(float ) * (unsigned long )mu_lumpsize);
#line 308
  mu = (float *)tmp___18;
#line 309
  tmp___19 = sre_malloc((char *)"hmmcalibrate.c", 309, sizeof(float ) * (unsigned long )mu_lumpsize);
#line 309
  lambda = (float *)tmp___19;
#line 311
  while (1) {
#line 311
    tmp___23 = HMMFileRead(hmmfp, & hmm);
#line 311
    if (! tmp___23) {
#line 311
      break;
    }
#line 313
    if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 314
      Die((char *)"HMM file may be corrupt or in incorrect format; parse failed");
    }
#line 316
    if (! do_pvm) {
#line 316
      if (num_threads == 0) {
#line 317
        main_loop_serial(hmm, seed, nsample, lenmean, lensd, fixedlen, & hist, & max);
      } else {
#line 333
        Die((char *)"wait. that can\'t happen. I didn\'t do anything.");
      }
    } else {
#line 333
      Die((char *)"wait. that can\'t happen. I didn\'t do anything.");
    }
#line 341
    tmp___20 = ExtremeValueFitHistogram(hist, 1, (float )9999.);
#line 341
    if (! tmp___20) {
#line 342
      Die((char *)"fit failed; --num may be set too small?\n");
    }
#line 344
    *(mu + nhmm) = hist->param[0];
#line 345
    *(lambda + nhmm) = hist->param[1];
#line 346
    nhmm ++;
#line 347
    if (nhmm % 100 == 0) {
#line 348
      tmp___21 = sre_realloc((char *)"hmmcalibrate.c", 348, (void *)mu, sizeof(float ) * (unsigned long )(nhmm + mu_lumpsize));
#line 348
      mu = (float *)tmp___21;
#line 349
      tmp___22 = sre_realloc((char *)"hmmcalibrate.c", 349, (void *)lambda, sizeof(float ) * (unsigned long )(nhmm + mu_lumpsize));
#line 349
      lambda = (float *)tmp___22;
    }
#line 354
    printf((char const   * __restrict  )"HMM    : %s\n", hmm->name);
#line 355
    printf((char const   * __restrict  )"mu     : %12f\n", (double )hist->param[0]);
#line 356
    printf((char const   * __restrict  )"lambda : %12f\n", (double )hist->param[1]);
#line 357
    printf((char const   * __restrict  )"max    : %12f\n", (double )max);
#line 358
    printf((char const   * __restrict  )"//\n");
#line 360
    if ((unsigned long )hfp != (unsigned long )((void *)0)) {
#line 362
      fprintf((FILE * __restrict  )hfp, (char const   * __restrict  )"HMM: %s\n",
              hmm->name);
#line 363
      PrintASCIIHistogram(hfp, hist);
#line 364
      fprintf((FILE * __restrict  )hfp, (char const   * __restrict  )"//\n");
    }
#line 367
    FreeHistogram(hist);
#line 368
    FreePlan7(hmm);
  }
#line 377
  HMMFileRewind(hmmfp);
#line 378
  tmp___24 = FileExists(tmpfile___0);
#line 378
  if (tmp___24) {
#line 379
    Die((char *)"Ouch. Temporary file %s appeared during the run.", tmpfile___0);
  }
#line 380
  outfp = fopen((char const   * __restrict  )tmpfile___0, (char const   * __restrict  )mode);
#line 380
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
#line 381
    Die((char *)"Ouch. Temporary file %s couldn\'t be opened for writing.", tmpfile___0);
  }
#line 383
  idx = 0;
#line 383
  while (idx < nhmm) {
#line 387
    tmp___25 = HMMFileRead(hmmfp, & hmm);
#line 387
    if (! tmp___25) {
#line 388
      Die((char *)"Ran out of HMMs too early in pass 2");
    }
#line 389
    if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 390
      Die((char *)"HMM file %s was corrupted? Parse failed in pass 2", hmmfile);
    }
#line 394
    hmm->mu = *(mu + idx);
#line 395
    hmm->lambda = *(lambda + idx);
#line 396
    hmm->flags |= 1 << 7;
#line 397
    Plan7ComlogAppend(hmm, argc, argv);
#line 401
    if (hmmfp->is_binary) {
#line 401
      WriteBinHMM(outfp, hmm);
    } else {
#line 402
      WriteAscHMM(outfp, hmm);
    }
#line 404
    FreePlan7(hmm);
#line 383
    idx ++;
  }
#line 414
  HMMFileClose(hmmfp);
#line 415
  tmp___26 = fclose(outfp);
#line 415
  if (tmp___26 != 0) {
#line 415
    Panic((char *)"hmmcalibrate.c", 415);
  }
#line 425
  free((void *)tmpfile___0);
#line 446
  free((void *)mu);
#line 447
  free((void *)lambda);
#line 448
  if ((unsigned long )hfp != (unsigned long )((void *)0)) {
#line 448
    fclose(hfp);
  }
#line 449
  SqdClean();
#line 450
  return (0);
}
}
#line 472 "hmmcalibrate.c"
static void main_loop_serial(struct plan7_s *hmm , int seed , int nsample , float lenmean ,
                             float lensd , int fixedlen , struct histogram_s **ret_hist ,
                             float *ret_max ) 
{ 
  struct histogram_s *hist ;
  struct dpmatrix_s *mx ;
  float randomseq[20] ;
  float p1 ;
  float max ;
  char *seq ;
  char *dsq ;
  float score ;
  int sqlen ;
  int idx ;
  double tmp ;
  int tmp___0 ;

  {
#line 492
  sre_srandom(seed);
#line 493
  P7Logoddsify(hmm, 1);
#line 494
  P7DefaultNullModel(randomseq, & p1);
#line 495
  hist = AllocHistogram(-200, 200, 100);
#line 496
  mx = CreatePlan7Matrix(1, hmm->M, 25, 0);
#line 497
  max = - 3.40282347e+38F;
#line 499
  idx = 0;
#line 499
  while (idx < nsample) {
#line 502
    if (fixedlen) {
#line 502
      sqlen = fixedlen;
    } else {
#line 503
      while (1) {
#line 503
        tmp = Gaussrandom((double )lenmean, (double )lensd);
#line 503
        sqlen = (int )tmp;
#line 503
        if (! (sqlen < 1)) {
#line 503
          break;
        }
      }
    }
#line 505
    seq = RandomSequence(Alphabet, randomseq, Alphabet_size, sqlen);
#line 506
    dsq = DigitizeSequence(seq, sqlen);
#line 508
    tmp___0 = P7ViterbiSize(sqlen, hmm->M);
#line 508
    if (tmp___0 <= 1000) {
#line 509
      score = P7Viterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)((void *)0));
    } else {
#line 511
      score = P7SmallViterbi(dsq, sqlen, hmm, mx, (struct p7trace_s **)((void *)0));
    }
#line 513
    AddToHistogram(hist, score);
#line 514
    if (score > max) {
#line 514
      max = score;
    }
#line 516
    free((void *)dsq);
#line 517
    free((void *)seq);
#line 499
    idx ++;
  }
#line 520
  FreePlan7Matrix(mx);
#line 521
  *ret_hist = hist;
#line 522
  *ret_max = max;
#line 523
  return;
}
}
#line 1 "hmmsearch.o"
#pragma merger("0","/tmp/cil-1JIlnsZY.i","")
#line 95 "./sqfuncs.h"
int Strparse(char *rexp , char *s___0 , int ntok ) ;
#line 158
void FreeSequence(char *seq , SQINFO *sqinfo ) ;
#line 166
SQFILE *SeqfileOpen(char *filename , int format , char *env ) ;
#line 171
void SeqfileClose(SQFILE *sqfp ) ;
#line 173
int ReadSeq(SQFILE *V , int format , char **ret_seq , SQINFO *sqinfo ) ;
#line 181
int String2SeqfileFormat(char *s___0 ) ;
#line 57 "./structs.h"
char Alphabet[25]  ;
#line 58 "./structs.h"
int Alphabet_type  ;
#line 59 "./structs.h"
int Alphabet_size  ;
#line 60 "./structs.h"
int Alphabet_iupac  ;
#line 61 "./structs.h"
char Degenerate[24][20]  ;
#line 62 "./structs.h"
int DegenCount[24]  ;
#line 160 "./funcs.h"
int XNU(char *dsq , int len ) ;
#line 185
int SetAutocuts(struct threshold_s *thresh___0 , struct plan7_s *hmm ) ;
#line 299
struct tophit_s *AllocTophits(int lumpsize ) ;
#line 301
void FreeTophits(struct tophit_s *h___0 ) ;
#line 312
void GetRankedHit(struct tophit_s *h___0 , int rank , double *r_pvalue , float *r_score ,
                  double *r_motherp , float *r_mothersc , char **r_name , char **r_acc ,
                  char **r_desc , int *r_sqfrom , int *r_sqto , int *r_sqlen , int *r_hmmfrom ,
                  int *r_hmmto , int *r_hmmlen , int *r_domidx , int *r_ndom , struct fancyali_s **r_ali ) ;
#line 320
int TophitsMaxName(struct tophit_s *h___0 ) ;
#line 321
void FullSortTophits(struct tophit_s *h___0 ) ;
#line 343
void PrintFancyAli(FILE *fp , struct fancyali_s *ali ) ;
#line 45 "hmmsearch.c"
static char banner___0[58]  = 
#line 45 "hmmsearch.c"
  {      (char )'h',      (char )'m',      (char )'m',      (char )'s', 
        (char )'e',      (char )'a',      (char )'r',      (char )'c', 
        (char )'h',      (char )' ',      (char )'-',      (char )' ', 
        (char )'s',      (char )'e',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )' ',      (char )'a', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )'d',      (char )'a', 
        (char )'t',      (char )'a',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'a',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'H',      (char )'M', 
        (char )'M',      (char )'\000'};
#line 47 "hmmsearch.c"
static char usage___0[382]  = 
#line 47
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'h', 
        (char )'m',      (char )'m',      (char )'s',      (char )'e', 
        (char )'a',      (char )'r',      (char )'c',      (char )'h', 
        (char )' ',      (char )'[',      (char )'-',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )']',      (char )' ', 
        (char )'<',      (char )'h',      (char )'m',      (char )'m', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'>',      (char )' ',      (char )'<',      (char )'s', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'n',      (char )'c',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )' ',      (char )'o',      (char )'r',      (char )' ', 
        (char )'d',      (char )'a',      (char )'t',      (char )'a', 
        (char )'b',      (char )'a',      (char )'s',      (char )'e', 
        (char )'>',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'A',      (char )'v',      (char )'a',      (char )'i', 
        (char )'l',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )' ',      (char )'o',      (char )'p', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'s',      (char )' ',      (char )'a',      (char )'r', 
        (char )'e',      (char )':',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'h', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )';',      (char )' ', 
        (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )' ',      (char )'b',      (char )'r', 
        (char )'i',      (char )'e',      (char )'f',      (char )' ', 
        (char )'h',      (char )'e',      (char )'l',      (char )'p', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'u',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'A',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'a',      (char )'l', 
        (char )'i',      (char )'g',      (char )'n',      (char )'m', 
        (char )'e',      (char )'n',      (char )'t',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'l', 
        (char )'i',      (char )'m',      (char )'i',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )'b',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'a',      (char )'l',      (char )'i',      (char )'g', 
        (char )'n',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )'s',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'E', 
        (char )' ',      (char )'<',      (char )'x',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )'s',      (char )' ',      (char )'E', 
        (char )' ',      (char )'v',      (char )'a',      (char )'l', 
        (char )'u',      (char )'e',      (char )' ',      (char )'c', 
        (char )'u',      (char )'t',      (char )'o',      (char )'f', 
        (char )'f',      (char )' ',      (char )'(',      (char )'g', 
        (char )'l',      (char )'o',      (char )'b',      (char )'E', 
        (char )')',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'<',      (char )'=',      (char )' ', 
        (char )'x',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'T',      (char )' ', 
        (char )'<',      (char )'x',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'T',      (char )' ', 
        (char )'b',      (char )'i',      (char )'t',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'(',      (char )'g', 
        (char )'l',      (char )'o',      (char )'b',      (char )'T', 
        (char )')',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'>',      (char )'=',      (char )' ', 
        (char )'x',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'Z',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'t', 
        (char )'s',      (char )' ',      (char )'Z',      (char )' ', 
        (char )'(',      (char )'#',      (char )' ',      (char )'s', 
        (char )'e',      (char )'q',      (char )'s',      (char )')', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'E',      (char )'-',      (char )'v', 
        (char )'a',      (char )'l',      (char )'u',      (char )'e', 
        (char )' ',      (char )'c',      (char )'a',      (char )'l', 
        (char )'c',      (char )'u',      (char )'l',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\n',      (char )'\000'};
#line 57 "hmmsearch.c"
static char experts___0[759]  = 
#line 57
  {      (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'a',      (char )'t',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'m',      (char )'a',      (char )'k',      (char )'e', 
        (char )' ',      (char )'b',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'e',      (char )'f', 
        (char )'f',      (char )'o',      (char )'r',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )' ', 
        (char )'l',      (char )'a',      (char )'s',      (char )'t', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )'\'',      (char )'s',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )'s',      (char )'t', 
        (char )'y',      (char )'l',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'c',      (char )'p',      (char )'u', 
        (char )' ',      (char )'<',      (char )'n',      (char )'>', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'r',      (char )'u',      (char )'n',      (char )' ', 
        (char )'<',      (char )'n',      (char )'>',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'s',      (char )' ', 
        (char )'i',      (char )'n',      (char )' ',      (char )'p', 
        (char )'a',      (char )'r',      (char )'a',      (char )'l', 
        (char )'l',      (char )'e',      (char )'l',      (char )' ', 
        (char )'(',      (char )'i',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'e',      (char )'d', 
        (char )')',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'g', 
        (char )'a',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'G', 
        (char )'A',      (char )' ',      (char )'g',      (char )'a', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'c',      (char )'u', 
        (char )'t',      (char )'o',      (char )'f',      (char )'f', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'n', 
        (char )'c',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'N', 
        (char )'C',      (char )' ',      (char )'n',      (char )'o', 
        (char )'i',      (char )'s',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'s',      (char )'h',      (char )'o',      (char )'l', 
        (char )'d',      (char )' ',      (char )'c',      (char )'u', 
        (char )'t',      (char )'o',      (char )'f',      (char )'f', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'c', 
        (char )'u',      (char )'t',      (char )'_',      (char )'t', 
        (char )'c',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'P',      (char )'f', 
        (char )'a',      (char )'m',      (char )' ',      (char )'T', 
        (char )'C',      (char )' ',      (char )'t',      (char )'r', 
        (char )'u',      (char )'s',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )'o',      (char )'l',      (char )'d',      (char )' ', 
        (char )'c',      (char )'u',      (char )'t',      (char )'o', 
        (char )'f',      (char )'f',      (char )'s',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'d',      (char )'o',      (char )'m', 
        (char )'E',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'E',      (char )'v',      (char )'a',      (char )'l', 
        (char )' ',      (char )'c',      (char )'u',      (char )'t', 
        (char )'o',      (char )'f',      (char )'f',      (char )' ', 
        (char )'(',      (char )'2',      (char )'n',      (char )'d', 
        (char )' ',      (char )'t',      (char )'h',      (char )'r', 
        (char )'e',      (char )'s',      (char )'h',      (char )'o', 
        (char )'l',      (char )'d',      (char )')',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'<', 
        (char )'=',      (char )' ',      (char )'x',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'d',      (char )'o',      (char )'m', 
        (char )'T',      (char )' ',      (char )'<',      (char )'x', 
        (char )'>',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'t',      (char )'s', 
        (char )' ',      (char )'d',      (char )'o',      (char )'m', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'T',      (char )' ',      (char )'b',      (char )'i', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )' ',      (char )'(',      (char )'2',      (char )'n', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'s',      (char )'h', 
        (char )'o',      (char )'l',      (char )'d',      (char )')', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'>',      (char )'=',      (char )' ',      (char )'x', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'f',      (char )'o', 
        (char )'r',      (char )'w',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'u',      (char )'l', 
        (char )'l',      (char )' ',      (char )'F',      (char )'o', 
        (char )'r',      (char )'w',      (char )'a',      (char )'r', 
        (char )'d',      (char )'(',      (char )')',      (char )' ', 
        (char )'a',      (char )'l',      (char )'g',      (char )'o', 
        (char )'r',      (char )'i',      (char )'t',      (char )'h', 
        (char )'m',      (char )' ',      (char )'i',      (char )'n', 
        (char )'s',      (char )'t',      (char )'e',      (char )'a', 
        (char )'d',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'V',      (char )'i',      (char )'t', 
        (char )'e',      (char )'r',      (char )'b',      (char )'i', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'i',      (char )'n', 
        (char )'f',      (char )'o',      (char )'r',      (char )'m', 
        (char )'a',      (char )'t',      (char )' ',      (char )'<', 
        (char )'s',      (char )'>',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'n',      (char )'c', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'t',      (char )' ', 
        (char )'<',      (char )'s',      (char )'>',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'n',      (char )'u',      (char )'l', 
        (char )'l',      (char )'2',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'t',      (char )'u',      (char )'r',      (char )'n', 
        (char )' ',      (char )'O',      (char )'F',      (char )'F', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'p',      (char )'o',      (char )'s', 
        (char )'t',      (char )' ',      (char )'h',      (char )'o', 
        (char )'c',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'n',      (char )'u',      (char )'l', 
        (char )'l',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'e',      (char )'l',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'p',      (char )'v',      (char )'m', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'r',      (char )'u',      (char )'n',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )' ',      (char )'P',      (char )'a',      (char )'r', 
        (char )'a',      (char )'l',      (char )'l',      (char )'e', 
        (char )'l',      (char )' ',      (char )'V',      (char )'i', 
        (char )'r',      (char )'t',      (char )'u',      (char )'a', 
        (char )'l',      (char )' ',      (char )'M',      (char )'a', 
        (char )'c',      (char )'h',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'(',      (char )'P', 
        (char )'V',      (char )'M',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'x',      (char )'n',      (char )'u', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'t',      (char )'u',      (char )'r',      (char )'n', 
        (char )' ',      (char )'O',      (char )'N',      (char )' ', 
        (char )'X',      (char )'N',      (char )'U',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'t', 
        (char )'e',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'t',      (char )' ', 
        (char )'p',      (char )'r',      (char )'o',      (char )'t', 
        (char )'e',      (char )'i',      (char )'n',      (char )' ', 
        (char )'s',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )'s',      (char )'\n',      (char )'\000'};
#line 72 "hmmsearch.c"
static struct opt_s OPTIONS___0[17]  = 
#line 72
  {      {(char *)"-h", 1, 0}, 
        {(char *)"-A", 1, 1}, 
        {(char *)"-E", 1, 2}, 
        {(char *)"-T", 1, 2}, 
        {(char *)"-Z", 1, 1}, 
        {(char *)"--compat", 0, 0}, 
        {(char *)"--cpu", 0, 1}, 
        {(char *)"--cut_ga", 0, 0}, 
        {(char *)"--cut_nc", 0, 0}, 
        {(char *)"--cut_tc", 0, 0}, 
        {(char *)"--domE", 0, 2}, 
        {(char *)"--domT", 0, 2}, 
        {(char *)"--forward", 0, 0}, 
        {(char *)"--informat", 0, 4}, 
        {(char *)"--null2", 0, 0}, 
        {(char *)"--pvm", 0, 0}, 
        {(char *)"--xnu", 0, 0}};
#line 95
static void main_loop_serial___0(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                                 int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                                 struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) ;
#line 99
static void main_loop_pvm(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                          int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                          struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) ;
#line 103
static void main_loop_threaded(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                               int do_forward , int do_null2 , int do_xnu , int num_threads ,
                               struct histogram_s *histogram , struct tophit_s *ghit ,
                               struct tophit_s *dhit , int *ret_nseq ) ;
#line 153 "hmmsearch.c"
int main(int argc , char **argv ) 
{ 
  char *hmmfile ;
  HMMFILE *hmmfp ;
  char *seqfile ;
  SQFILE *sqfp ;
  int format ;
  int i___0 ;
  struct plan7_s *hmm ;
  struct histogram_s *histogram ;
  struct fancyali_s *ali ;
  struct tophit_s *ghit ;
  struct tophit_s *dhit ;
  float sc ;
  double pvalue ;
  double evalue ;
  double motherp ;
  float mothersc ;
  int sqfrom ;
  int sqto ;
  int hmmfrom ;
  int hmmto ;
  char *name ;
  int sqlen ;
  int nseq ;
  int Z ;
  int domidx ;
  int ndom ;
  int namewidth ;
  int descwidth ;
  int nreported ;
  int Alimit ;
  struct threshold_s thresh___0 ;
  char *optname ;
  char *optarg___0 ;
  int optind___1 ;
  int do_null2 ;
  int do_forward ;
  int do_xnu ;
  int do_pvm ;
  int be_backwards ;
  int num_threads ;
  int threads_support ;
  int pvm_support ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 201
  if (argc != 3) {
#line 202
    tmp = hmmcalibrate(argc, argv);
#line 202
    return (tmp);
  }
#line 210
  format = 0;
#line 211
  do_forward = 0;
#line 212
  do_null2 = 1;
#line 213
  do_xnu = 0;
#line 214
  do_pvm = 0;
#line 215
  Z = 0;
#line 216
  be_backwards = 0;
#line 218
  pvm_support = 0;
#line 219
  threads_support = 0;
#line 220
  num_threads = 0;
#line 229
  Alimit = 2147483647;
#line 230
  thresh___0.globE = 10.0;
#line 231
  thresh___0.globT = - 3.40282347e+38F;
#line 232
  thresh___0.domT = - 3.40282347e+38F;
#line 233
  thresh___0.domE = (double )3.40282347e+38F;
#line 234
  thresh___0.autocut = (enum __anonenum_autocut_30 )0;
#line 235
  thresh___0.Z = 0;
#line 237
  while (1) {
#line 237
    tmp___19 = Getopt(argc, argv, OPTIONS___0, (int )(sizeof(OPTIONS___0) / sizeof(struct opt_s )),
                      usage___0, & optind___1, & optname, & optarg___0);
#line 237
    if (! tmp___19) {
#line 237
      break;
    }
#line 239
    tmp___18 = strcmp((char const   *)optname, "-A");
#line 239
    if (tmp___18 == 0) {
#line 239
      Alimit = atoi((char const   *)optarg___0);
    } else {
#line 240
      tmp___17 = strcmp((char const   *)optname, "-E");
#line 240
      if (tmp___17 == 0) {
#line 240
        thresh___0.globE = atof((char const   *)optarg___0);
      } else {
#line 241
        tmp___16 = strcmp((char const   *)optname, "-T");
#line 241
        if (tmp___16 == 0) {
#line 241
          tmp___0 = atof((char const   *)optarg___0);
#line 241
          thresh___0.globT = (float )tmp___0;
        } else {
#line 242
          tmp___15 = strcmp((char const   *)optname, "-Z");
#line 242
          if (tmp___15 == 0) {
#line 242
            thresh___0.Z = atoi((char const   *)optarg___0);
          } else {
#line 243
            tmp___14 = strcmp((char const   *)optname, "--compat");
#line 243
            if (tmp___14 == 0) {
#line 243
              be_backwards = 1;
            } else {
#line 244
              tmp___13 = strcmp((char const   *)optname, "--cpu");
#line 244
              if (tmp___13 == 0) {
#line 244
                num_threads = atoi((char const   *)optarg___0);
              } else {
#line 245
                tmp___12 = strcmp((char const   *)optname, "--cut_ga");
#line 245
                if (tmp___12 == 0) {
#line 245
                  thresh___0.autocut = (enum __anonenum_autocut_30 )1;
                } else {
#line 246
                  tmp___11 = strcmp((char const   *)optname, "--cut_nc");
#line 246
                  if (tmp___11 == 0) {
#line 246
                    thresh___0.autocut = (enum __anonenum_autocut_30 )2;
                  } else {
#line 247
                    tmp___10 = strcmp((char const   *)optname, "--cut_tc");
#line 247
                    if (tmp___10 == 0) {
#line 247
                      thresh___0.autocut = (enum __anonenum_autocut_30 )3;
                    } else {
#line 248
                      tmp___9 = strcmp((char const   *)optname, "--domE");
#line 248
                      if (tmp___9 == 0) {
#line 248
                        thresh___0.domE = atof((char const   *)optarg___0);
                      } else {
#line 249
                        tmp___8 = strcmp((char const   *)optname, "--domT");
#line 249
                        if (tmp___8 == 0) {
#line 249
                          tmp___1 = atof((char const   *)optarg___0);
#line 249
                          thresh___0.domT = (float )tmp___1;
                        } else {
#line 250
                          tmp___7 = strcmp((char const   *)optname, "--forward");
#line 250
                          if (tmp___7 == 0) {
#line 250
                            do_forward = 1;
                          } else {
#line 251
                            tmp___6 = strcmp((char const   *)optname, "--null2");
#line 251
                            if (tmp___6 == 0) {
#line 251
                              do_null2 = 0;
                            } else {
#line 252
                              tmp___5 = strcmp((char const   *)optname, "--pvm");
#line 252
                              if (tmp___5 == 0) {
#line 252
                                do_pvm = 1;
                              } else {
#line 253
                                tmp___4 = strcmp((char const   *)optname, "--xnu");
#line 253
                                if (tmp___4 == 0) {
#line 253
                                  do_xnu = 1;
                                } else {
#line 254
                                  tmp___3 = strcmp((char const   *)optname, "--informat");
#line 254
                                  if (tmp___3 == 0) {
#line 255
                                    format = String2SeqfileFormat(optarg___0);
#line 256
                                    if (format == 0) {
#line 257
                                      Die((char *)"unrecognized sequence file format \"%s\"",
                                          optarg___0);
                                    }
                                  } else {
#line 259
                                    tmp___2 = strcmp((char const   *)optname, "-h");
#line 259
                                    if (tmp___2 == 0) {
#line 260
                                      HMMERBanner(stdout, banner___0);
#line 261
                                      puts((char const   *)(usage___0));
#line 262
                                      puts((char const   *)(experts___0));
#line 263
                                      exit(0);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 266
  if (argc - optind___1 != 2) {
#line 267
    Die((char *)"Incorrect number of arguments.\n%s\n", usage___0);
  }
#line 269
  tmp___20 = optind___1;
#line 269
  optind___1 ++;
#line 269
  hmmfile = *(argv + tmp___20);
#line 270
  tmp___21 = optind___1;
#line 270
  optind___1 ++;
#line 270
  seqfile = *(argv + tmp___21);
#line 272
  if (do_pvm) {
#line 272
    if (! pvm_support) {
#line 273
      Die((char *)"PVM support is not compiled into your HMMER software; --pvm doesn\'t work.");
    }
  }
#line 274
  if (num_threads) {
#line 274
    if (! threads_support) {
#line 275
      Die((char *)"POSIX threads support is not compiled into HMMER; --cpu doesn\'t have any effect");
    }
  }
#line 280
  if (format == 0) {
#line 280
    tmp___22 = Strparse((char *)"^.*\\.gz$", seqfile, 0);
#line 280
    if (tmp___22) {
#line 282
      format = 7;
    } else {
#line 280
      tmp___23 = strcmp((char const   *)seqfile, "-");
#line 280
      if (tmp___23 == 0) {
#line 282
        format = 7;
      }
    }
  }
#line 288
  sqfp = SeqfileOpen(seqfile, format, (char *)"BLASTDB");
#line 288
  if ((unsigned long )sqfp == (unsigned long )((void *)0)) {
#line 289
    Die((char *)"Failed to open sequence database file %s\n%s\n", seqfile, usage___0);
  }
#line 297
  hmmfp = HMMFileOpen(hmmfile, (char *)"HMMERDB");
#line 297
  if ((unsigned long )hmmfp == (unsigned long )((void *)0)) {
#line 298
    Die((char *)"Failed to open HMM file %s\n%s", hmmfile, usage___0);
  }
#line 299
  tmp___24 = HMMFileRead(hmmfp, & hmm);
#line 299
  if (! tmp___24) {
#line 300
    Die((char *)"Failed to read any HMMs from %s\n", hmmfile);
  }
#line 301
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 302
    Die((char *)"HMM file %s corrupt or in incorrect format? Parse failed", hmmfile);
  }
#line 303
  P7Logoddsify(hmm, ! do_forward);
#line 305
  if (do_xnu) {
#line 305
    if (Alphabet_type == 2) {
#line 306
      Die((char *)"The HMM is a DNA model, and you can\'t use the --xnu filter on DNA data");
    }
  }
#line 313
  tmp___25 = SetAutocuts(& thresh___0, hmm);
#line 313
  if (! tmp___25) {
#line 314
    Die((char *)"HMM %s did not contain the GA, TC, or NC cutoffs you needed", hmm->name);
  }
#line 321
  HMMERBanner(stdout, banner___0);
#line 322
  printf((char const   * __restrict  )"HMM file:                   %s [%s]\n", hmmfile,
         hmm->name);
#line 323
  printf((char const   * __restrict  )"Sequence database:          %s\n", seqfile);
#line 324
  if (do_pvm) {
#line 325
    printf((char const   * __restrict  )"PVM:                        ACTIVE\n");
  }
#line 326
  printf((char const   * __restrict  )"per-sequence score cutoff:  ");
#line 327
  if (thresh___0.globT == - 3.40282347e+38F) {
#line 327
    printf((char const   * __restrict  )"[none]\n");
  } else {
#line 329
    printf((char const   * __restrict  )">= %.1f", (double )thresh___0.globT);
#line 330
    if ((unsigned int )thresh___0.autocut == 1U) {
#line 330
      printf((char const   * __restrict  )" [GA1]\n");
    } else
#line 331
    if ((unsigned int )thresh___0.autocut == 2U) {
#line 331
      printf((char const   * __restrict  )" [NC1]\n");
    } else
#line 332
    if ((unsigned int )thresh___0.autocut == 3U) {
#line 332
      printf((char const   * __restrict  )" [TC1]\n");
    } else {
#line 333
      printf((char const   * __restrict  )"\n");
    }
  }
#line 335
  printf((char const   * __restrict  )"per-domain score cutoff:    ");
#line 336
  if (thresh___0.domT == - 3.40282347e+38F) {
#line 336
    printf((char const   * __restrict  )"[none]\n");
  } else {
#line 338
    printf((char const   * __restrict  )">= %.1f", (double )thresh___0.domT);
#line 339
    if ((unsigned int )thresh___0.autocut == 1U) {
#line 339
      printf((char const   * __restrict  )" [GA2]\n");
    } else
#line 340
    if ((unsigned int )thresh___0.autocut == 2U) {
#line 340
      printf((char const   * __restrict  )" [NC2]\n");
    } else
#line 341
    if ((unsigned int )thresh___0.autocut == 3U) {
#line 341
      printf((char const   * __restrict  )" [TC2]\n");
    } else {
#line 342
      printf((char const   * __restrict  )"\n");
    }
  }
#line 344
  printf((char const   * __restrict  )"per-sequence Eval cutoff:   ");
#line 345
  if (thresh___0.globE == (double )3.40282347e+38F) {
#line 345
    printf((char const   * __restrict  )"[none]\n");
  } else {
#line 346
    printf((char const   * __restrict  )"<= %-10.2g\n", thresh___0.globE);
  }
#line 348
  printf((char const   * __restrict  )"per-domain Eval cutoff:     ");
#line 349
  if (thresh___0.domE == (double )3.40282347e+38F) {
#line 349
    printf((char const   * __restrict  )"[none]\n");
  } else {
#line 350
    printf((char const   * __restrict  )"<= %10.2g\n", thresh___0.domE);
  }
#line 351
  printf((char const   * __restrict  )"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
#line 358
  histogram = AllocHistogram(-200, 200, 100);
#line 359
  ghit = AllocTophits(200);
#line 360
  dhit = AllocTophits(200);
#line 362
  if (pvm_support) {
#line 362
    if (do_pvm) {
#line 363
      main_loop_pvm(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, histogram,
                    ghit, dhit, & nseq);
    } else {
#line 362
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 365
  if (threads_support) {
#line 365
    if (num_threads) {
#line 366
      main_loop_threaded(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, num_threads,
                         histogram, ghit, dhit, & nseq);
    } else {
#line 369
      main_loop_serial___0(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu,
                           histogram, ghit, dhit, & nseq);
    }
  } else {
#line 369
    main_loop_serial___0(hmm, sqfp, & thresh___0, do_forward, do_null2, do_xnu, histogram,
                         ghit, dhit, & nseq);
  }
#line 379
  if (hmm->flags & (1 << 7)) {
#line 380
    ExtremeValueSetHistogram(histogram, hmm->mu, hmm->lambda, (float )histogram->lowscore,
                             (float )histogram->highscore, 0);
  }
#line 382
  if (! thresh___0.Z) {
#line 382
    thresh___0.Z = nseq;
  }
#line 387
  if (be_backwards) {
#line 389
    if (hmm->flags & (1 << 1)) {
#line 389
      tmp___26 = (char const   *)hmm->desc;
    } else {
#line 389
      tmp___26 = "";
    }
#line 389
    if (hmm->flags & (1 << 9)) {
#line 389
      tmp___27 = (char const   *)hmm->acc;
    } else {
#line 389
      tmp___27 = "";
    }
#line 389
    printf((char const   * __restrict  )"\nQuery HMM: %s|%s|%s\n", hmm->name, tmp___27,
           tmp___26);
  } else {
#line 396
    printf((char const   * __restrict  )"\nQuery HMM:   %s\n", hmm->name);
#line 397
    if (hmm->flags & (1 << 9)) {
#line 397
      tmp___28 = (char const   *)hmm->acc;
    } else {
#line 397
      tmp___28 = "[none]";
    }
#line 397
    printf((char const   * __restrict  )"Accession:   %s\n", tmp___28);
#line 398
    if (hmm->flags & (1 << 1)) {
#line 398
      tmp___29 = (char const   *)hmm->desc;
    } else {
#line 398
      tmp___29 = "[none]";
    }
#line 398
    printf((char const   * __restrict  )"Description: %s\n", tmp___29);
  }
#line 401
  if (hmm->flags & (1 << 7)) {
#line 402
    printf((char const   * __restrict  )"  [HMM has been calibrated; E-values are empirical estimates]\n");
  } else {
#line 404
    printf((char const   * __restrict  )"  [No calibration for HMM; E-values are upper bounds]\n");
  }
#line 406
  FullSortTophits(ghit);
#line 407
  tmp___32 = TophitsMaxName(ghit);
#line 407
  if (8 > tmp___32) {
#line 407
    namewidth = 8;
  } else {
#line 407
    tmp___31 = TophitsMaxName(ghit);
#line 407
    namewidth = tmp___31;
  }
#line 408
  if (52 - namewidth > 11) {
#line 408
    descwidth = 52 - namewidth;
  } else {
#line 408
    descwidth = 11;
  }
#line 456
  FullSortTophits(dhit);
#line 457
  tmp___35 = TophitsMaxName(dhit);
#line 457
  if (8 > tmp___35) {
#line 457
    namewidth = 8;
  } else {
#line 457
    tmp___34 = TophitsMaxName(dhit);
#line 457
    namewidth = tmp___34;
  }
#line 503
  if (Alimit != 0) {
#line 505
    printf((char const   * __restrict  )"\nAlignments of top-scoring domains:\n");
#line 506
    i___0 = 0;
#line 506
    nreported = 0;
#line 506
    while (i___0 < dhit->num) {
#line 508
      if (nreported == Alimit) {
#line 508
        break;
      }
#line 509
      GetRankedHit(dhit, i___0, & pvalue, & sc, & motherp, & mothersc, & name, (char **)((void *)0),
                   (char **)((void *)0), & sqfrom, & sqto, & sqlen, & hmmfrom, & hmmto,
                   (int *)((void *)0), & domidx, & ndom, & ali);
#line 516
      evalue = pvalue * (double )thresh___0.Z;
#line 518
      if (! (motherp * (double )thresh___0.Z > thresh___0.globE)) {
#line 518
        if (mothersc < thresh___0.globT) {
#line 519
          goto __Cont;
        } else
#line 520
        if (evalue <= thresh___0.domE) {
#line 520
          if (sc >= thresh___0.domT) {
#line 522
            printf((char const   * __restrict  )"%s: domain %d of %d, from %d to %d: score %.1f, E = %.2g\n",
                   name, domidx, ndom, sqfrom, sqto, (double )sc, evalue);
#line 524
            PrintFancyAli(stdout, ali);
#line 525
            nreported ++;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 506
      i___0 ++;
    }
#line 528
    if (nreported == 0) {
#line 528
      printf((char const   * __restrict  )"\t[no hits above thresholds]\n");
    }
#line 529
    if (nreported == Alimit) {
#line 529
      printf((char const   * __restrict  )"\t[output cut off at A = %d top alignments]\n",
             Alimit);
    }
  }
#line 557
  printf((char const   * __restrict  )"\nTotal sequences searched: %d\n", nseq);
#line 562
  FreeHistogram(histogram);
#line 563
  HMMFileClose(hmmfp);
#line 564
  SeqfileClose(sqfp);
#line 565
  FreeTophits(ghit);
#line 566
  FreeTophits(dhit);
#line 567
  FreePlan7(hmm);
#line 568
  SqdClean();
#line 570
  return (0);
}
}
#line 597 "hmmsearch.c"
static void main_loop_serial___0(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                                 int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                                 struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) 
{ 
  struct dpmatrix_s *mx ;
  struct p7trace_s *tr ;
  char *seq ;
  char *dsq ;
  SQINFO sqinfo ;
  float sc ;
  double pvalue ;
  double evalue ;
  int nseq ;
  int tmp ;
  float tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 617
  mx = CreatePlan7Matrix(1, hmm->M, 25, 0);
#line 619
  nseq = 0;
#line 620
  while (1) {
#line 620
    tmp___3 = ReadSeq(sqfp, sqfp->format, & seq, & sqinfo);
#line 620
    if (! tmp___3) {
#line 620
      break;
    }
#line 626
    if (sqinfo.len == 0) {
#line 626
      continue;
    }
#line 628
    nseq ++;
#line 629
    dsq = DigitizeSequence(seq, sqinfo.len);
#line 631
    if (do_xnu) {
#line 631
      if (Alphabet_type == 3) {
#line 631
        XNU(dsq, sqinfo.len);
      }
    }
#line 639
    tmp = P7ViterbiSize(sqinfo.len, hmm->M);
#line 639
    if (tmp <= 1000) {
#line 640
      sc = P7Viterbi(dsq, sqinfo.len, hmm, mx, & tr);
    } else {
#line 642
      sc = P7SmallViterbi(dsq, sqinfo.len, hmm, mx, & tr);
    }
#line 648
    if (do_forward) {
#line 649
      sc = P7Forward(dsq, sqinfo.len, hmm, (struct dpmatrix_s **)((void *)0));
#line 650
      if (do_null2) {
#line 650
        tmp___0 = TraceScoreCorrection(hmm, tr, dsq);
#line 650
        sc -= tmp___0;
      }
    }
#line 665
    pvalue = PValue(hmm, sc);
#line 666
    if (thresh___0->Z) {
#line 666
      evalue = (double )thresh___0->Z * pvalue;
    } else {
#line 666
      evalue = (double )nseq * pvalue;
    }
#line 667
    if (sc >= thresh___0->globT) {
#line 667
      if (evalue <= thresh___0->globE) {
#line 669
        if (sqinfo.flags & (1 << 3)) {
#line 669
          tmp___1 = sqinfo.desc;
        } else {
#line 669
          tmp___1 = (char *)((void *)0);
        }
#line 669
        if (sqinfo.flags & (1 << 2)) {
#line 669
          tmp___2 = sqinfo.acc;
        } else {
#line 669
          tmp___2 = (char *)((void *)0);
        }
#line 669
        sc = PostprocessSignificantHit(ghit, dhit, tr, hmm, dsq, sqinfo.len, sqinfo.name,
                                       tmp___2, tmp___1, do_forward, sc, do_null2,
                                       thresh___0, 0);
      }
    }
#line 680
    AddToHistogram(histogram, sc);
#line 681
    FreeSequence(seq, & sqinfo);
#line 682
    P7FreeTrace(tr);
#line 683
    free((void *)dsq);
  }
#line 686
  FreePlan7Matrix(mx);
#line 687
  *ret_nseq = nseq;
#line 688
  return;
}
}
#line 931 "hmmsearch.c"
static void main_loop_pvm(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                          int do_forward , int do_null2 , int do_xnu , struct histogram_s *histogram ,
                          struct tophit_s *ghit , struct tophit_s *dhit , int *ret_nseq ) 
{ 


  {
#line 936
  Die((char *)"No PVM support");
#line 937
  return;
}
}
#line 1210 "hmmsearch.c"
static void main_loop_threaded(struct plan7_s *hmm , SQFILE *sqfp , struct threshold_s *thresh___0 ,
                               int do_forward , int do_null2 , int do_xnu , int num_threads ,
                               struct histogram_s *histogram , struct tophit_s *ghit ,
                               struct tophit_s *dhit , int *ret_nseq ) 
{ 


  {
#line 1216
  Die((char *)"No threads support");
#line 1217
  return;
}
}
#line 1 "mathsupport.o"
#pragma merger("0","/tmp/cil-YMIU6c_v.i","")
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 201 "./sqfuncs.h"
double Gammln(double x ) ;
#line 29 "./vectorops.h"
void FNorm(float *vec , int n ) ;
#line 170 "./funcs.h"
float LogSum(float p1 , float p2 ) ;
#line 172
void LogNorm(float *vec , int n ) ;
#line 173
float Logp_cvec(float *cvec , int n , float *alpha ) ;
#line 174
void SampleDirichlet(float *alpha , int n , float *p ) ;
#line 175
float SampleGamma(float alpha ) ;
#line 176
void SampleCountvector(float *p , int n , int c , float *cvec ) ;
#line 177
float P_PvecGivenDirichlet(float *p , int n , float *alpha ) ;
#line 43 "mathsupport.c"
int Prob2Score(float p , float null ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 46
  if ((double )p == 0.0) {
#line 46
    return (-987654321);
  } else {
#line 47
    if (p / null > (float )0) {
#line 47
      tmp = log((double )(p / null));
#line 47
      tmp___0 = tmp * 1.44269504;
    } else {
#line 47
      tmp___0 = - 9999.;
    }
#line 47
    tmp___1 = floor(0.5 + 1000.0 * tmp___0);
#line 47
    return ((int )tmp___1);
  }
}
}
#line 55 "mathsupport.c"
float Score2Prob(int sc , float null ) 
{ 
  double tmp ;

  {
#line 58
  if (sc == -987654321) {
#line 58
    return ((float )0.);
  } else {
#line 59
    tmp = exp(((double )((float )sc) / 1000.0) * 0.69314718);
#line 59
    return ((float )((double )null * tmp));
  }
}
}
#line 68 "mathsupport.c"
float Scorify(int sc ) 
{ 


  {
#line 71
  return ((float )((double )((float )sc) / 1000.0));
}
}
#line 88 "mathsupport.c"
double PValue(struct plan7_s *hmm , float sc ) 
{ 
  double pval ;
  double pval2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 95
  if (1.7976931348623157e+308 > (double )0) {
#line 95
    tmp___2 = log(1.7976931348623157e+308);
#line 95
    tmp___3 = tmp___2 * 1.44269504;
  } else {
#line 95
    tmp___3 = - 9999.;
  }
#line 95
  if ((double )sc >= tmp___3) {
#line 95
    pval = 0.0;
  } else {
#line 96
    if (1.7976931348623157e+308 > (double )0) {
#line 96
      tmp___0 = log(1.7976931348623157e+308);
#line 96
      tmp___1 = tmp___0 * 1.44269504;
    } else {
#line 96
      tmp___1 = - 9999.;
    }
#line 96
    if ((double )sc <= - 1. * tmp___1) {
#line 96
      pval = 1.0;
    } else {
#line 97
      tmp = exp((double )sc * 0.69314718);
#line 97
      pval = 1. / (1. + tmp);
    }
  }
#line 100
  if ((unsigned long )hmm != (unsigned long )((void *)0)) {
#line 100
    if (hmm->flags & (1 << 7)) {
#line 102
      pval2 = ExtremeValueP(sc, hmm->mu, hmm->lambda);
#line 103
      if (pval2 < pval) {
#line 103
        pval = pval2;
      }
    }
  }
#line 105
  return (pval);
}
}
#line 114 "mathsupport.c"
float LogSum(float p1 , float p2 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 117
  if (p1 > p2) {
#line 118
    if ((double )(p1 - p2) > 50.) {
#line 118
      tmp___1 = (double )p1;
    } else {
#line 118
      tmp = exp((double )(p2 - p1));
#line 118
      tmp___0 = log(1. + tmp);
#line 118
      tmp___1 = (double )p1 + tmp___0;
    }
#line 118
    return ((float )tmp___1);
  } else {
#line 120
    if ((double )(p2 - p1) > 50.) {
#line 120
      tmp___4 = (double )p2;
    } else {
#line 120
      tmp___2 = exp((double )(p1 - p2));
#line 120
      tmp___3 = log(1. + tmp___2);
#line 120
      tmp___4 = (double )p2 + tmp___3;
    }
#line 120
    return ((float )tmp___4);
  }
}
}
#line 147 "mathsupport.c"
static int ilogsum_lookup[20000]  ;
#line 148 "mathsupport.c"
static void init_ilogsum(void) 
{ 
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 152
  i___0 = 0;
#line 152
  while (i___0 < 20000) {
#line 153
    tmp = exp((0.69314718 * (double )((float )(- i___0))) / 1000.0);
#line 153
    tmp___0 = log(1. + tmp);
#line 153
    ilogsum_lookup[i___0] = (int )((1000.0 * 1.44269504) * tmp___0);
#line 152
    i___0 ++;
  }
#line 155
  return;
}
}
#line 164 "mathsupport.c"
static int firsttime  =    1;
#line 156 "mathsupport.c"
int ILogsum(int p1 , int p2 ) 
{ 
  int diff ;

  {
#line 165
  if (firsttime) {
#line 165
    init_ilogsum();
#line 165
    firsttime = 0;
  }
#line 168
  diff = p1 - p2;
#line 169
  if (diff >= 20000) {
#line 169
    return (p1);
  } else
#line 170
  if (diff <= -20000) {
#line 170
    return (p2);
  } else
#line 171
  if (diff > 0) {
#line 171
    return (p1 + ilogsum_lookup[diff]);
  } else {
#line 172
    return (p2 + ilogsum_lookup[- diff]);
  }
}
}
#line 184 "mathsupport.c"
void LogNorm(float *vec , int n ) 
{ 
  int x ;
  float max ;
  float denom ;
  double tmp ;
  double tmp___0 ;

  {
#line 188
  max = (float )(- 1.0e30);
#line 189
  denom = (float )0.;
#line 191
  x = 0;
#line 191
  while (x < n) {
#line 192
    if (*(vec + x) > max) {
#line 192
      max = *(vec + x);
    }
#line 191
    x ++;
  }
#line 193
  x = 0;
#line 193
  while (x < n) {
#line 194
    if ((double )*(vec + x) > (double )max - 50.) {
#line 195
      tmp = exp((double )(*(vec + x) - max));
#line 195
      denom = (float )((double )denom + tmp);
    }
#line 193
    x ++;
  }
#line 196
  x = 0;
#line 196
  while (x < n) {
#line 197
    if ((double )*(vec + x) > (double )max - 50.) {
#line 198
      tmp___0 = exp((double )(*(vec + x) - max));
#line 198
      *(vec + x) = (float )(tmp___0 / (double )denom);
    } else {
#line 200
      *(vec + x) = (float )0.0;
    }
#line 196
    x ++;
  }
#line 201
  return;
}
}
#line 216 "mathsupport.c"
float Logp_cvec(float *cvec , int n , float *alpha ) 
{ 
  float lnp ;
  float sum1 ;
  float sum2 ;
  float sum3 ;
  int x ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 223
  lnp = (float )0.0;
#line 223
  sum3 = lnp;
#line 223
  sum2 = sum3;
#line 223
  sum1 = sum2;
#line 224
  x = 0;
#line 224
  while (x < n) {
#line 226
    sum1 += *(cvec + x) + *(alpha + x);
#line 227
    sum2 += *(alpha + x);
#line 228
    sum3 += *(cvec + x);
#line 229
    tmp = Gammln((double )(*(alpha + x) + *(cvec + x)));
#line 229
    lnp = (float )((double )lnp + tmp);
#line 230
    tmp___0 = Gammln((double )*(cvec + x) + 1.);
#line 230
    lnp = (float )((double )lnp - tmp___0);
#line 231
    tmp___1 = Gammln((double )*(alpha + x));
#line 231
    lnp = (float )((double )lnp - tmp___1);
#line 224
    x ++;
  }
#line 233
  tmp___2 = Gammln((double )sum1);
#line 233
  lnp = (float )((double )lnp - tmp___2);
#line 234
  tmp___3 = Gammln((double )sum2);
#line 234
  lnp = (float )((double )lnp + tmp___3);
#line 235
  tmp___4 = Gammln((double )sum3 + 1.);
#line 235
  lnp = (float )((double )lnp + tmp___4);
#line 236
  return (lnp);
}
}
#line 256 "mathsupport.c"
void SampleDirichlet(float *alpha , int n , float *p ) 
{ 
  int x ;

  {
#line 261
  x = 0;
#line 261
  while (x < n) {
#line 262
    *(p + x) = SampleGamma(*(alpha + x));
#line 261
    x ++;
  }
#line 263
  FNorm(p, n);
#line 264
  return;
}
}
#line 280 "mathsupport.c"
float SampleGamma(float alpha ) 
{ 
  float U ;
  float V ;
  float X ;
  float W ;
  float lambda ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;

  {
#line 285
  if ((double )alpha >= 1.0) {
#line 287
    while (1) {
#line 289
      tmp = sqrt(2.0 * (double )alpha - 1.0);
#line 289
      lambda = (float )tmp;
#line 290
      tmp___0 = sre_random();
#line 290
      U = (float )tmp___0;
#line 291
      V = U / ((float )1 - U);
#line 292
      tmp___1 = pow((double )V, (double )((float )1 / lambda));
#line 292
      X = (float )((double )alpha * tmp___1);
#line 293
      tmp___2 = exp((double )(- X + alpha));
#line 293
      tmp___3 = pow((double )V, 1.0 + (double )(alpha / lambda));
#line 293
      tmp___4 = pow(1.0 + 1.0 / (double )V, 2.0);
#line 293
      W = (float )(((.25 * tmp___2) * tmp___3) * tmp___4);
#line 294
      tmp___5 = sre_random();
#line 294
      if (tmp___5 <= (double )W) {
#line 295
        return (X);
      }
    }
  } else
#line 298
  if ((double )alpha > 0.0) {
#line 300
    while (1) {
#line 302
      tmp___6 = sre_random();
#line 302
      U = (float )tmp___6;
#line 303
      tmp___7 = exp(1.0);
#line 303
      V = (float )((double )U * ((double )1 + (double )alpha / tmp___7));
#line 304
      if ((double )V > 1.0) {
#line 306
        tmp___8 = exp(1.0);
#line 306
        tmp___9 = log(((double )((float )1 - V) + (double )alpha / tmp___8) / (double )alpha);
#line 306
        X = (float )(- tmp___9);
#line 307
        tmp___10 = sre_random();
#line 307
        tmp___11 = pow((double )X, (double )alpha - 1.0);
#line 307
        if (tmp___10 <= tmp___11) {
#line 308
          return (X);
        }
      } else {
#line 312
        tmp___12 = pow((double )V, 1.0 / (double )alpha);
#line 312
        X = (float )tmp___12;
#line 313
        tmp___13 = sre_random();
#line 313
        tmp___14 = exp((double )(- X));
#line 313
        if (tmp___13 <= tmp___14) {
#line 314
          return (X);
        }
      }
    }
  }
#line 318
  Die((char *)"Invalid argument alpha < 0.0 to SampleGamma()");
#line 320
  return ((float )0.0);
}
}
#line 329 "mathsupport.c"
void SampleCountvector(float *p , int n , int c , float *cvec ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 334
  FSet(cvec, n, (float )0.0);
#line 335
  i___0 = 0;
#line 335
  while (i___0 < c) {
#line 336
    tmp = FChoose(p, n);
#line 336
    *(cvec + tmp) = (float )((double )*(cvec + tmp) + 1.0);
#line 335
    i___0 ++;
  }
#line 337
  return;
}
}
#line 349 "mathsupport.c"
float P_PvecGivenDirichlet(float *p , int n , float *alpha ) 
{ 
  float sum ;
  float logp ;
  int x ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 356
  logp = (float )0.0;
#line 356
  sum = logp;
#line 357
  x = 0;
#line 357
  while (x < n) {
#line 358
    if ((double )*(p + x) > 0.0) {
#line 360
      tmp = log((double )*(p + x));
#line 360
      logp = (float )((double )logp + ((double )*(alpha + x) - 1.0) * tmp);
#line 361
      tmp___0 = Gammln((double )*(alpha + x));
#line 361
      logp = (float )((double )logp - tmp___0);
#line 362
      sum += *(alpha + x);
    }
#line 357
    x ++;
  }
#line 364
  tmp___1 = Gammln((double )sum);
#line 364
  logp = (float )((double )logp + tmp___1);
#line 365
  return (logp);
}
}
#line 1 "masks.o"
#pragma merger("0","/tmp/cil-uKvI5Nxi.i","")
#line 15 "./vectorops.h"
void FAdd(float *vec1 , float *vec2 , int n ) ;
#line 225 "./funcs.h"
int DegenerateSymbolScore(float *p , float *null , int ambig ) ;
#line 43 "masks.c"
static int xpam120[23][23]  = 
#line 43 "masks.c"
  { {        3,        -3,        0,        0, 
            -4,        1,        -3,        -1, 
            -2,        -3,        -2,        -1, 
            1,        -1,        -3,        1, 
            1,        0,        -7,        -4, 
            1,        0,        0}, 
   {        -3,        9,        -7,        -7, 
            -6,        -4,        -4,        -3, 
            -7,        -7,        -6,        -5, 
            -4,        -7,        -4,        0, 
            -3,        -3,        -8,        -1, 
            -4,        -6,        0}, 
   {        0,        -7,        5,        3, 
            -7,        0,        0,        -3, 
            -1,        -5,        -4,        2, 
            -3,        1,        -3,        0, 
            -1,        -3,        -8,        -5, 
            5,        3,        0}, 
   {        0,        -7,        3,        5, 
            -7,        -1,        -1,        -3, 
            -1,        -4,        -3,        1, 
            -2,        2,        -3,        -1, 
            -2,        -3,        -8,        -5, 
            3,        5,        0}, 
   {        -4,        -6,        -7,        -7, 
            8,        -5,        -3,        0, 
            -7,        0,        -1,        -4, 
            -5,        -6,        -5,        -3, 
            -4,        -3,        -1,        4, 
            -4,        -5,        0}, 
   {        1,        -4,        0,        -1, 
            -5,        5,        -4,        -4, 
            -3,        -5,        -4,        0, 
            -2,        -3,        -4,        1, 
            -1,        -2,        -8,        -6, 
            1,        -1,        0}, 
   {        -3,        -4,        0,        -1, 
            -3,        -4,        7,        -4, 
            -2,        -3,        -4,        2, 
            -1,        3,        1,        -2, 
            -3,        -3,        -3,        -1, 
            2,        2,        0}, 
   {        -1,        -3,        -3,        -3, 
            0,        -4,        -4,        6, 
            -3,        1,        1,        -2, 
            -3,        -3,        -2,        -2, 
            0,        3,        -6,        -2, 
            -2,        -2,        0}, 
   {        -2,        -7,        -1,        -1, 
            -7,        -3,        -2,        -3, 
            5,        -4,        0,        1, 
            -2,        0,        2,        -1, 
            -1,        -4,        -5,        -5, 
            1,        0,        0}, 
   {        -3,        -7,        -5,        -4, 
            0,        -5,        -3,        1, 
            -4,        5,        3,        -4, 
            -3,        -2,        -4,        -4, 
            -3,        1,        -3,        -2, 
            -3,        -2,        0}, 
   {        -2,        -6,        -4,        -3, 
            -1,        -4,        -4,        1, 
            0,        3,        8,        -3, 
            -3,        -1,        -1,        -2, 
            -1,        1,        -6,        -4, 
            -3,        -1,        0}, 
   {        -1,        -5,        2,        1, 
            -4,        0,        2,        -2, 
            1,        -4,        -3,        4, 
            -2,        0,        -1,        1, 
            0,        -3,        -4,        -2, 
            4,        1,        0}, 
   {        1,        -4,        -3,        -2, 
            -5,        -2,        -1,        -3, 
            -2,        -3,        -3,        -2, 
            6,        0,        -1,        1, 
            -1,        -2,        -7,        -6, 
            -1,        0,        0}, 
   {        -1,        -7,        1,        2, 
            -6,        -3,        3,        -3, 
            0,        -2,        -1,        0, 
            0,        6,        1,        -2, 
            -2,        -3,        -6,        -5, 
            1,        5,        0}, 
   {        -3,        -4,        -3,        -3, 
            -5,        -4,        1,        -2, 
            2,        -4,        -1,        -1, 
            -1,        1,        6,        -1, 
            -2,        -3,        1,        -5, 
            -1,        0,        0}, 
   {        1,        0,        0,        -1, 
            -3,        1,        -2,        -2, 
            -1,        -4,        -2,        1, 
            1,        -2,        -1,        3, 
            2,        -2,        -2,        -3, 
            1,        0,        0}, 
   {        1,        -3,        -1,        -2, 
            -4,        -1,        -3,        0, 
            -1,        -3,        -1,        0, 
            -1,        -2,        -2,        2, 
            4,        0,        -6,        -3, 
            1,        -1,        0}, 
   {        0,        -3,        -3,        -3, 
            -3,        -2,        -3,        3, 
            -4,        1,        1,        -3, 
            -2,        -3,        -3,        -2, 
            0,        5,        -8,        -3, 
            -2,        -2,        0}, 
   {        -7,        -8,        -8,        -8, 
            -1,        -8,        -3,        -6, 
            -5,        -3,        -6,        -4, 
            -7,        -6,        1,        -2, 
            -6,        -8,        12,        -2, 
            -5,        -6,        0}, 
   {        -4,        -1,        -5,        -5, 
            4,        -6,        -1,        -2, 
            -5,        -2,        -4,        -2, 
            -6,        -5,        -5,        -3, 
            -3,        -3,        -2,        8, 
            -2,        -4,        0}, 
   {        1,        -4,        5,        3, 
            -4,        1,        2,        -2, 
            1,        -3,        -3,        4, 
            -1,        1,        -1,        1, 
            1,        -2,        -5,        -2, 
            6,        4,        0}, 
   {        0,        -6,        3,        5, 
            -5,        -1,        2,        -2, 
            0,        -2,        -1,        1, 
            0,        5,        0,        0, 
            -1,        -2,        -6,        -4, 
            4,        6,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0}};
#line 83 "masks.c"
int XNU(char *dsq , int len ) 
{ 
  int i___0 ;
  int k ;
  int off ;
  int sum ;
  int beg ;
  int end ;
  int top ;
  int topcut ;
  int fallcut ;
  double s0 ;
  int noff ;
  int mcut ;
  double pcut ;
  int *hit ;
  double lambda ;
  double K ;
  double H ;
  int xnum ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 89
  noff = 4;
#line 90
  mcut = 1;
#line 91
  pcut = 0.01;
#line 93
  lambda = 0.346574;
#line 94
  K = 0.2;
#line 95
  H = 0.664;
#line 96
  xnum = 0;
#line 98
  if (len == 0) {
#line 98
    return (0);
  }
#line 100
  tmp = sre_malloc((char *)"masks.c", 100, sizeof(int ) * (unsigned long )(len + 1));
#line 100
  hit = (int *)tmp;
#line 101
  i___0 = 1;
#line 101
  while (i___0 <= len) {
#line 101
    *(hit + i___0) = 0;
#line 101
    i___0 ++;
  }
#line 108
  tmp___0 = log((pcut * H) / ((double )noff * K));
#line 108
  s0 = - tmp___0 / lambda;
#line 109
  if (s0 > (double )0) {
#line 109
    tmp___1 = log(s0);
#line 109
    tmp___2 = floor((s0 + tmp___1 / lambda) + 0.5);
#line 109
    topcut = (int )tmp___2;
  } else {
#line 110
    topcut = 0;
  }
#line 111
  tmp___3 = log(K / 0.001);
#line 111
  fallcut = (int )((double )((int )tmp___3) / lambda);
#line 113
  off = mcut;
#line 113
  while (off <= noff) {
#line 114
    top = 0;
#line 114
    sum = top;
#line 115
    beg = off;
#line 116
    end = 0;
#line 118
    i___0 = off + 1;
#line 118
    while (i___0 <= len) {
#line 119
      sum += xpam120[(int )*(dsq + i___0)][(int )*(dsq + (i___0 - off))];
#line 120
      if (sum > top) {
#line 121
        top = sum;
#line 122
        end = i___0;
      }
#line 124
      if (top >= topcut) {
#line 124
        if (top - sum > fallcut) {
#line 125
          k = beg;
#line 125
          while (k <= end) {
#line 126
            tmp___4 = 1;
#line 126
            *(hit + (k - off)) = tmp___4;
#line 126
            *(hit + k) = tmp___4;
#line 125
            k ++;
          }
#line 127
          top = 0;
#line 127
          sum = top;
#line 128
          end = i___0 + 1;
#line 128
          beg = end;
        } else {
#line 124
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 129
      if (top - sum > fallcut) {
#line 130
        top = 0;
#line 130
        sum = top;
#line 131
        end = i___0 + 1;
#line 131
        beg = end;
      }
#line 133
      if (sum < 0) {
#line 134
        end = i___0 + 1;
#line 134
        beg = end;
#line 135
        top = 0;
#line 135
        sum = top;
      }
#line 118
      i___0 ++;
    }
#line 138
    if (top >= topcut) {
#line 139
      k = beg;
#line 139
      while (k <= end) {
#line 140
        tmp___5 = 1;
#line 140
        *(hit + (k - off)) = tmp___5;
#line 140
        *(hit + k) = tmp___5;
#line 139
        k ++;
      }
    }
#line 113
    off ++;
  }
#line 146
  i___0 = 1;
#line 146
  while (i___0 <= len) {
#line 147
    if (*(hit + i___0)) {
#line 147
      xnum ++;
#line 147
      *(dsq + i___0) = (char )(Alphabet_iupac - 1);
    }
#line 146
    i___0 ++;
  }
#line 149
  free((void *)hit);
#line 150
  return (xnum);
}
}
#line 167 "masks.c"
float TraceScoreCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) 
{ 
  float p[20] ;
  int sc[24] ;
  int x ;
  int tpos ;
  int score ;
  int tmp ;
  float tmp___0 ;

  {
#line 178
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
#line 178
    return ((float )0.0);
  }
#line 183
  FSet(p, Alphabet_size, (float )0.0);
#line 184
  tpos = 0;
#line 184
  while (tpos < tr->tlen) {
#line 185
    if ((int )*(tr->statetype + tpos) == 1) {
#line 186
      FAdd(p, *(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
    } else
#line 187
    if ((int )*(tr->statetype + tpos) == 3) {
#line 188
      FAdd(p, *(hmm->ins + *(tr->nodeidx + tpos)), Alphabet_size);
    }
#line 184
    tpos ++;
  }
#line 189
  FNorm(p, Alphabet_size);
#line 191
  x = 0;
#line 191
  while (x < Alphabet_size) {
#line 192
    sc[x] = Prob2Score(p[x], hmm->null[x]);
#line 191
    x ++;
  }
#line 195
  x = Alphabet_size;
#line 195
  while (x < Alphabet_iupac) {
#line 196
    sc[x] = DegenerateSymbolScore(p, hmm->null, x);
#line 195
    x ++;
  }
#line 201
  score = 0;
#line 202
  tpos = 0;
#line 202
  while (tpos < tr->tlen) {
#line 203
    if ((int )*(tr->statetype + tpos) == 1) {
#line 204
      score += sc[(int )*(dsq + *(tr->pos + tpos))];
    } else
#line 203
    if ((int )*(tr->statetype + tpos) == 3) {
#line 204
      score += sc[(int )*(dsq + *(tr->pos + tpos))];
    }
#line 202
    tpos ++;
  }
#line 210
  score = (int )((double )score - (double )8 * 1000.0);
#line 214
  tmp = ILogsum(0, score);
#line 214
  tmp___0 = Scorify(tmp);
#line 214
  return (tmp___0);
}
}
#line 365 "masks.c"
float SantaCruzCorrection(struct plan7_s *hmm , struct p7trace_s *tr , char *dsq ) 
{ 


  {
#line 368
  return ((float )0.0);
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-VBRhdbAN.i","")
#line 249 "./sqfuncs.h"
int IsInt(char *s___0 ) ;
#line 250
int IsReal(char *s___0 ) ;
#line 54 "misc.c"
void HMMERBanner(FILE *fp , char *banner___1 ) 
{ 


  {
#line 57
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", banner___1);
#line 58
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s %s (%s)\n", "HMMER",
          "2.3", "May 2003");
#line 59
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", "Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
#line 60
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", "Freely distributed under the GNU General Public License (GPL)");
#line 61
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
#line 62
  return;
}
}
#line 78 "misc.c"
static char buffer___0[512]  ;
#line 79 "misc.c"
static char *sptr  =    (char *)((void *)0);
#line 75 "misc.c"
char *Getword(FILE *fp , int type ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 81
  if ((unsigned long )sptr != (unsigned long )((void *)0)) {
#line 81
    sptr = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
  }
#line 83
  while ((unsigned long )sptr == (unsigned long )((void *)0)) {
#line 85
    sptr = fgets((char * __restrict  )(buffer___0), 512, (FILE * __restrict  )fp);
#line 85
    if ((unsigned long )sptr == (unsigned long )((void *)0)) {
#line 85
      return ((char *)((void *)0));
    }
#line 86
    sptr = strchr((char const   *)(buffer___0), '#');
#line 86
    if ((unsigned long )sptr != (unsigned long )((void *)0)) {
#line 86
      *sptr = (char )'\000';
    }
#line 87
    sptr = strtok((char * __restrict  )(buffer___0), (char const   * __restrict  )" \t\n");
  }
#line 90
  switch (type) {
  case 4: 
#line 92
  tmp = strlen((char const   *)sptr);
#line 92
  if (tmp == 0UL) {
#line 93
    Warn((char *)"Parse failed: expected string, got nothing");
#line 94
    sptr = (char *)((void *)0);
  }
#line 96
  break;
  case 1: 
#line 98
  tmp___0 = IsInt(sptr);
#line 98
  if (! tmp___0) {
#line 99
    Warn((char *)"Parse failed: expected integer, got %s", sptr);
#line 100
    sptr = (char *)((void *)0);
  }
#line 102
  break;
  case 2: 
#line 104
  tmp___1 = IsReal(sptr);
#line 104
  if (! tmp___1) {
#line 105
    Warn((char *)"Parse failed: expected real value, got %s", sptr);
#line 106
    sptr = (char *)((void *)0);
  }
#line 108
  break;
  }
#line 111
  return (sptr);
}
}
#line 128 "misc.c"
char *Getline(char *s___0 , int n , FILE *fp ) 
{ 
  char *first ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 133
  while (1) {
#line 134
    tmp = fgets((char * __restrict  )s___0, n, (FILE * __restrict  )fp);
#line 134
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 134
      return ((char *)((void *)0));
    }
#line 135
    first = s___0;
#line 135
    while (1) {
#line 135
      tmp___0 = __ctype_b_loc();
#line 135
      if (! ((int const   )*(*tmp___0 + (int )*first) & 8192)) {
#line 135
        break;
      }
#line 135
      first ++;
    }
#line 133
    if (! ((int )*first == 35)) {
#line 133
      if (! ((int )*first == 0)) {
#line 133
        break;
      }
    }
  }
#line 137
  return (s___0);
}
}
#line 157 "misc.c"
int SetAutocuts(struct threshold_s *thresh___0 , struct plan7_s *hmm ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 160
  if ((unsigned int )thresh___0->autocut == 1U) {
#line 161
    if (! (hmm->flags & (1 << 10))) {
#line 161
      return (0);
    }
#line 162
    thresh___0->globT = hmm->ga1;
#line 163
    thresh___0->domT = hmm->ga2;
#line 164
    tmp = (double )3.40282347e+38F;
#line 164
    thresh___0->domE = tmp;
#line 164
    thresh___0->globE = tmp;
  } else
#line 165
  if ((unsigned int )thresh___0->autocut == 2U) {
#line 166
    if (! (hmm->flags & (1 << 12))) {
#line 166
      return (0);
    }
#line 167
    thresh___0->globT = hmm->nc1;
#line 168
    thresh___0->domT = hmm->nc2;
#line 169
    tmp___0 = (double )3.40282347e+38F;
#line 169
    thresh___0->domE = tmp___0;
#line 169
    thresh___0->globE = tmp___0;
  } else
#line 170
  if ((unsigned int )thresh___0->autocut == 3U) {
#line 171
    if (! (hmm->flags & (1 << 11))) {
#line 171
      return (0);
    }
#line 172
    thresh___0->globT = hmm->tc1;
#line 173
    thresh___0->domT = hmm->tc2;
#line 174
    tmp___1 = (double )3.40282347e+38F;
#line 174
    thresh___0->domE = tmp___1;
#line 174
    thresh___0->globE = tmp___1;
  }
#line 176
  return (1);
}
}
#line 1 "modelmakers.o"
#pragma merger("0","/tmp/cil-Uf6wSqQQ.i","")
#line 243 "./msa.h"
char *MSAGetGC(MSA *msa , char *tag ) ;
#line 48 "./sqfuncs.h"
int DealignedLength(char *aseq ) ;
#line 19 "./vectorops.h"
float FDot(float *vec1 , float *vec2 , int n ) ;
#line 190 "./funcs.h"
void P7Handmodelmaker(MSA *msa , char **dsq , struct plan7_s **ret_hmm , struct p7trace_s ***ret_tr ) ;
#line 192
void P7Fastmodelmaker(MSA *msa , char **dsq , float maxgap , struct plan7_s **ret_hmm ,
                      struct p7trace_s ***ret_tr ) ;
#line 195
void P7Maxmodelmaker(MSA *msa , char **dsq , float maxgap , struct p7prior_s *prior ,
                     float *null , float null_p1 , float mpri , struct plan7_s **ret_hmm ,
                     struct p7trace_s ***ret_tr ) ;
#line 204
struct plan7_s *AllocPlan7(int M ) ;
#line 264
void P7PriorifyTransitionVector(float *t___0 , struct p7prior_s *prior , float *tq ) ;
#line 266
void P7PriorifyEmissionVector(float *vec , struct p7prior_s *pri , int num , float *eq ,
                              float (*e)[20] , float *ret_mix ) ;
#line 333
void P7TraceCount(struct plan7_s *hmm , char *dsq , float wt , struct p7trace_s *tr ) ;
#line 60 "modelmakers.c"
static int build_cij(char **aseqs , int nseq , int *insopt , int i___0 , int j , float *wgt ,
                     float *cij ) ;
#line 62
static int estimate_model_length(MSA *msa ) ;
#line 63
static void matassign2hmm(MSA *msa , char **dsq , int *matassign , struct plan7_s **ret_hmm ,
                          struct p7trace_s ***ret_tr ) ;
#line 66
static void fake_tracebacks(char **aseq , int nseq , int alen , int *matassign , struct p7trace_s ***ret_tr ) ;
#line 68
static void trace_doctor(struct p7trace_s *tr , int mlen , int *ret_ndi , int *ret_nid ) ;
#line 70
static void annotate_model(struct plan7_s *hmm , int *matassign , MSA *msa ) ;
#line 99 "modelmakers.c"
void P7Handmodelmaker(MSA *msa , char **dsq , struct plan7_s **ret_hmm , struct p7trace_s ***ret_tr ) 
{ 
  int *matassign ;
  int apos ;
  void *tmp ;

  {
#line 107
  if ((unsigned long )msa->rf == (unsigned long )((void *)0)) {
#line 108
    Die((char *)"Alignment must have RF annotation to hand-build an HMM");
  }
#line 111
  tmp = sre_malloc((char *)"modelmakers.c", 111, sizeof(int ) * (unsigned long )(msa->alen + 1));
#line 111
  matassign = (int *)tmp;
#line 115
  *(matassign + 0) = 0;
#line 116
  apos = 0;
#line 116
  while (apos < msa->alen) {
#line 118
    *(matassign + (apos + 1)) = 0;
#line 119
    if ((int )*(msa->rf + apos) == 32) {
#line 122
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
#line 119
    if ((int )*(msa->rf + apos) == 46) {
#line 122
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
#line 119
    if ((int )*(msa->rf + apos) == 95) {
#line 122
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
#line 119
    if ((int )*(msa->rf + apos) == 45) {
#line 122
      *(matassign + (apos + 1)) |= 1 << 3;
    } else
#line 119
    if ((int )*(msa->rf + apos) == 126) {
#line 122
      *(matassign + (apos + 1)) |= 1 << 3;
    } else {
#line 120
      *(matassign + (apos + 1)) |= 1;
    }
#line 116
    apos ++;
  }
#line 128
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
#line 130
  free((void *)matassign);
#line 131
  return;
}
}
#line 161 "modelmakers.c"
void P7Fastmodelmaker(MSA *msa , char **dsq , float maxgap , struct plan7_s **ret_hmm ,
                      struct p7trace_s ***ret_tr ) 
{ 
  int *matassign ;
  int idx ;
  int apos ;
  int ngap ;
  void *tmp ;

  {
#line 172
  tmp = sre_malloc((char *)"modelmakers.c", 172, sizeof(int ) * (unsigned long )(msa->alen + 1));
#line 172
  matassign = (int *)tmp;
#line 176
  *(matassign + 0) = 0;
#line 177
  apos = 0;
#line 177
  while (apos < msa->alen) {
#line 178
    *(matassign + (apos + 1)) = 0;
#line 180
    ngap = 0;
#line 181
    idx = 0;
#line 181
    while (idx < msa->nseq) {
#line 182
      if ((int )*(*(msa->aseq + idx) + apos) == 32) {
#line 183
        ngap ++;
      } else
#line 182
      if ((int )*(*(msa->aseq + idx) + apos) == 46) {
#line 183
        ngap ++;
      } else
#line 182
      if ((int )*(*(msa->aseq + idx) + apos) == 95) {
#line 183
        ngap ++;
      } else
#line 182
      if ((int )*(*(msa->aseq + idx) + apos) == 45) {
#line 183
        ngap ++;
      } else
#line 182
      if ((int )*(*(msa->aseq + idx) + apos) == 126) {
#line 183
        ngap ++;
      }
#line 181
      idx ++;
    }
#line 185
    if ((float )ngap / (float )msa->nseq > maxgap) {
#line 186
      *(matassign + (apos + 1)) |= 1 << 3;
    } else {
#line 188
      *(matassign + (apos + 1)) |= 1;
    }
#line 177
    apos ++;
  }
#line 195
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
#line 197
  free((void *)matassign);
#line 198
  return;
}
}
#line 226 "modelmakers.c"
void P7Maxmodelmaker(MSA *msa , char **dsq , float maxgap , struct p7prior_s *prior ,
                     float *null , float null_p1 , float mpri , struct plan7_s **ret_hmm ,
                     struct p7trace_s ***ret_tr ) 
{ 
  int idx ;
  int i___0 ;
  int j ;
  int x ;
  float **matc ;
  float cij[8] ;
  float tij[8] ;
  float matp[20] ;
  float insp[20] ;
  float insc[20] ;
  float *sc ;
  int *tbck ;
  int *matassign ;
  int *insopt ;
  int first ;
  int last ;
  float bm1 ;
  float bm2 ;
  int est_M ;
  float t_me ;
  float new ;
  float bestsc ;
  int code ;
  int ngap ;
  float wgtsum ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  float tmp___18 ;
  float tmp___19 ;
  float tmp___20 ;

  {
#line 255
  tmp = sre_malloc((char *)"modelmakers.c", 255, sizeof(float *) * (unsigned long )(msa->alen + 1));
#line 255
  matc = (float **)tmp;
#line 256
  tmp___0 = sre_malloc((char *)"modelmakers.c", 256, sizeof(float ) * (unsigned long )(msa->alen + 2));
#line 256
  sc = (float *)tmp___0;
#line 257
  tmp___1 = sre_malloc((char *)"modelmakers.c", 257, sizeof(int ) * (unsigned long )(msa->alen + 2));
#line 257
  tbck = (int *)tmp___1;
#line 258
  tmp___2 = sre_malloc((char *)"modelmakers.c", 258, sizeof(int ) * (unsigned long )(msa->alen + 1));
#line 258
  matassign = (int *)tmp___2;
#line 259
  tmp___3 = sre_malloc((char *)"modelmakers.c", 259, sizeof(int ) * (unsigned long )msa->nseq);
#line 259
  insopt = (int *)tmp___3;
#line 260
  i___0 = 0;
#line 260
  while (i___0 < msa->alen) {
#line 261
    tmp___4 = sre_malloc((char *)"modelmakers.c", 261, (unsigned long )Alphabet_size * sizeof(float ));
#line 261
    *(matc + (i___0 + 1)) = (float *)tmp___4;
#line 262
    FSet(*(matc + (i___0 + 1)), Alphabet_size, (float )0.);
#line 260
    i___0 ++;
  }
#line 267
  i___0 = 0;
#line 267
  while (i___0 < msa->alen) {
#line 268
    idx = 0;
#line 268
    while (idx < msa->nseq) {
#line 269
      if (! ((int )*(*(msa->aseq + idx) + i___0) == 32)) {
#line 269
        if (! ((int )*(*(msa->aseq + idx) + i___0) == 46)) {
#line 269
          if (! ((int )*(*(msa->aseq + idx) + i___0) == 95)) {
#line 269
            if (! ((int )*(*(msa->aseq + idx) + i___0) == 45)) {
#line 269
              if (! ((int )*(*(msa->aseq + idx) + i___0) == 126)) {
#line 270
                tmp___5 = SymbolIndex(*(*(msa->aseq + idx) + i___0));
#line 270
                P7CountSymbol(*(matc + (i___0 + 1)), (char )tmp___5, *(msa->wgt + idx));
              }
            }
          }
        }
      }
#line 268
      idx ++;
    }
#line 267
    i___0 ++;
  }
#line 271
  if (mpri > (float )0) {
#line 271
    tmp___6 = log((double )mpri);
#line 271
    mpri = (float )(tmp___6 * 1.44269504);
  } else {
#line 271
    mpri = (float )(- 9999.);
  }
#line 273
  FCopy(insp, prior->i[0], Alphabet_size);
#line 274
  FNorm(insp, Alphabet_size);
#line 275
  wgtsum = FSum(msa->wgt, msa->nseq);
#line 276
  x = 0;
#line 276
  while (x < Alphabet_size) {
#line 277
    if (insp[x] / *(null + x) > (float )0) {
#line 277
      tmp___7 = log((double )(insp[x] / *(null + x)));
#line 277
      insp[x] = (float )(tmp___7 * 1.44269504);
    } else {
#line 277
      insp[x] = (float )(- 9999.);
    }
#line 276
    x ++;
  }
#line 281
  est_M = estimate_model_length(msa);
#line 282
  t_me = (float )(0.5 / (double )((float )(est_M - 1)));
#line 283
  bm1 = (float )0.5;
#line 284
  bm2 = (float )(0.5 / (double )((float )(est_M - 1)));
#line 285
  if (bm1 / null_p1 > (float )0) {
#line 285
    tmp___8 = log((double )(bm1 / null_p1));
#line 285
    bm1 = (float )(tmp___8 * 1.44269504);
  } else {
#line 285
    bm1 = (float )(- 9999.);
  }
#line 286
  if (bm2 / null_p1 > (float )0) {
#line 286
    tmp___9 = log((double )(bm2 / null_p1));
#line 286
    bm2 = (float )(tmp___9 * 1.44269504);
  } else {
#line 286
    bm2 = (float )(- 9999.);
  }
#line 291
  maxgap = (float )0.5;
#line 292
  last = msa->alen;
#line 292
  while (last >= 1) {
#line 293
    ngap = 0;
#line 294
    idx = 0;
#line 294
    while (idx < msa->nseq) {
#line 295
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 32) {
#line 295
        ngap ++;
      } else
#line 295
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 46) {
#line 295
        ngap ++;
      } else
#line 295
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 95) {
#line 295
        ngap ++;
      } else
#line 295
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 45) {
#line 295
        ngap ++;
      } else
#line 295
      if ((int )*(*(msa->aseq + idx) + (last - 1)) == 126) {
#line 295
        ngap ++;
      }
#line 294
      idx ++;
    }
#line 296
    if ((float )ngap / (float )msa->nseq <= maxgap) {
#line 297
      break;
    }
#line 292
    last --;
  }
#line 302
  *(sc + last) = (float )0.;
#line 303
  *(tbck + last) = 0;
#line 307
  idx = 0;
#line 307
  while (idx < msa->nseq) {
#line 308
    i___0 = last;
#line 308
    while (1) {
#line 308
      if (i___0 > 0) {
#line 308
        if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32)) {
#line 308
          if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46)) {
#line 308
            if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95)) {
#line 308
              if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45)) {
#line 308
                if (! ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126)) {
#line 308
                  break;
                }
              }
            }
          }
        }
      } else {
#line 308
        break;
      }
#line 309
      *(*(msa->aseq + idx) + (i___0 - 1)) = (char )'_';
#line 308
      i___0 --;
    }
#line 307
    idx ++;
  }
#line 313
  i___0 = last - 1;
#line 313
  while (i___0 > 0) {
#line 315
    FCopy(matp, *(matc + i___0), Alphabet_size);
#line 316
    P7PriorifyEmissionVector(matp, prior, prior->mnum, (float *)(prior->mq), (float (*)[20])(prior->m),
                             (float *)((void *)0));
#line 317
    x = 0;
#line 317
    while (x < Alphabet_size) {
#line 318
      if (matp[x] / *(null + x) > (float )0) {
#line 318
        tmp___10 = log((double )(matp[x] / *(null + x)));
#line 318
        matp[x] = (float )(tmp___10 * 1.44269504);
      } else {
#line 318
        matp[x] = (float )(- 9999.);
      }
#line 317
      x ++;
    }
#line 321
    FSet(insc, Alphabet_size, (float )0.);
#line 322
    idx = 0;
#line 322
    while (idx < msa->nseq) {
#line 322
      *(insopt + idx) = 0;
#line 322
      idx ++;
    }
#line 324
    *(sc + i___0) = - 3.40282347e+38F;
#line 325
    j = i___0 + 1;
#line 325
    while (j <= last) {
#line 327
      code = build_cij(msa->aseq, msa->nseq, insopt, i___0, j, msa->wgt, cij);
#line 328
      if (code == -1) {
#line 328
        break;
      }
#line 329
      if (code == 1) {
#line 330
        FCopy(tij, cij, 7);
#line 331
        P7PriorifyTransitionVector(tij, prior, (float *)(prior->tq));
#line 332
        FNorm(tij, 3);
#line 333
        if (tij[0] / null_p1 > (float )0) {
#line 333
          tmp___11 = log((double )(tij[0] / null_p1));
#line 333
          tij[0] = (float )(tmp___11 * 1.44269504);
        } else {
#line 333
          tij[0] = (float )(- 9999.);
        }
#line 334
        if (tij[1] / null_p1 > (float )0) {
#line 334
          tmp___12 = log((double )(tij[1] / null_p1));
#line 334
          tij[1] = (float )(tmp___12 * 1.44269504);
        } else {
#line 334
          tij[1] = (float )(- 9999.);
        }
#line 335
        if (tij[2] > (float )0) {
#line 335
          tmp___13 = log((double )tij[2]);
#line 335
          tij[2] = (float )(tmp___13 * 1.44269504);
        } else {
#line 335
          tij[2] = (float )(- 9999.);
        }
#line 336
        if (tij[3] / null_p1 > (float )0) {
#line 336
          tmp___14 = log((double )(tij[3] / null_p1));
#line 336
          tij[3] = (float )(tmp___14 * 1.44269504);
        } else {
#line 336
          tij[3] = (float )(- 9999.);
        }
#line 337
        if (tij[4] / null_p1 > (float )0) {
#line 337
          tmp___15 = log((double )(tij[4] / null_p1));
#line 337
          tij[4] = (float )(tmp___15 * 1.44269504);
        } else {
#line 337
          tij[4] = (float )(- 9999.);
        }
#line 338
        if (tij[5] / null_p1 > (float )0) {
#line 338
          tmp___16 = log((double )(tij[5] / null_p1));
#line 338
          tij[5] = (float )(tmp___16 * 1.44269504);
        } else {
#line 338
          tij[5] = (float )(- 9999.);
        }
#line 339
        if (tij[6] > (float )0) {
#line 339
          tmp___17 = log((double )tij[6]);
#line 339
          tij[6] = (float )(tmp___17 * 1.44269504);
        } else {
#line 339
          tij[6] = (float )(- 9999.);
        }
#line 341
        tmp___18 = FDot(tij, cij, 7);
#line 341
        tmp___19 = FDot(insp, insc, Alphabet_size);
#line 341
        new = (*(sc + j) + tmp___18) + tmp___19;
#line 348
        if (new > *(sc + i___0)) {
#line 349
          *(sc + i___0) = new;
#line 350
          *(tbck + i___0) = j;
        }
      }
#line 354
      FAdd(insc, *(matc + j), Alphabet_size);
#line 355
      idx = 0;
#line 355
      while (idx < msa->nseq) {
#line 356
        if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 32)) {
#line 356
          if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 46)) {
#line 356
            if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 95)) {
#line 356
              if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 45)) {
#line 356
                if (! ((int )*(*(msa->aseq + idx) + (j - 1)) == 126)) {
#line 356
                  (*(insopt + idx)) ++;
                }
              }
            }
          }
        }
#line 355
        idx ++;
      }
#line 325
      j ++;
    }
#line 360
    tmp___20 = FDot(matp, *(matc + i___0), Alphabet_size);
#line 360
    *(sc + i___0) += tmp___20 + mpri * wgtsum;
#line 313
    i___0 --;
  }
#line 367
  bestsc = - 3.40282347e+38F;
#line 368
  first = 0;
#line 369
  i___0 = 1;
#line 369
  while (i___0 <= last) {
#line 370
    new = *(sc + i___0);
#line 371
    idx = 0;
#line 371
    while (idx < msa->nseq) {
#line 372
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 32) {
#line 373
        new += bm2;
      } else
#line 372
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 46) {
#line 373
        new += bm2;
      } else
#line 372
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 95) {
#line 373
        new += bm2;
      } else
#line 372
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 45) {
#line 373
        new += bm2;
      } else
#line 372
      if ((int )*(*(msa->aseq + idx) + (i___0 - 1)) == 126) {
#line 373
        new += bm2;
      } else {
#line 375
        new += bm1;
      }
#line 371
      idx ++;
    }
#line 377
    if (new > bestsc) {
#line 378
      bestsc = new;
#line 379
      first = i___0;
    }
#line 369
    i___0 ++;
  }
#line 385
  *(matassign + 0) = 0;
#line 386
  i___0 = 1;
#line 386
  while (i___0 <= msa->alen) {
#line 386
    *(matassign + i___0) = 1 << 3;
#line 386
    i___0 ++;
  }
#line 387
  i___0 = first;
#line 387
  while (i___0 != 0) {
#line 388
    *(matassign + i___0) &= ~ (1 << 3);
#line 389
    *(matassign + i___0) |= 1;
#line 387
    i___0 = *(tbck + i___0);
  }
#line 395
  matassign2hmm(msa, dsq, matassign, ret_hmm, ret_tr);
#line 399
  i___0 = 1;
#line 399
  while (i___0 <= msa->alen) {
#line 399
    free((void *)*(matc + i___0));
#line 399
    i___0 ++;
  }
#line 400
  free((void *)matc);
#line 401
  free((void *)sc);
#line 402
  free((void *)tbck);
#line 403
  free((void *)matassign);
#line 404
  free((void *)insopt);
#line 405
  return;
}
}
#line 436 "modelmakers.c"
static int build_cij(char **aseqs , int nseq , int *insopt , int i___0 , int j , float *wgt ,
                     float *cij ) 
{ 
  int idx ;

  {
#line 442
  i___0 --;
#line 443
  j --;
#line 444
  FSet(cij, 8, (float )0.);
#line 445
  idx = 0;
#line 445
  while (idx < nseq) {
#line 446
    if (*(insopt + idx) > 0) {
#line 447
      if ((int )*(*(aseqs + idx) + i___0) == 32) {
#line 447
        return (-1);
      } else
#line 447
      if ((int )*(*(aseqs + idx) + i___0) == 46) {
#line 447
        return (-1);
      } else
#line 447
      if ((int )*(*(aseqs + idx) + i___0) == 95) {
#line 447
        return (-1);
      } else
#line 447
      if ((int )*(*(aseqs + idx) + i___0) == 45) {
#line 447
        return (-1);
      } else
#line 447
      if ((int )*(*(aseqs + idx) + i___0) == 126) {
#line 447
        return (-1);
      }
#line 448
      if ((int )*(*(aseqs + idx) + j) == 32) {
#line 448
        return (0);
      } else
#line 448
      if ((int )*(*(aseqs + idx) + j) == 46) {
#line 448
        return (0);
      } else
#line 448
      if ((int )*(*(aseqs + idx) + j) == 95) {
#line 448
        return (0);
      } else
#line 448
      if ((int )*(*(aseqs + idx) + j) == 45) {
#line 448
        return (0);
      } else
#line 448
      if ((int )*(*(aseqs + idx) + j) == 126) {
#line 448
        return (0);
      }
#line 449
      *(cij + 1) += *(wgt + idx);
#line 450
      *(cij + 4) += (float )(*(insopt + idx) - 1) * *(wgt + idx);
#line 451
      *(cij + 3) += *(wgt + idx);
    } else
#line 453
    if ((int )*(*(aseqs + idx) + i___0) == 32) {
#line 453
      goto _L;
    } else
#line 453
    if ((int )*(*(aseqs + idx) + i___0) == 46) {
#line 453
      goto _L;
    } else
#line 453
    if ((int )*(*(aseqs + idx) + i___0) == 95) {
#line 453
      goto _L;
    } else
#line 453
    if ((int )*(*(aseqs + idx) + i___0) == 45) {
#line 453
      goto _L;
    } else
#line 453
    if ((int )*(*(aseqs + idx) + i___0) == 126) {
      _L: /* CIL Label */ 
#line 458
      if ((int )*(*(aseqs + idx) + j) == 95) {
#line 458
        goto __Cont;
      } else
#line 459
      if ((int )*(*(aseqs + idx) + j) == 32) {
#line 459
        *(cij + 6) += *(wgt + idx);
      } else
#line 459
      if ((int )*(*(aseqs + idx) + j) == 46) {
#line 459
        *(cij + 6) += *(wgt + idx);
      } else
#line 459
      if ((int )*(*(aseqs + idx) + j) == 95) {
#line 459
        *(cij + 6) += *(wgt + idx);
      } else
#line 459
      if ((int )*(*(aseqs + idx) + j) == 45) {
#line 459
        *(cij + 6) += *(wgt + idx);
      } else
#line 459
      if ((int )*(*(aseqs + idx) + j) == 126) {
#line 459
        *(cij + 6) += *(wgt + idx);
      } else {
#line 460
        *(cij + 5) += *(wgt + idx);
      }
    } else
#line 454
    if (! ((int )*(*(aseqs + idx) + j) == 95)) {
#line 455
      if ((int )*(*(aseqs + idx) + j) == 32) {
#line 455
        *(cij + 2) += *(wgt + idx);
      } else
#line 455
      if ((int )*(*(aseqs + idx) + j) == 46) {
#line 455
        *(cij + 2) += *(wgt + idx);
      } else
#line 455
      if ((int )*(*(aseqs + idx) + j) == 95) {
#line 455
        *(cij + 2) += *(wgt + idx);
      } else
#line 455
      if ((int )*(*(aseqs + idx) + j) == 45) {
#line 455
        *(cij + 2) += *(wgt + idx);
      } else
#line 455
      if ((int )*(*(aseqs + idx) + j) == 126) {
#line 455
        *(cij + 2) += *(wgt + idx);
      } else {
#line 456
        *(cij + 0) += *(wgt + idx);
      }
    }
    __Cont: /* CIL Label */ 
#line 445
    idx ++;
  }
#line 464
  return (1);
}
}
#line 477 "modelmakers.c"
static int estimate_model_length(MSA *msa ) 
{ 
  int idx ;
  float total ;
  float wgtsum ;
  int tmp ;

  {
#line 481
  total = (float )0.;
#line 482
  wgtsum = (float )0.;
#line 484
  idx = 0;
#line 484
  while (idx < msa->nseq) {
#line 486
    tmp = DealignedLength(*(msa->aseq + idx));
#line 486
    total += *(msa->wgt + idx) * (float )tmp;
#line 487
    wgtsum += *(msa->wgt + idx);
#line 484
    idx ++;
  }
#line 490
  return ((int )(total / wgtsum));
}
}
#line 511 "modelmakers.c"
static void matassign2hmm(MSA *msa , char **dsq , int *matassign , struct plan7_s **ret_hmm ,
                          struct p7trace_s ***ret_tr ) 
{ 
  struct plan7_s *hmm ;
  struct p7trace_s **tr ;
  int M ;
  int idx ;
  int apos ;
  void *tmp ;

  {
#line 522
  M = 0;
#line 523
  apos = 1;
#line 523
  while (apos <= msa->alen) {
#line 524
    if (*(matassign + apos) & 1) {
#line 525
      M ++;
    }
#line 523
    apos ++;
  }
#line 528
  if (M == 0) {
#line 529
    Die((char *)"No conserved consensus columns found; aborting construction!\nThis is an unusual situation. Reexamine your sequence alignment. It is\nprobably unusually full of gaps, or lots of sequence fragments. You may be\nable to force HMMER to model it; see the --fast (and --gapmax), or --hand\noptions to hmmbuild.");
  }
#line 536
  apos = 1;
#line 536
  while (1) {
#line 536
    if (*(matassign + apos) & (1 << 3)) {
#line 536
      if (! (apos <= msa->alen)) {
#line 536
        break;
      }
    } else {
#line 536
      break;
    }
#line 537
    *(matassign + apos) |= 1 << 4;
#line 536
    apos ++;
  }
#line 538
  if (apos <= msa->alen) {
#line 538
    *(matassign + apos) |= 1 << 1;
  }
#line 541
  apos = msa->alen;
#line 541
  while (1) {
#line 541
    if (*(matassign + apos) & (1 << 3)) {
#line 541
      if (! (apos > 0)) {
#line 541
        break;
      }
    } else {
#line 541
      break;
    }
#line 542
    *(matassign + apos) |= 1 << 5;
#line 541
    apos --;
  }
#line 543
  if (apos > 0) {
#line 543
    *(matassign + apos) |= 1 << 2;
  }
#line 548
  fake_tracebacks(msa->aseq, msa->nseq, msa->alen, matassign, & tr);
#line 550
  hmm = AllocPlan7(M);
#line 551
  ZeroPlan7(hmm);
#line 552
  idx = 0;
#line 552
  while (idx < msa->nseq) {
#line 554
    P7TraceCount(hmm, *(dsq + idx), *(msa->wgt + idx), *(tr + idx));
#line 552
    idx ++;
  }
#line 557
  annotate_model(hmm, matassign, msa);
#line 563
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 563
    free((void *)msa->rf);
  }
#line 564
  tmp = sre_malloc((char *)"modelmakers.c", 564, sizeof(char ) * (unsigned long )(msa->alen + 1));
#line 564
  msa->rf = (char *)tmp;
#line 565
  apos = 0;
#line 565
  while (apos < msa->alen) {
#line 566
    if (*(matassign + (apos + 1)) & 1) {
#line 566
      *(msa->rf + apos) = (char )'x';
    } else {
#line 566
      *(msa->rf + apos) = (char )'.';
    }
#line 565
    apos ++;
  }
#line 567
  *(msa->rf + msa->alen) = (char )'\000';
#line 570
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
#line 570
    *ret_tr = tr;
  } else {
#line 571
    idx = 0;
#line 571
    while (idx < msa->nseq) {
#line 571
      P7FreeTrace(*(tr + idx));
#line 571
      idx ++;
    }
#line 571
    free((void *)tr);
  }
#line 572
  if ((unsigned long )ret_hmm != (unsigned long )((void *)0)) {
#line 572
    *ret_hmm = hmm;
  } else {
#line 572
    FreePlan7(hmm);
  }
#line 573
  return;
}
}
#line 596 "modelmakers.c"
static void fake_tracebacks(char **aseq , int nseq , int alen , int *matassign , struct p7trace_s ***ret_tr ) 
{ 
  struct p7trace_s **tr ;
  int idx ;
  int i___0 ;
  int k ;
  int apos ;
  int tpos ;
  void *tmp ;

  {
#line 607
  tmp = sre_malloc((char *)"modelmakers.c", 607, sizeof(struct p7trace_s *) * (unsigned long )nseq);
#line 607
  tr = (struct p7trace_s **)tmp;
#line 609
  idx = 0;
#line 609
  while (idx < nseq) {
#line 611
    P7AllocTrace(alen + 6, tr + idx);
#line 614
    *((*(tr + idx))->statetype + 0) = (char)4;
#line 615
    *((*(tr + idx))->nodeidx + 0) = 0;
#line 616
    *((*(tr + idx))->pos + 0) = 0;
#line 619
    *((*(tr + idx))->statetype + 1) = (char)5;
#line 620
    *((*(tr + idx))->nodeidx + 1) = 0;
#line 621
    *((*(tr + idx))->pos + 1) = 0;
#line 623
    i___0 = 1;
#line 624
    k = 0;
#line 625
    tpos = 2;
#line 626
    apos = 0;
#line 626
    while (apos < alen) {
#line 628
      *((*(tr + idx))->statetype + tpos) = (char)0;
#line 630
      if (*(matassign + (apos + 1)) & (1 << 1)) {
#line 632
        *((*(tr + idx))->statetype + tpos) = (char)6;
#line 633
        *((*(tr + idx))->nodeidx + tpos) = 0;
#line 634
        *((*(tr + idx))->pos + tpos) = 0;
#line 635
        tpos ++;
      }
#line 638
      if (*(matassign + (apos + 1)) & 1) {
#line 638
        if ((int )*(*(aseq + idx) + apos) == 32) {
#line 638
          goto _L___1;
        } else
#line 638
        if ((int )*(*(aseq + idx) + apos) == 46) {
#line 638
          goto _L___1;
        } else
#line 638
        if ((int )*(*(aseq + idx) + apos) == 95) {
#line 638
          goto _L___1;
        } else
#line 638
        if ((int )*(*(aseq + idx) + apos) == 45) {
#line 638
          goto _L___1;
        } else
#line 638
        if ((int )*(*(aseq + idx) + apos) == 126) {
#line 638
          goto _L___1;
        } else {
#line 640
          k ++;
#line 641
          *((*(tr + idx))->statetype + tpos) = (char)1;
#line 642
          *((*(tr + idx))->nodeidx + tpos) = k;
#line 643
          *((*(tr + idx))->pos + tpos) = i___0;
#line 644
          i___0 ++;
#line 645
          tpos ++;
        }
      } else
      _L___1: /* CIL Label */ 
#line 647
      if (*(matassign + (apos + 1)) & 1) {
#line 650
        k ++;
#line 651
        if ((int )*((*(tr + idx))->statetype + (tpos - 1)) != 6) {
#line 653
          *((*(tr + idx))->statetype + tpos) = (char)2;
#line 654
          *((*(tr + idx))->nodeidx + tpos) = k;
#line 655
          *((*(tr + idx))->pos + tpos) = 0;
#line 656
          tpos ++;
        }
      } else
#line 659
      if (*(matassign + (apos + 1)) & (1 << 4)) {
#line 659
        if ((int )*(*(aseq + idx) + apos) == 32) {
#line 659
          goto _L___0;
        } else
#line 659
        if ((int )*(*(aseq + idx) + apos) == 46) {
#line 659
          goto _L___0;
        } else
#line 659
        if ((int )*(*(aseq + idx) + apos) == 95) {
#line 659
          goto _L___0;
        } else
#line 659
        if ((int )*(*(aseq + idx) + apos) == 45) {
#line 659
          goto _L___0;
        } else
#line 659
        if ((int )*(*(aseq + idx) + apos) == 126) {
#line 659
          goto _L___0;
        } else {
#line 662
          *((*(tr + idx))->statetype + tpos) = (char)5;
#line 663
          *((*(tr + idx))->nodeidx + tpos) = 0;
#line 664
          *((*(tr + idx))->pos + tpos) = i___0;
#line 665
          i___0 ++;
#line 666
          tpos ++;
        }
      } else
      _L___0: /* CIL Label */ 
#line 668
      if (*(matassign + (apos + 1)) & (1 << 5)) {
#line 668
        if ((int )*(*(aseq + idx) + apos) == 32) {
#line 668
          goto _L;
        } else
#line 668
        if ((int )*(*(aseq + idx) + apos) == 46) {
#line 668
          goto _L;
        } else
#line 668
        if ((int )*(*(aseq + idx) + apos) == 95) {
#line 668
          goto _L;
        } else
#line 668
        if ((int )*(*(aseq + idx) + apos) == 45) {
#line 668
          goto _L;
        } else
#line 668
        if ((int )*(*(aseq + idx) + apos) == 126) {
#line 668
          goto _L;
        } else {
#line 671
          *((*(tr + idx))->statetype + tpos) = (char)8;
#line 672
          *((*(tr + idx))->nodeidx + tpos) = 0;
#line 673
          *((*(tr + idx))->pos + tpos) = i___0;
#line 674
          i___0 ++;
#line 675
          tpos ++;
        }
      } else
      _L: /* CIL Label */ 
#line 677
      if (! ((int )*(*(aseq + idx) + apos) == 32)) {
#line 677
        if (! ((int )*(*(aseq + idx) + apos) == 46)) {
#line 677
          if (! ((int )*(*(aseq + idx) + apos) == 95)) {
#line 677
            if (! ((int )*(*(aseq + idx) + apos) == 45)) {
#line 677
              if (! ((int )*(*(aseq + idx) + apos) == 126)) {
#line 679
                *((*(tr + idx))->statetype + tpos) = (char)3;
#line 680
                *((*(tr + idx))->nodeidx + tpos) = k;
#line 681
                *((*(tr + idx))->pos + tpos) = i___0;
#line 682
                i___0 ++;
#line 683
                tpos ++;
              }
            }
          }
        }
      }
#line 686
      if (*(matassign + (apos + 1)) & (1 << 2)) {
#line 691
        while ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 2) {
#line 692
          tpos --;
        }
#line 693
        *((*(tr + idx))->statetype + tpos) = (char)7;
#line 694
        *((*(tr + idx))->nodeidx + tpos) = 0;
#line 695
        *((*(tr + idx))->pos + tpos) = 0;
#line 696
        tpos ++;
#line 700
        *((*(tr + idx))->statetype + tpos) = (char)8;
#line 701
        *((*(tr + idx))->nodeidx + tpos) = 0;
#line 702
        *((*(tr + idx))->pos + tpos) = 0;
#line 703
        tpos ++;
      }
#line 626
      apos ++;
    }
#line 707
    *((*(tr + idx))->statetype + tpos) = (char)9;
#line 708
    *((*(tr + idx))->nodeidx + tpos) = 0;
#line 709
    *((*(tr + idx))->pos + tpos) = 0;
#line 710
    tpos ++;
#line 710
    (*(tr + idx))->tlen = tpos;
#line 713
    trace_doctor(*(tr + idx), k, (int *)((void *)0), (int *)((void *)0));
#line 609
    idx ++;
  }
#line 717
  *ret_tr = tr;
#line 718
  return;
}
}
#line 744 "modelmakers.c"
static void trace_doctor(struct p7trace_s *tr , int mlen , int *ret_ndi , int *ret_nid ) 
{ 
  int opos ;
  int npos ;
  int ndi ;
  int nid ;

  {
#line 752
  nid = 0;
#line 752
  ndi = nid;
#line 753
  npos = 0;
#line 753
  opos = npos;
#line 754
  while (opos < tr->tlen) {
#line 756
    if ((int )*(tr->statetype + opos) == 2) {
#line 756
      if ((int )*(tr->statetype + (opos + 1)) == 3) {
#line 757
        *(tr->statetype + npos) = (char)1;
#line 758
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 759
        *(tr->pos + npos) = *(tr->pos + (opos + 1));
#line 760
        opos += 2;
#line 761
        npos ++;
#line 762
        ndi ++;
      } else {
#line 756
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 764
    if ((int )*(tr->statetype + opos) == 3) {
#line 764
      if ((int )*(tr->statetype + (opos + 1)) == 2) {
#line 765
        *(tr->statetype + npos) = (char)1;
#line 766
        *(tr->nodeidx + npos) = *(tr->nodeidx + (opos + 1));
#line 767
        *(tr->pos + npos) = *(tr->pos + opos);
#line 768
        opos += 2;
#line 769
        npos ++;
#line 770
        nid ++;
      } else {
#line 764
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 772
    if ((int )*(tr->statetype + opos) == 3) {
#line 772
      if ((int )*(tr->statetype + (opos - 1)) == 6) {
#line 773
        *(tr->statetype + npos) = (char)1;
#line 774
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 775
        *(tr->pos + npos) = *(tr->pos + opos);
#line 776
        opos ++;
#line 777
        npos ++;
      } else {
#line 772
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 779
    if ((int )*(tr->statetype + opos) == 3) {
#line 779
      if ((int )*(tr->statetype + (opos + 1)) == 7) {
#line 780
        *(tr->statetype + npos) = (char)1;
#line 781
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos) + 1;
#line 782
        *(tr->pos + npos) = *(tr->pos + opos);
#line 783
        opos ++;
#line 784
        npos ++;
      } else {
#line 779
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 786
    if ((int )*(tr->statetype + opos) == 6) {
#line 786
      if ((int )*(tr->statetype + (opos + 1)) == 7) {
#line 786
        if ((int )*(tr->statetype + (opos - 1)) == 5) {
#line 786
          if (*(tr->pos + (opos - 1)) > 0) {
#line 788
            *(tr->statetype + npos) = (char)1;
#line 789
            *(tr->nodeidx + npos) = 1;
#line 790
            *(tr->pos + npos) = *(tr->pos + (opos - 1));
#line 791
            *(tr->statetype + (npos - 1)) = (char)6;
#line 792
            *(tr->nodeidx + (npos - 1)) = 0;
#line 793
            *(tr->pos + (npos - 1)) = 0;
#line 794
            opos ++;
#line 795
            npos ++;
          } else {
#line 786
            goto _L___1;
          }
        } else {
#line 786
          goto _L___1;
        }
      } else {
#line 786
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 797
    if ((int )*(tr->statetype + opos) == 7) {
#line 797
      if ((int )*(tr->statetype + (opos - 1)) == 6) {
#line 797
        if ((int )*(tr->statetype + (opos + 1)) == 8) {
#line 797
          if ((int )*(tr->statetype + (opos + 2)) == 8) {
#line 800
            *(tr->statetype + npos) = (char)1;
#line 801
            *(tr->nodeidx + npos) = mlen;
#line 802
            *(tr->pos + npos) = *(tr->pos + (opos + 2));
#line 803
            *(tr->statetype + (npos + 1)) = (char)7;
#line 804
            *(tr->nodeidx + (npos + 1)) = 0;
#line 805
            *(tr->pos + (npos + 1)) = 0;
#line 806
            *(tr->statetype + (npos + 2)) = (char)8;
#line 807
            *(tr->nodeidx + (npos + 2)) = 0;
#line 808
            *(tr->pos + (npos + 2)) = 0;
#line 809
            opos += 3;
#line 810
            npos += 3;
          } else {
#line 813
            *(tr->statetype + npos) = *(tr->statetype + opos);
#line 814
            *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 815
            *(tr->pos + npos) = *(tr->pos + opos);
#line 816
            opos ++;
#line 817
            npos ++;
          }
        } else {
#line 813
          *(tr->statetype + npos) = *(tr->statetype + opos);
#line 814
          *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 815
          *(tr->pos + npos) = *(tr->pos + opos);
#line 816
          opos ++;
#line 817
          npos ++;
        }
      } else {
#line 813
        *(tr->statetype + npos) = *(tr->statetype + opos);
#line 814
        *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 815
        *(tr->pos + npos) = *(tr->pos + opos);
#line 816
        opos ++;
#line 817
        npos ++;
      }
    } else {
#line 813
      *(tr->statetype + npos) = *(tr->statetype + opos);
#line 814
      *(tr->nodeidx + npos) = *(tr->nodeidx + opos);
#line 815
      *(tr->pos + npos) = *(tr->pos + opos);
#line 816
      opos ++;
#line 817
      npos ++;
    }
  }
#line 820
  tr->tlen = npos;
#line 822
  if ((unsigned long )ret_ndi != (unsigned long )((void *)0)) {
#line 822
    *ret_ndi = ndi;
  }
#line 823
  if ((unsigned long )ret_nid != (unsigned long )((void *)0)) {
#line 823
    *ret_nid = nid;
  }
#line 824
  return;
}
}
#line 838 "modelmakers.c"
static void annotate_model(struct plan7_s *hmm , int *matassign , MSA *msa ) 
{ 
  int apos ;
  int k ;
  char *pri ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  void *tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 848
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 849
    *(hmm->rf + 0) = (char )' ';
#line 850
    k = 1;
#line 850
    apos = k;
#line 850
    while (apos <= msa->alen) {
#line 851
      if (*(matassign + apos) & 1) {
#line 852
        tmp = k;
#line 852
        k ++;
#line 852
        if ((int )*(msa->rf + (apos - 1)) == 32) {
#line 852
          *(hmm->rf + tmp) = (char )'.';
        } else {
#line 852
          *(hmm->rf + tmp) = *(msa->rf + (apos - 1));
        }
      }
#line 850
      apos ++;
    }
#line 853
    *(hmm->rf + k) = (char )'\000';
#line 854
    hmm->flags |= 1 << 2;
  }
#line 860
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 861
    *(hmm->cs + 0) = (char )' ';
#line 862
    k = 1;
#line 862
    apos = k;
#line 862
    while (apos <= msa->alen) {
#line 863
      if (*(matassign + apos) & 1) {
#line 864
        tmp___0 = k;
#line 864
        k ++;
#line 864
        if ((int )*(msa->ss_cons + (apos - 1)) == 32) {
#line 864
          *(hmm->cs + tmp___0) = (char )'.';
        } else {
#line 864
          *(hmm->cs + tmp___0) = *(msa->ss_cons + (apos - 1));
        }
      }
#line 862
      apos ++;
    }
#line 865
    *(hmm->cs + k) = (char )'\000';
#line 866
    hmm->flags |= 1 << 3;
  }
#line 872
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 873
    *(hmm->ca + 0) = (char )' ';
#line 874
    k = 1;
#line 874
    apos = k;
#line 874
    while (apos <= msa->alen) {
#line 875
      if (*(matassign + apos) & 1) {
#line 876
        tmp___1 = k;
#line 876
        k ++;
#line 876
        if ((int )*(msa->sa_cons + (apos - 1)) == 32) {
#line 876
          *(hmm->ca + tmp___1) = (char )'.';
        } else {
#line 876
          *(hmm->ca + tmp___1) = *(msa->sa_cons + (apos - 1));
        }
      }
#line 874
      apos ++;
    }
#line 877
    *(hmm->ca + k) = (char )'\000';
#line 878
    hmm->flags |= 1 << 13;
  }
#line 883
  k = 1;
#line 883
  apos = k;
#line 883
  while (apos <= msa->alen) {
#line 884
    if (*(matassign + apos) & 1) {
#line 885
      tmp___2 = k;
#line 885
      k ++;
#line 885
      *(hmm->map + tmp___2) = apos;
    }
#line 883
    apos ++;
  }
#line 886
  hmm->flags |= 1 << 8;
#line 894
  pri = MSAGetGC(msa, (char *)"X-PRM");
#line 894
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
#line 896
    tmp___3 = sre_malloc((char *)"modelmakers.c", 896, sizeof(int ) * (unsigned long )(hmm->M + 1));
#line 896
    hmm->mpri = (int *)tmp___3;
#line 897
    k = 1;
#line 897
    apos = k;
#line 897
    while (apos <= msa->alen) {
#line 898
      if (*(matassign + apos) & 1) {
#line 900
        tmp___6 = __ctype_b_loc();
#line 900
        if ((int const   )*(*tmp___6 + (int )*(pri + (apos - 1))) & 2048) {
#line 900
          *(hmm->mpri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
#line 901
          tmp___5 = __ctype_b_loc();
#line 901
          if ((int const   )*(*tmp___5 + (int )*(pri + (apos - 1))) & 512) {
#line 901
            *(hmm->mpri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
#line 902
            tmp___4 = __ctype_b_loc();
#line 902
            if ((int const   )*(*tmp___4 + (int )*(pri + (apos - 1))) & 256) {
#line 902
              *(hmm->mpri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
#line 903
              *(hmm->mpri + k) = -1;
            }
          }
        }
#line 904
        k ++;
      }
#line 897
      apos ++;
    }
  }
#line 909
  pri = MSAGetGC(msa, (char *)"X-PRI");
#line 909
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
#line 911
    tmp___7 = sre_malloc((char *)"modelmakers.c", 911, sizeof(int ) * (unsigned long )(hmm->M + 1));
#line 911
    hmm->ipri = (int *)tmp___7;
#line 912
    k = 1;
#line 912
    apos = k;
#line 912
    while (apos <= msa->alen) {
#line 913
      if (*(matassign + apos) & 1) {
#line 915
        tmp___10 = __ctype_b_loc();
#line 915
        if ((int const   )*(*tmp___10 + (int )*(pri + (apos - 1))) & 2048) {
#line 915
          *(hmm->ipri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
#line 916
          tmp___9 = __ctype_b_loc();
#line 916
          if ((int const   )*(*tmp___9 + (int )*(pri + (apos - 1))) & 512) {
#line 916
            *(hmm->ipri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
#line 917
            tmp___8 = __ctype_b_loc();
#line 917
            if ((int const   )*(*tmp___8 + (int )*(pri + (apos - 1))) & 256) {
#line 917
              *(hmm->ipri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
#line 918
              *(hmm->ipri + k) = -1;
            }
          }
        }
#line 919
        k ++;
      }
#line 912
      apos ++;
    }
  }
#line 924
  pri = MSAGetGC(msa, (char *)"X-PRT");
#line 924
  if ((unsigned long )pri != (unsigned long )((void *)0)) {
#line 926
    tmp___11 = sre_malloc((char *)"modelmakers.c", 926, sizeof(int ) * (unsigned long )(hmm->M + 1));
#line 926
    hmm->tpri = (int *)tmp___11;
#line 927
    k = 1;
#line 927
    apos = k;
#line 927
    while (apos <= msa->alen) {
#line 928
      if (*(matassign + apos) & 1) {
#line 930
        tmp___14 = __ctype_b_loc();
#line 930
        if ((int const   )*(*tmp___14 + (int )*(pri + (apos - 1))) & 2048) {
#line 930
          *(hmm->tpri + k) = (int )*(pri + (apos - 1)) - 48;
        } else {
#line 931
          tmp___13 = __ctype_b_loc();
#line 931
          if ((int const   )*(*tmp___13 + (int )*(pri + (apos - 1))) & 512) {
#line 931
            *(hmm->tpri + k) = ((int )*(pri + (apos - 1)) - 97) + 10;
          } else {
#line 932
            tmp___12 = __ctype_b_loc();
#line 932
            if ((int const   )*(*tmp___12 + (int )*(pri + (apos - 1))) & 256) {
#line 932
              *(hmm->tpri + k) = ((int )*(pri + (apos - 1)) - 65) + 10;
            } else {
#line 933
              *(hmm->tpri + k) = -1;
            }
          }
        }
#line 934
        k ++;
      }
#line 927
      apos ++;
    }
  }
#line 938
  return;
}
}
#line 1 "plan7.o"
#pragma merger("0","/tmp/cil-4DkYfNXN.i","")
#line 142 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 214 "./funcs.h"
void Plan7SetNullModel(struct plan7_s *hmm , float *null , float p1 ) ;
#line 217
void Plan7RenormalizeExits(struct plan7_s *hmm ) ;
#line 218
void Plan7NakedConfig(struct plan7_s *hmm ) ;
#line 219
void Plan7GlobalConfig(struct plan7_s *hmm ) ;
#line 221
void Plan7SWConfig(struct plan7_s *hmm , float pentry , float pexit ) ;
#line 222
void Plan7FSConfig(struct plan7_s *hmm , float pentry , float pexit ) ;
#line 223
void PrintPlan7Stats(FILE *fp , struct plan7_s *hmm , char **dsq , int nseq , struct p7trace_s **tr ) ;
#line 40 "plan7.c"
struct plan7_s *AllocPlan7(int M ) 
{ 
  struct plan7_s *hmm ;

  {
#line 45
  hmm = AllocPlan7Shell();
#line 46
  AllocPlan7Body(hmm, M);
#line 47
  return (hmm);
}
}
#line 49 "plan7.c"
struct plan7_s *AllocPlan7Shell(void) 
{ 
  struct plan7_s *hmm ;
  void *tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  int **tmp___3 ;
  int **tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 54
  tmp = sre_malloc((char *)"plan7.c", 54, sizeof(struct plan7_s ));
#line 54
  hmm = (struct plan7_s *)tmp;
#line 55
  hmm->M = 0;
#line 57
  hmm->name = (char *)((void *)0);
#line 58
  hmm->acc = (char *)((void *)0);
#line 59
  hmm->desc = (char *)((void *)0);
#line 60
  hmm->rf = (char *)((void *)0);
#line 61
  hmm->cs = (char *)((void *)0);
#line 62
  hmm->ca = (char *)((void *)0);
#line 63
  hmm->comlog = (char *)((void *)0);
#line 64
  hmm->nseq = 0;
#line 65
  hmm->ctime = (char *)((void *)0);
#line 66
  hmm->map = (int *)((void *)0);
#line 67
  hmm->checksum = 0;
#line 69
  hmm->tpri = (int *)((void *)0);
#line 70
  hmm->mpri = (int *)((void *)0);
#line 71
  hmm->ipri = (int *)((void *)0);
#line 73
  tmp___0 = (float )0.0;
#line 73
  hmm->ga2 = tmp___0;
#line 73
  hmm->ga1 = tmp___0;
#line 74
  tmp___1 = (float )0.0;
#line 74
  hmm->tc2 = tmp___1;
#line 74
  hmm->tc1 = tmp___1;
#line 75
  tmp___2 = (float )0.0;
#line 75
  hmm->nc2 = tmp___2;
#line 75
  hmm->nc1 = tmp___2;
#line 77
  hmm->t = (float **)((void *)0);
#line 78
  hmm->mat = (float **)((void *)0);
#line 79
  hmm->ins = (float **)((void *)0);
#line 81
  tmp___4 = (int **)((void *)0);
#line 81
  hmm->isc = tmp___4;
#line 81
  tmp___3 = tmp___4;
#line 81
  hmm->msc = tmp___3;
#line 81
  hmm->tsc = tmp___3;
#line 82
  tmp___6 = (int *)((void *)0);
#line 82
  hmm->msc_mem = tmp___6;
#line 82
  tmp___5 = tmp___6;
#line 82
  hmm->msc_mem = tmp___5;
#line 82
  hmm->tsc_mem = tmp___5;
#line 84
  hmm->begin = (float *)((void *)0);
#line 85
  hmm->end = (float *)((void *)0);
#line 87
  tmp___7 = (int *)((void *)0);
#line 87
  hmm->bsc_mem = tmp___7;
#line 87
  hmm->bsc = tmp___7;
#line 88
  tmp___8 = (int *)((void *)0);
#line 88
  hmm->esc_mem = tmp___8;
#line 88
  hmm->esc = tmp___8;
#line 91
  hmm->dnam = (int **)((void *)0);
#line 92
  hmm->dnai = (int **)((void *)0);
#line 93
  hmm->dna2 = -987654321;
#line 94
  hmm->dna4 = -987654321;
#line 96
  hmm->mu = (float )0.;
#line 97
  hmm->lambda = (float )0.;
#line 99
  hmm->flags = 0;
#line 100
  return (hmm);
}
}
#line 104 "plan7.c"
void AllocPlan7Body(struct plan7_s *hmm , int M ) 
{ 
  int k ;
  int x ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
#line 109
  hmm->M = M;
#line 111
  tmp = sre_malloc((char *)"plan7.c", 111, (unsigned long )(M + 2) * sizeof(char ));
#line 111
  hmm->rf = (char *)tmp;
#line 112
  tmp___0 = sre_malloc((char *)"plan7.c", 112, (unsigned long )(M + 2) * sizeof(char ));
#line 112
  hmm->cs = (char *)tmp___0;
#line 113
  tmp___1 = sre_malloc((char *)"plan7.c", 113, (unsigned long )(M + 2) * sizeof(char ));
#line 113
  hmm->ca = (char *)tmp___1;
#line 114
  tmp___2 = sre_malloc((char *)"plan7.c", 114, (unsigned long )(M + 1) * sizeof(int ));
#line 114
  hmm->map = (int *)tmp___2;
#line 116
  tmp___3 = sre_malloc((char *)"plan7.c", 116, (unsigned long )M * sizeof(float *));
#line 116
  hmm->t = (float **)tmp___3;
#line 117
  tmp___4 = sre_malloc((char *)"plan7.c", 117, (unsigned long )(M + 1) * sizeof(float *));
#line 117
  hmm->mat = (float **)tmp___4;
#line 118
  tmp___5 = sre_malloc((char *)"plan7.c", 118, (unsigned long )M * sizeof(float *));
#line 118
  hmm->ins = (float **)tmp___5;
#line 119
  tmp___6 = sre_malloc((char *)"plan7.c", 119, (unsigned long )(7 * M) * sizeof(float ));
#line 119
  *(hmm->t + 0) = (float *)tmp___6;
#line 120
  tmp___7 = sre_malloc((char *)"plan7.c", 120, (unsigned long )(20 * (M + 1)) * sizeof(float ));
#line 120
  *(hmm->mat + 0) = (float *)tmp___7;
#line 121
  tmp___8 = sre_malloc((char *)"plan7.c", 121, (unsigned long )(20 * M) * sizeof(float ));
#line 121
  *(hmm->ins + 0) = (float *)tmp___8;
#line 123
  tmp___9 = sre_malloc((char *)"plan7.c", 123, 7UL * sizeof(int *));
#line 123
  hmm->tsc = (int **)tmp___9;
#line 124
  tmp___10 = sre_malloc((char *)"plan7.c", 124, 24UL * sizeof(int *));
#line 124
  hmm->msc = (int **)tmp___10;
#line 125
  tmp___11 = sre_malloc((char *)"plan7.c", 125, 24UL * sizeof(int *));
#line 125
  hmm->isc = (int **)tmp___11;
#line 126
  tmp___12 = sre_malloc((char *)"plan7.c", 126, (unsigned long )(7 * M) * sizeof(int ));
#line 126
  hmm->tsc_mem = (int *)tmp___12;
#line 127
  tmp___13 = sre_malloc((char *)"plan7.c", 127, (unsigned long )(24 * (M + 1)) * sizeof(int ));
#line 127
  hmm->msc_mem = (int *)tmp___13;
#line 128
  tmp___14 = sre_malloc((char *)"plan7.c", 128, (unsigned long )(24 * M) * sizeof(int ));
#line 128
  hmm->isc_mem = (int *)tmp___14;
#line 130
  *(hmm->tsc + 0) = hmm->tsc_mem;
#line 131
  *(hmm->msc + 0) = hmm->msc_mem;
#line 132
  *(hmm->isc + 0) = hmm->isc_mem;
#line 137
  k = 1;
#line 137
  while (k <= M) {
#line 138
    *(hmm->mat + k) = *(hmm->mat + 0) + k * 20;
#line 139
    if (k < M) {
#line 140
      *(hmm->ins + k) = *(hmm->ins + 0) + k * 20;
#line 141
      *(hmm->t + k) = *(hmm->t + 0) + k * 7;
    }
#line 137
    k ++;
  }
#line 144
  x = 1;
#line 144
  while (x < 24) {
#line 145
    *(hmm->msc + x) = *(hmm->msc + 0) + x * (M + 1);
#line 146
    *(hmm->isc + x) = *(hmm->isc + 0) + x * M;
#line 144
    x ++;
  }
#line 148
  x = 0;
#line 148
  while (x < 7) {
#line 149
    *(hmm->tsc + x) = *(hmm->tsc + 0) + x * M;
#line 148
    x ++;
  }
#line 154
  x = 0;
#line 154
  while (x < 7) {
#line 155
    *(*(hmm->tsc + x) + 0) = -987654321;
#line 154
    x ++;
  }
#line 157
  tmp___15 = sre_malloc((char *)"plan7.c", 157, (unsigned long )(M + 1) * sizeof(float ));
#line 157
  hmm->begin = (float *)tmp___15;
#line 158
  tmp___16 = sre_malloc((char *)"plan7.c", 158, (unsigned long )(M + 1) * sizeof(float ));
#line 158
  hmm->end = (float *)tmp___16;
#line 160
  tmp___17 = sre_malloc((char *)"plan7.c", 160, (unsigned long )(M + 1) * sizeof(int ));
#line 160
  hmm->bsc_mem = (int *)tmp___17;
#line 161
  tmp___18 = sre_malloc((char *)"plan7.c", 161, (unsigned long )(M + 1) * sizeof(int ));
#line 161
  hmm->esc_mem = (int *)tmp___18;
#line 163
  hmm->bsc = hmm->bsc_mem;
#line 164
  hmm->esc = hmm->esc_mem;
#line 166
  return;
}
}
#line 170 "plan7.c"
void FreePlan7(struct plan7_s *hmm ) 
{ 


  {
#line 173
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
#line 173
    free((void *)hmm->name);
  }
#line 174
  if ((unsigned long )hmm->acc != (unsigned long )((void *)0)) {
#line 174
    free((void *)hmm->acc);
  }
#line 175
  if ((unsigned long )hmm->desc != (unsigned long )((void *)0)) {
#line 175
    free((void *)hmm->desc);
  }
#line 176
  if ((unsigned long )hmm->rf != (unsigned long )((void *)0)) {
#line 176
    free((void *)hmm->rf);
  }
#line 177
  if ((unsigned long )hmm->cs != (unsigned long )((void *)0)) {
#line 177
    free((void *)hmm->cs);
  }
#line 178
  if ((unsigned long )hmm->ca != (unsigned long )((void *)0)) {
#line 178
    free((void *)hmm->ca);
  }
#line 179
  if ((unsigned long )hmm->comlog != (unsigned long )((void *)0)) {
#line 179
    free((void *)hmm->comlog);
  }
#line 180
  if ((unsigned long )hmm->ctime != (unsigned long )((void *)0)) {
#line 180
    free((void *)hmm->ctime);
  }
#line 181
  if ((unsigned long )hmm->map != (unsigned long )((void *)0)) {
#line 181
    free((void *)hmm->map);
  }
#line 182
  if ((unsigned long )hmm->tpri != (unsigned long )((void *)0)) {
#line 182
    free((void *)hmm->tpri);
  }
#line 183
  if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
#line 183
    free((void *)hmm->mpri);
  }
#line 184
  if ((unsigned long )hmm->ipri != (unsigned long )((void *)0)) {
#line 184
    free((void *)hmm->ipri);
  }
#line 185
  if ((unsigned long )hmm->bsc_mem != (unsigned long )((void *)0)) {
#line 185
    free((void *)hmm->bsc_mem);
  }
#line 186
  if ((unsigned long )hmm->begin != (unsigned long )((void *)0)) {
#line 186
    free((void *)hmm->begin);
  }
#line 187
  if ((unsigned long )hmm->esc_mem != (unsigned long )((void *)0)) {
#line 187
    free((void *)hmm->esc_mem);
  }
#line 188
  if ((unsigned long )hmm->end != (unsigned long )((void *)0)) {
#line 188
    free((void *)hmm->end);
  }
#line 189
  if ((unsigned long )hmm->msc_mem != (unsigned long )((void *)0)) {
#line 189
    free((void *)hmm->msc_mem);
  }
#line 190
  if ((unsigned long )hmm->isc_mem != (unsigned long )((void *)0)) {
#line 190
    free((void *)hmm->isc_mem);
  }
#line 191
  if ((unsigned long )hmm->tsc_mem != (unsigned long )((void *)0)) {
#line 191
    free((void *)hmm->tsc_mem);
  }
#line 192
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
#line 192
    free((void *)*(hmm->mat + 0));
  }
#line 193
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
#line 193
    free((void *)*(hmm->ins + 0));
  }
#line 194
  if ((unsigned long )hmm->t != (unsigned long )((void *)0)) {
#line 194
    free((void *)*(hmm->t + 0));
  }
#line 195
  if ((unsigned long )hmm->msc != (unsigned long )((void *)0)) {
#line 195
    free((void *)hmm->msc);
  }
#line 196
  if ((unsigned long )hmm->isc != (unsigned long )((void *)0)) {
#line 196
    free((void *)hmm->isc);
  }
#line 197
  if ((unsigned long )hmm->tsc != (unsigned long )((void *)0)) {
#line 197
    free((void *)hmm->tsc);
  }
#line 198
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
#line 198
    free((void *)hmm->mat);
  }
#line 199
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
#line 199
    free((void *)hmm->ins);
  }
#line 200
  if ((unsigned long )hmm->t != (unsigned long )((void *)0)) {
#line 200
    free((void *)hmm->t);
  }
#line 201
  if ((unsigned long )hmm->dnam != (unsigned long )((void *)0)) {
#line 201
    free((void *)hmm->dnam);
  }
#line 202
  if ((unsigned long )hmm->dnai != (unsigned long )((void *)0)) {
#line 202
    free((void *)hmm->dnai);
  }
#line 203
  free((void *)hmm);
#line 204
  return;
}
}
#line 211 "plan7.c"
void ZeroPlan7(struct plan7_s *hmm ) 
{ 
  int k ;

  {
#line 215
  k = 1;
#line 215
  while (k < hmm->M) {
#line 217
    FSet(*(hmm->t + k), 7, (float )0.);
#line 218
    FSet(*(hmm->mat + k), Alphabet_size, (float )0.);
#line 219
    FSet(*(hmm->ins + k), Alphabet_size, (float )0.);
#line 215
    k ++;
  }
#line 221
  FSet(*(hmm->mat + hmm->M), Alphabet_size, (float )0.);
#line 222
  hmm->tbd1 = (float )0.;
#line 223
  FSet(hmm->begin + 1, hmm->M, (float )0.);
#line 224
  FSet(hmm->end + 1, hmm->M, (float )0.);
#line 225
  k = 0;
#line 225
  while (k < 4) {
#line 226
    FSet(hmm->xt[k], 2, (float )0.);
#line 225
    k ++;
  }
#line 227
  hmm->flags &= -2;
#line 228
  hmm->flags &= ~ (1 << 5);
#line 229
  return;
}
}
#line 238 "plan7.c"
void Plan7SetName(struct plan7_s *hmm , char *name ) 
{ 


  {
#line 241
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
#line 241
    free((void *)hmm->name);
  }
#line 242
  hmm->name = Strdup(name);
#line 243
  StringChop(hmm->name);
#line 244
  return;
}
}
#line 251 "plan7.c"
void Plan7SetAccession(struct plan7_s *hmm , char *acc ) 
{ 


  {
#line 254
  if ((unsigned long )hmm->acc != (unsigned long )((void *)0)) {
#line 254
    free((void *)hmm->acc);
  }
#line 255
  hmm->acc = Strdup(acc);
#line 256
  StringChop(hmm->acc);
#line 257
  hmm->flags |= 1 << 9;
#line 258
  return;
}
}
#line 266 "plan7.c"
void Plan7SetDescription(struct plan7_s *hmm , char *desc ) 
{ 


  {
#line 269
  if ((unsigned long )hmm->desc != (unsigned long )((void *)0)) {
#line 269
    free((void *)hmm->desc);
  }
#line 270
  hmm->desc = Strdup(desc);
#line 271
  StringChop(hmm->desc);
#line 272
  hmm->flags |= 1 << 1;
#line 273
  return;
}
}
#line 281 "plan7.c"
void Plan7ComlogAppend(struct plan7_s *hmm , int argc , char **argv ) 
{ 
  int len ;
  int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 288
  len = argc;
#line 289
  i___0 = 0;
#line 289
  while (i___0 < argc) {
#line 290
    tmp = strlen((char const   *)*(argv + i___0));
#line 290
    len = (int )((size_t )len + tmp);
#line 289
    i___0 ++;
  }
#line 293
  if ((unsigned long )hmm->comlog != (unsigned long )((void *)0)) {
#line 295
    tmp___0 = strlen((char const   *)hmm->comlog);
#line 295
    len = (int )((size_t )len + tmp___0);
#line 296
    tmp___1 = sre_realloc((char *)"plan7.c", 296, (void *)hmm->comlog, sizeof(char ) * (unsigned long )(len + 1));
#line 296
    hmm->comlog = (char *)tmp___1;
  } else {
#line 300
    tmp___2 = sre_malloc((char *)"plan7.c", 300, sizeof(char ) * (unsigned long )(len + 1));
#line 300
    hmm->comlog = (char *)tmp___2;
#line 301
    *(hmm->comlog) = (char )'\000';
  }
#line 305
  strcat((char * __restrict  )hmm->comlog, (char const   * __restrict  )"\n");
#line 306
  i___0 = 0;
#line 306
  while (i___0 < argc) {
#line 308
    strcat((char * __restrict  )hmm->comlog, (char const   * __restrict  )*(argv + i___0));
#line 309
    if (i___0 < argc - 1) {
#line 309
      strcat((char * __restrict  )hmm->comlog, (char const   * __restrict  )" ");
    }
#line 306
    i___0 ++;
  }
#line 311
  return;
}
}
#line 318 "plan7.c"
void Plan7SetCtime(struct plan7_s *hmm ) 
{ 
  time_t date ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 321
  tmp = time((time_t *)((void *)0));
#line 321
  date = tmp;
#line 322
  if ((unsigned long )hmm->ctime != (unsigned long )((void *)0)) {
#line 322
    free((void *)hmm->ctime);
  }
#line 323
  tmp___0 = ctime((time_t const   *)(& date));
#line 323
  hmm->ctime = Strdup(tmp___0);
#line 324
  StringChop(hmm->ctime);
#line 325
  return;
}
}
#line 333 "plan7.c"
void Plan7SetNullModel(struct plan7_s *hmm , float *null , float p1 ) 
{ 
  int x ;

  {
#line 337
  x = 0;
#line 337
  while (x < Alphabet_size) {
#line 338
    hmm->null[x] = *(null + x);
#line 337
    x ++;
  }
#line 339
  hmm->p1 = p1;
#line 340
  return;
}
}
#line 387 "plan7.c"
void P7Logoddsify(struct plan7_s *hmm , int viterbi_mode ) 
{ 
  int k ;
  int x ;
  float accum ;
  float tbm ;
  float tme ;
  double tmp ;
  double tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;

  {
#line 395
  if (hmm->flags & 1) {
#line 395
    return;
  }
#line 399
  k = 1;
#line 399
  while (k <= hmm->M) {
#line 402
    x = 0;
#line 402
    while (x < Alphabet_size) {
#line 404
      *(*(hmm->msc + x) + k) = Prob2Score(*(*(hmm->mat + k) + x), hmm->null[x]);
#line 405
      if (k < hmm->M) {
#line 406
        *(*(hmm->isc + x) + k) = Prob2Score(*(*(hmm->ins + k) + x), hmm->null[x]);
      }
#line 402
      x ++;
    }
#line 409
    x = Alphabet_size;
#line 409
    while (x < Alphabet_iupac) {
#line 411
      *(*(hmm->msc + x) + k) = DegenerateSymbolScore(*(hmm->mat + k), hmm->null, x);
#line 412
      if (k < hmm->M) {
#line 413
        *(*(hmm->isc + x) + k) = DegenerateSymbolScore(*(hmm->ins + k), hmm->null,
                                                       x);
      }
#line 409
      x ++;
    }
#line 399
    k ++;
  }
#line 433
  k = 1;
#line 433
  while (k < hmm->M) {
#line 435
    *(*(hmm->tsc + 0) + k) = Prob2Score(*(*(hmm->t + k) + 0), hmm->p1);
#line 436
    *(*(hmm->tsc + 1) + k) = Prob2Score(*(*(hmm->t + k) + 1), hmm->p1);
#line 437
    *(*(hmm->tsc + 2) + k) = Prob2Score(*(*(hmm->t + k) + 2), (float )1.0);
#line 438
    *(*(hmm->tsc + 3) + k) = Prob2Score(*(*(hmm->t + k) + 3), hmm->p1);
#line 439
    *(*(hmm->tsc + 4) + k) = Prob2Score(*(*(hmm->t + k) + 4), hmm->p1);
#line 440
    *(*(hmm->tsc + 5) + k) = Prob2Score(*(*(hmm->t + k) + 5), hmm->p1);
#line 441
    *(*(hmm->tsc + 6) + k) = Prob2Score(*(*(hmm->t + k) + 6), (float )1.0);
#line 433
    k ++;
  }
#line 453
  if ((double )hmm->tbd1 > 0.0) {
#line 453
    tmp = log((double )hmm->tbd1);
#line 453
    accum = (float )tmp;
  } else {
#line 453
    accum = (float )(- 9999.);
  }
#line 454
  k = 1;
#line 454
  while (k <= hmm->M) {
#line 456
    if ((double )*(hmm->begin + k) > 0.) {
#line 456
      tmp___0 = log((double )*(hmm->begin + k));
#line 456
      tbm = (float )tmp___0;
    } else {
#line 456
      tbm = (float )(- 9999.);
    }
#line 459
    if (k > 1) {
#line 459
      if ((double )accum > - 9999.) {
#line 461
        if ((double )*(*(hmm->t + (k - 1)) + 5) > 0.0) {
#line 463
          if (viterbi_mode) {
#line 463
            tmp___3 = log((double )*(*(hmm->t + (k - 1)) + 5));
#line 463
            if ((double )tbm > (double )accum + tmp___3) {
#line 463
              tbm = tbm;
            } else {
#line 463
              tmp___2 = log((double )*(*(hmm->t + (k - 1)) + 5));
#line 463
              tbm = (float )((double )accum + tmp___2);
            }
          } else {
#line 464
            tmp___4 = log((double )*(*(hmm->t + (k - 1)) + 5));
#line 464
            tbm = LogSum(tbm, (float )((double )accum + tmp___4));
          }
        }
#line 467
        if ((double )*(*(hmm->t + (k - 1)) + 6) > 0.0) {
#line 467
          tmp___5 = log((double )*(*(hmm->t + (k - 1)) + 6));
#line 467
          accum = (float )((double )accum + tmp___5);
        } else {
#line 467
          accum = (float )(- 9999.);
        }
      }
    }
#line 470
    if ((double )tbm > - 9999.) {
#line 471
      tmp___6 = log((double )hmm->p1);
#line 471
      tmp___7 = floor(0.5 + (1000.0 * 1.44269504) * ((double )tbm - tmp___6));
#line 471
      *(hmm->bsc + k) = (int )tmp___7;
    } else {
#line 473
      *(hmm->bsc + k) = -987654321;
    }
#line 454
    k ++;
  }
#line 484
  *(hmm->esc + hmm->M) = 0;
#line 485
  accum = (float )0.;
#line 486
  k = hmm->M - 1;
#line 486
  while (k >= 1) {
#line 488
    if ((double )*(hmm->end + k) > 0.) {
#line 488
      tmp___8 = log((double )*(hmm->end + k));
#line 488
      tme = (float )tmp___8;
    } else {
#line 488
      tme = (float )(- 9999.);
    }
#line 489
    if ((double )accum > - 9999.) {
#line 491
      if ((double )*(*(hmm->t + k) + 2) > 0.0) {
#line 493
        if (viterbi_mode) {
#line 493
          tmp___11 = log((double )*(*(hmm->t + k) + 2));
#line 493
          if ((double )tme > (double )accum + tmp___11) {
#line 493
            tme = tme;
          } else {
#line 493
            tmp___10 = log((double )*(*(hmm->t + k) + 2));
#line 493
            tme = (float )((double )accum + tmp___10);
          }
        } else {
#line 494
          tmp___12 = log((double )*(*(hmm->t + k) + 2));
#line 494
          tme = LogSum(tme, (float )((double )accum + tmp___12));
        }
      }
#line 496
      if ((double )*(*(hmm->t + k) + 6) > 0.0) {
#line 496
        tmp___13 = log((double )*(*(hmm->t + k) + 6));
#line 496
        accum = (float )((double )accum + tmp___13);
      } else {
#line 496
        accum = (float )(- 9999.);
      }
    }
#line 499
    if ((double )tme > - 9999.) {
#line 499
      tmp___14 = floor(0.5 + (1000.0 * 1.44269504) * (double )tme);
#line 499
      *(hmm->esc + k) = (int )tmp___14;
    } else {
#line 499
      *(hmm->esc + k) = -987654321;
    }
#line 486
    k --;
  }
#line 503
  hmm->xsc[0][1] = Prob2Score(hmm->xt[0][1], hmm->p1);
#line 504
  hmm->xsc[0][0] = Prob2Score(hmm->xt[0][0], (float )1.0);
#line 505
  hmm->xsc[1][1] = Prob2Score(hmm->xt[1][1], (float )1.0);
#line 506
  hmm->xsc[1][0] = Prob2Score(hmm->xt[1][0], (float )1.0);
#line 507
  hmm->xsc[2][1] = Prob2Score(hmm->xt[2][1], hmm->p1);
#line 508
  hmm->xsc[2][0] = Prob2Score(hmm->xt[2][0], (float )(1. - (double )hmm->p1));
#line 509
  hmm->xsc[3][1] = Prob2Score(hmm->xt[3][1], hmm->p1);
#line 510
  hmm->xsc[3][0] = Prob2Score(hmm->xt[3][0], (float )1.0);
#line 512
  hmm->flags |= 1;
#line 513
  return;
}
}
#line 528 "plan7.c"
void Plan7Renormalize(struct plan7_s *hmm ) 
{ 
  int k ;
  int st ;
  float d___0 ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
#line 536
  k = 1;
#line 536
  while (k <= hmm->M) {
#line 537
    FNorm(*(hmm->mat + k), Alphabet_size);
#line 536
    k ++;
  }
#line 539
  k = 1;
#line 539
  while (k < hmm->M) {
#line 540
    FNorm(*(hmm->ins + k), Alphabet_size);
#line 539
    k ++;
  }
#line 542
  tmp = FSum(hmm->begin + 1, hmm->M);
#line 542
  d___0 = tmp + hmm->tbd1;
#line 543
  FScale(hmm->begin + 1, hmm->M, (float )(1. / (double )d___0));
#line 544
  hmm->tbd1 /= d___0;
#line 546
  k = 1;
#line 546
  while (k < hmm->M) {
#line 548
    tmp___0 = FSum(*(hmm->t + k), 3);
#line 548
    d___0 = tmp___0 + *(hmm->end + k);
#line 549
    FScale(*(hmm->t + k), 3, (float )(1. / (double )d___0));
#line 550
    *(hmm->end + k) /= d___0;
#line 552
    FNorm(*(hmm->t + k) + 3, 2);
#line 553
    FNorm(*(hmm->t + k) + 5, 2);
#line 546
    k ++;
  }
#line 556
  FNorm(hmm->null, Alphabet_size);
#line 558
  st = 0;
#line 558
  while (st < 4) {
#line 559
    FNorm(hmm->xt[st], 2);
#line 558
    st ++;
  }
#line 562
  tmp___1 = (float )0.0;
#line 562
  *(*(hmm->t + 0) + 6) = tmp___1;
#line 562
  *(*(hmm->t + 0) + 5) = tmp___1;
#line 564
  hmm->flags &= -2;
#line 565
  hmm->flags |= 1 << 5;
#line 566
  return;
}
}
#line 580 "plan7.c"
void Plan7RenormalizeExits(struct plan7_s *hmm ) 
{ 
  int k ;
  float d___0 ;

  {
#line 586
  k = 1;
#line 586
  while (k < hmm->M) {
#line 588
    d___0 = FSum(*(hmm->t + k), 3);
#line 589
    FScale(*(hmm->t + k), 3, (float )(1. / (double )(d___0 + d___0 * *(hmm->end + k))));
#line 586
    k ++;
  }
#line 591
  return;
}
}
#line 632 "plan7.c"
void Plan7NakedConfig(struct plan7_s *hmm ) 
{ 


  {
#line 635
  hmm->xt[0][0] = (float )1.;
#line 636
  hmm->xt[0][1] = (float )0.;
#line 637
  hmm->xt[1][0] = (float )1.;
#line 638
  hmm->xt[1][1] = (float )0.;
#line 639
  hmm->xt[2][0] = (float )1.;
#line 640
  hmm->xt[2][1] = (float )0.;
#line 641
  hmm->xt[3][0] = (float )0.;
#line 642
  hmm->xt[3][1] = (float )1.;
#line 643
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
#line 644
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
#line 645
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
#line 646
  *(hmm->end + hmm->M) = (float )1.;
#line 647
  Plan7RenormalizeExits(hmm);
#line 648
  hmm->flags &= -2;
#line 649
  return;
}
}
#line 665 "plan7.c"
void Plan7GlobalConfig(struct plan7_s *hmm ) 
{ 


  {
#line 668
  hmm->xt[0][0] = (float )(1. - (double )hmm->p1);
#line 669
  hmm->xt[0][1] = hmm->p1;
#line 670
  hmm->xt[1][0] = (float )1.;
#line 671
  hmm->xt[1][1] = (float )0.;
#line 672
  hmm->xt[2][0] = (float )(1. - (double )hmm->p1);
#line 673
  hmm->xt[2][1] = hmm->p1;
#line 674
  hmm->xt[3][0] = (float )0.;
#line 675
  hmm->xt[3][1] = (float )1.;
#line 676
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
#line 677
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
#line 678
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
#line 679
  *(hmm->end + hmm->M) = (float )1.;
#line 680
  Plan7RenormalizeExits(hmm);
#line 681
  hmm->flags &= -2;
#line 682
  return;
}
}
#line 694 "plan7.c"
void Plan7LSConfig(struct plan7_s *hmm ) 
{ 


  {
#line 697
  hmm->xt[0][0] = (float )(1. - (double )hmm->p1);
#line 698
  hmm->xt[0][1] = hmm->p1;
#line 699
  hmm->xt[1][0] = (float )0.5;
#line 700
  hmm->xt[1][1] = (float )0.5;
#line 701
  hmm->xt[2][0] = (float )(1. - (double )hmm->p1);
#line 702
  hmm->xt[2][1] = hmm->p1;
#line 703
  hmm->xt[3][0] = (float )(1. - (double )hmm->p1);
#line 704
  hmm->xt[3][1] = hmm->p1;
#line 705
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
#line 706
  *(hmm->begin + 1) = (float )(1. - (double )hmm->tbd1);
#line 707
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
#line 708
  *(hmm->end + hmm->M) = (float )1.;
#line 709
  Plan7RenormalizeExits(hmm);
#line 710
  hmm->flags &= -2;
#line 711
  return;
}
}
#line 739 "plan7.c"
void Plan7SWConfig(struct plan7_s *hmm , float pentry , float pexit ) 
{ 
  float basep ;
  int k ;

  {
#line 747
  hmm->xt[0][0] = (float )1 - hmm->p1;
#line 748
  hmm->xt[0][1] = hmm->p1;
#line 749
  hmm->xt[1][0] = (float )1.;
#line 750
  hmm->xt[1][1] = (float )0.;
#line 751
  hmm->xt[2][0] = (float )1 - hmm->p1;
#line 752
  hmm->xt[2][1] = hmm->p1;
#line 753
  hmm->xt[3][0] = (float )1.;
#line 754
  hmm->xt[3][1] = (float )0.;
#line 758
  *(hmm->begin + 1) = (float )((1. - (double )pentry) * (1. - (double )hmm->tbd1));
#line 759
  FSet(hmm->begin + 2, hmm->M - 1, (float )(((double )pentry * (1. - (double )hmm->tbd1)) / (double )((float )(hmm->M - 1))));
#line 763
  *(hmm->end + hmm->M) = (float )1.0;
#line 764
  basep = pexit / (float )(hmm->M - 1);
#line 765
  k = 1;
#line 765
  while (k < hmm->M) {
#line 766
    *(hmm->end + k) = (float )((double )basep / (1. - (double )(basep * (float )(k - 1))));
#line 765
    k ++;
  }
#line 767
  Plan7RenormalizeExits(hmm);
#line 768
  hmm->flags &= -2;
#line 769
  return;
}
}
#line 789 "plan7.c"
void Plan7FSConfig(struct plan7_s *hmm , float pentry , float pexit ) 
{ 
  float basep ;
  int k ;

  {
#line 797
  hmm->xt[0][0] = (float )1 - hmm->p1;
#line 798
  hmm->xt[0][1] = hmm->p1;
#line 799
  hmm->xt[1][0] = (float )0.5;
#line 800
  hmm->xt[1][1] = (float )0.5;
#line 801
  hmm->xt[2][0] = (float )1 - hmm->p1;
#line 802
  hmm->xt[2][1] = hmm->p1;
#line 803
  hmm->xt[3][0] = (float )(1. - (double )hmm->p1);
#line 804
  hmm->xt[3][1] = hmm->p1;
#line 808
  *(hmm->begin + 1) = (float )((1. - (double )pentry) * (1. - (double )hmm->tbd1));
#line 809
  FSet(hmm->begin + 2, hmm->M - 1, (float )(((double )pentry * (1. - (double )hmm->tbd1)) / (double )((float )(hmm->M - 1))));
#line 813
  *(hmm->end + hmm->M) = (float )1.0;
#line 814
  basep = pexit / (float )(hmm->M - 1);
#line 815
  k = 1;
#line 815
  while (k < hmm->M) {
#line 816
    *(hmm->end + k) = (float )((double )basep / (1. - (double )(basep * (float )(k - 1))));
#line 815
    k ++;
  }
#line 817
  Plan7RenormalizeExits(hmm);
#line 818
  hmm->flags &= -2;
#line 819
  return;
}
}
#line 837 "plan7.c"
void Plan7ESTConfig(struct plan7_s *hmm , int *aacode , float **estmodel , float dna2 ,
                    float dna4 ) 
{ 
  int k ;
  int x ;
  float p ;
  float *tripnull ;

  {
#line 846
  tripnull = (float *)((void *)0);
#line 849
  hmm->xt[0][0] = (float )(1. / 351.);
#line 850
  hmm->xt[0][1] = (float )(350. / 351.);
#line 851
  hmm->xt[1][0] = (float )1.;
#line 852
  hmm->xt[1][1] = (float )0.;
#line 853
  hmm->xt[2][0] = (float )(1. / 351.);
#line 854
  hmm->xt[2][1] = (float )(350. / 351.);
#line 855
  hmm->xt[3][0] = (float )1.;
#line 856
  hmm->xt[3][1] = (float )0.;
#line 858
  *(hmm->begin + 1) = (float )0.5;
#line 859
  FSet(hmm->begin + 2, hmm->M - 1, (float )(0.5 / ((double )((float )hmm->M) - 1.)));
#line 860
  *(hmm->end + hmm->M) = (float )1.;
#line 861
  FSet(hmm->end, hmm->M - 1, (float )(0.5 / ((double )((float )hmm->M) - 1.)));
#line 864
  k = 1;
#line 864
  while (k <= hmm->M) {
#line 867
    x = 0;
#line 867
    while (x < 64) {
#line 868
      p = (float )((double )(*(*(hmm->mat + k) + *(aacode + x)) * *(*(estmodel + *(aacode + x)) + x)) * ((1. - (double )dna2) - (double )dna4));
#line 869
      *(*(hmm->dnam + x) + k) = Prob2Score(p, *(tripnull + x));
#line 871
      p = (float )((double )(*(*(hmm->ins + k) + *(aacode + x)) * *(*(estmodel + *(aacode + x)) + x)) * ((1. - (double )dna2) - (double )dna4));
#line 872
      *(*(hmm->dnai + x) + k) = Prob2Score(p, *(tripnull + x));
#line 867
      x ++;
    }
#line 874
    *(*(hmm->dnam + 64) + k) = 0;
#line 875
    hmm->dna2 = Prob2Score(dna2, (float )1.);
#line 876
    hmm->dna4 = Prob2Score(dna4, (float )1.);
#line 864
    k ++;
  }
#line 878
  return;
}
}
#line 896 "plan7.c"
void PrintPlan7Stats(FILE *fp , struct plan7_s *hmm , char **dsq , int nseq , struct p7trace_s **tr ) 
{ 
  int idx ;
  float score ;
  float total ;
  float best ;
  float worst ;
  float sqsum ;
  float stddev ;
  double tmp ;

  {
#line 905
  P7Logoddsify(hmm, 1);
#line 908
  score = P7TraceScore(hmm, *(dsq + 0), *(tr + 0));
#line 909
  worst = score;
#line 909
  best = worst;
#line 909
  total = best;
#line 910
  sqsum = score * score;
#line 911
  idx = 1;
#line 911
  while (idx < nseq) {
#line 913
    score = P7TraceScore(hmm, *(dsq + idx), *(tr + idx));
#line 914
    total += score;
#line 915
    sqsum += score * score;
#line 916
    if (score > best) {
#line 916
      best = score;
    }
#line 917
    if (score < worst) {
#line 917
      worst = score;
    }
#line 911
    idx ++;
  }
#line 919
  if (nseq > 1) {
#line 920
    stddev = (float )((double )(sqsum - (total * total) / (float )nseq) / ((double )((float )nseq) - 1.));
#line 921
    if (stddev > (float )0) {
#line 921
      tmp = sqrt((double )stddev);
#line 921
      stddev = (float )tmp;
    } else {
#line 921
      stddev = (float )0.0;
    }
  } else {
#line 922
    stddev = (float )0.0;
  }
#line 924
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Average score:  %10.2f bits\n",
          (double )(total / (float )nseq));
#line 925
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Minimum score:  %10.2f bits\n",
          (double )worst);
#line 926
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Maximum score:  %10.2f bits\n",
          (double )best);
#line 927
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Std. deviation: %10.2f bits\n",
          (double )stddev);
#line 928
  return;
}
}
#line 970 "plan7.c"
int DegenerateSymbolScore(float *p , float *null , int ambig ) 
{ 
  int x ;
  float numer ;
  float denom ;
  double tmp ;
  double tmp___0 ;

  {
#line 974
  numer = (float )0.;
#line 975
  denom = (float )0.;
#line 977
  x = 0;
#line 977
  while (x < Alphabet_size) {
#line 978
    if (Degenerate[ambig][x]) {
#line 979
      if (*(p + x) / *(null + x) > (float )0) {
#line 979
        tmp = log((double )(*(p + x) / *(null + x)));
#line 979
        tmp___0 = tmp * 1.44269504;
      } else {
#line 979
        tmp___0 = - 9999.;
      }
#line 979
      numer = (float )((double )numer + (double )*(null + x) * tmp___0);
#line 980
      denom += *(null + x);
    }
#line 977
    x ++;
  }
#line 983
  return ((int )((1000.0 * (double )numer) / (double )denom));
}
}
#line 1005 "plan7.c"
void Plan9toPlan7(struct plan9_s *hmm , struct plan7_s **ret_plan7 ) 
{ 
  struct plan7_s *plan7 ;
  int k ;
  int x ;

  {
#line 1011
  plan7 = AllocPlan7(hmm->M);
#line 1013
  k = 1;
#line 1013
  while (k < hmm->M) {
#line 1015
    *(*(plan7->t + k) + 0) = (hmm->mat + k)->t[0];
#line 1016
    *(*(plan7->t + k) + 2) = (hmm->mat + k)->t[2];
#line 1017
    *(*(plan7->t + k) + 1) = (hmm->mat + k)->t[1];
#line 1018
    *(*(plan7->t + k) + 5) = (hmm->del + k)->t[0];
#line 1019
    *(*(plan7->t + k) + 6) = (hmm->del + k)->t[2];
#line 1020
    *(*(plan7->t + k) + 3) = (hmm->ins + k)->t[0];
#line 1021
    *(*(plan7->t + k) + 4) = (hmm->ins + k)->t[1];
#line 1013
    k ++;
  }
#line 1024
  k = 1;
#line 1024
  while (k <= hmm->M) {
#line 1025
    x = 0;
#line 1025
    while (x < Alphabet_size) {
#line 1026
      *(*(plan7->mat + k) + x) = (hmm->mat + k)->p[x];
#line 1025
      x ++;
    }
#line 1024
    k ++;
  }
#line 1028
  k = 1;
#line 1028
  while (k < hmm->M) {
#line 1029
    x = 0;
#line 1029
    while (x < Alphabet_size) {
#line 1030
      *(*(plan7->ins + k) + x) = (hmm->ins + k)->p[x];
#line 1029
      x ++;
    }
#line 1028
    k ++;
  }
#line 1032
  plan7->tbd1 = (hmm->mat + 0)->t[2] / ((hmm->mat + 0)->t[2] + (hmm->mat + 0)->t[0]);
#line 1035
  P7DefaultNullModel(plan7->null, & plan7->p1);
#line 1036
  x = 0;
#line 1036
  while (x < Alphabet_size) {
#line 1037
    plan7->null[x] = hmm->null[x];
#line 1036
    x ++;
  }
#line 1039
  if ((unsigned long )hmm->name != (unsigned long )((void *)0)) {
#line 1040
    Plan7SetName(plan7, hmm->name);
  }
#line 1041
  if (hmm->flags & 1) {
#line 1042
    strcpy((char * __restrict  )plan7->rf, (char const   * __restrict  )hmm->ref);
#line 1043
    plan7->flags |= 1 << 2;
  }
#line 1045
  if (hmm->flags & (1 << 1)) {
#line 1046
    strcpy((char * __restrict  )plan7->cs, (char const   * __restrict  )hmm->cs);
#line 1047
    plan7->flags |= 1 << 3;
  }
#line 1050
  Plan7LSConfig(plan7);
#line 1051
  Plan7Renormalize(plan7);
#line 1052
  plan7->flags |= 1 << 5;
#line 1053
  plan7->flags &= -2;
#line 1054
  *ret_plan7 = plan7;
#line 1055
  return;
}
}
#line 1 "plan9.o"
#pragma merger("0","/tmp/cil-ZJRGk8Vb.i","")
#line 129 "./squid.h"
float aafq[20] ;
#line 233 "./funcs.h"
void P9ZeroHMM(struct plan9_s *hmm ) ;
#line 30 "plan9.c"
struct plan9_s *P9AllocHMM(int M ) 
{ 
  struct plan9_s *hmm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 35
  tmp = sre_malloc((char *)"plan9.c", 35, sizeof(struct plan9_s ));
#line 35
  hmm = (struct plan9_s *)tmp;
#line 36
  tmp___0 = sre_malloc((char *)"plan9.c", 36, sizeof(struct basic_state ) * (unsigned long )(M + 2));
#line 36
  hmm->ins = (struct basic_state *)tmp___0;
#line 37
  tmp___1 = sre_malloc((char *)"plan9.c", 37, sizeof(struct basic_state ) * (unsigned long )(M + 2));
#line 37
  hmm->del = (struct basic_state *)tmp___1;
#line 38
  tmp___2 = sre_malloc((char *)"plan9.c", 38, sizeof(struct basic_state ) * (unsigned long )(M + 2));
#line 38
  hmm->mat = (struct basic_state *)tmp___2;
#line 39
  tmp___3 = sre_malloc((char *)"plan9.c", 39, (unsigned long )(M + 2) * sizeof(char ));
#line 39
  hmm->ref = (char *)tmp___3;
#line 40
  tmp___4 = sre_malloc((char *)"plan9.c", 40, (unsigned long )(M + 2) * sizeof(char ));
#line 40
  hmm->cs = (char *)tmp___4;
#line 41
  tmp___5 = sre_malloc((char *)"plan9.c", 41, ((unsigned long )(M + 2) * sizeof(float )) * 4UL);
#line 41
  hmm->xray = (float *)tmp___5;
#line 42
  hmm->M = M;
#line 43
  hmm->name = Strdup((char *)"unnamed");
#line 45
  hmm->flags = 0;
#line 46
  P9ZeroHMM(hmm);
#line 47
  return (hmm);
}
}
#line 49 "plan9.c"
int P9FreeHMM(struct plan9_s *hmm ) 
{ 


  {
#line 52
  if ((unsigned long )hmm == (unsigned long )((void *)0)) {
#line 52
    return (0);
  }
#line 53
  free((void *)hmm->ref);
#line 54
  free((void *)hmm->cs);
#line 55
  free((void *)hmm->xray);
#line 56
  free((void *)hmm->name);
#line 57
  if ((unsigned long )hmm->mat != (unsigned long )((void *)0)) {
#line 57
    free((void *)hmm->mat);
  }
#line 58
  if ((unsigned long )hmm->ins != (unsigned long )((void *)0)) {
#line 58
    free((void *)hmm->ins);
  }
#line 59
  if ((unsigned long )hmm->del != (unsigned long )((void *)0)) {
#line 59
    free((void *)hmm->del);
  }
#line 60
  free((void *)hmm);
#line 61
  return (1);
}
}
#line 69 "plan9.c"
void P9ZeroHMM(struct plan9_s *hmm ) 
{ 
  int k ;
  int ts ;
  int idx ;

  {
#line 74
  k = 0;
#line 74
  while (k <= hmm->M + 1) {
#line 76
    ts = 0;
#line 76
    while (ts < 3) {
#line 78
      (hmm->mat + k)->t[ts] = (float )0.0;
#line 79
      (hmm->ins + k)->t[ts] = (float )0.0;
#line 80
      (hmm->del + k)->t[ts] = (float )0.0;
#line 76
      ts ++;
    }
#line 82
    idx = 0;
#line 82
    while (idx < Alphabet_size) {
#line 84
      (hmm->mat + k)->p[idx] = (float )0.0;
#line 85
      (hmm->ins + k)->p[idx] = (float )0.0;
#line 86
      (hmm->del + k)->p[idx] = (float )0.0;
#line 82
      idx ++;
    }
#line 74
    k ++;
  }
#line 89
  return;
}
}
#line 103 "plan9.c"
void P9Renormalize(struct plan9_s *hmm ) 
{ 
  int k ;

  {
#line 108
  k = 0;
#line 108
  while (k <= hmm->M) {
#line 111
    FNorm((hmm->mat + k)->t, 3);
#line 112
    FNorm((hmm->ins + k)->t, 3);
#line 113
    if (k > 0) {
#line 113
      FNorm((hmm->del + k)->t, 3);
    }
#line 115
    if (k > 0) {
#line 115
      FNorm((hmm->mat + k)->p, Alphabet_size);
    }
#line 116
    FNorm((hmm->ins + k)->p, Alphabet_size);
#line 108
    k ++;
  }
#line 118
  return;
}
}
#line 127 "plan9.c"
void P9DefaultNullModel(float *null ) 
{ 
  int x ;

  {
#line 131
  if (Alphabet_type == 3) {
#line 132
    x = 0;
#line 132
    while (x < Alphabet_size) {
#line 133
      *(null + x) = aafq[x];
#line 132
      x ++;
    }
  } else
#line 134
  if (Alphabet_type == 2) {
#line 135
    x = 0;
#line 135
    while (x < Alphabet_size) {
#line 136
      *(null + x) = (float )0.25;
#line 135
      x ++;
    }
  } else {
#line 138
    Die((char *)"No support for non-protein, non-nucleic acid alphabets.");
  }
#line 139
  return;
}
}
#line 1 "postprob.o"
#pragma merger("0","/tmp/cil-ut2ss92i.i","")
#line 242 "./funcs.h"
float P7OptimalAccuracy(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) ;
#line 243
float P7Backward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) ;
#line 244
void P7EmitterPosterior(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                        struct dpmatrix_s *backward , struct dpmatrix_s *mx ) ;
#line 246
float P7FillOptimalAccuracy(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) ;
#line 248
void P7OptimalAccuracyTrace(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) ;
#line 250
char *PostalCode(int L , struct dpmatrix_s *mx , struct p7trace_s *tr ) ;
#line 96 "postprob.c"
float P7OptimalAccuracy(char *dsq , int L , struct plan7_s *hmm , struct p7trace_s **ret_tr ) 
{ 
  double sc ;
  struct dpmatrix_s *forward ;
  struct dpmatrix_s *backward ;
  float tmp ;

  {
#line 103
  P7Forward(dsq, L, hmm, & forward);
#line 104
  P7Backward(dsq, L, hmm, & backward);
#line 106
  P7EmitterPosterior(L, hmm, forward, backward, backward);
#line 108
  tmp = P7FillOptimalAccuracy(L, hmm->M, backward, forward, ret_tr);
#line 108
  sc = (double )tmp;
#line 110
  FreePlan7Matrix(forward);
#line 111
  FreePlan7Matrix(backward);
#line 113
  return ((float )sc);
}
}
#line 131 "postprob.c"
float P7Backward(char *dsq , int L , struct plan7_s *hmm , struct dpmatrix_s **ret_mx ) 
{ 
  struct dpmatrix_s *mx ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  float tmp___5 ;

  {
#line 144
  mx = AllocPlan7Matrix(L + 1, hmm->M, & xmx, & mmx, & imx, & dmx);
#line 150
  *(*(xmx + L) + 2) = hmm->xsc[2][0];
#line 151
  *(*(xmx + L) + 1) = *(*(xmx + L) + 2) + hmm->xsc[1][0];
#line 152
  tmp___0 = -987654321;
#line 152
  *(*(xmx + L) + 4) = tmp___0;
#line 152
  tmp = tmp___0;
#line 152
  *(*(xmx + L) + 0) = tmp;
#line 152
  *(*(xmx + L) + 3) = tmp;
#line 153
  k = hmm->M;
#line 153
  while (k >= 1) {
#line 154
    *(*(mmx + L) + k) = *(*(xmx + L) + 1) + *(hmm->esc + k);
#line 155
    *(*(mmx + L) + k) += *(*(hmm->msc + (int )*(dsq + L)) + k);
#line 156
    tmp___1 = -987654321;
#line 156
    *(*(dmx + L) + k) = tmp___1;
#line 156
    *(*(imx + L) + k) = tmp___1;
#line 153
    k --;
  }
#line 166
  tmp___2 = -987654321;
#line 166
  *(*(hmm->tsc + 2) + (hmm->M - 1)) = tmp___2;
#line 166
  *(*(hmm->tsc + 6) + (hmm->M - 1)) = tmp___2;
#line 167
  i___0 = L - 1;
#line 167
  while (i___0 >= 0) {
#line 172
    *(*(xmx + i___0) + 2) = *(*(xmx + (i___0 + 1)) + 2) + hmm->xsc[2][1];
#line 174
    *(*(xmx + i___0) + 0) = -987654321;
#line 182
    *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 0), *(*(mmx + (i___0 + 1)) + hmm->M) + *(hmm->bsc + (hmm->M - 1)));
#line 183
    k = hmm->M - 1;
#line 183
    while (k >= 1) {
#line 184
      *(*(xmx + i___0) + 0) = ILogsum(*(*(xmx + i___0) + 0), *(*(mmx + (i___0 + 1)) + k) + *(hmm->bsc + k));
#line 183
      k --;
    }
#line 186
    *(*(xmx + i___0) + 3) = ILogsum(*(*(xmx + i___0) + 0) + hmm->xsc[3][0], *(*(xmx + (i___0 + 1)) + 3) + hmm->xsc[3][1]);
#line 189
    *(*(xmx + i___0) + 1) = ILogsum(*(*(xmx + i___0) + 2) + hmm->xsc[1][0], *(*(xmx + i___0) + 3) + hmm->xsc[1][1]);
#line 192
    *(*(xmx + i___0) + 4) = ILogsum(*(*(xmx + i___0) + 0) + hmm->xsc[0][0], *(*(xmx + (i___0 + 1)) + 4) + hmm->xsc[0][1]);
#line 198
    if (i___0 > 0) {
#line 199
      *(*(mmx + i___0) + hmm->M) = (*(*(xmx + i___0) + 1) + *(hmm->esc + hmm->M)) + *(*(hmm->msc + (int )*(dsq + i___0)) + hmm->M);
#line 200
      *(*(dmx + i___0) + hmm->M) = -987654321;
#line 201
      k = hmm->M - 1;
#line 201
      while (k >= 1) {
#line 203
        tmp___3 = ILogsum(*(*(imx + (i___0 + 1)) + k) + *(*(hmm->tsc + 1) + k), *(*(dmx + i___0) + (k + 1)) + *(*(hmm->tsc + 2) + k));
#line 203
        tmp___4 = ILogsum(*(*(xmx + i___0) + 1) + *(hmm->esc + k), *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 0) + k));
#line 203
        *(*(mmx + i___0) + k) = ILogsum(tmp___4, tmp___3);
#line 207
        *(*(mmx + i___0) + k) += *(*(hmm->msc + (int )*(dsq + i___0)) + k);
#line 209
        *(*(imx + i___0) + k) = ILogsum(*(*(imx + (i___0 + 1)) + k) + *(*(hmm->tsc + 4) + k),
                                        *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 3) + k));
#line 211
        *(*(imx + i___0) + k) += *(*(hmm->isc + (int )*(dsq + i___0)) + k);
#line 213
        *(*(dmx + i___0) + k) = ILogsum(*(*(dmx + i___0) + (k + 1)) + *(*(hmm->tsc + 6) + k),
                                        *(*(mmx + (i___0 + 1)) + (k + 1)) + *(*(hmm->tsc + 5) + k));
#line 201
        k --;
      }
    }
#line 167
    i___0 --;
  }
#line 221
  sc = *(*(xmx + 0) + 4);
#line 223
  if ((unsigned long )ret_mx != (unsigned long )((void *)0)) {
#line 223
    *ret_mx = mx;
  } else {
#line 224
    FreePlan7Matrix(mx);
  }
#line 226
  tmp___5 = Scorify(sc);
#line 226
  return (tmp___5);
}
}
#line 249 "postprob.c"
void P7EmitterPosterior(int L , struct plan7_s *hmm , struct dpmatrix_s *forward ,
                        struct dpmatrix_s *backward , struct dpmatrix_s *mx ) 
{ 
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 260
  sc = *(*(backward->xmx + 0) + 4);
#line 262
  i___0 = L;
#line 262
  while (i___0 >= 1) {
#line 264
    *(*(mx->xmx + i___0) + 2) = ((*(*(forward->xmx + (i___0 - 1)) + 2) + hmm->xsc[2][1]) + *(*(backward->xmx + i___0) + 2)) - sc;
#line 266
    *(*(mx->xmx + i___0) + 3) = ((*(*(forward->xmx + (i___0 - 1)) + 3) + hmm->xsc[3][1]) + *(*(backward->xmx + i___0) + 3)) - sc;
#line 268
    *(*(mx->xmx + i___0) + 4) = ((*(*(forward->xmx + (i___0 - 1)) + 4) + hmm->xsc[0][1]) + *(*(backward->xmx + i___0) + 4)) - sc;
#line 270
    tmp = -987654321;
#line 270
    *(*(mx->xmx + i___0) + 1) = tmp;
#line 270
    *(*(mx->xmx + i___0) + 0) = tmp;
#line 272
    k = 1;
#line 272
    while (k < hmm->M) {
#line 273
      *(*(mx->mmx + i___0) + k) = *(*(backward->mmx + i___0) + k);
#line 274
      tmp___0 = ILogsum(*(*(forward->xmx + (i___0 - 1)) + 0) + *(hmm->bsc + k), *(*(forward->dmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 5) + (k - 1)));
#line 274
      tmp___1 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 0) + (k - 1)),
                        *(*(forward->imx + (i___0 - 1)) + (k - 1)) + *(*(hmm->tsc + 3) + (k - 1)));
#line 274
      tmp___2 = ILogsum(tmp___1, tmp___0);
#line 274
      *(*(mx->mmx + i___0) + k) += tmp___2;
#line 278
      *(*(mx->mmx + i___0) + k) -= sc;
#line 280
      *(*(mx->imx + i___0) + k) = *(*(backward->imx + i___0) + k);
#line 281
      tmp___3 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + k) + *(*(hmm->tsc + 1) + k),
                        *(*(forward->imx + (i___0 - 1)) + k) + *(*(hmm->tsc + 4) + k));
#line 281
      *(*(mx->imx + i___0) + k) += tmp___3;
#line 283
      *(*(mx->imx + i___0) + k) -= sc;
#line 285
      *(*(mx->dmx + i___0) + k) = -987654321;
#line 272
      k ++;
    }
#line 287
    *(*(mx->mmx + i___0) + hmm->M) = *(*(backward->mmx + i___0) + hmm->M);
#line 288
    tmp___4 = ILogsum(*(*(forward->xmx + (i___0 - 1)) + 0) + *(hmm->bsc + hmm->M),
                      *(*(forward->dmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 5) + (hmm->M - 1)));
#line 288
    tmp___5 = ILogsum(*(*(forward->mmx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 0) + (hmm->M - 1)),
                      *(*(forward->imx + (i___0 - 1)) + (hmm->M - 1)) + *(*(hmm->tsc + 3) + (hmm->M - 1)));
#line 288
    tmp___6 = ILogsum(tmp___5, tmp___4);
#line 288
    *(*(mx->mmx + i___0) + hmm->M) += tmp___6;
#line 292
    *(*(mx->mmx + i___0) + hmm->M) -= sc;
#line 294
    tmp___8 = -987654321;
#line 294
    *(*(mx->dmx + i___0) + 0) = tmp___8;
#line 294
    tmp___7 = tmp___8;
#line 294
    *(*(mx->dmx + i___0) + hmm->M) = tmp___7;
#line 294
    *(*(mx->imx + i___0) + hmm->M) = tmp___7;
#line 262
    i___0 --;
  }
#line 297
  return;
}
}
#line 319 "postprob.c"
float P7FillOptimalAccuracy(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int i___0 ;
  int k ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  float tmp___7 ;

  {
#line 333
  xmx = mx->xmx;
#line 334
  mmx = mx->mmx;
#line 335
  imx = mx->imx;
#line 336
  dmx = mx->dmx;
#line 343
  tmp___2 = -987654321;
#line 343
  *(*(xmx + 0) + 3) = tmp___2;
#line 343
  tmp___1 = tmp___2;
#line 343
  *(*(xmx + 0) + 2) = tmp___1;
#line 343
  tmp___0 = tmp___1;
#line 343
  *(*(xmx + 0) + 1) = tmp___0;
#line 343
  tmp = tmp___0;
#line 343
  *(*(xmx + 0) + 0) = tmp;
#line 343
  *(*(xmx + 0) + 4) = tmp;
#line 344
  k = 0;
#line 344
  while (k <= M) {
#line 345
    tmp___4 = -987654321;
#line 345
    *(*(dmx + 0) + k) = tmp___4;
#line 345
    tmp___3 = tmp___4;
#line 345
    *(*(imx + 0) + k) = tmp___3;
#line 345
    *(*(mmx + 0) + k) = tmp___3;
#line 344
    k ++;
  }
#line 351
  i___0 = 1;
#line 351
  while (i___0 <= L) {
#line 353
    tmp___6 = -987654321;
#line 353
    *(*(dmx + i___0) + 0) = tmp___6;
#line 353
    tmp___5 = tmp___6;
#line 353
    *(*(imx + i___0) + 0) = tmp___5;
#line 353
    *(*(mmx + i___0) + 0) = tmp___5;
#line 355
    k = 1;
#line 355
    while (k <= M) {
#line 358
      *(*(mmx + i___0) + k) = -987654321;
#line 359
      sc = *(*(mmx + (i___0 - 1)) + (k - 1));
#line 359
      if (sc > *(*(mmx + i___0) + k)) {
#line 360
        *(*(mmx + i___0) + k) = sc;
      }
#line 361
      sc = *(*(imx + (i___0 - 1)) + (k - 1));
#line 361
      if (sc > *(*(mmx + i___0) + k)) {
#line 362
        *(*(mmx + i___0) + k) = sc;
      }
#line 363
      sc = *(*(dmx + (i___0 - 1)) + (k - 1));
#line 363
      if (sc > *(*(mmx + i___0) + k)) {
#line 364
        *(*(mmx + i___0) + k) = sc;
      }
#line 365
      sc = *(*(xmx + (i___0 - 1)) + 0);
#line 365
      if (sc > *(*(mmx + i___0) + k)) {
#line 366
        *(*(mmx + i___0) + k) = sc;
      }
#line 367
      *(*(mmx + i___0) + k) = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->mmx + i___0) + k));
#line 370
      *(*(dmx + i___0) + k) = -987654321;
#line 371
      sc = *(*(mmx + i___0) + (k - 1));
#line 371
      if (sc > *(*(dmx + i___0) + k)) {
#line 372
        *(*(dmx + i___0) + k) = sc;
      }
#line 373
      sc = *(*(dmx + i___0) + (k - 1));
#line 373
      if (sc > *(*(dmx + i___0) + k)) {
#line 374
        *(*(dmx + i___0) + k) = sc;
      }
#line 377
      *(*(imx + i___0) + k) = -987654321;
#line 378
      sc = *(*(mmx + (i___0 - 1)) + k);
#line 378
      if (sc > *(*(imx + i___0) + k)) {
#line 379
        *(*(imx + i___0) + k) = sc;
      }
#line 380
      sc = *(*(imx + (i___0 - 1)) + k);
#line 380
      if (sc > *(*(imx + i___0) + k)) {
#line 381
        *(*(imx + i___0) + k) = sc;
      }
#line 382
      *(*(imx + i___0) + k) = ILogsum(*(*(imx + i___0) + k), *(*(posterior->imx + i___0) + k));
#line 355
      k ++;
    }
#line 390
    *(*(xmx + i___0) + 4) = -987654321;
#line 391
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 4), *(*(posterior->xmx + i___0) + 4));
#line 391
    if (sc > -987654321) {
#line 392
      *(*(xmx + i___0) + 4) = sc;
    }
#line 395
    *(*(xmx + i___0) + 1) = -987654321;
#line 396
    k = 1;
#line 396
    while (k <= M) {
#line 397
      sc = *(*(mmx + i___0) + k);
#line 397
      if (sc > *(*(xmx + i___0) + 1)) {
#line 398
        *(*(xmx + i___0) + 1) = sc;
      }
#line 396
      k ++;
    }
#line 401
    *(*(xmx + i___0) + 3) = -987654321;
#line 402
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 3), *(*(posterior->xmx + i___0) + 3));
#line 402
    if (sc > -987654321) {
#line 403
      *(*(xmx + i___0) + 3) = sc;
    }
#line 404
    sc = *(*(xmx + i___0) + 1);
#line 404
    if (sc > *(*(xmx + i___0) + 3)) {
#line 405
      *(*(xmx + i___0) + 3) = sc;
    }
#line 408
    *(*(xmx + i___0) + 0) = -987654321;
#line 409
    sc = *(*(xmx + i___0) + 4);
#line 409
    if (sc > -987654321) {
#line 410
      *(*(xmx + i___0) + 0) = sc;
    }
#line 411
    sc = *(*(xmx + i___0) + 3);
#line 411
    if (sc > *(*(xmx + i___0) + 0)) {
#line 412
      *(*(xmx + i___0) + 0) = sc;
    }
#line 415
    *(*(xmx + i___0) + 2) = -987654321;
#line 416
    sc = ILogsum(*(*(xmx + (i___0 - 1)) + 2), *(*(posterior->xmx + i___0) + 2));
#line 416
    if (sc > -987654321) {
#line 417
      *(*(xmx + i___0) + 2) = sc;
    }
#line 418
    sc = *(*(xmx + i___0) + 1);
#line 418
    if (sc > *(*(xmx + i___0) + 2)) {
#line 419
      *(*(xmx + i___0) + 2) = sc;
    }
#line 351
    i___0 ++;
  }
#line 423
  sc = *(*(xmx + L) + 2);
#line 425
  if ((unsigned long )ret_tr != (unsigned long )((void *)0)) {
#line 426
    P7OptimalAccuracyTrace(L, M, posterior, mx, & tr);
#line 427
    *ret_tr = tr;
  }
#line 430
  tmp___7 = Score2Prob(sc, (float )1);
#line 430
  return (tmp___7);
}
}
#line 448 "postprob.c"
void P7OptimalAccuracyTrace(int L , int M , struct dpmatrix_s *posterior , struct dpmatrix_s *mx ,
                            struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  int curralloc ;
  int tpos ;
  int i___0 ;
  int k ;
  int **xmx ;
  int **mmx ;
  int **imx ;
  int **dmx ;
  int sc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 467
  curralloc = L * 2 + 6;
#line 468
  P7AllocTrace(curralloc, & tr);
#line 470
  xmx = mx->xmx;
#line 471
  mmx = mx->mmx;
#line 472
  imx = mx->imx;
#line 473
  dmx = mx->dmx;
#line 478
  *(tr->statetype + 0) = (char)9;
#line 479
  *(tr->nodeidx + 0) = 0;
#line 480
  *(tr->pos + 0) = 0;
#line 481
  *(tr->statetype + 1) = (char)8;
#line 482
  *(tr->nodeidx + 1) = 0;
#line 483
  *(tr->pos + 1) = 0;
#line 484
  tpos = 2;
#line 485
  i___0 = L;
#line 489
  while ((int )*(tr->statetype + (tpos - 1)) != 4) {
#line 490
    switch ((int )*(tr->statetype + (tpos - 1))) {
    case 1: 
#line 492
    sc = *(*(mmx + (i___0 + 1)) + (k + 1));
#line 493
    tmp___6 = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
#line 493
    if (sc == tmp___6) {
#line 493
      if (i___0 > 0) {
#line 493
        if (k > 0) {
#line 495
          *(tr->statetype + tpos) = (char)1;
#line 496
          tmp = k;
#line 496
          k --;
#line 496
          *(tr->nodeidx + tpos) = tmp;
#line 497
          tmp___0 = i___0;
#line 497
          i___0 --;
#line 497
          *(tr->pos + tpos) = tmp___0;
        } else {
#line 493
          goto _L___4;
        }
      } else {
#line 493
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 499
      tmp___5 = ILogsum(*(*(imx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
#line 499
      if (sc == tmp___5) {
#line 499
        if (i___0 > 0) {
#line 499
          if (k > 0) {
#line 501
            *(tr->statetype + tpos) = (char)3;
#line 502
            *(tr->nodeidx + tpos) = k;
#line 503
            tmp___1 = i___0;
#line 503
            i___0 --;
#line 503
            *(tr->pos + tpos) = tmp___1;
          } else {
#line 499
            goto _L___2;
          }
        } else {
#line 499
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 505
        tmp___4 = ILogsum(*(*(dmx + i___0) + k), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
#line 505
        if (sc == tmp___4) {
#line 505
          if (i___0 > 0) {
#line 505
            if (k > 1) {
#line 507
              *(tr->statetype + tpos) = (char)2;
#line 508
              tmp___2 = k;
#line 508
              k --;
#line 508
              *(tr->nodeidx + tpos) = tmp___2;
#line 509
              *(tr->pos + tpos) = 0;
            } else {
#line 505
              goto _L___0;
            }
          } else {
#line 505
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 511
          tmp___3 = ILogsum(*(*(xmx + i___0) + 0), *(*(posterior->mmx + (i___0 + 1)) + (k + 1)));
#line 511
          if (sc == tmp___3) {
#line 513
            *(tr->statetype + tpos) = (char)6;
#line 514
            *(tr->nodeidx + tpos) = 0;
#line 515
            *(tr->pos + tpos) = 0;
          } else {
#line 517
            Die((char *)"traceback failed");
          }
        }
      }
    }
#line 518
    break;
    case 2: 
#line 521
    if (*(*(dmx + i___0) + (k + 1)) == *(*(mmx + i___0) + k)) {
#line 521
      if (i___0 > 0) {
#line 521
        if (k > 0) {
#line 523
          *(tr->statetype + tpos) = (char)1;
#line 524
          tmp___7 = k;
#line 524
          k --;
#line 524
          *(tr->nodeidx + tpos) = tmp___7;
#line 525
          tmp___8 = i___0;
#line 525
          i___0 --;
#line 525
          *(tr->pos + tpos) = tmp___8;
        } else {
#line 521
          goto _L___6;
        }
      } else {
#line 521
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 527
    if (*(*(dmx + i___0) + (k + 1)) == *(*(dmx + i___0) + k)) {
#line 527
      if (k > 1) {
#line 529
        *(tr->statetype + tpos) = (char)2;
#line 530
        tmp___9 = k;
#line 530
        k --;
#line 530
        *(tr->nodeidx + tpos) = tmp___9;
#line 531
        *(tr->pos + tpos) = 0;
      } else {
#line 533
        Die((char *)"traceback failed");
      }
    } else {
#line 533
      Die((char *)"traceback failed");
    }
#line 534
    break;
    case 3: 
#line 537
    sc = *(*(imx + (i___0 + 1)) + k);
#line 538
    tmp___14 = ILogsum(*(*(mmx + i___0) + k), *(*(posterior->imx + (i___0 + 1)) + k));
#line 538
    if (sc == tmp___14) {
#line 538
      if (i___0 > 0) {
#line 538
        if (k > 0) {
#line 540
          *(tr->statetype + tpos) = (char)1;
#line 541
          tmp___10 = k;
#line 541
          k --;
#line 541
          *(tr->nodeidx + tpos) = tmp___10;
#line 542
          tmp___11 = i___0;
#line 542
          i___0 --;
#line 542
          *(tr->pos + tpos) = tmp___11;
        } else {
#line 538
          goto _L___8;
        }
      } else {
#line 538
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ 
#line 544
      tmp___13 = ILogsum(*(*(imx + i___0) + k), *(*(posterior->imx + (i___0 + 1)) + k));
#line 544
      if (sc == tmp___13) {
#line 544
        if (i___0 > 0) {
#line 544
          if (k > 0) {
#line 546
            *(tr->statetype + tpos) = (char)3;
#line 547
            *(tr->nodeidx + tpos) = k;
#line 548
            tmp___12 = i___0;
#line 548
            i___0 --;
#line 548
            *(tr->pos + tpos) = tmp___12;
          } else {
#line 550
            Die((char *)"traceback failed");
          }
        } else {
#line 550
          Die((char *)"traceback failed");
        }
      } else {
#line 550
        Die((char *)"traceback failed");
      }
    }
#line 551
    break;
    case 5: 
#line 554
    if (i___0 == 0) {
#line 554
      if (*(*(xmx + i___0) + 4) == -987654321) {
#line 556
        *(tr->statetype + tpos) = (char)4;
#line 557
        *(tr->nodeidx + tpos) = 0;
#line 558
        *(tr->pos + tpos) = 0;
      } else {
#line 554
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 560
    if (i___0 > 0) {
#line 560
      tmp___16 = ILogsum(*(*(xmx + i___0) + 4), *(*(posterior->xmx + (i___0 + 1)) + 4));
#line 560
      if (*(*(xmx + (i___0 + 1)) + 4) == tmp___16) {
#line 560
        if (i___0 > 0) {
#line 562
          *(tr->statetype + tpos) = (char)5;
#line 563
          *(tr->nodeidx + tpos) = 0;
#line 564
          *(tr->pos + tpos) = 0;
#line 565
          tmp___15 = i___0;
#line 565
          i___0 --;
#line 565
          *(tr->pos + (tpos - 1)) = tmp___15;
        } else {
#line 567
          Die((char *)"traceback failed");
        }
      } else {
#line 567
        Die((char *)"traceback failed");
      }
    } else {
#line 567
      Die((char *)"traceback failed");
    }
#line 568
    break;
    case 6: 
#line 571
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 4)) {
#line 573
      *(tr->statetype + tpos) = (char)5;
#line 574
      *(tr->nodeidx + tpos) = 0;
#line 575
      *(tr->pos + tpos) = 0;
    } else
#line 577
    if (*(*(xmx + i___0) + 0) == *(*(xmx + i___0) + 3)) {
#line 579
      *(tr->statetype + tpos) = (char)10;
#line 580
      *(tr->nodeidx + tpos) = 0;
#line 581
      *(tr->pos + tpos) = 0;
    } else {
#line 583
      Die((char *)"traceback failed");
    }
#line 584
    break;
    case 7: 
#line 587
    k = M;
#line 587
    while (k >= 1) {
#line 588
      if (*(*(xmx + i___0) + 1) == *(*(mmx + i___0) + k)) {
#line 588
        if (i___0 > 0) {
#line 590
          *(tr->statetype + tpos) = (char)1;
#line 591
          tmp___17 = k;
#line 591
          k --;
#line 591
          *(tr->nodeidx + tpos) = tmp___17;
#line 592
          tmp___18 = i___0;
#line 592
          i___0 --;
#line 592
          *(tr->pos + tpos) = tmp___18;
#line 593
          break;
        }
      }
#line 587
      k --;
    }
#line 595
    if (k <= 0) {
#line 595
      Die((char *)"traceback failed");
    }
#line 596
    break;
    case 8: 
#line 599
    tmp___20 = ILogsum(*(*(xmx + (i___0 - 1)) + 2), *(*(posterior->xmx + i___0) + 2));
#line 599
    if (*(*(xmx + i___0) + 2) == tmp___20) {
#line 599
      if (i___0 > 0) {
#line 601
        *(tr->statetype + tpos) = (char)8;
#line 602
        *(tr->nodeidx + tpos) = 0;
#line 603
        *(tr->pos + tpos) = 0;
#line 604
        tmp___19 = i___0;
#line 604
        i___0 --;
#line 604
        *(tr->pos + (tpos - 1)) = tmp___19;
      } else {
#line 599
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 606
    if (*(*(xmx + i___0) + 2) == *(*(xmx + i___0) + 1)) {
#line 608
      *(tr->statetype + tpos) = (char)7;
#line 609
      *(tr->nodeidx + tpos) = 0;
#line 610
      *(tr->pos + tpos) = 0;
    } else {
#line 612
      Die((char *)"Traceback failed.");
    }
#line 613
    break;
    case 10: 
#line 616
    tmp___22 = ILogsum(*(*(xmx + (i___0 - 1)) + 3), *(*(posterior->xmx + i___0) + 3));
#line 616
    if (*(*(xmx + i___0) + 3) == tmp___22) {
#line 616
      if (i___0 > 0) {
#line 618
        *(tr->statetype + tpos) = (char)10;
#line 619
        *(tr->nodeidx + tpos) = 0;
#line 620
        *(tr->pos + tpos) = 0;
#line 621
        tmp___21 = i___0;
#line 621
        i___0 --;
#line 621
        *(tr->pos + (tpos - 1)) = tmp___21;
      } else {
#line 616
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 623
    if (*(*(xmx + i___0) + 3) == *(*(xmx + i___0) + 1)) {
#line 625
      *(tr->statetype + tpos) = (char)7;
#line 626
      *(tr->nodeidx + tpos) = 0;
#line 627
      *(tr->pos + tpos) = 0;
    } else {
#line 629
      Die((char *)"Traceback failed.");
    }
#line 630
    break;
    default: 
#line 633
    Die((char *)"traceback failed");
    }
#line 637
    tpos ++;
#line 638
    if (tpos == curralloc) {
#line 640
      curralloc += L;
#line 641
      P7ReallocTrace(tr, curralloc);
    }
  }
#line 645
  tr->tlen = tpos;
#line 646
  P7ReverseTrace(tr);
#line 647
  *ret_tr = tr;
#line 649
  return;
}
}
#line 677 "postprob.c"
static char score2postcode(int sc ) 
{ 
  char i___0 ;
  float tmp ;
  int tmp___0 ;

  {
#line 681
  tmp = Score2Prob(sc, (float )1.);
#line 681
  i___0 = (char )((double )tmp * 10.);
#line 682
  if ((int )i___0 > 9) {
#line 682
    tmp___0 = '*';
  } else {
#line 682
    tmp___0 = 48 + (int )i___0;
  }
#line 682
  return ((char )tmp___0);
}
}
#line 684 "postprob.c"
char *PostalCode(int L , struct dpmatrix_s *mx , struct p7trace_s *tr ) 
{ 
  int tpos ;
  int i___0 ;
  int k ;
  char *postcode ;
  void *tmp ;

  {
#line 692
  tmp = sre_malloc((char *)"postprob.c", 692, (unsigned long )(L + 1) * sizeof(char ));
#line 692
  postcode = (char *)tmp;
#line 693
  tpos = 0;
#line 693
  while (tpos < tr->tlen) {
#line 695
    i___0 = *(tr->pos + tpos);
#line 696
    k = *(tr->nodeidx + tpos);
#line 697
    if (i___0 == 0) {
#line 697
      goto __Cont;
    }
#line 699
    switch ((int )*(tr->statetype + tpos)) {
    case 1: 
#line 700
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->mmx + i___0) + k));
#line 700
    break;
    case 3: 
#line 701
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->imx + i___0) + k));
#line 701
    break;
    case 5: 
#line 702
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 4));
#line 702
    break;
    case 8: 
#line 703
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 2));
#line 703
    break;
    case 10: 
#line 704
    *(postcode + (i___0 - 1)) = score2postcode(*(*(mx->xmx + i___0) + 3));
#line 704
    break;
    }
    __Cont: /* CIL Label */ 
#line 693
    tpos ++;
  }
#line 707
  *(postcode + L) = (char )'\000';
#line 709
  return (postcode);
}
}
#line 1 "prior.o"
#pragma merger("0","/tmp/cil-JXseAf1V.i","")
#line 70 "./sqfuncs.h"
int ParsePAMFile(FILE *fp , int ***ret_pam , float *ret_scale ) ;
#line 222
void Free2DArray(void **p , int dim1 ) ;
#line 255 "./funcs.h"
struct p7prior_s *P7AllocPrior(void) ;
#line 256
struct p7prior_s *P7LaplacePrior(void) ;
#line 257
struct p7prior_s *P7DefaultPrior(void) ;
#line 258
struct p7prior_s *P7ReadPrior(char *prifile ) ;
#line 259
void P7FreePrior(struct p7prior_s *pri ) ;
#line 260
void PAMPrior(char *pamfile , struct p7prior_s *pri , float wt ) ;
#line 262
void P7ReadNullModel(char *rndfile , float *null , float *ret_p1 ) ;
#line 263
void P7PriorifyHMM(struct plan7_s *hmm , struct p7prior_s *pri ) ;
#line 27 "prior.c"
static struct p7prior_s *default_amino_prior(void) ;
#line 28
static struct p7prior_s *default_nucleic_prior(void) ;
#line 35 "prior.c"
struct p7prior_s *P7AllocPrior(void) 
{ 
  void *tmp ;

  {
#line 37
  tmp = sre_malloc((char *)"prior.c", 37, sizeof(struct p7prior_s ));
#line 37
  return ((struct p7prior_s *)tmp);
}
}
#line 38 "prior.c"
void P7FreePrior(struct p7prior_s *pri ) 
{ 


  {
#line 40
  free((void *)pri);
#line 40
  return;
}
}
#line 52 "prior.c"
struct p7prior_s *P7LaplacePrior(void) 
{ 
  struct p7prior_s *pri ;

  {
#line 57
  pri = P7AllocPrior();
#line 58
  pri->strategy = 0;
#line 60
  pri->tnum = 1;
#line 61
  pri->tq[0] = (float )1.;
#line 62
  FSet(pri->t[0], 8, (float )1.);
#line 64
  pri->mnum = 1;
#line 65
  pri->mq[0] = (float )1.;
#line 66
  FSet(pri->m[0], Alphabet_size, (float )1.);
#line 68
  pri->inum = 1;
#line 69
  pri->iq[0] = (float )1.;
#line 70
  FSet(pri->i[0], Alphabet_size, (float )1.);
#line 72
  return (pri);
}
}
#line 80 "prior.c"
struct p7prior_s *P7DefaultPrior(void) 
{ 
  struct p7prior_s *tmp ;
  struct p7prior_s *tmp___0 ;

  {
#line 83
  switch (Alphabet_type) {
  case 3: 
#line 84
  tmp = default_amino_prior();
#line 84
  return (tmp);
  case 2: 
#line 85
  tmp___0 = default_nucleic_prior();
#line 85
  return (tmp___0);
  case 0: 
#line 86
  Die((char *)"Can\'t set prior; alphabet type not set yet");
  }
#line 89
  return ((struct p7prior_s *)((void *)0));
}
}
#line 96 "prior.c"
struct p7prior_s *P7ReadPrior(char *prifile ) 
{ 
  FILE *fp ;
  struct p7prior_s *pri ;
  char *sptr___0 ;
  int q ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;
  double tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  double tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  double tmp___16 ;

  {
#line 104
  fp = fopen((char const   * __restrict  )prifile, (char const   * __restrict  )"r");
#line 104
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 105
    Die((char *)"Failed to open HMMER prior file %s\n", prifile);
  }
#line 106
  pri = P7AllocPrior();
#line 111
  sptr___0 = Getword(fp, 4);
#line 112
  s2upper(sptr___0);
#line 113
  tmp = strcmp((char const   *)sptr___0, "DIRICHLET");
#line 113
  if (tmp == 0) {
#line 113
    pri->strategy = 0;
  } else {
#line 114
    Die((char *)"No such prior strategy %s; failed to parse file %s", sptr___0, prifile);
  }
#line 119
  sptr___0 = Getword(fp, 4);
#line 120
  s2upper(sptr___0);
#line 121
  tmp___1 = strcmp((char const   *)sptr___0, "AMINO");
#line 121
  if (tmp___1 == 0) {
#line 123
    if (Alphabet_type != 3) {
#line 124
      Die((char *)"HMM and/or sequences are DNA/RNA; can\'t use protein prior %s",
          prifile);
    }
  } else {
#line 126
    tmp___0 = strcmp((char const   *)sptr___0, "NUCLEIC");
#line 126
    if (tmp___0 == 0) {
#line 128
      if (Alphabet_type != 2) {
#line 129
        Die((char *)"HMM and/or sequences are protein; can\'t use DNA/RNA prior %s",
            prifile);
      }
    } else {
#line 132
      Die((char *)"Alphabet \"%s\" in prior file %s isn\'t valid.", sptr___0, prifile);
    }
  }
#line 140
  tmp___2 = Getword(fp, 1);
#line 140
  pri->tnum = atoi((char const   *)tmp___2);
#line 141
  if (pri->tnum < 0) {
#line 142
    Die((char *)"%d is bad; need at least one state transition mixture component",
        pri->tnum);
  }
#line 143
  if (pri->tnum > 200) {
#line 144
    Die((char *)"%d is bad, too many transition components (MAXDCHLET = %d)\n", 200);
  }
#line 145
  q = 0;
#line 145
  while (q < pri->tnum) {
#line 147
    tmp___3 = Getword(fp, 2);
#line 147
    tmp___4 = atof((char const   *)tmp___3);
#line 147
    pri->tq[q] = (float )tmp___4;
#line 148
    x = 0;
#line 148
    while (x < 7) {
#line 149
      tmp___5 = Getword(fp, 2);
#line 149
      tmp___6 = atof((char const   *)tmp___5);
#line 149
      pri->t[q][x] = (float )tmp___6;
#line 148
      x ++;
    }
#line 145
    q ++;
  }
#line 158
  tmp___7 = Getword(fp, 1);
#line 158
  pri->mnum = atoi((char const   *)tmp___7);
#line 159
  if (pri->mnum < 0) {
#line 160
    Die((char *)"%d is bad; need at least one match emission mixture component", pri->mnum);
  }
#line 161
  if (pri->mnum > 200) {
#line 162
    Die((char *)"%d is bad; too many match components (MAXDCHLET = %d)\n", pri->mnum,
        200);
  }
#line 164
  q = 0;
#line 164
  while (q < pri->mnum) {
#line 166
    tmp___8 = Getword(fp, 2);
#line 166
    tmp___9 = atof((char const   *)tmp___8);
#line 166
    pri->mq[q] = (float )tmp___9;
#line 167
    x = 0;
#line 167
    while (x < Alphabet_size) {
#line 168
      tmp___10 = Getword(fp, 2);
#line 168
      tmp___11 = atof((char const   *)tmp___10);
#line 168
      pri->m[q][x] = (float )tmp___11;
#line 167
      x ++;
    }
#line 164
    q ++;
  }
#line 177
  tmp___12 = Getword(fp, 1);
#line 177
  pri->inum = atoi((char const   *)tmp___12);
#line 178
  if (pri->inum < 0) {
#line 179
    Die((char *)"%d is bad; need at least one insert emission mixture component",
        pri->inum);
  }
#line 180
  if (pri->inum > 200) {
#line 181
    Die((char *)"%d is bad; too many insert components (MAXDCHLET = %d)\n", pri->inum,
        200);
  }
#line 182
  q = 0;
#line 182
  while (q < pri->inum) {
#line 184
    tmp___13 = Getword(fp, 2);
#line 184
    tmp___14 = atof((char const   *)tmp___13);
#line 184
    pri->iq[q] = (float )tmp___14;
#line 185
    x = 0;
#line 185
    while (x < Alphabet_size) {
#line 186
      tmp___15 = Getword(fp, 2);
#line 186
      tmp___16 = atof((char const   *)tmp___15);
#line 186
      pri->i[q][x] = (float )tmp___16;
#line 185
      x ++;
    }
#line 182
    q ++;
  }
#line 189
  fclose(fp);
#line 190
  return (pri);
}
}
#line 213 "prior.c"
void PAMPrior(char *pamfile , struct p7prior_s *pri , float wt ) 
{ 
  FILE *fp ;
  char *blastpamfile ;
  int **pam ;
  float scale ;
  int xi ;
  int xj ;
  int idx1 ;
  int idx2 ;
  int tmp ;
  double tmp___0 ;

  {
#line 223
  if (Alphabet_type != 3) {
#line 224
    Die((char *)"PAM prior is only valid for protein sequences");
  }
#line 225
  if (pri->strategy != 0) {
#line 226
    Die((char *)"PAM prior may only be applied over an existing Dirichlet prior");
  }
#line 227
  if (pri->inum != 1) {
#line 228
    Die((char *)"PAM prior requires that the insert emissions be a single Dirichlet");
  }
#line 232
  blastpamfile = FileConcat((char *)"aa", pamfile);
#line 234
  fp = fopen((char const   * __restrict  )pamfile, (char const   * __restrict  )"r");
#line 234
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 234
    fp = EnvFileOpen(pamfile, (char *)"BLASTMAT", (char **)((void *)0));
#line 234
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 234
      fp = EnvFileOpen(blastpamfile, (char *)"BLASTMAT", (char **)((void *)0));
#line 234
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 237
        Die((char *)"Failed to open PAM scoring matrix file %s", pamfile);
      }
    }
  }
#line 238
  tmp = ParsePAMFile(fp, & pam, & scale);
#line 238
  if (! tmp) {
#line 239
    Die((char *)"Failed to parse PAM scoring matrix file %s", pamfile);
  }
#line 240
  fclose(fp);
#line 241
  free((void *)blastpamfile);
#line 243
  pri->strategy = 1;
#line 244
  pri->mnum = 20;
#line 249
  xi = 0;
#line 249
  while (xi < Alphabet_size) {
#line 250
    xj = 0;
#line 250
    while (xj < Alphabet_size) {
#line 252
      idx1 = (int )Alphabet[xi] - 65;
#line 253
      idx2 = (int )Alphabet[xj] - 65;
#line 254
      tmp___0 = exp((double )((float )*(*(pam + idx1) + idx2) * scale));
#line 254
      pri->m[xi][xj] = (float )((double )aafq[xj] * tmp___0);
#line 250
      xj ++;
    }
#line 249
    xi ++;
  }
#line 260
  xi = 0;
#line 260
  while (xi < Alphabet_size) {
#line 262
    pri->mq[xi] = (float )(1. / (double )Alphabet_size);
#line 263
    FNorm(pri->m[xi], Alphabet_size);
#line 264
    FScale(pri->m[xi], Alphabet_size, wt);
#line 260
    xi ++;
  }
#line 267
  Free2DArray((void **)pam, 27);
#line 268
  return;
}
}
#line 278 "prior.c"
void P7DefaultNullModel(float *null , float *ret_p1 ) 
{ 
  int x ;

  {
#line 282
  if (Alphabet_type == 3) {
#line 283
    x = 0;
#line 283
    while (x < Alphabet_size) {
#line 284
      *(null + x) = aafq[x];
#line 283
      x ++;
    }
#line 285
    *ret_p1 = (float )(350. / 351.);
  } else {
#line 287
    x = 0;
#line 287
    while (x < Alphabet_size) {
#line 288
      *(null + x) = (float )(1.0 / (double )((float )Alphabet_size));
#line 287
      x ++;
    }
#line 289
    *ret_p1 = (float )(1000. / 1001.);
  }
#line 291
  return;
}
}
#line 293 "prior.c"
void P7ReadNullModel(char *rndfile , float *null , float *ret_p1 ) 
{ 
  FILE *fp ;
  char *s___0 ;
  int x ;
  int type ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 299
  type = 0;
#line 301
  fp = fopen((char const   * __restrict  )rndfile, (char const   * __restrict  )"r");
#line 301
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 302
    Die((char *)"Failed to open null model file %s\n", rndfile);
  }
#line 303
  s___0 = Getword(fp, 4);
#line 303
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 303
    goto FAILURE;
  }
#line 304
  s2upper(s___0);
#line 305
  tmp___0 = strcmp((char const   *)s___0, "NUCLEIC");
#line 305
  if (tmp___0 == 0) {
#line 305
    type = 2;
  } else {
#line 306
    tmp = strcmp((char const   *)s___0, "AMINO");
#line 306
    if (tmp == 0) {
#line 306
      type = 3;
    } else {
#line 307
      goto FAILURE;
    }
  }
#line 309
  if (Alphabet_type == 0) {
#line 310
    SetAlphabet(type);
  } else
#line 311
  if (Alphabet_type != type) {
#line 312
    Die((char *)"Alphabet type conflict; null model in %s is inappropriate\n", rndfile);
  }
#line 314
  x = 0;
#line 314
  while (x < Alphabet_size) {
#line 315
    s___0 = Getword(fp, 2);
#line 315
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 315
      goto FAILURE;
    }
#line 316
    tmp___1 = atof((char const   *)s___0);
#line 316
    *(null + x) = (float )tmp___1;
#line 314
    x ++;
  }
#line 318
  s___0 = Getword(fp, 2);
#line 318
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 318
    goto FAILURE;
  }
#line 319
  tmp___2 = atof((char const   *)s___0);
#line 319
  *ret_p1 = (float )tmp___2;
#line 321
  fclose(fp);
#line 322
  return;
  FAILURE: 
#line 325
  fclose(fp);
#line 326
  Die((char *)"%s is not in HMMER null model file format", rndfile);
#line 327
  return;
}
}
#line 341 "prior.c"
void P7PriorifyHMM(struct plan7_s *hmm , struct p7prior_s *pri ) 
{ 
  int k ;
  float d___0 ;
  float tq[200] ;
  float mq[200] ;
  float iq[200] ;

  {
#line 352
  FSet(hmm->begin + 2, hmm->M - 1, (float )0.);
#line 353
  FSet(hmm->end + 1, hmm->M - 1, (float )0.);
#line 354
  d___0 = (float )((double )(hmm->tbd1 + *(hmm->begin + 1)) + 2.);
#line 355
  hmm->tbd1 = (float )(((double )hmm->tbd1 + 1.) / (double )d___0);
#line 356
  *(hmm->begin + 1) = (float )(((double )*(hmm->begin + 1) + 1.) / (double )d___0);
#line 357
  *(hmm->end + hmm->M) = (float )1.0;
#line 361
  k = 1;
#line 361
  while (k < hmm->M) {
#line 372
    if ((unsigned long )hmm->tpri != (unsigned long )((void *)0)) {
#line 372
      if (*(hmm->tpri + k) >= 0) {
#line 374
        if (*(hmm->tpri + k) >= pri->tnum) {
#line 374
          Die((char *)"X-PRT annotation out of range");
        }
#line 375
        FSet(tq, pri->tnum, (float )0.0);
#line 376
        tq[*(hmm->tpri + k)] = (float )1.0;
      } else {
#line 379
        FCopy(tq, pri->tq, pri->tnum);
      }
    } else {
#line 379
      FCopy(tq, pri->tq, pri->tnum);
    }
#line 380
    if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
#line 380
      if (*(hmm->mpri + k) >= 0) {
#line 382
        if (*(hmm->mpri + k) >= pri->mnum) {
#line 382
          Die((char *)"X-PRM annotation out of range");
        }
#line 383
        FSet(mq, pri->mnum, (float )0.0);
#line 384
        mq[*(hmm->mpri + k)] = (float )1.0;
      } else {
#line 387
        FCopy(mq, pri->mq, pri->mnum);
      }
    } else {
#line 387
      FCopy(mq, pri->mq, pri->mnum);
    }
#line 388
    if ((unsigned long )hmm->ipri != (unsigned long )((void *)0)) {
#line 388
      if (*(hmm->ipri + k) >= 0) {
#line 390
        if (*(hmm->ipri + k) >= pri->inum) {
#line 390
          Die((char *)"X-PRI annotation out of range");
        }
#line 391
        FSet(iq, pri->inum, (float )0.0);
#line 392
        iq[*(hmm->ipri + k)] = (float )1.0;
      } else {
#line 395
        FCopy(iq, pri->iq, pri->inum);
      }
    } else {
#line 395
      FCopy(iq, pri->iq, pri->inum);
    }
#line 399
    P7PriorifyTransitionVector(*(hmm->t + k), pri, (float *)(tq));
#line 400
    P7PriorifyEmissionVector(*(hmm->mat + k), pri, pri->mnum, (float *)(mq), (float (*)[20])(pri->m),
                             (float *)((void *)0));
#line 401
    P7PriorifyEmissionVector(*(hmm->ins + k), pri, pri->inum, (float *)(iq), (float (*)[20])(pri->i),
                             (float *)((void *)0));
#line 361
    k ++;
  }
#line 406
  if ((unsigned long )hmm->mpri != (unsigned long )((void *)0)) {
#line 406
    if (*(hmm->mpri + hmm->M) >= 0) {
#line 408
      if (*(hmm->mpri + hmm->M) >= pri->mnum) {
#line 408
        Die((char *)"X-PRM annotation out of range");
      }
#line 409
      FSet(mq, pri->mnum, (float )0.0);
#line 410
      mq[*(hmm->mpri + hmm->M)] = (float )1.0;
    } else {
#line 413
      FCopy(mq, pri->mq, pri->mnum);
    }
  } else {
#line 413
    FCopy(mq, pri->mq, pri->mnum);
  }
#line 415
  P7PriorifyEmissionVector(*(hmm->mat + hmm->M), pri, pri->mnum, (float *)(mq), (float (*)[20])(pri->m),
                           (float *)((void *)0));
#line 419
  Plan7Renormalize(hmm);
#line 420
  return;
}
}
#line 442 "prior.c"
void P7PriorifyEmissionVector(float *vec , struct p7prior_s *pri , int num , float *eq ,
                              float (*e)[20] , float *ret_mix ) 
{ 
  int x ;
  int q ;
  float mix[200] ;
  float totc ;
  float tota ;
  float xi ;
  double tmp ;
  float tmp___0 ;

  {
#line 466
  mix[0] = (float )1.0;
#line 467
  if (pri->strategy == 0) {
#line 467
    if (num > 1) {
#line 469
      q = 0;
#line 469
      while (q < num) {
#line 471
        if ((double )*(eq + q) > 0.0) {
#line 471
          tmp = log((double )*(eq + q));
#line 471
          mix[q] = (float )tmp;
        } else {
#line 471
          mix[q] = (float )(- 999.);
        }
#line 472
        tmp___0 = Logp_cvec(vec, Alphabet_size, *(e + q));
#line 472
        mix[q] += tmp___0;
#line 469
        q ++;
      }
#line 474
      LogNorm(mix, num);
    } else {
#line 467
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 476
  if (pri->strategy == 1) {
#line 476
    if (num > 1) {
#line 478
      q = 0;
#line 478
      while (q < Alphabet_size) {
#line 479
        mix[q] = *(vec + q);
#line 478
        q ++;
      }
#line 480
      FNorm(mix, Alphabet_size);
    }
  }
#line 485
  totc = FSum(vec, Alphabet_size);
#line 486
  x = 0;
#line 486
  while (x < Alphabet_size) {
#line 487
    xi = (float )0.0;
#line 488
    q = 0;
#line 488
    while (q < num) {
#line 489
      tota = FSum(*(e + q), Alphabet_size);
#line 490
      xi += (mix[q] * (*(vec + x) + (*(e + q))[x])) / (totc + tota);
#line 488
      q ++;
    }
#line 492
    *(vec + x) = xi;
#line 486
    x ++;
  }
#line 494
  FNorm(vec, Alphabet_size);
#line 496
  if ((unsigned long )ret_mix != (unsigned long )((void *)0)) {
#line 497
    q = 0;
#line 497
    while (q < num) {
#line 498
      *(ret_mix + q) = mix[q];
#line 497
      q ++;
    }
  }
#line 499
  return;
}
}
#line 519 "prior.c"
void P7PriorifyTransitionVector(float *t___0 , struct p7prior_s *prior , float *tq ) 
{ 
  int ts ;
  int q ;
  float mix[200] ;
  float totm ;
  float totd ;
  float toti ;
  float xi ;
  double tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 529
  mix[0] = (float )1.0;
#line 530
  if (prior->strategy == 0) {
#line 530
    goto _L;
  } else
#line 530
  if (prior->strategy == 1) {
    _L: /* CIL Label */ 
#line 530
    if (prior->mnum > 1) {
#line 532
      q = 0;
#line 532
      while (q < prior->tnum) {
#line 534
        if ((double )*(tq + q) > 0.0) {
#line 534
          tmp = log((double )*(tq + q));
#line 534
          mix[q] = (float )tmp;
        } else {
#line 534
          mix[q] = (float )(- 999.);
        }
#line 535
        tmp___0 = Logp_cvec(t___0, 3, prior->t[q]);
#line 535
        mix[q] += tmp___0;
#line 536
        tmp___1 = Logp_cvec(t___0 + 3, 2, prior->t[q] + 3);
#line 536
        mix[q] += tmp___1;
#line 537
        tmp___2 = Logp_cvec(t___0 + 5, 2, prior->t[q] + 5);
#line 537
        mix[q] += tmp___2;
#line 532
        q ++;
      }
#line 539
      LogNorm(mix, prior->tnum);
    }
  }
#line 542
  totm = FSum(t___0, 3);
#line 543
  toti = *(t___0 + 3) + *(t___0 + 4);
#line 544
  totd = *(t___0 + 5) + *(t___0 + 6);
#line 546
  ts = 0;
#line 546
  while (ts < 7) {
#line 548
    xi = (float )0.0;
#line 549
    q = 0;
#line 549
    while (q < prior->tnum) {
#line 551
      switch (ts) {
      case 2: 
      case 1: 
      case 0: 
#line 553
      tmp___3 = FSum(prior->t[q], 3);
#line 553
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / (totm + tmp___3);
#line 555
      break;
      case 4: 
      case 3: 
#line 557
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / ((toti + prior->t[q][3]) + prior->t[q][4]);
#line 559
      break;
      case 6: 
      case 5: 
#line 561
      xi += (mix[q] * (*(t___0 + ts) + prior->t[q][ts])) / ((totd + prior->t[q][5]) + prior->t[q][6]);
#line 563
      break;
      }
#line 549
      q ++;
    }
#line 566
    *(t___0 + ts) = xi;
#line 546
    ts ++;
  }
#line 568
  FNorm(t___0, 3);
#line 569
  FNorm(t___0 + 3, 2);
#line 570
  FNorm(t___0 + 5, 2);
#line 571
  return;
}
}
#line 584 "prior.c"
static float defmq[9]  = 
#line 584
  {      (float )0.178091,      (float )0.056591,      (float )0.0960191,      (float )0.0781233, 
        (float )0.0834977,      (float )0.0904123,      (float )0.114468,      (float )0.0682132, 
        (float )0.234585};
#line 589 "prior.c"
static float defm[9][20]  = 
#line 589
  { {        (float )0.270671,        (float )0.039848,        (float )0.017576,        (float )0.016415, 
            (float )0.014268,        (float )0.131916,        (float )0.012391,        (float )0.022599, 
            (float )0.020358,        (float )0.030727,        (float )0.015315,        (float )0.048298, 
            (float )0.053803,        (float )0.020662,        (float )0.023612,        (float )0.216147, 
            (float )0.147226,        (float )0.065438,        (float )0.003758,        (float )0.009621}, 
   {        (float )0.021465,        (float )0.010300,        (float )0.011741,        (float )0.010883, 
            (float )0.385651,        (float )0.016416,        (float )0.076196,        (float )0.035329, 
            (float )0.013921,        (float )0.093517,        (float )0.022034,        (float )0.028593, 
            (float )0.013086,        (float )0.023011,        (float )0.018866,        (float )0.029156, 
            (float )0.018153,        (float )0.036100,        (float )0.071770,        (float )0.419641}, 
   {        (float )0.561459,        (float )0.045448,        (float )0.438366,        (float )0.764167, 
            (float )0.087364,        (float )0.259114,        (float )0.214940,        (float )0.145928, 
            (float )0.762204,        (float )0.247320,        (float )0.118662,        (float )0.441564, 
            (float )0.174822,        (float )0.530840,        (float )0.465529,        (float )0.583402, 
            (float )0.445586,        (float )0.227050,        (float )0.029510,        (float )0.121090}, 
   {        (float )0.070143,        (float )0.011140,        (float )0.019479,        (float )0.094657, 
            (float )0.013162,        (float )0.048038,        (float )0.077000,        (float )0.032939, 
            (float )0.576639,        (float )0.072293,        (float )0.028240,        (float )0.080372, 
            (float )0.037661,        (float )0.185037,        (float )0.506783,        (float )0.073732, 
            (float )0.071587,        (float )0.042532,        (float )0.011254,        (float )0.028723}, 
   {        (float )0.041103,        (float )0.014794,        (float )0.005610,        (float )0.010216, 
            (float )0.153602,        (float )0.007797,        (float )0.007175,        (float )0.299635, 
            (float )0.010849,        (float )0.999446,        (float )0.210189,        (float )0.006127, 
            (float )0.013021,        (float )0.019798,        (float )0.014509,        (float )0.012049, 
            (float )0.035799,        (float )0.180085,        (float )0.012744,        (float )0.026466}, 
   {        (float )0.115607,        (float )0.037381,        (float )0.012414,        (float )0.018179, 
            (float )0.051778,        (float )0.017255,        (float )0.004911,        (float )0.796882, 
            (float )0.017074,        (float )0.285858,        (float )0.075811,        (float )0.014548, 
            (float )0.015092,        (float )0.011382,        (float )0.012696,        (float )0.027535, 
            (float )0.088333,        (float )0.944340,        (float )0.004373,        (float )0.016741}, 
   {        (float )0.093461,        (float )0.004737,        (float )0.387252,        (float )0.347841, 
            (float )0.010822,        (float )0.105877,        (float )0.049776,        (float )0.014963, 
            (float )0.094276,        (float )0.027761,        (float )0.010040,        (float )0.187869, 
            (float )0.050018,        (float )0.110039,        (float )0.038668,        (float )0.119471, 
            (float )0.065802,        (float )0.025430,        (float )0.003215,        (float )0.018742}, 
   {        (float )0.452171,        (float )0.114613,        (float )0.062460,        (float )0.115702, 
            (float )0.284246,        (float )0.140204,        (float )0.100358,        (float )0.550230, 
            (float )0.143995,        (float )0.700649,        (float )0.276580,        (float )0.118569, 
            (float )0.097470,        (float )0.126673,        (float )0.143634,        (float )0.278983, 
            (float )0.358482,        (float )0.661750,        (float )0.061533,        (float )0.199373}, 
   {        (float )0.005193,        (float )0.004039,        (float )0.006722,        (float )0.006121, 
            (float )0.003468,        (float )0.016931,        (float )0.003647,        (float )0.002184, 
            (float )0.005019,        (float )0.005990,        (float )0.001473,        (float )0.004158, 
            (float )0.009055,        (float )0.003630,        (float )0.006583,        (float )0.003172, 
            (float )0.003690,        (float )0.002967,        (float )0.002772,        (float )0.002686}};
#line 578 "prior.c"
static struct p7prior_s *default_amino_prior(void) 
{ 
  struct p7prior_s *pri ;
  int q ;
  int x ;

  {
#line 628
  pri = P7AllocPrior();
#line 629
  pri->strategy = 0;
#line 634
  pri->tnum = 1;
#line 635
  pri->tq[0] = (float )1.0;
#line 636
  pri->t[0][0] = (float )0.7939;
#line 637
  pri->t[0][1] = (float )0.0278;
#line 638
  pri->t[0][2] = (float )0.0135;
#line 639
  pri->t[0][3] = (float )0.1551;
#line 640
  pri->t[0][4] = (float )0.1331;
#line 641
  pri->t[0][5] = (float )0.9002;
#line 642
  pri->t[0][6] = (float )0.5630;
#line 647
  pri->mnum = 9;
#line 648
  q = 0;
#line 648
  while (q < pri->mnum) {
#line 650
    pri->mq[q] = defmq[q];
#line 651
    x = 0;
#line 651
    while (x < 20) {
#line 652
      pri->m[q][x] = defm[q][x];
#line 651
      x ++;
    }
#line 648
    q ++;
  }
#line 661
  pri->inum = 1;
#line 662
  pri->iq[0] = (float )1.;
#line 663
  pri->i[0][0] = (float )681.;
#line 664
  pri->i[0][1] = (float )120.;
#line 665
  pri->i[0][2] = (float )623.;
#line 666
  pri->i[0][3] = (float )651.;
#line 667
  pri->i[0][4] = (float )313.;
#line 668
  pri->i[0][5] = (float )902.;
#line 669
  pri->i[0][6] = (float )241.;
#line 670
  pri->i[0][7] = (float )371.;
#line 671
  pri->i[0][8] = (float )687.;
#line 672
  pri->i[0][9] = (float )676.;
#line 673
  pri->i[0][10] = (float )143.;
#line 674
  pri->i[0][11] = (float )548.;
#line 675
  pri->i[0][12] = (float )647.;
#line 676
  pri->i[0][13] = (float )415.;
#line 677
  pri->i[0][14] = (float )551.;
#line 678
  pri->i[0][15] = (float )926.;
#line 679
  pri->i[0][16] = (float )623.;
#line 680
  pri->i[0][17] = (float )505.;
#line 681
  pri->i[0][18] = (float )102.;
#line 682
  pri->i[0][19] = (float )269.;
#line 684
  return (pri);
}
}
#line 692 "prior.c"
static struct p7prior_s *default_nucleic_prior(void) 
{ 
  struct p7prior_s *pri ;

  {
#line 697
  pri = P7AllocPrior();
#line 698
  pri->strategy = 0;
#line 706
  pri->tnum = 1;
#line 707
  pri->tq[0] = (float )1.;
#line 708
  pri->t[0][0] = (float )0.7939;
#line 709
  pri->t[0][1] = (float )0.0278;
#line 710
  pri->t[0][2] = (float )0.0135;
#line 711
  pri->t[0][3] = (float )0.1551;
#line 712
  pri->t[0][4] = (float )0.1331;
#line 713
  pri->t[0][5] = (float )0.9002;
#line 714
  pri->t[0][6] = (float )0.5630;
#line 716
  pri->mnum = 1;
#line 717
  pri->mq[0] = (float )1.;
#line 718
  FSet(pri->m[0], Alphabet_size, (float )1.);
#line 720
  pri->inum = 1;
#line 721
  pri->iq[0] = (float )1.;
#line 722
  FSet(pri->i[0], Alphabet_size, (float )1.);
#line 724
  return (pri);
}
}
#line 1 "tophits.o"
#pragma merger("0","/tmp/cil-yZXCO7kL.i","")
#line 300 "./funcs.h"
void GrowTophits(struct tophit_s *h___0 ) ;
#line 302
struct fancyali_s *AllocFancyAli(void) ;
#line 303
void FreeFancyAli(struct fancyali_s *ali ) ;
#line 322
void TophitsReport(struct tophit_s *h___0 , double E , int nseq ) ;
#line 77 "tophits.c"
struct tophit_s *AllocTophits(int lumpsize ) 
{ 
  struct tophit_s *hitlist ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 82
  tmp = sre_malloc((char *)"tophits.c", 82, sizeof(struct tophit_s ));
#line 82
  hitlist = (struct tophit_s *)tmp;
#line 83
  hitlist->hit = (struct hit_s **)((void *)0);
#line 84
  tmp___0 = sre_malloc((char *)"tophits.c", 84, (unsigned long )lumpsize * sizeof(struct hit_s ));
#line 84
  hitlist->unsrt = (struct hit_s *)tmp___0;
#line 85
  hitlist->alloc = lumpsize;
#line 86
  hitlist->num = 0;
#line 87
  hitlist->lump = lumpsize;
#line 88
  return (hitlist);
}
}
#line 90 "tophits.c"
void GrowTophits(struct tophit_s *h___0 ) 
{ 
  void *tmp ;

  {
#line 93
  tmp = sre_realloc((char *)"tophits.c", 93, (void *)h___0->unsrt, (unsigned long )(h___0->alloc + h___0->lump) * sizeof(struct hit_s ));
#line 93
  h___0->unsrt = (struct hit_s *)tmp;
#line 94
  h___0->alloc += h___0->lump;
#line 95
  return;
}
}
#line 96 "tophits.c"
void FreeTophits(struct tophit_s *h___0 ) 
{ 
  int pos ;

  {
#line 100
  pos = 0;
#line 100
  while (pos < h___0->num) {
#line 102
    if ((unsigned long )(h___0->unsrt + pos)->ali != (unsigned long )((void *)0)) {
#line 102
      FreeFancyAli((h___0->unsrt + pos)->ali);
    }
#line 103
    if ((unsigned long )(h___0->unsrt + pos)->name != (unsigned long )((void *)0)) {
#line 103
      free((void *)(h___0->unsrt + pos)->name);
    }
#line 104
    if ((unsigned long )(h___0->unsrt + pos)->acc != (unsigned long )((void *)0)) {
#line 104
      free((void *)(h___0->unsrt + pos)->acc);
    }
#line 105
    if ((unsigned long )(h___0->unsrt + pos)->desc != (unsigned long )((void *)0)) {
#line 105
      free((void *)(h___0->unsrt + pos)->desc);
    }
#line 100
    pos ++;
  }
#line 107
  free((void *)h___0->unsrt);
#line 108
  if ((unsigned long )h___0->hit != (unsigned long )((void *)0)) {
#line 108
    free((void *)h___0->hit);
  }
#line 109
  free((void *)h___0);
#line 110
  return;
}
}
#line 112 "tophits.c"
struct fancyali_s *AllocFancyAli(void) 
{ 
  struct fancyali_s *ali ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 117
  tmp = sre_malloc((char *)"tophits.c", 117, sizeof(struct fancyali_s ));
#line 117
  ali = (struct fancyali_s *)tmp;
#line 118
  tmp___3 = (char *)((void *)0);
#line 118
  ali->aseq = tmp___3;
#line 118
  tmp___2 = tmp___3;
#line 118
  ali->mline = tmp___2;
#line 118
  tmp___1 = tmp___2;
#line 118
  ali->model = tmp___1;
#line 118
  tmp___0 = tmp___1;
#line 118
  ali->csline = tmp___0;
#line 118
  ali->rfline = tmp___0;
#line 119
  tmp___4 = (char *)((void *)0);
#line 119
  ali->target = tmp___4;
#line 119
  ali->query = tmp___4;
#line 120
  tmp___5 = 0;
#line 120
  ali->sqto = tmp___5;
#line 120
  ali->sqfrom = tmp___5;
#line 121
  return (ali);
}
}
#line 123 "tophits.c"
void FreeFancyAli(struct fancyali_s *ali ) 
{ 


  {
#line 126
  if ((unsigned long )ali != (unsigned long )((void *)0)) {
#line 127
    if ((unsigned long )ali->rfline != (unsigned long )((void *)0)) {
#line 127
      free((void *)ali->rfline);
    }
#line 128
    if ((unsigned long )ali->csline != (unsigned long )((void *)0)) {
#line 128
      free((void *)ali->csline);
    }
#line 129
    if ((unsigned long )ali->model != (unsigned long )((void *)0)) {
#line 129
      free((void *)ali->model);
    }
#line 130
    if ((unsigned long )ali->mline != (unsigned long )((void *)0)) {
#line 130
      free((void *)ali->mline);
    }
#line 131
    if ((unsigned long )ali->aseq != (unsigned long )((void *)0)) {
#line 131
      free((void *)ali->aseq);
    }
#line 132
    if ((unsigned long )ali->query != (unsigned long )((void *)0)) {
#line 132
      free((void *)ali->query);
    }
#line 133
    if ((unsigned long )ali->target != (unsigned long )((void *)0)) {
#line 133
      free((void *)ali->target);
    }
#line 134
    free((void *)ali);
  }
#line 136
  return;
}
}
#line 175 "tophits.c"
void RegisterHit(struct tophit_s *h___0 , double key , double pvalue , float score ,
                 double motherp , float mothersc , char *name , char *acc , char *desc ,
                 int sqfrom , int sqto , int sqlen , int hmmfrom , int hmmto , int hmmlen ,
                 int domidx , int ndom , struct fancyali_s *ali ) 
{ 


  {
#line 186
  if (h___0->num == h___0->alloc) {
#line 186
    GrowTophits(h___0);
  }
#line 188
  (h___0->unsrt + h___0->num)->name = Strdup(name);
#line 189
  (h___0->unsrt + h___0->num)->acc = Strdup(acc);
#line 190
  (h___0->unsrt + h___0->num)->desc = Strdup(desc);
#line 191
  (h___0->unsrt + h___0->num)->sortkey = key;
#line 192
  (h___0->unsrt + h___0->num)->pvalue = pvalue;
#line 193
  (h___0->unsrt + h___0->num)->score = score;
#line 194
  (h___0->unsrt + h___0->num)->motherp = motherp;
#line 195
  (h___0->unsrt + h___0->num)->mothersc = mothersc;
#line 196
  (h___0->unsrt + h___0->num)->sqfrom = sqfrom;
#line 197
  (h___0->unsrt + h___0->num)->sqto = sqto;
#line 198
  (h___0->unsrt + h___0->num)->sqlen = sqlen;
#line 199
  (h___0->unsrt + h___0->num)->hmmfrom = hmmfrom;
#line 200
  (h___0->unsrt + h___0->num)->hmmto = hmmto;
#line 201
  (h___0->unsrt + h___0->num)->hmmlen = hmmlen;
#line 202
  (h___0->unsrt + h___0->num)->domidx = domidx;
#line 203
  (h___0->unsrt + h___0->num)->ndom = ndom;
#line 204
  (h___0->unsrt + h___0->num)->ali = ali;
#line 205
  (h___0->num) ++;
#line 206
  return;
}
}
#line 219 "tophits.c"
void GetRankedHit(struct tophit_s *h___0 , int rank , double *r_pvalue , float *r_score ,
                  double *r_motherp , float *r_mothersc , char **r_name , char **r_acc ,
                  char **r_desc , int *r_sqfrom , int *r_sqto , int *r_sqlen , int *r_hmmfrom ,
                  int *r_hmmto , int *r_hmmlen , int *r_domidx , int *r_ndom , struct fancyali_s **r_ali ) 
{ 


  {
#line 229
  if ((unsigned long )r_pvalue != (unsigned long )((void *)0)) {
#line 229
    *r_pvalue = (*(h___0->hit + rank))->pvalue;
  }
#line 230
  if ((unsigned long )r_score != (unsigned long )((void *)0)) {
#line 230
    *r_score = (*(h___0->hit + rank))->score;
  }
#line 231
  if ((unsigned long )r_motherp != (unsigned long )((void *)0)) {
#line 231
    *r_motherp = (*(h___0->hit + rank))->motherp;
  }
#line 232
  if ((unsigned long )r_mothersc != (unsigned long )((void *)0)) {
#line 232
    *r_mothersc = (*(h___0->hit + rank))->mothersc;
  }
#line 233
  if ((unsigned long )r_name != (unsigned long )((void *)0)) {
#line 233
    *r_name = (*(h___0->hit + rank))->name;
  }
#line 234
  if ((unsigned long )r_acc != (unsigned long )((void *)0)) {
#line 234
    *r_acc = (*(h___0->hit + rank))->acc;
  }
#line 235
  if ((unsigned long )r_desc != (unsigned long )((void *)0)) {
#line 235
    *r_desc = (*(h___0->hit + rank))->desc;
  }
#line 236
  if ((unsigned long )r_sqfrom != (unsigned long )((void *)0)) {
#line 236
    *r_sqfrom = (*(h___0->hit + rank))->sqfrom;
  }
#line 237
  if ((unsigned long )r_sqto != (unsigned long )((void *)0)) {
#line 237
    *r_sqto = (*(h___0->hit + rank))->sqto;
  }
#line 238
  if ((unsigned long )r_sqlen != (unsigned long )((void *)0)) {
#line 238
    *r_sqlen = (*(h___0->hit + rank))->sqlen;
  }
#line 239
  if ((unsigned long )r_hmmfrom != (unsigned long )((void *)0)) {
#line 239
    *r_hmmfrom = (*(h___0->hit + rank))->hmmfrom;
  }
#line 240
  if ((unsigned long )r_hmmto != (unsigned long )((void *)0)) {
#line 240
    *r_hmmto = (*(h___0->hit + rank))->hmmto;
  }
#line 241
  if ((unsigned long )r_hmmlen != (unsigned long )((void *)0)) {
#line 241
    *r_hmmlen = (*(h___0->hit + rank))->hmmlen;
  }
#line 242
  if ((unsigned long )r_domidx != (unsigned long )((void *)0)) {
#line 242
    *r_domidx = (*(h___0->hit + rank))->domidx;
  }
#line 243
  if ((unsigned long )r_ndom != (unsigned long )((void *)0)) {
#line 243
    *r_ndom = (*(h___0->hit + rank))->ndom;
  }
#line 244
  if ((unsigned long )r_ali != (unsigned long )((void *)0)) {
#line 244
    *r_ali = (*(h___0->hit + rank))->ali;
  }
#line 245
  return;
}
}
#line 252 "tophits.c"
int TophitsMaxName(struct tophit_s *h___0 ) 
{ 
  int i___0 ;
  int len ;
  int maxlen ;
  size_t tmp ;

  {
#line 258
  maxlen = 0;
#line 259
  i___0 = 0;
#line 259
  while (i___0 < h___0->num) {
#line 261
    tmp = strlen((char const   *)(h___0->unsrt + i___0)->name);
#line 261
    len = (int )tmp;
#line 262
    if (len > maxlen) {
#line 262
      maxlen = len;
    }
#line 259
    i___0 ++;
  }
#line 264
  return (maxlen);
}
}
#line 275 "tophits.c"
int hit_comparison(void const   *vh1 , void const   *vh2 ) 
{ 
  struct hit_s *h1 ;
  struct hit_s *h2 ;

  {
#line 279
  h1 = *((struct hit_s **)vh1);
#line 280
  h2 = *((struct hit_s **)vh2);
#line 282
  if (h1->sortkey < h2->sortkey) {
#line 282
    return (1);
  } else
#line 283
  if (h1->sortkey > h2->sortkey) {
#line 283
    return (-1);
  } else
#line 284
  if (h1->sortkey == h2->sortkey) {
#line 284
    return (0);
  }
#line 286
  return (0);
}
}
#line 307
void specqsort(char *base , int n , int size , int (*compar)() ) ;
#line 288 "tophits.c"
void FullSortTophits(struct tophit_s *h___0 ) 
{ 
  int i___0 ;
  void *tmp ;

  {
#line 296
  if (h___0->num == 0) {
#line 296
    return;
  }
#line 300
  tmp = sre_malloc((char *)"tophits.c", 300, (unsigned long )h___0->num * sizeof(struct hit_s *));
#line 300
  h___0->hit = (struct hit_s **)tmp;
#line 301
  i___0 = 0;
#line 301
  while (i___0 < h___0->num) {
#line 302
    *(h___0->hit + i___0) = h___0->unsrt + i___0;
#line 301
    i___0 ++;
  }
#line 306
  if (h___0->num > 1) {
#line 307
    specqsort(h___0->hit, h___0->num, sizeof(struct hit_s *), & hit_comparison);
  }
#line 308
  return;
}
}
#line 327 "tophits.c"
void TophitsReport(struct tophit_s *h___0 , double E , int nseq ) 
{ 
  int i___0 ;
  int memused ;
  int x ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 338
  memused = (int )(sizeof(struct hit_s ) * (unsigned long )h___0->alloc + sizeof(struct tophit_s ));
#line 339
  i___0 = 0;
#line 339
  while (i___0 < h___0->num) {
#line 341
    if ((unsigned long )(h___0->unsrt + i___0)->name != (unsigned long )((void *)0)) {
#line 342
      tmp = strlen((char const   *)(h___0->unsrt + i___0)->name);
#line 342
      memused = (int )((size_t )memused + (tmp + 1UL));
    }
#line 343
    if ((unsigned long )(h___0->unsrt + i___0)->acc != (unsigned long )((void *)0)) {
#line 344
      tmp___0 = strlen((char const   *)(h___0->unsrt + i___0)->acc);
#line 344
      memused = (int )((size_t )memused + (tmp___0 + 1UL));
    }
#line 345
    if ((unsigned long )(h___0->unsrt + i___0)->desc != (unsigned long )((void *)0)) {
#line 346
      tmp___1 = strlen((char const   *)(h___0->unsrt + i___0)->desc);
#line 346
      memused = (int )((size_t )memused + (tmp___1 + 1UL));
    }
#line 347
    if ((unsigned long )(h___0->unsrt + i___0)->ali != (unsigned long )((void *)0)) {
#line 349
      memused = (int )((unsigned long )memused + sizeof(struct fancyali_s ));
#line 350
      x = 0;
#line 351
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->rfline != (unsigned long )((void *)0)) {
#line 351
        x ++;
      }
#line 352
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->csline != (unsigned long )((void *)0)) {
#line 352
        x ++;
      }
#line 353
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->model != (unsigned long )((void *)0)) {
#line 353
        x ++;
      }
#line 354
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->mline != (unsigned long )((void *)0)) {
#line 354
        x ++;
      }
#line 355
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->aseq != (unsigned long )((void *)0)) {
#line 355
        x ++;
      }
#line 356
      memused += x * (((h___0->unsrt + i___0)->ali)->len + 1);
#line 358
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->query != (unsigned long )((void *)0)) {
#line 359
        tmp___2 = strlen((char const   *)((h___0->unsrt + i___0)->ali)->query);
#line 359
        memused = (int )((size_t )memused + (tmp___2 + 1UL));
      }
#line 360
      if ((unsigned long )((h___0->unsrt + i___0)->ali)->target != (unsigned long )((void *)0)) {
#line 361
        tmp___3 = strlen((char const   *)((h___0->unsrt + i___0)->ali)->target);
#line 361
        memused = (int )((size_t )memused + (tmp___3 + 1UL));
      }
    }
#line 339
    i___0 ++;
  }
#line 367
  n = 0;
#line 368
  i___0 = 0;
#line 368
  while (i___0 < h___0->num) {
#line 370
    if ((*(h___0->hit + i___0))->pvalue * (double )nseq >= E) {
#line 370
      break;
    }
#line 371
    n ++;
#line 368
    i___0 ++;
  }
#line 376
  printf((char const   * __restrict  )"tophits_s report:\n");
#line 377
  printf((char const   * __restrict  )"     Total hits:           %d\n", h___0->num);
#line 378
  printf((char const   * __restrict  )"     Satisfying E cutoff:  %d\n", n);
#line 379
  printf((char const   * __restrict  )"     Total memory:         %dK\n", memused / 1000);
#line 380
  return;
}
}
#line 1 "trace.o"
#pragma merger("0","/tmp/cil-XF7HOJ9D.i","")
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 234 "./msa.h"
MSA *MSAAlloc(int nseq , int alen ) ;
#line 237
void MSASetSeqAccession(MSA *msa , int seqidx , char *acc ) ;
#line 238
void MSASetSeqDescription(MSA *msa , int seqidx , char *desc ) ;
#line 46 "./sqfuncs.h"
int MakeAlignedString(char *aseq , int alen , char *ss , char **ret_s ) ;
#line 228
char *sre_strdup(char *s___0 , int n ) ;
#line 331 "./funcs.h"
struct p7trace_s **MergeTraceArrays(struct p7trace_s **t1 , int n1 , struct p7trace_s **t2 ,
                                    int n2 ) ;
#line 336
MSA *P7Traces2Alignment(char **dsq , SQINFO *sqinfo , float *wgt , int nseq , int mlen ,
                        struct p7trace_s **tr , int matchonly ) ;
#line 346
int TraceDomainNumber(struct p7trace_s *tr ) ;
#line 349
struct p7trace_s *MasterTraceFromMap(int *map , int M , int alen ) ;
#line 350
void ImposeMasterTrace(char **aseq , int nseq , struct p7trace_s *mtr , struct p7trace_s ***ret_tr ) ;
#line 29 "trace.c"
static void rightjustify(char *s___0 , int n ) ;
#line 35 "trace.c"
void P7AllocTrace(int tlen , struct p7trace_s **ret_tr ) 
{ 
  struct p7trace_s *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 40
  tmp = sre_malloc((char *)"trace.c", 40, sizeof(struct p7trace_s ));
#line 40
  tr = (struct p7trace_s *)tmp;
#line 41
  tmp___0 = sre_malloc((char *)"trace.c", 41, sizeof(char ) * (unsigned long )tlen);
#line 41
  tr->statetype = (char *)tmp___0;
#line 42
  tmp___1 = sre_malloc((char *)"trace.c", 42, sizeof(int ) * (unsigned long )tlen);
#line 42
  tr->nodeidx = (int *)tmp___1;
#line 43
  tmp___2 = sre_malloc((char *)"trace.c", 43, sizeof(int ) * (unsigned long )tlen);
#line 43
  tr->pos = (int *)tmp___2;
#line 44
  *ret_tr = tr;
#line 45
  return;
}
}
#line 46 "trace.c"
void P7ReallocTrace(struct p7trace_s *tr , int tlen ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 49
  tmp = sre_realloc((char *)"trace.c", 49, (void *)tr->statetype, (unsigned long )tlen * sizeof(char ));
#line 49
  tr->statetype = (char *)tmp;
#line 50
  tmp___0 = sre_realloc((char *)"trace.c", 50, (void *)tr->nodeidx, (unsigned long )tlen * sizeof(int ));
#line 50
  tr->nodeidx = (int *)tmp___0;
#line 51
  tmp___1 = sre_realloc((char *)"trace.c", 51, (void *)tr->pos, (unsigned long )tlen * sizeof(int ));
#line 51
  tr->pos = (int *)tmp___1;
#line 52
  return;
}
}
#line 53 "trace.c"
void P7FreeTrace(struct p7trace_s *tr ) 
{ 


  {
#line 56
  if ((unsigned long )tr == (unsigned long )((void *)0)) {
#line 56
    return;
  }
#line 57
  free((void *)tr->pos);
#line 58
  free((void *)tr->nodeidx);
#line 59
  free((void *)tr->statetype);
#line 60
  free((void *)tr);
#line 61
  return;
}
}
#line 78 "trace.c"
void TraceSet(struct p7trace_s *tr , int tpos , char type , int idx , int pos ) 
{ 


  {
#line 81
  *(tr->statetype + tpos) = type;
#line 82
  *(tr->nodeidx + tpos) = idx;
#line 83
  *(tr->pos + tpos) = pos;
#line 84
  return;
}
}
#line 104 "trace.c"
struct p7trace_s **MergeTraceArrays(struct p7trace_s **t1 , int n1 , struct p7trace_s **t2 ,
                                    int n2 ) 
{ 
  struct p7trace_s **tr ;
  int i___0 ;
  void *tmp ;

  {
#line 110
  tmp = sre_malloc((char *)"trace.c", 110, sizeof(struct p7trace_s *) * (unsigned long )(n1 + n2));
#line 110
  tr = (struct p7trace_s **)tmp;
#line 111
  i___0 = 0;
#line 111
  while (i___0 < n1) {
#line 111
    *(tr + i___0) = *(t1 + i___0);
#line 111
    i___0 ++;
  }
#line 112
  i___0 = 0;
#line 112
  while (i___0 < n2) {
#line 112
    *(tr + (n1 + i___0)) = *(t2 + i___0);
#line 112
    i___0 ++;
  }
#line 113
  free((void *)t1);
#line 114
  free((void *)t2);
#line 115
  return (tr);
}
}
#line 139 "trace.c"
void P7ReverseTrace(struct p7trace_s *tr ) 
{ 
  char *statetype ;
  int *nodeidx ;
  int *pos ;
  int opos ;
  int npos ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 149
  tmp = sre_malloc((char *)"trace.c", 149, sizeof(char ) * (unsigned long )tr->tlen);
#line 149
  statetype = (char *)tmp;
#line 150
  tmp___0 = sre_malloc((char *)"trace.c", 150, sizeof(int ) * (unsigned long )tr->tlen);
#line 150
  nodeidx = (int *)tmp___0;
#line 151
  tmp___1 = sre_malloc((char *)"trace.c", 151, sizeof(int ) * (unsigned long )tr->tlen);
#line 151
  pos = (int *)tmp___1;
#line 155
  opos = tr->tlen - 1;
#line 155
  npos = 0;
#line 155
  while (npos < tr->tlen) {
#line 157
    *(statetype + npos) = *(tr->statetype + opos);
#line 158
    *(nodeidx + npos) = *(tr->nodeidx + opos);
#line 159
    *(pos + npos) = *(tr->pos + opos);
#line 155
    npos ++;
#line 155
    opos --;
  }
#line 164
  free((void *)tr->statetype);
#line 165
  free((void *)tr->nodeidx);
#line 166
  free((void *)tr->pos);
#line 167
  tr->statetype = statetype;
#line 168
  tr->nodeidx = nodeidx;
#line 169
  tr->pos = pos;
#line 170
  return;
}
}
#line 186 "trace.c"
void P7TraceCount(struct plan7_s *hmm , char *dsq , float wt , struct p7trace_s *tr ) 
{ 
  int tpos ;
  int i___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 192
  tpos = 0;
#line 192
  while (tpos < tr->tlen) {
#line 194
    i___0 = *(tr->pos + tpos);
#line 199
    if ((int )*(tr->statetype + tpos) == 1) {
#line 200
      P7CountSymbol(*(hmm->mat + *(tr->nodeidx + tpos)), *(dsq + i___0), wt);
    } else
#line 201
    if ((int )*(tr->statetype + tpos) == 3) {
#line 202
      P7CountSymbol(*(hmm->ins + *(tr->nodeidx + tpos)), *(dsq + i___0), wt);
    }
#line 206
    switch ((int )*(tr->statetype + tpos)) {
    case 4: 
#line 208
    break;
    case 5: 
#line 210
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 6: 
#line 211
    hmm->xt[0][0] += wt;
#line 211
    break;
    case 5: 
#line 212
    hmm->xt[0][1] += wt;
#line 212
    break;
    default: 
#line 214
    tmp = Statetype(*(tr->statetype + (tpos + 1)));
#line 214
    tmp___0 = Statetype(*(tr->statetype + tpos));
#line 214
    Die((char *)"illegal state transition %s->%s in traceback", tmp___0, tmp);
    }
#line 218
    break;
    case 6: 
#line 220
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
#line 221
    *(hmm->begin + *(tr->nodeidx + (tpos + 1))) += wt;
#line 221
    break;
    case 2: 
#line 222
    hmm->tbd1 += wt;
#line 222
    break;
    default: 
#line 224
    tmp___1 = Statetype(*(tr->statetype + (tpos + 1)));
#line 224
    tmp___2 = Statetype(*(tr->statetype + tpos));
#line 224
    Die((char *)"illegal state transition %s->%s in traceback", tmp___2, tmp___1);
    }
#line 228
    break;
    case 1: 
#line 230
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
#line 231
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 0) += wt;
#line 231
    break;
    case 3: 
#line 232
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 1) += wt;
#line 232
    break;
    case 2: 
#line 233
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 2) += wt;
#line 233
    break;
    case 7: 
#line 234
    *(hmm->end + *(tr->nodeidx + tpos)) += wt;
#line 234
    break;
    default: 
#line 236
    tmp___3 = Statetype(*(tr->statetype + (tpos + 1)));
#line 236
    tmp___4 = Statetype(*(tr->statetype + tpos));
#line 236
    Die((char *)"illegal state transition %s->%s in traceback", tmp___4, tmp___3);
    }
#line 240
    break;
    case 3: 
#line 242
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
#line 243
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 3) += wt;
#line 243
    break;
    case 3: 
#line 244
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 4) += wt;
#line 244
    break;
    default: 
#line 246
    tmp___5 = Statetype(*(tr->statetype + (tpos + 1)));
#line 246
    tmp___6 = Statetype(*(tr->statetype + tpos));
#line 246
    Die((char *)"illegal state transition %s->%s in traceback", tmp___6, tmp___5);
    }
#line 250
    break;
    case 2: 
#line 252
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 1: 
#line 253
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 5) += wt;
#line 253
    break;
    case 2: 
#line 254
    *(*(hmm->t + *(tr->nodeidx + tpos)) + 6) += wt;
#line 254
    break;
    case 7: 
#line 255
    break;
    default: 
#line 257
    tmp___7 = Statetype(*(tr->statetype + (tpos + 1)));
#line 257
    tmp___8 = Statetype(*(tr->statetype + tpos));
#line 257
    Die((char *)"illegal state transition %s->%s in traceback", tmp___8, tmp___7);
    }
#line 261
    break;
    case 7: 
#line 263
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 8: 
#line 264
    hmm->xt[1][0] += wt;
#line 264
    break;
    case 10: 
#line 265
    hmm->xt[1][1] += wt;
#line 265
    break;
    default: 
#line 267
    tmp___9 = Statetype(*(tr->statetype + (tpos + 1)));
#line 267
    tmp___10 = Statetype(*(tr->statetype + tpos));
#line 267
    Die((char *)"illegal state transition %s->%s in traceback", tmp___10, tmp___9);
    }
#line 271
    break;
    case 10: 
#line 273
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 6: 
#line 274
    hmm->xt[3][0] += wt;
#line 274
    break;
    case 10: 
#line 275
    hmm->xt[3][1] += wt;
#line 275
    break;
    default: 
#line 277
    tmp___11 = Statetype(*(tr->statetype + (tpos + 1)));
#line 277
    tmp___12 = Statetype(*(tr->statetype + tpos));
#line 277
    Die((char *)"illegal state transition %s->%s in traceback", tmp___12, tmp___11);
    }
#line 281
    break;
    case 8: 
#line 283
    switch ((int )*(tr->statetype + (tpos + 1))) {
    case 9: 
#line 284
    hmm->xt[2][0] += wt;
#line 284
    break;
    case 8: 
#line 285
    hmm->xt[2][1] += wt;
#line 285
    break;
    default: 
#line 287
    tmp___13 = Statetype(*(tr->statetype + (tpos + 1)));
#line 287
    tmp___14 = Statetype(*(tr->statetype + tpos));
#line 287
    Die((char *)"illegal state transition %s->%s in traceback", tmp___14, tmp___13);
    }
#line 291
    break;
    case 9: 
#line 293
    break;
    default: 
#line 295
    tmp___15 = Statetype(*(tr->statetype + tpos));
#line 295
    Die((char *)"illegal state %s in traceback", tmp___15);
    }
#line 192
    tpos ++;
  }
#line 299
  return;
}
}
#line 312 "trace.c"
float P7TraceScore(struct plan7_s *hmm , char *dsq , struct p7trace_s *tr ) 
{ 
  int score ;
  int tpos ;
  int sym ;
  int tmp ;
  float tmp___0 ;

  {
#line 320
  score = 0;
#line 321
  tpos = 0;
#line 321
  while (tpos < tr->tlen - 1) {
#line 323
    sym = (int )*(dsq + *(tr->pos + tpos));
#line 328
    if ((int )*(tr->statetype + tpos) == 1) {
#line 329
      score += *(*(hmm->msc + sym) + *(tr->nodeidx + tpos));
    } else
#line 330
    if ((int )*(tr->statetype + tpos) == 3) {
#line 331
      score += *(*(hmm->isc + sym) + *(tr->nodeidx + tpos));
    }
#line 335
    tmp = TransitionScoreLookup(hmm, *(tr->statetype + tpos), *(tr->nodeidx + tpos),
                                *(tr->statetype + (tpos + 1)), *(tr->nodeidx + (tpos + 1)));
#line 335
    score += tmp;
#line 321
    tpos ++;
  }
#line 339
  tmp___0 = Scorify(score);
#line 339
  return (tmp___0);
}
}
#line 378 "trace.c"
MSA *P7Traces2Alignment(char **dsq , SQINFO *sqinfo , float *wgt , int nseq , int mlen ,
                        struct p7trace_s **tr , int matchonly ) 
{ 
  MSA *msa ;
  int idx ;
  int alen ;
  int *inserts ;
  int *matmap ;
  int nins ;
  int apos ;
  int rpos ;
  int tpos ;
  int statetype ;
  int k ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 408
  tmp = sre_malloc((char *)"trace.c", 408, sizeof(int ) * (unsigned long )(mlen + 1));
#line 408
  inserts = (int *)tmp;
#line 409
  k = 0;
#line 409
  while (k <= mlen) {
#line 410
    *(inserts + k) = 0;
#line 409
    k ++;
  }
#line 411
  idx = 0;
#line 411
  while (idx < nseq) {
#line 412
    nins = 0;
#line 413
    tpos = 0;
#line 413
    while (tpos < (*(tr + idx))->tlen) {
#line 414
      switch ((int )*((*(tr + idx))->statetype + tpos)) {
      case 3: 
#line 415
      nins ++;
#line 415
      break;
      case 5: 
#line 416
      if ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 5) {
#line 416
        nins ++;
      }
#line 416
      break;
      case 8: 
#line 417
      if ((int )*((*(tr + idx))->statetype + (tpos - 1)) == 8) {
#line 417
        nins ++;
      }
#line 417
      break;
      case 2: 
      case 1: 
#line 420
      if (nins > *(inserts + (*((*(tr + idx))->nodeidx + tpos) - 1))) {
#line 421
        *(inserts + (*((*(tr + idx))->nodeidx + tpos) - 1)) = nins;
      }
#line 422
      nins = 0;
#line 423
      break;
      case 6: 
#line 425
      if (nins > *(inserts + 0)) {
#line 426
        *(inserts + 0) = nins;
      }
#line 427
      nins = 0;
#line 428
      break;
      case 9: 
#line 430
      if (nins > *(inserts + mlen)) {
#line 431
        *(inserts + mlen) = nins;
      }
#line 432
      break;
      case 7: 
      case 4: 
#line 433
      break;
      case 10: 
#line 435
      Die((char *)"yo! you don\'t support J in Traces2Alignment(), remember?");
      default: 
#line 437
      tmp___0 = Statetype(*((*(tr + idx))->statetype + tpos));
#line 437
      Die((char *)"Traces2Alignment reports unrecognized statetype %c", tmp___0);
      }
#line 413
      tpos ++;
    }
#line 411
    idx ++;
  }
#line 444
  if (matchonly) {
#line 445
    k = 0;
#line 445
    while (k <= mlen) {
#line 446
      if (*(inserts + k) > 1) {
#line 447
        *(inserts + k) = 1;
      }
#line 445
      k ++;
    }
  }
#line 453
  tmp___1 = sre_malloc((char *)"trace.c", 453, sizeof(int ) * (unsigned long )(mlen + 1));
#line 453
  matmap = (int *)tmp___1;
#line 454
  *(matmap + 0) = -1;
#line 455
  alen = *(inserts + 0);
#line 456
  k = 1;
#line 456
  while (k <= mlen) {
#line 457
    *(matmap + k) = alen;
#line 458
    alen += *(inserts + k) + 1;
#line 456
    k ++;
  }
#line 461
  msa = MSAAlloc(nseq, alen);
#line 463
  idx = 0;
#line 463
  while (idx < nseq) {
#line 465
    apos = 0;
#line 465
    while (apos < alen) {
#line 466
      *(*(msa->aseq + idx) + apos) = (char )'.';
#line 465
      apos ++;
    }
#line 467
    k = 1;
#line 467
    while (k <= mlen) {
#line 468
      *(*(msa->aseq + idx) + *(matmap + k)) = (char )'-';
#line 467
      k ++;
    }
#line 469
    *(*(msa->aseq + idx) + alen) = (char )'\000';
#line 471
    apos = 0;
#line 472
    tpos = 0;
#line 472
    while (tpos < (*(tr + idx))->tlen) {
#line 473
      statetype = (int )*((*(tr + idx))->statetype + tpos);
#line 474
      rpos = *((*(tr + idx))->pos + tpos);
#line 475
      k = *((*(tr + idx))->nodeidx + tpos);
#line 477
      if (statetype == 1) {
#line 478
        apos = *(matmap + k);
#line 479
        *(*(msa->aseq + idx) + apos) = Alphabet[(int )*(*(dsq + idx) + rpos)];
#line 480
        apos ++;
      } else
#line 482
      if (statetype == 2) {
#line 483
        apos = *(matmap + k) + 1;
      } else
#line 485
      if (statetype == 3) {
#line 486
        if (matchonly) {
#line 487
          *(*(msa->aseq + idx) + apos) = (char )'*';
        } else {
#line 489
          tmp___2 = tolower((int )Alphabet[(int )*(*(dsq + idx) + rpos)]);
#line 489
          *(*(msa->aseq + idx) + apos) = (char )tmp___2;
#line 490
          apos ++;
        }
      } else
#line 493
      if (statetype == 5) {
#line 493
        goto _L___0;
      } else
#line 493
      if (statetype == 8) {
        _L___0: /* CIL Label */ 
#line 493
        if (rpos > 0) {
#line 494
          if (matchonly) {
#line 495
            *(*(msa->aseq + idx) + apos) = (char )'*';
          } else {
#line 497
            tmp___3 = tolower((int )Alphabet[(int )*(*(dsq + idx) + rpos)]);
#line 497
            *(*(msa->aseq + idx) + apos) = (char )tmp___3;
#line 498
            apos ++;
          }
        } else {
#line 493
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 501
      if (statetype == 7) {
#line 502
        apos = *(matmap + mlen) + 1;
      }
#line 472
      tpos ++;
    }
#line 509
    if (! matchonly) {
#line 510
      rightjustify(*(msa->aseq + idx), *(inserts + 0));
#line 512
      k = 1;
#line 512
      while (k < mlen) {
#line 513
        if (*(inserts + k) > 1) {
#line 514
          nins = 0;
#line 514
          apos = *(matmap + k) + 1;
#line 514
          while (1) {
#line 514
            tmp___4 = __ctype_b_loc();
#line 514
            if (! ((int const   )*(*tmp___4 + (int )*(*(msa->aseq + idx) + apos)) & 512)) {
#line 514
              break;
            }
#line 515
            nins ++;
#line 514
            apos ++;
          }
#line 516
          nins /= 2;
#line 517
          rightjustify(((*(msa->aseq + idx) + *(matmap + k)) + 1) + nins, *(inserts + k) - nins);
        }
#line 512
        k ++;
      }
    }
#line 463
    idx ++;
  }
#line 527
  msa->nseq = nseq;
#line 528
  msa->alen = alen;
#line 529
  tmp___5 = strlen("2.3");
#line 529
  tmp___6 = sre_malloc((char *)"trace.c", 529, sizeof(char ) * (tmp___5 + 7UL));
#line 529
  msa->au = (char *)tmp___6;
#line 530
  sprintf((char * __restrict  )msa->au, (char const   * __restrict  )"HMMER %s", "2.3");
#line 532
  idx = 0;
#line 532
  while (idx < nseq) {
#line 534
    *(msa->sqname + idx) = sre_strdup((sqinfo + idx)->name, -1);
#line 535
    if ((sqinfo + idx)->flags & (1 << 2)) {
#line 536
      MSASetSeqAccession(msa, idx, (sqinfo + idx)->acc);
    }
#line 537
    if ((sqinfo + idx)->flags & (1 << 3)) {
#line 538
      MSASetSeqDescription(msa, idx, (sqinfo + idx)->desc);
    }
#line 540
    if ((sqinfo + idx)->flags & (1 << 9)) {
#line 541
      if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
#line 541
        tmp___7 = sre_malloc((char *)"trace.c", 541, sizeof(char *) * (unsigned long )nseq);
#line 541
        msa->ss = (char **)tmp___7;
      }
#line 542
      MakeAlignedString(*(msa->aseq + idx), alen, (sqinfo + idx)->ss, msa->ss + idx);
    }
#line 545
    if ((sqinfo + idx)->flags & (1 << 10)) {
#line 546
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
#line 546
        tmp___8 = sre_malloc((char *)"trace.c", 546, sizeof(char *) * (unsigned long )nseq);
#line 546
        msa->sa = (char **)tmp___8;
      }
#line 547
      MakeAlignedString(*(msa->aseq + idx), alen, (sqinfo + idx)->sa, msa->sa + idx);
    }
#line 550
    *(msa->wgt + idx) = *(wgt + idx);
#line 532
    idx ++;
  }
#line 555
  tmp___9 = sre_malloc((char *)"trace.c", 555, sizeof(char ) * (unsigned long )(alen + 1));
#line 555
  msa->rf = (char *)tmp___9;
#line 556
  apos = 0;
#line 556
  while (apos < alen) {
#line 557
    *(msa->rf + apos) = (char )'.';
#line 556
    apos ++;
  }
#line 558
  k = 1;
#line 558
  while (k <= mlen) {
#line 559
    *(msa->rf + *(matmap + k)) = (char )'x';
#line 558
    k ++;
  }
#line 560
  *(msa->rf + alen) = (char )'\000';
#line 566
  free((void *)inserts);
#line 567
  free((void *)matmap);
#line 568
  return (msa);
}
}
#line 577 "trace.c"
int TransitionScoreLookup(struct plan7_s *hmm , char st1 , int k1 , char st2 , int k2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 581
  switch ((int )st1) {
  case 4: 
#line 582
  return (0);
  case 5: 
#line 584
  switch ((int )st2) {
  case 6: 
#line 585
  return (hmm->xsc[0][0]);
  case 5: 
#line 586
  return (hmm->xsc[0][1]);
  default: 
#line 587
  tmp = Statetype(st2);
#line 587
  tmp___0 = Statetype(st1);
#line 587
  Die((char *)"illegal %s->%s transition", tmp___0, tmp);
  }
#line 589
  break;
  case 6: 
#line 591
  switch ((int )st2) {
  case 1: 
#line 592
  return (*(hmm->bsc + k2));
  case 2: 
#line 593
  tmp___1 = Prob2Score(hmm->tbd1, (float )1.);
#line 593
  return (tmp___1);
  default: 
#line 594
  tmp___2 = Statetype(st2);
#line 594
  tmp___3 = Statetype(st1);
#line 594
  Die((char *)"illegal %s->%s transition", tmp___3, tmp___2);
  }
#line 596
  break;
  case 1: 
#line 598
  switch ((int )st2) {
  case 1: 
#line 599
  return (*(*(hmm->tsc + 0) + k1));
  case 3: 
#line 600
  return (*(*(hmm->tsc + 1) + k1));
  case 2: 
#line 601
  return (*(*(hmm->tsc + 2) + k1));
  case 7: 
#line 602
  return (*(hmm->esc + k1));
  default: 
#line 603
  tmp___4 = Statetype(st2);
#line 603
  tmp___5 = Statetype(st1);
#line 603
  Die((char *)"illegal %s->%s transition", tmp___5, tmp___4);
  }
#line 605
  break;
  case 3: 
#line 607
  switch ((int )st2) {
  case 1: 
#line 608
  return (*(*(hmm->tsc + 3) + k1));
  case 3: 
#line 609
  return (*(*(hmm->tsc + 4) + k1));
  default: 
#line 610
  tmp___6 = Statetype(st2);
#line 610
  tmp___7 = Statetype(st1);
#line 610
  Die((char *)"illegal %s->%s transition", tmp___7, tmp___6);
  }
#line 612
  break;
  case 2: 
#line 614
  switch ((int )st2) {
  case 1: 
#line 615
  return (*(*(hmm->tsc + 5) + k1));
  case 2: 
#line 616
  return (*(*(hmm->tsc + 6) + k1));
  case 7: 
#line 617
  return (0);
  default: 
#line 618
  tmp___8 = Statetype(st2);
#line 618
  tmp___9 = Statetype(st1);
#line 618
  Die((char *)"illegal %s->%s transition", tmp___9, tmp___8);
  }
#line 620
  break;
  case 7: 
#line 622
  switch ((int )st2) {
  case 8: 
#line 623
  return (hmm->xsc[1][0]);
  case 10: 
#line 624
  return (hmm->xsc[1][1]);
  default: 
#line 625
  tmp___10 = Statetype(st2);
#line 625
  tmp___11 = Statetype(st1);
#line 625
  Die((char *)"illegal %s->%s transition", tmp___11, tmp___10);
  }
#line 627
  break;
  case 10: 
#line 629
  switch ((int )st2) {
  case 6: 
#line 630
  return (hmm->xsc[3][0]);
  case 10: 
#line 631
  return (hmm->xsc[3][1]);
  default: 
#line 632
  tmp___12 = Statetype(st2);
#line 632
  tmp___13 = Statetype(st1);
#line 632
  Die((char *)"illegal %s->%s transition", tmp___13, tmp___12);
  }
#line 634
  break;
  case 8: 
#line 636
  switch ((int )st2) {
  case 9: 
#line 637
  return (hmm->xsc[2][0]);
  case 8: 
#line 638
  return (hmm->xsc[2][1]);
  default: 
#line 639
  tmp___14 = Statetype(st2);
#line 639
  tmp___15 = Statetype(st1);
#line 639
  Die((char *)"illegal %s->%s transition", tmp___15, tmp___14);
  }
#line 641
  break;
  case 9: 
#line 642
  return (0);
  default: 
#line 643
  tmp___16 = Statetype(st1);
#line 643
  Die((char *)"illegal state %s in traceback", tmp___16);
  }
#line 646
  return (0);
}
}
#line 666 "trace.c"
struct fancyali_s *CreateFancyAli(struct p7trace_s *tr , struct plan7_s *hmm , char *dsq ,
                                  char *name ) 
{ 
  struct fancyali_s *ali ;
  int tpos ;
  int bestsym ;
  float mthresh___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 677
  ali = AllocFancyAli();
#line 678
  ali->rfline = (char *)((void *)0);
#line 679
  ali->csline = (char *)((void *)0);
#line 680
  tmp = sre_malloc((char *)"trace.c", 680, sizeof(char ) * (unsigned long )(tr->tlen + 1));
#line 680
  ali->model = (char *)tmp;
#line 681
  tmp___0 = sre_malloc((char *)"trace.c", 681, sizeof(char ) * (unsigned long )(tr->tlen + 1));
#line 681
  ali->mline = (char *)tmp___0;
#line 682
  tmp___1 = sre_malloc((char *)"trace.c", 682, sizeof(char ) * (unsigned long )(tr->tlen + 1));
#line 682
  ali->aseq = (char *)tmp___1;
#line 684
  memset((void *)ali->model, ' ', (size_t )tr->tlen);
#line 685
  memset((void *)ali->mline, ' ', (size_t )tr->tlen);
#line 686
  memset((void *)ali->aseq, ' ', (size_t )tr->tlen);
#line 688
  if (hmm->flags & (1 << 2)) {
#line 690
    tmp___2 = sre_malloc((char *)"trace.c", 690, sizeof(char ) * (unsigned long )(tr->tlen + 1));
#line 690
    ali->rfline = (char *)tmp___2;
#line 691
    memset((void *)ali->rfline, ' ', (size_t )tr->tlen);
  }
#line 693
  if (hmm->flags & (1 << 3)) {
#line 695
    tmp___3 = sre_malloc((char *)"trace.c", 695, sizeof(char ) * (unsigned long )(tr->tlen + 1));
#line 695
    ali->csline = (char *)tmp___3;
#line 696
    memset((void *)ali->csline, ' ', (size_t )tr->tlen);
  }
#line 699
  ali->query = Strdup(hmm->name);
#line 700
  ali->target = Strdup(name);
#line 702
  if (Alphabet_type == 3) {
#line 702
    mthresh___0 = (float )0.5;
  } else {
#line 703
    mthresh___0 = (float )0.9;
  }
#line 709
  tpos = 0;
#line 709
  while (tpos < tr->tlen) {
#line 710
    if (*(tr->pos + tpos) > 0) {
#line 711
      ali->sqfrom = *(tr->pos + tpos);
#line 712
      break;
    }
#line 709
    tpos ++;
  }
#line 714
  tpos = tr->tlen - 1;
#line 714
  while (tpos >= 0) {
#line 715
    if (*(tr->pos + tpos) > 0) {
#line 716
      ali->sqto = *(tr->pos + tpos);
#line 717
      break;
    }
#line 714
    tpos --;
  }
#line 722
  tpos = 0;
#line 722
  while (tpos < tr->tlen) {
#line 723
    switch ((int )*(tr->statetype + tpos)) {
    case 9: 
    case 4: 
#line 726
    *(ali->model + tpos) = (char )'*';
#line 727
    break;
    case 8: 
    case 10: 
    case 5: 
#line 732
    *(ali->model + tpos) = (char )'-';
#line 733
    if (*(tr->pos + tpos) > 0) {
#line 734
      tmp___4 = tolower((int )Alphabet[(int )*(dsq + *(tr->pos + tpos))]);
#line 734
      *(ali->aseq + tpos) = (char )tmp___4;
    }
#line 736
    break;
    case 6: 
#line 739
    *(ali->model + tpos) = (char )'>';
#line 740
    break;
    case 7: 
#line 743
    *(ali->model + tpos) = (char )'<';
#line 744
    break;
    case 1: 
#line 747
    if (hmm->flags & (1 << 2)) {
#line 747
      *(ali->rfline + tpos) = *(hmm->rf + *(tr->nodeidx + tpos));
    }
#line 748
    if (hmm->flags & (1 << 3)) {
#line 748
      *(ali->csline + tpos) = *(hmm->cs + *(tr->nodeidx + tpos));
    }
#line 749
    bestsym = FArgMax(*(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
#line 750
    *(ali->model + tpos) = Alphabet[bestsym];
#line 751
    if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
#line 752
      tmp___5 = tolower((int )*(ali->model + tpos));
#line 752
      *(ali->model + tpos) = (char )tmp___5;
    }
#line 753
    if ((int )*(dsq + *(tr->pos + tpos)) == bestsym) {
#line 755
      *(ali->mline + tpos) = Alphabet[(int )*(dsq + *(tr->pos + tpos))];
#line 756
      if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
#line 757
        tmp___6 = tolower((int )*(ali->mline + tpos));
#line 757
        *(ali->mline + tpos) = (char )tmp___6;
      }
    } else
#line 759
    if (*(*(hmm->msc + (int )*(dsq + *(tr->pos + tpos))) + *(tr->nodeidx + tpos)) > 0) {
#line 760
      *(ali->mline + tpos) = (char )'+';
    }
#line 761
    *(ali->aseq + tpos) = Alphabet[(int )*(dsq + *(tr->pos + tpos))];
#line 762
    break;
    case 2: 
#line 765
    if (hmm->flags & (1 << 2)) {
#line 765
      *(ali->rfline + tpos) = *(hmm->rf + *(tr->nodeidx + tpos));
    }
#line 766
    if (hmm->flags & (1 << 3)) {
#line 766
      *(ali->csline + tpos) = *(hmm->cs + *(tr->nodeidx + tpos));
    }
#line 767
    bestsym = FArgMax(*(hmm->mat + *(tr->nodeidx + tpos)), Alphabet_size);
#line 768
    *(ali->model + tpos) = Alphabet[bestsym];
#line 769
    if (*(*(hmm->mat + *(tr->nodeidx + tpos)) + bestsym) < mthresh___0) {
#line 770
      tmp___7 = tolower((int )*(ali->model + tpos));
#line 770
      *(ali->model + tpos) = (char )tmp___7;
    }
#line 771
    *(ali->aseq + tpos) = (char )'-';
#line 772
    break;
    case 3: 
#line 775
    *(ali->model + tpos) = (char )'.';
#line 776
    if (*(*(hmm->isc + (int )*(dsq + *(tr->pos + tpos))) + *(tr->nodeidx + tpos)) > 0) {
#line 777
      *(ali->mline + tpos) = (char )'+';
    }
#line 778
    tmp___8 = tolower((int )Alphabet[(int )*(dsq + *(tr->pos + tpos))]);
#line 778
    *(ali->aseq + tpos) = (char )tmp___8;
#line 779
    break;
    default: 
#line 782
    Die((char *)"bogus statetype");
    }
#line 722
    tpos ++;
  }
#line 786
  ali->len = tpos;
#line 787
  if (hmm->flags & (1 << 2)) {
#line 787
    *(ali->rfline + tpos) = (char )'\000';
  }
#line 788
  if (hmm->flags & (1 << 3)) {
#line 788
    *(ali->csline + tpos) = (char )'\000';
  }
#line 789
  *(ali->model + tpos) = (char )'\000';
#line 790
  *(ali->mline + tpos) = (char )'\000';
#line 791
  *(ali->aseq + tpos) = (char )'\000';
#line 792
  return (ali);
}
}
#line 808 "trace.c"
void PrintFancyAli(FILE *fp , struct fancyali_s *ali ) 
{ 
  char buffer___1[51] ;
  int starti ;
  int endi ;
  int pos ;
  int i___0 ;

  {
#line 816
  buffer___1[50] = (char )'\000';
#line 817
  endi = ali->sqfrom - 1;
#line 818
  pos = 0;
#line 818
  while (pos < ali->len) {
#line 821
    starti = endi + 1;
#line 822
    i___0 = pos;
#line 822
    while (1) {
#line 822
      if ((int )*(ali->aseq + i___0) != 0) {
#line 822
        if (! (i___0 < pos + 50)) {
#line 822
          break;
        }
      } else {
#line 822
        break;
      }
#line 823
      if (! ((int )*(ali->aseq + i___0) == 32)) {
#line 823
        if (! ((int )*(ali->aseq + i___0) == 46)) {
#line 823
          if (! ((int )*(ali->aseq + i___0) == 95)) {
#line 823
            if (! ((int )*(ali->aseq + i___0) == 45)) {
#line 823
              if (! ((int )*(ali->aseq + i___0) == 126)) {
#line 823
                endi ++;
              }
            }
          }
        }
      }
#line 822
      i___0 ++;
    }
#line 825
    if ((unsigned long )ali->csline != (unsigned long )((void *)0)) {
#line 826
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(ali->csline + pos),
              (size_t )50);
#line 827
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %16s %s\n",
              "CS", buffer___1);
    }
#line 829
    if ((unsigned long )ali->rfline != (unsigned long )((void *)0)) {
#line 830
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(ali->rfline + pos),
              (size_t )50);
#line 831
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %16s %s\n",
              "RF", buffer___1);
    }
#line 833
    if ((unsigned long )ali->model != (unsigned long )((void *)0)) {
#line 834
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(ali->model + pos),
              (size_t )50);
#line 835
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %16s %s\n",
              " ", buffer___1);
    }
#line 837
    if ((unsigned long )ali->mline != (unsigned long )((void *)0)) {
#line 838
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(ali->mline + pos),
              (size_t )50);
#line 839
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %16s %s\n",
              " ", buffer___1);
    }
#line 841
    if ((unsigned long )ali->aseq != (unsigned long )((void *)0)) {
#line 842
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(ali->aseq + pos),
              (size_t )50);
#line 843
      if (endi >= starti) {
#line 844
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %10.10s %5d %s %-5d\n\n",
                ali->target, starti, buffer___1, endi);
      } else {
#line 846
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %10.10s %5s %s %-5s\n\n",
                ali->target, "-", buffer___1, "-");
      }
    }
#line 818
    pos += 50;
  }
#line 852
  fflush(fp);
#line 853
  return;
}
}
#line 873 "trace.c"
void TraceDecompose(struct p7trace_s *otr , struct p7trace_s ***ret_tr , int *ret_ntr ) 
{ 
  struct p7trace_s **tr ;
  int ntr ;
  int i___0 ;
  int j ;
  int idx ;
  void *tmp ;

  {
#line 883
  ntr = 0;
#line 883
  i___0 = 0;
#line 883
  while (i___0 < otr->tlen) {
#line 884
    if ((int )*(otr->statetype + i___0) == 6) {
#line 884
      ntr ++;
    }
#line 883
    i___0 ++;
  }
#line 888
  if (ntr == 0) {
#line 889
    *ret_ntr = 0;
#line 890
    *ret_tr = (struct p7trace_s **)((void *)0);
#line 891
    return;
  }
#line 893
  tmp = sre_malloc((char *)"trace.c", 893, sizeof(struct p7trace_s *) * (unsigned long )ntr);
#line 893
  tr = (struct p7trace_s **)tmp;
#line 895
  idx = 0;
#line 895
  i___0 = 0;
#line 895
  while (i___0 < otr->tlen) {
#line 896
    if ((int )*(otr->statetype + i___0) == 6) {
#line 898
      j = i___0 + 1;
#line 898
      while (j < otr->tlen) {
#line 899
        if ((int )*(otr->statetype + j) == 7) {
#line 899
          break;
        }
#line 898
        j ++;
      }
#line 901
      P7AllocTrace((j - i___0) + 5, tr + idx);
#line 902
      (*(tr + idx))->tlen = (j - i___0) + 5;
#line 904
      *((*(tr + idx))->statetype + 0) = (char)4;
#line 905
      *((*(tr + idx))->nodeidx + 0) = 0;
#line 906
      *((*(tr + idx))->pos + 0) = 0;
#line 907
      *((*(tr + idx))->statetype + 1) = (char)5;
#line 908
      *((*(tr + idx))->nodeidx + 1) = 0;
#line 909
      *((*(tr + idx))->pos + 1) = 0;
#line 910
      j = 2;
#line 911
      while (1) {
#line 913
        *((*(tr + idx))->statetype + j) = *(otr->statetype + i___0);
#line 914
        *((*(tr + idx))->nodeidx + j) = *(otr->nodeidx + i___0);
#line 915
        *((*(tr + idx))->pos + j) = *(otr->pos + i___0);
#line 916
        if ((int )*(otr->statetype + i___0) == 7) {
#line 916
          break;
        }
#line 917
        i___0 ++;
#line 917
        j ++;
      }
#line 919
      j ++;
#line 920
      *((*(tr + idx))->statetype + j) = (char)8;
#line 921
      *((*(tr + idx))->nodeidx + j) = 0;
#line 922
      *((*(tr + idx))->pos + j) = 0;
#line 923
      j ++;
#line 924
      *((*(tr + idx))->statetype + j) = (char)9;
#line 925
      *((*(tr + idx))->nodeidx + j) = 0;
#line 926
      *((*(tr + idx))->pos + j) = 0;
#line 927
      idx ++;
    }
#line 895
    i___0 ++;
  }
#line 930
  *ret_tr = tr;
#line 931
  *ret_ntr = ntr;
#line 932
  return;
}
}
#line 946 "trace.c"
int TraceDomainNumber(struct p7trace_s *tr ) 
{ 
  int i___0 ;
  int ndom ;

  {
#line 950
  ndom = 0;
#line 952
  i___0 = 0;
#line 952
  while (i___0 < tr->tlen) {
#line 953
    if ((int )*(tr->statetype + i___0) == 6) {
#line 953
      ndom ++;
    }
#line 952
    i___0 ++;
  }
#line 954
  return (ndom);
}
}
#line 973 "trace.c"
void TraceSimpleBounds(struct p7trace_s *tr , int *ret_i1 , int *ret_i2 , int *ret_k1 ,
                       int *ret_k2 ) 
{ 
  int i1 ;
  int i2 ;
  int k1 ;
  int k2 ;
  int tpos ;

  {
#line 979
  k2 = -1;
#line 979
  i2 = k2;
#line 979
  k1 = i2;
#line 979
  i1 = k1;
#line 982
  tpos = 0;
#line 982
  while (tpos < tr->tlen) {
#line 984
    if (k1 == -1) {
#line 984
      if ((int )*(tr->statetype + tpos) == 1) {
#line 985
        k1 = *(tr->nodeidx + tpos);
      } else
#line 984
      if ((int )*(tr->statetype + tpos) == 2) {
#line 985
        k1 = *(tr->nodeidx + tpos);
      }
    }
#line 986
    if ((int )*(tr->statetype + tpos) == 1) {
#line 988
      i1 = *(tr->pos + tpos);
#line 989
      break;
    }
#line 982
    tpos ++;
  }
#line 992
  if (tpos == tr->tlen) {
#line 993
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
#line 992
  if (i1 == -1) {
#line 993
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
#line 992
  if (k1 == -1) {
#line 993
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  }
#line 996
  tpos = tr->tlen - 1;
#line 996
  while (tpos >= 0) {
#line 998
    if (k2 == -1) {
#line 998
      if ((int )*(tr->statetype + tpos) == 1) {
#line 999
        k2 = *(tr->nodeidx + tpos);
      } else
#line 998
      if ((int )*(tr->statetype + tpos) == 2) {
#line 999
        k2 = *(tr->nodeidx + tpos);
      }
    }
#line 1000
    if ((int )*(tr->statetype + tpos) == 1) {
#line 1002
      i2 = *(tr->pos + tpos);
#line 1003
      break;
    }
#line 996
    tpos --;
  }
#line 1006
  if (tpos == tr->tlen) {
#line 1007
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
#line 1006
  if (i2 == -1) {
#line 1007
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  } else
#line 1006
  if (k2 == -1) {
#line 1007
    Die((char *)"sanity check failed: didn\'t find a match state in trace");
  }
#line 1009
  *ret_k1 = k1;
#line 1010
  *ret_i1 = i1;
#line 1011
  *ret_k2 = k2;
#line 1012
  *ret_i2 = i2;
#line 1013
  return;
}
}
#line 1035 "trace.c"
struct p7trace_s *MasterTraceFromMap(int *map , int M , int alen ) 
{ 
  struct p7trace_s *tr ;
  int tpos ;
  int apos ;
  int k ;

  {
#line 1048
  P7AllocTrace(alen + 6, & tr);
#line 1052
  tpos = 0;
#line 1053
  TraceSet(tr, tpos, (char)4, 0, 0);
#line 1053
  tpos ++;
#line 1054
  TraceSet(tr, tpos, (char)5, 0, 0);
#line 1054
  tpos ++;
#line 1058
  apos = 1;
#line 1058
  while (apos < *(map + 1)) {
#line 1059
    TraceSet(tr, tpos, (char)5, 0, apos);
#line 1059
    tpos ++;
#line 1058
    apos ++;
  }
#line 1061
  TraceSet(tr, tpos, (char)6, 0, 0);
#line 1061
  tpos ++;
#line 1063
  k = 1;
#line 1063
  while (k < M) {
#line 1065
    TraceSet(tr, tpos, (char)1, k, apos);
#line 1065
    tpos ++;
#line 1066
    apos ++;
#line 1068
    while (apos < *(map + (k + 1))) {
#line 1069
      TraceSet(tr, tpos, (char)3, k, apos);
#line 1069
      tpos ++;
#line 1068
      apos ++;
    }
#line 1063
    k ++;
  }
#line 1073
  TraceSet(tr, tpos, (char)1, M, apos);
#line 1073
  tpos ++;
#line 1074
  apos ++;
#line 1078
  TraceSet(tr, tpos, (char)7, 0, 0);
#line 1078
  tpos ++;
#line 1079
  TraceSet(tr, tpos, (char)8, 0, 0);
#line 1079
  tpos ++;
#line 1080
  while (apos <= alen) {
#line 1081
    TraceSet(tr, tpos, (char)8, 0, apos);
#line 1081
    tpos ++;
#line 1080
    apos ++;
  }
#line 1086
  TraceSet(tr, tpos, (char)9, 0, 0);
#line 1086
  tpos ++;
#line 1087
  tr->tlen = tpos;
#line 1088
  return (tr);
}
}
#line 1117 "trace.c"
void ImposeMasterTrace(char **aseq , int nseq , struct p7trace_s *mtr , struct p7trace_s ***ret_tr ) 
{ 
  struct p7trace_s **tr ;
  int idx ;
  int i___0 ;
  int tpos ;
  int mpos ;
  void *tmp ;

  {
#line 1126
  tmp = sre_malloc((char *)"trace.c", 1126, sizeof(struct p7trace_s *) * (unsigned long )nseq);
#line 1126
  tr = (struct p7trace_s **)tmp;
#line 1128
  idx = 0;
#line 1128
  while (idx < nseq) {
#line 1130
    P7AllocTrace(mtr->tlen, tr + idx);
#line 1132
    tpos = 0;
#line 1133
    i___0 = 1;
#line 1134
    mpos = 0;
#line 1134
    while (mpos < mtr->tlen) {
#line 1136
      switch ((int )*(mtr->statetype + mpos)) {
      case 9: 
      case 7: 
      case 2: 
      case 6: 
      case 4: 
#line 1143
      TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), *(mtr->nodeidx + mpos),
               0);
#line 1144
      tpos ++;
#line 1145
      break;
      case 1: 
#line 1148
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32) {
#line 1149
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
#line 1148
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46) {
#line 1149
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
#line 1148
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95) {
#line 1149
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
#line 1148
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45) {
#line 1149
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else
#line 1148
      if ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126) {
#line 1149
        TraceSet(*(tr + idx), tpos, (char)2, *(mtr->nodeidx + mpos), 0);
      } else {
#line 1151
        TraceSet(*(tr + idx), tpos, (char)1, *(mtr->nodeidx + mpos), i___0);
#line 1152
        i___0 ++;
      }
#line 1154
      tpos ++;
#line 1155
      break;
      case 3: 
#line 1158
      if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32)) {
#line 1158
        if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46)) {
#line 1158
          if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95)) {
#line 1158
            if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45)) {
#line 1158
              if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126)) {
#line 1159
                TraceSet(*(tr + idx), tpos, (char)3, *(mtr->nodeidx + mpos), i___0);
#line 1160
                i___0 ++;
#line 1161
                tpos ++;
              }
            }
          }
        }
      }
#line 1163
      break;
      case 8: 
      case 5: 
      case 10: 
#line 1168
      if (*(mtr->pos + mpos) == 0) {
#line 1169
        TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), 0, 0);
#line 1170
        tpos ++;
      } else
#line 1171
      if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 32)) {
#line 1171
        if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 46)) {
#line 1171
          if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 95)) {
#line 1171
            if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 45)) {
#line 1171
              if (! ((int )*(*(aseq + idx) + (*(mtr->pos + mpos) - 1)) == 126)) {
#line 1172
                TraceSet(*(tr + idx), tpos, *(mtr->statetype + mpos), 0, i___0);
#line 1173
                i___0 ++;
#line 1174
                tpos ++;
              }
            }
          }
        }
      }
#line 1176
      break;
      case 0: 
#line 1179
      Die((char *)"never happens. Trust me.");
      }
#line 1134
      mpos ++;
    }
#line 1182
    (*(tr + idx))->tlen = tpos;
#line 1128
    idx ++;
  }
#line 1184
  *ret_tr = tr;
#line 1185
  return;
}
}
#line 1196 "trace.c"
static void rightjustify(char *s___0 , int n ) 
{ 
  int npos ;
  int opos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1202
  npos = n - 1;
#line 1203
  opos = n - 1;
#line 1204
  while (opos >= 0) {
#line 1205
    if ((int )*(s___0 + opos) == 32) {
#line 1205
      opos --;
    } else
#line 1205
    if ((int )*(s___0 + opos) == 46) {
#line 1205
      opos --;
    } else
#line 1205
    if ((int )*(s___0 + opos) == 95) {
#line 1205
      opos --;
    } else
#line 1205
    if ((int )*(s___0 + opos) == 45) {
#line 1205
      opos --;
    } else
#line 1205
    if ((int )*(s___0 + opos) == 126) {
#line 1205
      opos --;
    } else {
#line 1206
      tmp = npos;
#line 1206
      npos --;
#line 1206
      tmp___0 = opos;
#line 1206
      opos --;
#line 1206
      *(s___0 + tmp) = *(s___0 + tmp___0);
    }
  }
#line 1208
  while (npos >= 0) {
#line 1209
    tmp___1 = npos;
#line 1209
    npos --;
#line 1209
    *(s___0 + tmp___1) = (char )'.';
  }
#line 1210
  return;
}
}
#line 1 "ucbqsort.o"
#pragma merger("0","/tmp/cil-Uj7ypIOJ.i","")
#line 15 "ucbqsort.c"
static int (*qcmp)()  ;
#line 16 "ucbqsort.c"
static int qsz  ;
#line 17 "ucbqsort.c"
static int thresh  ;
#line 18 "ucbqsort.c"
static int mthresh  ;
#line 20
static void qst(char *base , char *max ) ;
#line 30 "ucbqsort.c"
void specqsort(char *base , int n , int size , int (*compar)() ) 
{ 
  register char c ;
  register char *i___0 ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 39
  if (n <= 1) {
#line 40
    return;
  }
#line 41
  qsz = size;
#line 42
  qcmp = compar;
#line 43
  thresh = qsz * 4;
#line 44
  mthresh = qsz * 6;
#line 45
  max = base + n * qsz;
#line 46
  if (n >= 4) {
#line 47
    qst(base, max);
#line 48
    hi = base + thresh;
  } else {
#line 50
    hi = max;
  }
#line 58
  lo = base;
#line 58
  j = lo;
#line 58
  while (1) {
#line 58
    lo += qsz;
#line 58
    if (! ((unsigned long )lo < (unsigned long )hi)) {
#line 58
      break;
    }
#line 59
    tmp = (*qcmp)(j, lo);
#line 59
    if (tmp > 0) {
#line 60
      j = lo;
    }
  }
#line 61
  if ((unsigned long )j != (unsigned long )base) {
#line 63
    i___0 = base;
#line 63
    hi = base + qsz;
#line 63
    while ((unsigned long )i___0 < (unsigned long )hi) {
#line 64
      c = *j;
#line 65
      tmp___0 = j;
#line 65
      j ++;
#line 65
      *tmp___0 = *i___0;
#line 66
      tmp___1 = i___0;
#line 66
      i___0 ++;
#line 66
      *tmp___1 = c;
    }
  }
#line 76
  min = base;
#line 76
  while (1) {
#line 76
    min += qsz;
#line 76
    hi = min;
#line 76
    if (! ((unsigned long )hi < (unsigned long )max)) {
#line 76
      break;
    }
#line 77
    while (1) {
#line 77
      hi -= qsz;
#line 77
      tmp___2 = (*qcmp)(hi, min);
#line 77
      if (! (tmp___2 > 0)) {
#line 77
        break;
      }
    }
#line 79
    hi += qsz;
#line 79
    if ((unsigned long )hi != (unsigned long )min) {
#line 80
      lo = min + qsz;
#line 80
      while (1) {
#line 80
        lo --;
#line 80
        if (! ((unsigned long )lo >= (unsigned long )min)) {
#line 80
          break;
        }
#line 81
        c = *lo;
#line 82
        j = lo;
#line 82
        i___0 = j;
#line 82
        while (1) {
#line 82
          j -= qsz;
#line 82
          if (! ((unsigned long )j >= (unsigned long )hi)) {
#line 82
            break;
          }
#line 83
          *i___0 = *j;
#line 82
          i___0 = j;
        }
#line 84
        *i___0 = c;
      }
    }
  }
#line 88
  return;
}
}
#line 105 "ucbqsort.c"
static void qst(char *base , char *max ) 
{ 
  register char c ;
  register char *i___0 ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 123
  lo = (int )(max - base);
#line 124
  while (1) {
#line 125
    i___0 = base + qsz * (lo / qsz >> 1);
#line 125
    mid = i___0;
#line 126
    if (lo >= mthresh) {
#line 127
      jj = base;
#line 127
      tmp___1 = (*qcmp)(jj, i___0);
#line 127
      if (tmp___1 > 0) {
#line 127
        j = jj;
      } else {
#line 127
        j = i___0;
      }
#line 128
      tmp = max - qsz;
#line 128
      tmp___3 = (*qcmp)(j, tmp);
#line 128
      if (tmp___3 > 0) {
#line 130
        if ((unsigned long )j == (unsigned long )jj) {
#line 130
          j = i___0;
        } else {
#line 130
          j = jj;
        }
#line 131
        tmp___2 = (*qcmp)(j, tmp);
#line 131
        if (tmp___2 < 0) {
#line 132
          j = tmp;
        }
      }
#line 134
      if ((unsigned long )j != (unsigned long )i___0) {
#line 135
        ii = qsz;
#line 136
        while (1) {
#line 137
          c = *i___0;
#line 138
          tmp___4 = i___0;
#line 138
          i___0 ++;
#line 138
          *tmp___4 = *j;
#line 139
          tmp___5 = j;
#line 139
          j ++;
#line 139
          *tmp___5 = c;
#line 136
          ii --;
#line 136
          if (! ii) {
#line 136
            break;
          }
        }
      }
    }
#line 146
    i___0 = base;
#line 146
    j = max - qsz;
#line 146
    while (1) {
#line 147
      while (1) {
#line 147
        if ((unsigned long )i___0 < (unsigned long )mid) {
#line 147
          tmp___6 = (*qcmp)(i___0, mid);
#line 147
          if (! (tmp___6 <= 0)) {
#line 147
            break;
          }
        } else {
#line 147
          break;
        }
#line 148
        i___0 += qsz;
      }
#line 149
      while ((unsigned long )j > (unsigned long )mid) {
#line 150
        tmp___7 = (*qcmp)(mid, j);
#line 150
        if (tmp___7 <= 0) {
#line 151
          j -= qsz;
#line 152
          continue;
        }
#line 154
        tmp = i___0 + qsz;
#line 155
        if ((unsigned long )i___0 == (unsigned long )mid) {
#line 157
          jj = j;
#line 157
          mid = jj;
        } else {
#line 160
          jj = j;
#line 161
          j -= qsz;
        }
#line 163
        goto swap;
      }
#line 165
      if ((unsigned long )i___0 == (unsigned long )mid) {
#line 166
        break;
      } else {
#line 169
        jj = mid;
#line 170
        mid = i___0;
#line 170
        tmp = mid;
#line 171
        j -= qsz;
      }
      swap: 
#line 174
      ii = qsz;
#line 175
      while (1) {
#line 176
        c = *i___0;
#line 177
        tmp___8 = i___0;
#line 177
        i___0 ++;
#line 177
        *tmp___8 = *jj;
#line 178
        tmp___9 = jj;
#line 178
        jj ++;
#line 178
        *tmp___9 = c;
#line 175
        ii --;
#line 175
        if (! ii) {
#line 175
          break;
        }
      }
#line 180
      i___0 = tmp;
    }
#line 190
    j = mid;
#line 190
    i___0 = j + qsz;
#line 191
    lo = (int )(j - base);
#line 191
    hi = (int )(max - i___0);
#line 191
    if (lo <= hi) {
#line 192
      if (lo >= thresh) {
#line 193
        qst(base, j);
      }
#line 194
      base = i___0;
#line 195
      lo = hi;
    } else {
#line 197
      if (hi >= thresh) {
#line 198
        qst(i___0, max);
      }
#line 199
      max = j;
    }
#line 124
    if (! (lo >= thresh)) {
#line 124
      break;
    }
  }
#line 202
  return;
}
}
#line 1 "a2m.o"
#pragma merger("0","/tmp/cil-qm_Qg57x.i","")
#line 47 "./gki.h"
int GKIStoreKey(GKI *hash , char *key ) ;
#line 226 "./msa.h"
void MSAFree(MSA *msa ) ;
#line 235
void MSAExpand(MSA *msa ) ;
#line 236
char *MSAFileGetLine(MSAFILE *afp ) ;
#line 245
void MSAVerifyParse(MSA *msa ) ;
#line 264
MSA *ReadA2M(MSAFILE *afp ) ;
#line 265
void WriteA2M(FILE *fp , MSA *msa ) ;
#line 226 "./sqfuncs.h"
int sre_strcat(char **dest , int ldest , char *src , int lsrc ) ;
#line 227
char *sre_strtok(char **s___0 , char *delim , int *len ) ;
#line 39 "a2m.c"
MSA *ReadA2M(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *buf ;
  char *name ;
  char *desc ;
  char *seq ;
  int idx ;
  int len1 ;
  int len2 ;
  int tmp ;

  {
#line 50
  tmp = feof(afp->f);
#line 50
  if (tmp) {
#line 50
    return ((MSA *)((void *)0));
  }
#line 52
  name = (char *)((void *)0);
#line 53
  msa = MSAAlloc(10, 0);
#line 54
  idx = 0;
#line 55
  while (1) {
#line 55
    buf = MSAFileGetLine(afp);
#line 55
    if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
#line 55
      break;
    }
#line 57
    if ((int )*buf == 62) {
#line 59
      buf ++;
#line 60
      name = sre_strtok(& buf, (char *)" \t\n", & len1);
#line 60
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 61
        Die((char *)"Blank name in A2M file %s (line %d)\n", afp->fname, afp->linenumber);
      }
#line 62
      desc = sre_strtok(& buf, (char *)"\n", & len2);
#line 64
      idx = GKIStoreKey(msa->index, name);
#line 65
      if (idx >= msa->nseqalloc) {
#line 65
        MSAExpand(msa);
      }
#line 67
      *(msa->sqname + idx) = sre_strdup(name, len1);
#line 68
      if ((unsigned long )desc != (unsigned long )((void *)0)) {
#line 68
        MSASetSeqDescription(msa, idx, desc);
      }
#line 69
      (msa->nseq) ++;
    } else
#line 71
    if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 73
      seq = sre_strtok(& buf, (char *)" \t\n", & len1);
#line 73
      if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 73
        continue;
      }
#line 74
      *(msa->sqlen + idx) = sre_strcat(msa->aseq + idx, *(msa->sqlen + idx), seq,
                                       len1);
    }
  }
#line 77
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 77
    MSAFree(msa);
#line 77
    return ((MSA *)((void *)0));
  }
#line 79
  MSAVerifyParse(msa);
#line 80
  return (msa);
}
}
#line 95 "a2m.c"
void WriteA2M(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int pos ;
  char buf[64] ;
  int cpl ;
  char const   *tmp ;

  {
#line 101
  cpl = 60;
#line 103
  buf[cpl] = (char )'\000';
#line 104
  idx = 0;
#line 104
  while (idx < msa->nseq) {
#line 106
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 106
      if ((unsigned long )*(msa->sqdesc + idx) != (unsigned long )((void *)0)) {
#line 106
        tmp = (char const   *)*(msa->sqdesc + idx);
      } else {
#line 106
        tmp = "";
      }
    } else {
#line 106
      tmp = "";
    }
#line 106
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )">%s %s\n", *(msa->sqname + idx),
            tmp);
#line 109
    pos = 0;
#line 109
    while (pos < msa->alen) {
#line 111
      strncpy((char * __restrict  )(buf), (char const   * __restrict  )(*(msa->aseq + idx) + pos),
              (size_t )cpl);
#line 112
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", buf);
#line 109
      pos += cpl;
    }
#line 104
    idx ++;
  }
#line 115
  return;
}
}
#line 1 "aligneval.o"
#pragma merger("0","/tmp/cil-vULqoN87.i","")
#line 30 "./sqfuncs.h"
float ComparePairAlignments(char *known1 , char *known2 , char *calc1 , char *calc2 ) ;
#line 31
float CompareRefPairAlignments(int *ref , char *known1 , char *known2 , char *calc1 ,
                               char *calc2 ) ;
#line 32
float CompareMultAlignments(char **kseqs , char **tseqs , int N ) ;
#line 33
float CompareRefMultAlignments(int *ref , char **kseqs , char **tseqs , int N ) ;
#line 34
float PairwiseIdentity(char *s1 , char *s2 ) ;
#line 35
float AlignmentIdentityBySampling(char **aseq , int L , int N , int nsample ) ;
#line 36
char *MajorityRuleConsensus(char **aseq , int nseq , int alen ) ;
#line 64 "aligneval.c"
static int make_alilist(char *s1 , char *s2 , int **ret_s1_list , int *ret_listlen ) ;
#line 65
static int make_ref_alilist(int *ref , char *k1 , char *k2 , char *s1 , char *s2 ,
                            int **ret_s1_list , int *ret_listlen ) ;
#line 67
static int compare_lists(int *k1 , int *k2 , int *t1 , int *t2 , int len1 , int len2 ,
                         float *ret_sc ) ;
#line 94 "aligneval.c"
float ComparePairAlignments(char *known1 , char *known2 , char *calc1 , char *calc2 ) 
{ 
  int *klist1 ;
  int *klist2 ;
  int *tlist1 ;
  int *tlist2 ;
  int len1 ;
  int len2 ;
  float score ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 104
  tmp = make_alilist(calc1, calc2, & tlist1, & len1);
#line 104
  if (! tmp) {
#line 104
    return ((float )(- 1.0));
  }
#line 105
  tmp___0 = make_alilist(calc2, calc1, & tlist2, & len2);
#line 105
  if (! tmp___0) {
#line 105
    return ((float )(- 1.0));
  }
#line 106
  tmp___1 = make_alilist(known1, known2, & klist1, & len1);
#line 106
  if (! tmp___1) {
#line 106
    return ((float )(- 1.0));
  }
#line 107
  tmp___2 = make_alilist(known2, known1, & klist2, & len2);
#line 107
  if (! tmp___2) {
#line 107
    return ((float )(- 1.0));
  }
#line 108
  tmp___3 = compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, & score);
#line 108
  if (! tmp___3) {
#line 108
    return ((float )(- 1.0));
  }
#line 110
  free((void *)klist1);
#line 111
  free((void *)klist2);
#line 112
  free((void *)tlist1);
#line 113
  free((void *)tlist2);
#line 114
  return (score);
}
}
#line 132 "aligneval.c"
float CompareRefPairAlignments(int *ref , char *known1 , char *known2 , char *calc1 ,
                               char *calc2 ) 
{ 
  int *klist1 ;
  int *klist2 ;
  int *tlist1 ;
  int *tlist2 ;
  int len1 ;
  int len2 ;
  float score ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 142
  tmp = make_ref_alilist(ref, known1, known2, calc1, calc2, & tlist1, & len1);
#line 142
  if (! tmp) {
#line 142
    return ((float )(- 1.0));
  }
#line 143
  tmp___0 = make_ref_alilist(ref, known2, known1, calc2, calc1, & tlist2, & len2);
#line 143
  if (! tmp___0) {
#line 143
    return ((float )(- 1.0));
  }
#line 144
  tmp___1 = make_ref_alilist(ref, known1, known2, known1, known2, & klist1, & len1);
#line 144
  if (! tmp___1) {
#line 144
    return ((float )(- 1.0));
  }
#line 145
  tmp___2 = make_ref_alilist(ref, known2, known1, known2, known1, & klist2, & len2);
#line 145
  if (! tmp___2) {
#line 145
    return ((float )(- 1.0));
  }
#line 146
  tmp___3 = compare_lists(klist1, klist2, tlist1, tlist2, len1, len2, & score);
#line 146
  if (! tmp___3) {
#line 146
    return ((float )(- 1.0));
  }
#line 148
  free((void *)klist1);
#line 149
  free((void *)klist2);
#line 150
  free((void *)tlist1);
#line 151
  free((void *)tlist2);
#line 152
  return (score);
}
}
#line 169 "aligneval.c"
static int make_alilist(char *s1 , char *s2 , int **ret_s1_list , int *ret_listlen ) 
{ 
  int *s1_list ;
  int col ;
  int r1 ;
  int r2 ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 179
  tmp = strlen((char const   *)s1);
#line 179
  tmp___0 = sre_malloc((char *)"aligneval.c", 179, sizeof(int ) * tmp);
#line 179
  s1_list = (int *)tmp___0;
#line 180
  r2 = 0;
#line 180
  r1 = r2;
#line 181
  col = 0;
#line 181
  while ((int )*(s1 + col) != 0) {
#line 186
    if (! ((int )*(s1 + col) == 32)) {
#line 186
      if (! ((int )*(s1 + col) == 46)) {
#line 186
        if (! ((int )*(s1 + col) == 95)) {
#line 186
          if (! ((int )*(s1 + col) == 45)) {
#line 186
            if (! ((int )*(s1 + col) == 126)) {
#line 188
              if ((int )*(s2 + col) == 32) {
#line 188
                *(s1_list + r1) = -1;
              } else
#line 188
              if ((int )*(s2 + col) == 46) {
#line 188
                *(s1_list + r1) = -1;
              } else
#line 188
              if ((int )*(s2 + col) == 95) {
#line 188
                *(s1_list + r1) = -1;
              } else
#line 188
              if ((int )*(s2 + col) == 45) {
#line 188
                *(s1_list + r1) = -1;
              } else
#line 188
              if ((int )*(s2 + col) == 126) {
#line 188
                *(s1_list + r1) = -1;
              } else {
#line 188
                *(s1_list + r1) = r2;
              }
#line 189
              r1 ++;
            }
          }
        }
      }
    }
#line 194
    if (! ((int )*(s2 + col) == 32)) {
#line 194
      if (! ((int )*(s2 + col) == 46)) {
#line 194
        if (! ((int )*(s2 + col) == 95)) {
#line 194
          if (! ((int )*(s2 + col) == 45)) {
#line 194
            if (! ((int )*(s2 + col) == 126)) {
#line 195
              r2 ++;
            }
          }
        }
      }
    }
#line 181
    col ++;
  }
#line 198
  *ret_listlen = r1;
#line 199
  *ret_s1_list = s1_list;
#line 200
  return (1);
}
}
#line 223 "aligneval.c"
static int make_ref_alilist(int *ref , char *k1 , char *k2 , char *s1 , char *s2 ,
                            int **ret_s1_list , int *ret_listlen ) 
{ 
  int *s1_list ;
  int col ;
  int r1 ;
  int r2 ;
  int *canons1 ;
  int lpos ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 236
  tmp = strlen((char const   *)s1);
#line 236
  tmp___0 = sre_malloc((char *)"aligneval.c", 236, sizeof(int ) * tmp);
#line 236
  s1_list = (int *)tmp___0;
#line 237
  tmp___1 = strlen((char const   *)s1);
#line 237
  tmp___2 = sre_malloc((char *)"aligneval.c", 237, sizeof(int ) * tmp___1);
#line 237
  canons1 = (int *)tmp___2;
#line 243
  r1 = 0;
#line 244
  col = 0;
#line 244
  while ((int )*(k1 + col) != 0) {
#line 246
    if (! ((int )*(k1 + col) == 32)) {
#line 246
      if (! ((int )*(k1 + col) == 46)) {
#line 246
        if (! ((int )*(k1 + col) == 95)) {
#line 246
          if (! ((int )*(k1 + col) == 45)) {
#line 246
            if (! ((int )*(k1 + col) == 126)) {
#line 248
              if (*(ref + col)) {
#line 248
                *(canons1 + r1) = 1;
              } else {
#line 248
                *(canons1 + r1) = 0;
              }
#line 249
              r1 ++;
            }
          }
        }
      }
    }
#line 244
    col ++;
  }
#line 258
  lpos = 0;
#line 258
  r2 = lpos;
#line 258
  r1 = r2;
#line 259
  col = 0;
#line 259
  while ((int )*(s1 + col) != 0) {
#line 261
    if (! ((int )*(s1 + col) == 32)) {
#line 261
      if (! ((int )*(s1 + col) == 46)) {
#line 261
        if (! ((int )*(s1 + col) == 95)) {
#line 261
          if (! ((int )*(s1 + col) == 45)) {
#line 261
            if (! ((int )*(s1 + col) == 126)) {
#line 261
              if (*(canons1 + r1)) {
#line 263
                if ((int )*(s2 + col) == 32) {
#line 263
                  *(s1_list + lpos) = -1;
                } else
#line 263
                if ((int )*(s2 + col) == 46) {
#line 263
                  *(s1_list + lpos) = -1;
                } else
#line 263
                if ((int )*(s2 + col) == 95) {
#line 263
                  *(s1_list + lpos) = -1;
                } else
#line 263
                if ((int )*(s2 + col) == 45) {
#line 263
                  *(s1_list + lpos) = -1;
                } else
#line 263
                if ((int )*(s2 + col) == 126) {
#line 263
                  *(s1_list + lpos) = -1;
                } else {
#line 263
                  *(s1_list + lpos) = r2;
                }
#line 264
                lpos ++;
              }
            }
          }
        }
      }
    }
#line 267
    if (! ((int )*(s1 + col) == 32)) {
#line 267
      if (! ((int )*(s1 + col) == 46)) {
#line 267
        if (! ((int )*(s1 + col) == 95)) {
#line 267
          if (! ((int )*(s1 + col) == 45)) {
#line 267
            if (! ((int )*(s1 + col) == 126)) {
#line 268
              r1 ++;
            }
          }
        }
      }
    }
#line 269
    if (! ((int )*(s2 + col) == 32)) {
#line 269
      if (! ((int )*(s2 + col) == 46)) {
#line 269
        if (! ((int )*(s2 + col) == 95)) {
#line 269
          if (! ((int )*(s2 + col) == 45)) {
#line 269
            if (! ((int )*(s2 + col) == 126)) {
#line 270
              r2 ++;
            }
          }
        }
      }
    }
#line 259
    col ++;
  }
#line 273
  free((void *)canons1);
#line 274
  *ret_listlen = lpos;
#line 275
  *ret_s1_list = s1_list;
#line 276
  return (1);
}
}
#line 294 "aligneval.c"
static int compare_lists(int *k1 , int *k2 , int *t1 , int *t2 , int len1 , int len2 ,
                         float *ret_sc ) 
{ 
  float id ;
  float tot ;
  int i___0 ;

  {
#line 301
  tot = (float )0.0;
#line 301
  id = tot;
#line 302
  i___0 = 0;
#line 302
  while (i___0 < len1) {
#line 304
    tot = (float )((double )tot + 1.0);
#line 305
    if (*(t1 + i___0) == *(k1 + i___0)) {
#line 305
      id = (float )((double )id + 1.0);
    }
#line 302
    i___0 ++;
  }
#line 308
  i___0 = 0;
#line 308
  while (i___0 < len2) {
#line 310
    tot = (float )((double )tot + 1.0);
#line 311
    if (*(k2 + i___0) == *(t2 + i___0)) {
#line 311
      id = (float )((double )id + 1.0);
    }
#line 308
    i___0 ++;
  }
#line 314
  *ret_sc = id / tot;
#line 315
  return (1);
}
}
#line 333 "aligneval.c"
float CompareMultAlignments(char **kseqs , char **tseqs , int N ) 
{ 
  int i___0 ;
  int j ;
  float score ;
  float tot_score ;

  {
#line 338
  tot_score = (float )0.0;
#line 340
  i___0 = 0;
#line 340
  while (i___0 < N) {
#line 341
    j = i___0 + 1;
#line 341
    while (j < N) {
#line 343
      score = ComparePairAlignments(*(kseqs + i___0), *(kseqs + j), *(tseqs + i___0),
                                    *(tseqs + j));
#line 344
      if ((double )score < 0.0) {
#line 344
        return ((float )(- 1.0));
      }
#line 345
      tot_score += score;
#line 341
      j ++;
    }
#line 340
    i___0 ++;
  }
#line 347
  return ((float )(((double )tot_score * 2.0) / ((double )((float )N) * ((double )((float )N) - 1.0))));
}
}
#line 365 "aligneval.c"
float CompareRefMultAlignments(int *ref , char **kseqs , char **tseqs , int N ) 
{ 
  int i___0 ;
  int j ;
  float score ;
  float tot_score ;

  {
#line 370
  tot_score = (float )0.0;
#line 373
  i___0 = 0;
#line 373
  while (i___0 < N) {
#line 374
    j = i___0 + 1;
#line 374
    while (j < N) {
#line 376
      score = CompareRefPairAlignments(ref, *(kseqs + i___0), *(kseqs + j), *(tseqs + i___0),
                                       *(tseqs + j));
#line 377
      if ((double )score < 0.0) {
#line 377
        return ((float )(- 1.0));
      }
#line 378
      tot_score += score;
#line 374
      j ++;
    }
#line 373
    i___0 ++;
  }
#line 380
  return ((float )(((double )tot_score * 2.0) / ((double )((float )N) * ((double )((float )N) - 1.0))));
}
}
#line 400 "aligneval.c"
float PairwiseIdentity(char *s1 , char *s2 ) 
{ 
  int idents ;
  int len1 ;
  int len2 ;
  int x ;
  double tmp ;

  {
#line 407
  len2 = 0;
#line 407
  len1 = len2;
#line 407
  idents = len1;
#line 408
  x = 0;
#line 408
  while (1) {
#line 408
    if ((int )*(s1 + x) != 0) {
#line 408
      if (! ((int )*(s2 + x) != 0)) {
#line 408
        break;
      }
    } else {
#line 408
      break;
    }
#line 410
    if (! ((int )*(s1 + x) == 32)) {
#line 410
      if (! ((int )*(s1 + x) == 46)) {
#line 410
        if (! ((int )*(s1 + x) == 95)) {
#line 410
          if (! ((int )*(s1 + x) == 45)) {
#line 410
            if (! ((int )*(s1 + x) == 126)) {
#line 411
              len1 ++;
#line 412
              if ((int )*(s1 + x) == (int )*(s2 + x)) {
#line 412
                idents ++;
              }
            }
          }
        }
      }
    }
#line 414
    if (! ((int )*(s2 + x) == 32)) {
#line 414
      if (! ((int )*(s2 + x) == 46)) {
#line 414
        if (! ((int )*(s2 + x) == 95)) {
#line 414
          if (! ((int )*(s2 + x) == 45)) {
#line 414
            if (! ((int )*(s2 + x) == 126)) {
#line 414
              len2 ++;
            }
          }
        }
      }
    }
#line 408
    x ++;
  }
#line 416
  if (len2 < len1) {
#line 416
    len1 = len2;
  }
#line 417
  if (len1 == 0) {
#line 417
    tmp = 0.0;
  } else {
#line 417
    tmp = (double )((float )idents / (float )len1);
  }
#line 417
  return ((float )tmp);
}
}
#line 442 "aligneval.c"
float AlignmentIdentityBySampling(char **aseq , int L , int N , int nsample ) 
{ 
  int x ;
  int i___0 ;
  int j ;
  float sum ;
  double tmp ;
  double tmp___0 ;
  float tmp___1 ;

  {
#line 448
  if (N < 2) {
#line 448
    return ((float )1.0);
  }
#line 450
  sum = (float )0.;
#line 451
  x = 0;
#line 451
  while (x < nsample) {
#line 453
    tmp = sre_random();
#line 453
    i___0 = (int )(tmp * (double )N);
#line 454
    while (1) {
#line 454
      tmp___0 = sre_random();
#line 454
      j = (int )(tmp___0 * (double )N);
#line 454
      if (! (j == i___0)) {
#line 454
        break;
      }
    }
#line 455
    tmp___1 = PairwiseIdentity(*(aseq + i___0), *(aseq + j));
#line 455
    sum += tmp___1;
#line 451
    x ++;
  }
#line 457
  return (sum / (float )nsample);
}
}
#line 474 "aligneval.c"
char *MajorityRuleConsensus(char **aseq , int nseq , int alen ) 
{ 
  char *cs ;
  int count[27] ;
  int idx ;
  int apos ;
  int spos ;
  int x ;
  int sym ;
  int max ;
  int bestx ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 485
  tmp = sre_malloc((char *)"aligneval.c", 485, sizeof(char ) * (unsigned long )(alen + 1));
#line 485
  cs = (char *)tmp;
#line 487
  spos = 0;
#line 487
  apos = 0;
#line 487
  while (apos < alen) {
#line 489
    x = 0;
#line 489
    while (x < 27) {
#line 489
      count[x] = 0;
#line 489
      x ++;
    }
#line 491
    idx = 0;
#line 491
    while (idx < nseq) {
#line 493
      tmp___0 = __ctype_b_loc();
#line 493
      if ((int const   )*(*tmp___0 + (int )*(*(aseq + idx) + apos)) & 1024) {
#line 494
        sym = toupper((int )*(*(aseq + idx) + apos));
#line 495
        (count[sym - 65]) ++;
      } else {
#line 497
        (count[26]) ++;
      }
#line 491
      idx ++;
    }
#line 501
    if ((double )((float )count[26] / (float )nseq) <= 0.5) {
#line 502
      bestx = -1;
#line 502
      max = bestx;
#line 503
      x = 0;
#line 503
      while (x < 26) {
#line 504
        if (count[x] > max) {
#line 504
          max = count[x];
#line 504
          bestx = x;
        }
#line 503
        x ++;
      }
#line 505
      tmp___1 = spos;
#line 505
      spos ++;
#line 505
      *(cs + tmp___1) = (char )(65 + bestx);
    }
#line 487
    apos ++;
  }
#line 508
  *(cs + spos) = (char )'\000';
#line 509
  return (cs);
}
}
#line 1 "alignio.o"
#pragma merger("0","/tmp/cil-2bM4xmaF.i","")
#line 59 "./squid.h"
int squid_errno ;
#line 41 "./sqfuncs.h"
void AllocAlignment(int nseq , int alen , char ***ret_aseq , AINFO *ainfo ) ;
#line 42
void InitAinfo(AINFO *ainfo ) ;
#line 43
void FreeAlignment(char **aseqs , AINFO *ainfo ) ;
#line 44
void SAMizeAlignment(char **aseq , int nseq , int alen ) ;
#line 45
void SAMizeAlignmentByGapFrac(char **aseq , int nseq , int alen , float maxgap ) ;
#line 47
int MakeDealignedString(char *aseq , int alen , char *ss , char **ret_s ) ;
#line 49
int WritePairwiseAlignment(FILE *ofp , char *aseq1 , char *name1 , int spos1 , char *aseq2 ,
                           char *name2 , int spos2 , int **pam , int indent ) ;
#line 52
int MingapAlignment(char **aseqs , AINFO *ainfo ) ;
#line 53
int RandomAlignment(char **rseqs , SQINFO *sqinfo , int nseq , float pop , float pex ,
                    char ***ret_aseqs , AINFO *ainfo ) ;
#line 55
void AlignmentHomogenousGapsym(char **aseq , int nseq , int alen , char gapsym ) ;
#line 160
void SeqinfoCopy(SQINFO *sq1 , SQINFO *sq2 ) ;
#line 42 "alignio.c"
void AllocAlignment(int nseq , int alen , char ***ret_aseq , AINFO *ainfo ) 
{ 
  char **aseq ;
  int idx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 48
  InitAinfo(ainfo);
#line 50
  tmp = sre_malloc((char *)"alignio.c", 50, sizeof(char *) * (unsigned long )nseq);
#line 50
  aseq = (char **)tmp;
#line 51
  idx = 0;
#line 51
  while (idx < nseq) {
#line 52
    tmp___0 = sre_malloc((char *)"alignio.c", 52, sizeof(char ) * (unsigned long )(alen + 1));
#line 52
    *(aseq + idx) = (char *)tmp___0;
#line 51
    idx ++;
  }
#line 54
  ainfo->alen = alen;
#line 55
  ainfo->nseq = nseq;
#line 57
  tmp___1 = sre_malloc((char *)"alignio.c", 57, sizeof(float ) * (unsigned long )nseq);
#line 57
  ainfo->wgt = (float *)tmp___1;
#line 58
  FSet(ainfo->wgt, nseq, (float )1.0);
#line 60
  tmp___2 = sre_malloc((char *)"alignio.c", 60, sizeof(SQINFO ) * (unsigned long )nseq);
#line 60
  ainfo->sqinfo = (SQINFO *)tmp___2;
#line 61
  idx = 0;
#line 61
  while (idx < nseq) {
#line 62
    (ainfo->sqinfo + idx)->flags = 0;
#line 61
    idx ++;
  }
#line 64
  *ret_aseq = aseq;
#line 65
  return;
}
}
#line 79 "alignio.c"
void InitAinfo(AINFO *ainfo ) 
{ 
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
#line 82
  ainfo->name = (char *)((void *)0);
#line 83
  ainfo->desc = (char *)((void *)0);
#line 84
  ainfo->cs = (char *)((void *)0);
#line 85
  ainfo->rf = (char *)((void *)0);
#line 86
  ainfo->acc = (char *)((void *)0);
#line 87
  ainfo->au = (char *)((void *)0);
#line 88
  ainfo->flags = 0;
#line 90
  tmp = (float )0.0;
#line 90
  ainfo->tc2 = tmp;
#line 90
  ainfo->tc1 = tmp;
#line 91
  tmp___0 = (float )0.0;
#line 91
  ainfo->nc2 = tmp___0;
#line 91
  ainfo->nc1 = tmp___0;
#line 92
  tmp___1 = (float )0.0;
#line 92
  ainfo->ga2 = tmp___1;
#line 92
  ainfo->ga1 = tmp___1;
#line 93
  return;
}
}
#line 104 "alignio.c"
void FreeAlignment(char **aseqs , AINFO *ainfo ) 
{ 
  int i___0 ;

  {
#line 109
  i___0 = 0;
#line 109
  while (i___0 < ainfo->nseq) {
#line 111
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
#line 111
      free((void *)(ainfo->sqinfo + i___0)->ss);
    }
#line 112
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
#line 112
      free((void *)(ainfo->sqinfo + i___0)->sa);
    }
#line 109
    i___0 ++;
  }
#line 114
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
#line 114
    free((void *)ainfo->cs);
  }
#line 115
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
#line 115
    free((void *)ainfo->rf);
  }
#line 116
  if ((unsigned long )ainfo->name != (unsigned long )((void *)0)) {
#line 116
    free((void *)ainfo->name);
  }
#line 117
  if ((unsigned long )ainfo->desc != (unsigned long )((void *)0)) {
#line 117
    free((void *)ainfo->desc);
  }
#line 118
  if ((unsigned long )ainfo->acc != (unsigned long )((void *)0)) {
#line 118
    free((void *)ainfo->acc);
  }
#line 119
  if ((unsigned long )ainfo->au != (unsigned long )((void *)0)) {
#line 119
    free((void *)ainfo->au);
  }
#line 121
  free((void *)ainfo->sqinfo);
#line 122
  free((void *)ainfo->wgt);
#line 123
  Free2DArray((void **)aseqs, ainfo->nseq);
#line 124
  return;
}
}
#line 143 "alignio.c"
void SAMizeAlignment(char **aseq , int nseq , int alen ) 
{ 
  int col ;
  int i___0 ;
  int sawlower ;
  int sawupper ;
  int sawgap ;
  char gapchar ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 151
  col = 0;
#line 151
  while (col < alen) {
#line 153
    sawgap = 0;
#line 153
    sawupper = sawgap;
#line 153
    sawlower = sawupper;
#line 155
    i___0 = 0;
#line 155
    while (i___0 < nseq) {
#line 157
      if ((int )*(*(aseq + i___0) + col) == 32) {
#line 157
        sawgap = 1;
#line 157
        goto __Cont;
      } else
#line 157
      if ((int )*(*(aseq + i___0) + col) == 46) {
#line 157
        sawgap = 1;
#line 157
        goto __Cont;
      } else
#line 157
      if ((int )*(*(aseq + i___0) + col) == 95) {
#line 157
        sawgap = 1;
#line 157
        goto __Cont;
      } else
#line 157
      if ((int )*(*(aseq + i___0) + col) == 45) {
#line 157
        sawgap = 1;
#line 157
        goto __Cont;
      } else
#line 157
      if ((int )*(*(aseq + i___0) + col) == 126) {
#line 157
        sawgap = 1;
#line 157
        goto __Cont;
      }
#line 158
      tmp = __ctype_b_loc();
#line 158
      if ((int const   )*(*tmp + (int )*(*(aseq + i___0) + col)) & 256) {
#line 158
        sawupper = 1;
#line 158
        goto __Cont;
      }
#line 159
      tmp___0 = __ctype_b_loc();
#line 159
      if ((int const   )*(*tmp___0 + (int )*(*(aseq + i___0) + col)) & 512) {
#line 159
        sawlower = 1;
      }
      __Cont: /* CIL Label */ 
#line 155
      i___0 ++;
    }
#line 162
    gapchar = (char )'-';
#line 163
    if (sawlower) {
#line 163
      if (! sawupper) {
#line 163
        gapchar = (char )'.';
      }
    }
#line 166
    i___0 = 0;
#line 166
    while (i___0 < nseq) {
#line 167
      if ((int )*(*(aseq + i___0) + col) == 32) {
#line 167
        *(*(aseq + i___0) + col) = gapchar;
      } else
#line 167
      if ((int )*(*(aseq + i___0) + col) == 46) {
#line 167
        *(*(aseq + i___0) + col) = gapchar;
      } else
#line 167
      if ((int )*(*(aseq + i___0) + col) == 95) {
#line 167
        *(*(aseq + i___0) + col) = gapchar;
      } else
#line 167
      if ((int )*(*(aseq + i___0) + col) == 45) {
#line 167
        *(*(aseq + i___0) + col) = gapchar;
      } else
#line 167
      if ((int )*(*(aseq + i___0) + col) == 126) {
#line 167
        *(*(aseq + i___0) + col) = gapchar;
      }
#line 166
      i___0 ++;
    }
#line 151
    col ++;
  }
#line 169
  return;
}
}
#line 189 "alignio.c"
void SAMizeAlignmentByGapFrac(char **aseq , int nseq , int alen , float maxgap ) 
{ 
  int apos ;
  int idx ;
  int ngap ;
  int tmp ;
  int tmp___0 ;

  {
#line 196
  apos = 0;
#line 196
  while (apos < alen) {
#line 199
    ngap = 0;
#line 200
    idx = 0;
#line 200
    while (idx < nseq) {
#line 201
      if ((int )*(*(aseq + idx) + apos) == 32) {
#line 201
        ngap ++;
      } else
#line 201
      if ((int )*(*(aseq + idx) + apos) == 46) {
#line 201
        ngap ++;
      } else
#line 201
      if ((int )*(*(aseq + idx) + apos) == 95) {
#line 201
        ngap ++;
      } else
#line 201
      if ((int )*(*(aseq + idx) + apos) == 45) {
#line 201
        ngap ++;
      } else
#line 201
      if ((int )*(*(aseq + idx) + apos) == 126) {
#line 201
        ngap ++;
      }
#line 200
      idx ++;
    }
#line 204
    if ((float )ngap / (float )nseq > maxgap) {
#line 206
      idx = 0;
#line 206
      while (idx < nseq) {
#line 207
        if ((int )*(*(aseq + idx) + apos) == 32) {
#line 207
          *(*(aseq + idx) + apos) = (char )'.';
        } else
#line 207
        if ((int )*(*(aseq + idx) + apos) == 46) {
#line 207
          *(*(aseq + idx) + apos) = (char )'.';
        } else
#line 207
        if ((int )*(*(aseq + idx) + apos) == 95) {
#line 207
          *(*(aseq + idx) + apos) = (char )'.';
        } else
#line 207
        if ((int )*(*(aseq + idx) + apos) == 45) {
#line 207
          *(*(aseq + idx) + apos) = (char )'.';
        } else
#line 207
        if ((int )*(*(aseq + idx) + apos) == 126) {
#line 207
          *(*(aseq + idx) + apos) = (char )'.';
        } else {
#line 208
          tmp = tolower((int )*(*(aseq + idx) + apos));
#line 208
          *(*(aseq + idx) + apos) = (char )tmp;
        }
#line 206
        idx ++;
      }
    } else {
#line 212
      idx = 0;
#line 212
      while (idx < nseq) {
#line 213
        if ((int )*(*(aseq + idx) + apos) == 32) {
#line 213
          *(*(aseq + idx) + apos) = (char )'-';
        } else
#line 213
        if ((int )*(*(aseq + idx) + apos) == 46) {
#line 213
          *(*(aseq + idx) + apos) = (char )'-';
        } else
#line 213
        if ((int )*(*(aseq + idx) + apos) == 95) {
#line 213
          *(*(aseq + idx) + apos) = (char )'-';
        } else
#line 213
        if ((int )*(*(aseq + idx) + apos) == 45) {
#line 213
          *(*(aseq + idx) + apos) = (char )'-';
        } else
#line 213
        if ((int )*(*(aseq + idx) + apos) == 126) {
#line 213
          *(*(aseq + idx) + apos) = (char )'-';
        } else {
#line 214
          tmp___0 = toupper((int )*(*(aseq + idx) + apos));
#line 214
          *(*(aseq + idx) + apos) = (char )tmp___0;
        }
#line 212
        idx ++;
      }
    }
#line 196
    apos ++;
  }
#line 217
  return;
}
}
#line 236 "alignio.c"
int MakeAlignedString(char *aseq , int alen , char *ss , char **ret_s ) 
{ 
  char *new ;
  int apos ;
  int rpos ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 242
  tmp = sre_malloc((char *)"alignio.c", 242, (unsigned long )(alen + 1) * sizeof(char ));
#line 242
  new = (char *)tmp;
#line 243
  rpos = 0;
#line 243
  apos = rpos;
#line 243
  while (apos < alen) {
#line 244
    if ((int )*(aseq + apos) == 32) {
#line 250
      *(new + apos) = (char )'.';
    } else
#line 244
    if ((int )*(aseq + apos) == 46) {
#line 250
      *(new + apos) = (char )'.';
    } else
#line 244
    if ((int )*(aseq + apos) == 95) {
#line 250
      *(new + apos) = (char )'.';
    } else
#line 244
    if ((int )*(aseq + apos) == 45) {
#line 250
      *(new + apos) = (char )'.';
    } else
#line 244
    if ((int )*(aseq + apos) == 126) {
#line 250
      *(new + apos) = (char )'.';
    } else {
#line 246
      *(new + apos) = *(ss + rpos);
#line 247
      rpos ++;
    }
#line 243
    apos ++;
  }
#line 251
  *(new + apos) = (char )'\000';
#line 253
  tmp___0 = strlen((char const   *)ss);
#line 253
  if ((size_t )rpos != tmp___0) {
#line 254
    squid_errno = 6;
#line 254
    free((void *)new);
#line 254
    return (0);
  }
#line 255
  *ret_s = new;
#line 256
  return (1);
}
}
#line 274 "alignio.c"
int MakeDealignedString(char *aseq , int alen , char *ss , char **ret_s ) 
{ 
  char *new ;
  int apos ;
  int rpos ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 280
  tmp = sre_malloc((char *)"alignio.c", 280, (unsigned long )(alen + 1) * sizeof(char ));
#line 280
  new = (char *)tmp;
#line 281
  rpos = 0;
#line 281
  apos = rpos;
#line 281
  while (apos < alen) {
#line 282
    if (! ((int )*(aseq + apos) == 32)) {
#line 282
      if (! ((int )*(aseq + apos) == 46)) {
#line 282
        if (! ((int )*(aseq + apos) == 95)) {
#line 282
          if (! ((int )*(aseq + apos) == 45)) {
#line 282
            if (! ((int )*(aseq + apos) == 126)) {
#line 284
              *(new + rpos) = *(ss + apos);
#line 285
              rpos ++;
            }
          }
        }
      }
    }
#line 281
    apos ++;
  }
#line 287
  *(new + rpos) = (char )'\000';
#line 288
  tmp___0 = strlen((char const   *)ss);
#line 288
  if ((size_t )alen != tmp___0) {
#line 289
    squid_errno = 6;
#line 289
    free((void *)new);
#line 289
    return (0);
  }
#line 290
  *ret_s = new;
#line 291
  return (1);
}
}
#line 304 "alignio.c"
int DealignedLength(char *aseq ) 
{ 
  int rlen ;

  {
#line 308
  rlen = 0;
#line 308
  while (*aseq) {
#line 309
    if (! ((int )*aseq == 32)) {
#line 309
      if (! ((int )*aseq == 46)) {
#line 309
        if (! ((int )*aseq == 95)) {
#line 309
          if (! ((int )*aseq == 45)) {
#line 309
            if (! ((int )*aseq == 126)) {
#line 309
              rlen ++;
            }
          }
        }
      }
    }
#line 308
    aseq ++;
  }
#line 310
  return (rlen);
}
}
#line 332 "alignio.c"
int WritePairwiseAlignment(FILE *ofp , char *aseq1 , char *name1 , int spos1 , char *aseq2 ,
                           char *name2 , int spos2 , int **pam , int indent ) 
{ 
  char sname1[11] ;
  char sname2[11] ;
  int still_going ;
  char buf1[61] ;
  char bufmid[61] ;
  char buf2[61] ;
  char *s1 ;
  char *s2 ;
  int count1 ;
  int count2 ;
  int rpos1 ;
  int rpos2 ;
  int rawcount1 ;
  int rawcount2 ;
  int apos ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 350
  strncpy((char * __restrict  )(sname1), (char const   * __restrict  )name1, (size_t )10);
#line 351
  sname1[10] = (char )'\000';
#line 352
  strtok((char * __restrict  )(sname1), (char const   * __restrict  )" \t\n");
#line 354
  strncpy((char * __restrict  )(sname2), (char const   * __restrict  )name2, (size_t )10);
#line 355
  sname2[10] = (char )'\000';
#line 356
  strtok((char * __restrict  )(sname2), (char const   * __restrict  )" \t\n");
#line 358
  s1 = aseq1;
#line 359
  s2 = aseq2;
#line 360
  rpos1 = spos1;
#line 361
  rpos2 = spos2;
#line 363
  still_going = 1;
#line 364
  while (still_going) {
#line 366
    still_going = 0;
#line 369
    strncpy((char * __restrict  )(buf1), (char const   * __restrict  )s1, (size_t )60);
#line 369
    buf1[60] = (char )'\000';
#line 370
    strncpy((char * __restrict  )(buf2), (char const   * __restrict  )s2, (size_t )60);
#line 370
    buf2[60] = (char )'\000';
#line 371
    tmp = strlen((char const   *)(buf1));
#line 371
    count1 = (int )tmp;
#line 372
    tmp___0 = strlen((char const   *)(buf2));
#line 372
    count2 = (int )tmp___0;
#line 375
    if (count1 == 60) {
#line 375
      if ((int )*(s1 + 60) != 0) {
#line 377
        still_going = 1;
      } else {
#line 375
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 375
    if (count2 == 60) {
#line 375
      if ((int )*(s2 + 60) != 0) {
#line 377
        still_going = 1;
      }
    }
#line 380
    s1 += count1;
#line 381
    s2 += count2;
#line 384
    apos = 0;
#line 384
    while (1) {
#line 384
      if (apos < count1) {
#line 384
        if (! (apos < count2)) {
#line 384
          break;
        }
      } else {
#line 384
        break;
      }
#line 386
      if ((int )buf1[apos] == 32) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf1[apos] == 46) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf1[apos] == 95) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf1[apos] == 45) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf1[apos] == 126) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf2[apos] == 32) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf2[apos] == 46) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf2[apos] == 95) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf2[apos] == 45) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 386
      if ((int )buf2[apos] == 126) {
#line 396
        bufmid[apos] = (char )' ';
      } else
#line 388
      if ((int )buf1[apos] == (int )buf2[apos]) {
#line 389
        bufmid[apos] = buf1[apos];
      } else
#line 390
      if (*(*(pam + ((int )buf1[apos] - 65)) + ((int )buf2[apos] - 65)) > 0) {
#line 391
        bufmid[apos] = (char )'+';
      } else {
#line 393
        bufmid[apos] = (char )' ';
      }
#line 384
      apos ++;
    }
#line 398
    bufmid[apos] = (char )'\000';
#line 400
    rawcount1 = 0;
#line 401
    apos = 0;
#line 401
    while (apos < count1) {
#line 402
      if (! ((int )buf1[apos] == 32)) {
#line 402
        if (! ((int )buf1[apos] == 46)) {
#line 402
          if (! ((int )buf1[apos] == 95)) {
#line 402
            if (! ((int )buf1[apos] == 45)) {
#line 402
              if (! ((int )buf1[apos] == 126)) {
#line 402
                rawcount1 ++;
              }
            }
          }
        }
      }
#line 401
      apos ++;
    }
#line 404
    rawcount2 = 0;
#line 405
    apos = 0;
#line 405
    while (apos < count2) {
#line 406
      if (! ((int )buf2[apos] == 32)) {
#line 406
        if (! ((int )buf2[apos] == 46)) {
#line 406
          if (! ((int )buf2[apos] == 95)) {
#line 406
            if (! ((int )buf2[apos] == 45)) {
#line 406
              if (! ((int )buf2[apos] == 126)) {
#line 406
                rawcount2 ++;
              }
            }
          }
        }
      }
#line 405
      apos ++;
    }
#line 408
    fprintf((FILE * __restrict  )ofp, (char const   * __restrict  )"%*s%-10.10s %5d %s %5d\n",
            indent, "", sname1, rpos1, buf1, (rpos1 + rawcount1) - 1);
#line 410
    fprintf((FILE * __restrict  )ofp, (char const   * __restrict  )"%*s                 %s\n",
            indent, "", bufmid);
#line 412
    fprintf((FILE * __restrict  )ofp, (char const   * __restrict  )"%*s%-10.10s %5d %s %5d\n",
            indent, "", sname2, rpos2, buf2, (rpos2 + rawcount2) - 1);
#line 414
    fprintf((FILE * __restrict  )ofp, (char const   * __restrict  )"\n");
#line 416
    rpos1 += rawcount1;
#line 417
    rpos2 += rawcount2;
  }
#line 420
  return (1);
}
}
#line 430 "alignio.c"
int MingapAlignment(char **aseqs , AINFO *ainfo ) 
{ 
  int apos ;
  int mpos ;
  int idx ;

  {
#line 439
  apos = 0;
#line 439
  mpos = 0;
#line 439
  while ((int )*(*(aseqs + 0) + apos) != 0) {
#line 442
    idx = 0;
#line 442
    while (idx < ainfo->nseq) {
#line 443
      if (! ((int )*(*(aseqs + idx) + apos) == 32)) {
#line 443
        if (! ((int )*(*(aseqs + idx) + apos) == 46)) {
#line 443
          if (! ((int )*(*(aseqs + idx) + apos) == 95)) {
#line 443
            if (! ((int )*(*(aseqs + idx) + apos) == 45)) {
#line 443
              if (! ((int )*(*(aseqs + idx) + apos) == 126)) {
#line 444
                break;
              }
            }
          }
        }
      }
#line 442
      idx ++;
    }
#line 445
    if (idx == ainfo->nseq) {
#line 445
      goto __Cont;
    }
#line 448
    if (mpos != apos) {
#line 450
      idx = 0;
#line 450
      while (idx < ainfo->nseq) {
#line 451
        *(*(aseqs + idx) + mpos) = *(*(aseqs + idx) + apos);
#line 450
        idx ++;
      }
#line 453
      if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
#line 453
        *(ainfo->cs + mpos) = *(ainfo->cs + apos);
      }
#line 454
      if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
#line 454
        *(ainfo->rf + mpos) = *(ainfo->rf + apos);
      }
    }
#line 456
    mpos ++;
    __Cont: /* CIL Label */ 
#line 439
    apos ++;
  }
#line 459
  idx = 0;
#line 459
  while (idx < ainfo->nseq) {
#line 460
    *(*(aseqs + idx) + mpos) = (char )'\000';
#line 459
    idx ++;
  }
#line 461
  ainfo->alen = mpos;
#line 462
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
#line 462
    *(ainfo->cs + mpos) = (char )'\000';
  }
#line 463
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
#line 463
    *(ainfo->rf + mpos) = (char )'\000';
  }
#line 464
  return (1);
}
}
#line 513 "alignio.c"
int RandomAlignment(char **rseqs , SQINFO *sqinfo , int nseq , float pop , float pex ,
                    char ***ret_aseqs , AINFO *ainfo ) 
{ 
  char **aseqs ;
  int alen ;
  int *rlen ;
  int M ;
  int **ins ;
  int *master_ins ;
  int apos ;
  int rpos ;
  int idx ;
  int statepos ;
  int count ;
  int minlen ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;

  {
#line 530
  tmp = sre_malloc((char *)"alignio.c", 530, sizeof(int ) * (unsigned long )nseq);
#line 530
  rlen = (int *)tmp;
#line 531
  M = 0;
#line 532
  minlen = 9999999;
#line 533
  idx = 0;
#line 533
  while (idx < nseq) {
#line 535
    tmp___0 = strlen((char const   *)*(rseqs + idx));
#line 535
    *(rlen + idx) = (int )tmp___0;
#line 536
    M += *(rlen + idx);
#line 537
    if (*(rlen + idx) < minlen) {
#line 537
      minlen = *(rlen + idx);
    } else {
#line 537
      minlen = minlen;
    }
#line 533
    idx ++;
  }
#line 539
  M = (int )((double )((float )M) / (1.0 + (double )pop * (1.0 + 1.0 / (1.0 - (double )pex))));
#line 540
  M /= nseq;
#line 541
  if (M > minlen) {
#line 541
    M = minlen;
  }
#line 545
  tmp___1 = sre_malloc((char *)"alignio.c", 545, sizeof(int *) * (unsigned long )nseq);
#line 545
  ins = (int **)tmp___1;
#line 546
  tmp___2 = sre_malloc((char *)"alignio.c", 546, sizeof(int ) * (unsigned long )(M + 1));
#line 546
  master_ins = (int *)tmp___2;
#line 547
  idx = 0;
#line 547
  while (idx < nseq) {
#line 549
    tmp___3 = sre_malloc((char *)"alignio.c", 549, sizeof(int ) * (unsigned long )(M + 1));
#line 549
    *(ins + idx) = (int *)tmp___3;
#line 550
    rpos = 0;
#line 550
    while (rpos <= M) {
#line 551
      *(*(ins + idx) + rpos) = 0;
#line 550
      rpos ++;
    }
#line 547
    idx ++;
  }
#line 554
  pop /= pop + pex;
#line 555
  pex = (float )(1.0 - (double )pop);
#line 557
  idx = 0;
#line 557
  while (idx < nseq) {
#line 559
    apos = -1;
#line 560
    rpos = 0;
#line 560
    while (rpos < *(rlen + idx) - M) {
#line 562
      tmp___5 = sre_random();
#line 562
      if (tmp___5 < (double )pop) {
#line 563
        tmp___4 = sre_random();
#line 563
        apos = (int )(tmp___4 * (double )(M + 1));
      } else
#line 562
      if (apos == -1) {
#line 563
        tmp___4 = sre_random();
#line 563
        apos = (int )(tmp___4 * (double )(M + 1));
      }
#line 564
      (*(*(ins + idx) + apos)) ++;
#line 560
      rpos ++;
    }
#line 557
    idx ++;
  }
#line 568
  alen = M;
#line 569
  apos = 0;
#line 569
  while (apos <= M) {
#line 571
    *(master_ins + apos) = 0;
#line 572
    idx = 0;
#line 572
    while (idx < nseq) {
#line 573
      if (*(*(ins + idx) + apos) > *(master_ins + apos)) {
#line 574
        *(master_ins + apos) = *(*(ins + idx) + apos);
      }
#line 572
      idx ++;
    }
#line 575
    alen += *(master_ins + apos);
#line 569
    apos ++;
  }
#line 581
  tmp___6 = sre_malloc((char *)"alignio.c", 581, sizeof(char *) * (unsigned long )nseq);
#line 581
  aseqs = (char **)tmp___6;
#line 582
  idx = 0;
#line 582
  while (idx < nseq) {
#line 583
    tmp___7 = sre_malloc((char *)"alignio.c", 583, sizeof(char ) * (unsigned long )(alen + 1));
#line 583
    *(aseqs + idx) = (char *)tmp___7;
#line 582
    idx ++;
  }
#line 584
  idx = 0;
#line 584
  while (idx < nseq) {
#line 586
    rpos = 0;
#line 586
    apos = rpos;
#line 588
    statepos = 0;
#line 588
    while (statepos <= M) {
#line 590
      count = 0;
#line 590
      while (count < *(*(ins + idx) + statepos)) {
#line 591
        tmp___8 = apos;
#line 591
        apos ++;
#line 591
        tmp___9 = rpos;
#line 591
        rpos ++;
#line 591
        *(*(aseqs + idx) + tmp___8) = *(*(rseqs + idx) + tmp___9);
#line 590
        count ++;
      }
#line 592
      while (count < *(master_ins + statepos)) {
#line 593
        tmp___10 = apos;
#line 593
        apos ++;
#line 593
        *(*(aseqs + idx) + tmp___10) = (char )' ';
#line 592
        count ++;
      }
#line 595
      if (statepos != M) {
#line 596
        tmp___11 = apos;
#line 596
        apos ++;
#line 596
        tmp___12 = rpos;
#line 596
        rpos ++;
#line 596
        *(*(aseqs + idx) + tmp___11) = *(*(rseqs + idx) + tmp___12);
      }
#line 588
      statepos ++;
    }
#line 598
    *(*(aseqs + idx) + alen) = (char )'\000';
#line 584
    idx ++;
  }
#line 600
  ainfo->flags = 0;
#line 601
  ainfo->alen = alen;
#line 602
  ainfo->nseq = nseq;
#line 603
  tmp___13 = sre_malloc((char *)"alignio.c", 603, sizeof(SQINFO ) * (unsigned long )nseq);
#line 603
  ainfo->sqinfo = (SQINFO *)tmp___13;
#line 604
  idx = 0;
#line 604
  while (idx < nseq) {
#line 605
    SeqinfoCopy(ainfo->sqinfo + idx, sqinfo + idx);
#line 604
    idx ++;
  }
#line 607
  free((void *)rlen);
#line 608
  free((void *)master_ins);
#line 609
  Free2DArray((void **)ins, nseq);
#line 610
  *ret_aseqs = aseqs;
#line 611
  return (1);
}
}
#line 634 "alignio.c"
void AlignmentHomogenousGapsym(char **aseq , int nseq , int alen , char gapsym ) 
{ 
  int i___0 ;
  int apos ;

  {
#line 639
  i___0 = 0;
#line 639
  while (i___0 < nseq) {
#line 640
    apos = 0;
#line 640
    while (apos < alen) {
#line 641
      if ((int )*(*(aseq + i___0) + apos) == 32) {
#line 641
        *(*(aseq + i___0) + apos) = gapsym;
      } else
#line 641
      if ((int )*(*(aseq + i___0) + apos) == 46) {
#line 641
        *(*(aseq + i___0) + apos) = gapsym;
      } else
#line 641
      if ((int )*(*(aseq + i___0) + apos) == 95) {
#line 641
        *(*(aseq + i___0) + apos) = gapsym;
      } else
#line 641
      if ((int )*(*(aseq + i___0) + apos) == 45) {
#line 641
        *(*(aseq + i___0) + apos) = gapsym;
      } else
#line 641
      if ((int )*(*(aseq + i___0) + apos) == 126) {
#line 641
        *(*(aseq + i___0) + apos) = gapsym;
      }
#line 640
      apos ++;
    }
#line 639
    i___0 ++;
  }
#line 642
  return;
}
}
#line 1 "clustal.o"
#pragma merger("0","/tmp/cil-PhQ21Oh_.i","")
#line 302 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 246 "./msa.h"
int MSAGetSeqidx(MSA *msa , char *name , int guess ) ;
#line 269
MSA *ReadClustal(MSAFILE *afp ) ;
#line 270
void WriteClustal(FILE *fp , MSA *msa ) ;
#line 78 "clustal.c"
MSA *ReadClustal(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int slen ;
  int sqidx ;
  char *name ;
  char *seq ;
  char *s2 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 89
  tmp = feof(afp->f);
#line 89
  if (tmp) {
#line 89
    return ((MSA *)((void *)0));
  }
#line 93
  while (1) {
#line 93
    s___0 = MSAFileGetLine(afp);
#line 93
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 93
      break;
    }
#line 95
    tmp___0 = strncmp((char const   *)s___0, "CLUSTAL", (size_t )7);
#line 95
    if (tmp___0 == 0) {
#line 95
      tmp___1 = strstr((char const   *)s___0, "multiple sequence alignment");
#line 95
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 97
        break;
      }
    }
  }
#line 99
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 99
    return ((MSA *)((void *)0));
  }
#line 101
  msa = MSAAlloc(10, 0);
#line 108
  while (1) {
#line 108
    s___0 = MSAFileGetLine(afp);
#line 108
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 108
      break;
    }
#line 110
    name = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 110
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 110
      continue;
    }
#line 111
    seq = sre_strtok(& s___0, (char *)" \t\n", & slen);
#line 111
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 111
      continue;
    }
#line 112
    s2 = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
#line 116
    tmp___2 = strpbrk((char const   *)name, ".*:");
#line 116
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 116
      tmp___3 = strpbrk((char const   *)seq, ".*:");
#line 116
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 117
        continue;
      }
    }
#line 118
    if ((unsigned long )s2 != (unsigned long )((void *)0)) {
#line 119
      Die((char *)"Parse failed at line %d, file %s: possibly using spaces as gaps",
          afp->linenumber, afp->fname);
    }
#line 124
    sqidx = MSAGetSeqidx(msa, name, msa->lastidx + 1);
#line 125
    msa->lastidx = sqidx;
#line 126
    *(msa->sqlen + sqidx) = sre_strcat(msa->aseq + sqidx, *(msa->sqlen + sqidx), seq,
                                       slen);
  }
#line 129
  MSAVerifyParse(msa);
#line 130
  return (msa);
}
}
#line 144 "clustal.c"
void WriteClustal(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int len ;
  int namelen ;
  int pos ;
  char buf[64] ;
  int cpl ;
  size_t tmp ;

  {
#line 152
  cpl = 50;
#line 155
  namelen = 0;
#line 156
  idx = 0;
#line 156
  while (idx < msa->nseq) {
#line 157
    tmp = strlen((char const   *)*(msa->sqname + idx));
#line 157
    len = (int )tmp;
#line 157
    if (len > namelen) {
#line 158
      namelen = len;
    }
#line 156
    idx ++;
  }
#line 160
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"CLUSTAL W(1.5) multiple sequence alignment\n");
#line 166
  pos = 0;
#line 166
  while (pos < msa->alen) {
#line 168
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 169
    idx = 0;
#line 169
    while (idx < msa->nseq) {
#line 171
      strncpy((char * __restrict  )(buf), (char const   * __restrict  )(*(msa->aseq + idx) + pos),
              (size_t )cpl);
#line 172
      buf[cpl] = (char )'\000';
#line 173
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s %s\n", namelen,
              *(msa->sqname + idx), buf);
#line 169
      idx ++;
    }
#line 166
    pos += cpl;
  }
#line 177
  return;
}
}
#line 1 "cluster.o"
#pragma merger("0","/tmp/cil-2Wuqyka1.i","")
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 59 "./sqfuncs.h"
int Cluster(float **dmx , int N , enum clust_strategy mode , struct phylo_s **ret_tree ) ;
#line 60
struct phylo_s *AllocPhylo(int N ) ;
#line 61
void FreePhylo(struct phylo_s *tree , int N ) ;
#line 62
void MakeDiffMx(char **aseqs , int num , float ***ret_dmx ) ;
#line 63
void MakeIdentityMx(char **aseqs , int num , float ***ret_imx ) ;
#line 64
void PrintNewHampshireTree(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) ;
#line 65
void PrintPhylo(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) ;
#line 202
float **FMX2Alloc(int rows , int cols ) ;
#line 235
struct intstack_s *InitIntStack(void) ;
#line 236
void PushIntStack(struct intstack_s *stack , int data ) ;
#line 237
int PopIntStack(struct intstack_s *stack , int *ret_data ) ;
#line 239
int FreeIntStack(struct intstack_s *stack ) ;
#line 147 "cluster.c"
int Cluster(float **dmx , int N , enum clust_strategy mode , struct phylo_s **ret_tree ) 
{ 
  struct phylo_s *tree ;
  float **mx ;
  int *coord ;
  int i___0 ;
  int j ;
  int idx ;
  int Np ;
  int row ;
  int col ;
  float min ;
  float *trow ;
  float tcol ;
  float *diff ;
  int swapfoo ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;

  {
#line 168
  tmp = sre_malloc((char *)"cluster.c", 168, sizeof(float *) * (unsigned long )N);
#line 168
  mx = (float **)tmp;
#line 169
  i___0 = 0;
#line 169
  while (i___0 < N) {
#line 171
    tmp___0 = sre_malloc((char *)"cluster.c", 171, sizeof(float ) * (unsigned long )N);
#line 171
    *(mx + i___0) = (float *)tmp___0;
#line 172
    j = 0;
#line 172
    while (j < N) {
#line 173
      *(*(mx + i___0) + j) = *(*(dmx + i___0) + j);
#line 172
      j ++;
    }
#line 169
    i___0 ++;
  }
#line 176
  tmp___1 = sre_malloc((char *)"cluster.c", 176, (unsigned long )N * sizeof(int ));
#line 176
  coord = (int *)tmp___1;
#line 177
  tmp___2 = sre_malloc((char *)"cluster.c", 177, (unsigned long )(N - 1) * sizeof(float ));
#line 177
  diff = (float *)tmp___2;
#line 179
  col = 0;
#line 179
  while (col < N) {
#line 179
    *(coord + col) = col;
#line 179
    col ++;
  }
#line 180
  i___0 = 0;
#line 180
  while (i___0 < N - 1) {
#line 180
    *(diff + i___0) = (float )0.0;
#line 180
    i___0 ++;
  }
#line 183
  tree = AllocPhylo(N);
#line 183
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 183
    Die((char *)"AllocPhylo() failed");
  }
#line 190
  j = 0;
#line 191
  Np = N;
#line 191
  while (Np >= 2) {
#line 194
    min = (float )999999.;
#line 195
    row = 0;
#line 195
    while (row < Np) {
#line 196
      col = row + 1;
#line 196
      while (col < Np) {
#line 197
        if (*(*(mx + row) + col) < min) {
#line 199
          min = *(*(mx + row) + col);
#line 200
          i___0 = row;
#line 201
          j = col;
        }
#line 196
        col ++;
      }
#line 195
      row ++;
    }
#line 208
    (tree + (Np - 2))->left = *(coord + i___0);
#line 209
    (tree + (Np - 2))->right = *(coord + j);
#line 210
    if (*(coord + i___0) >= N) {
#line 210
      (tree + (*(coord + i___0) - N))->parent = (N + Np) - 2;
    }
#line 211
    if (*(coord + j) >= N) {
#line 211
      (tree + (*(coord + j) - N))->parent = (N + Np) - 2;
    }
#line 214
    tmp___3 = min;
#line 214
    (tree + (Np - 2))->diff = tmp___3;
#line 214
    *(diff + (Np - 2)) = tmp___3;
#line 217
    tmp___4 = min;
#line 217
    (tree + (Np - 2))->rblen = tmp___4;
#line 217
    (tree + (Np - 2))->lblen = tmp___4;
#line 218
    if (*(coord + i___0) >= N) {
#line 218
      (tree + (Np - 2))->lblen -= *(diff + (*(coord + i___0) - N));
    }
#line 219
    if (*(coord + j) >= N) {
#line 219
      (tree + (Np - 2))->rblen -= *(diff + (*(coord + j) - N));
    }
#line 222
    if (*(coord + i___0) < N) {
#line 224
      ((tree + (Np - 2))->incnum) ++;
#line 225
      *((tree + (Np - 2))->is_in + *(coord + i___0)) = (char)1;
    } else {
#line 229
      (tree + (Np - 2))->incnum += (tree + (*(coord + i___0) - N))->incnum;
#line 230
      idx = 0;
#line 230
      while (idx < N) {
#line 231
        *((tree + (Np - 2))->is_in + idx) = (char )((int )*((tree + (Np - 2))->is_in + idx) | (int )*((tree + (*(coord + i___0) - N))->is_in + idx));
#line 230
        idx ++;
      }
    }
#line 234
    if (*(coord + j) < N) {
#line 236
      ((tree + (Np - 2))->incnum) ++;
#line 237
      *((tree + (Np - 2))->is_in + *(coord + j)) = (char)1;
    } else {
#line 241
      (tree + (Np - 2))->incnum += (tree + (*(coord + j) - N))->incnum;
#line 242
      idx = 0;
#line 242
      while (idx < N) {
#line 243
        *((tree + (Np - 2))->is_in + idx) = (char )((int )*((tree + (Np - 2))->is_in + idx) | (int )*((tree + (*(coord + j) - N))->is_in + idx));
#line 242
        idx ++;
      }
    }
#line 252
    if (i___0 == Np - 1) {
#line 253
      swapfoo = j;
#line 253
      j = i___0;
#line 253
      i___0 = swapfoo;
    } else
#line 252
    if (j == Np - 2) {
#line 253
      swapfoo = j;
#line 253
      j = i___0;
#line 253
      i___0 = swapfoo;
    }
#line 255
    if (i___0 != Np - 2) {
#line 258
      trow = *(mx + (Np - 2));
#line 258
      *(mx + (Np - 2)) = *(mx + i___0);
#line 258
      *(mx + i___0) = trow;
#line 260
      row = 0;
#line 260
      while (row < Np) {
#line 262
        tcol = *(*(mx + row) + (Np - 2));
#line 263
        *(*(mx + row) + (Np - 2)) = *(*(mx + row) + i___0);
#line 264
        *(*(mx + row) + i___0) = tcol;
#line 260
        row ++;
      }
#line 267
      swapfoo = *(coord + (Np - 2));
#line 267
      *(coord + (Np - 2)) = *(coord + i___0);
#line 267
      *(coord + i___0) = swapfoo;
    }
#line 270
    if (j != Np - 1) {
#line 273
      trow = *(mx + (Np - 1));
#line 273
      *(mx + (Np - 1)) = *(mx + j);
#line 273
      *(mx + j) = trow;
#line 275
      row = 0;
#line 275
      while (row < Np) {
#line 277
        tcol = *(*(mx + row) + (Np - 1));
#line 278
        *(*(mx + row) + (Np - 1)) = *(*(mx + row) + j);
#line 279
        *(*(mx + row) + j) = tcol;
#line 275
        row ++;
      }
#line 282
      swapfoo = *(coord + (Np - 1));
#line 282
      *(coord + (Np - 1)) = *(coord + j);
#line 282
      *(coord + j) = swapfoo;
    }
#line 287
    i___0 = Np - 2;
#line 288
    j = Np - 1;
#line 290
    col = 0;
#line 290
    while (col < Np) {
#line 292
      switch ((unsigned int )mode) {
      case 0U: 
#line 293
      *(*(mx + i___0) + col) = (float )((double )(*(*(mx + i___0) + col) + *(*(mx + j) + col)) / 2.0);
#line 293
      break;
      case 2U: 
#line 294
      if (*(*(mx + i___0) + col) < *(*(mx + j) + col)) {
#line 294
        *(*(mx + i___0) + col) = *(*(mx + i___0) + col);
      } else {
#line 294
        *(*(mx + i___0) + col) = *(*(mx + j) + col);
      }
#line 294
      break;
      case 1U: 
#line 295
      if (*(*(mx + i___0) + col) > *(*(mx + j) + col)) {
#line 295
        *(*(mx + i___0) + col) = *(*(mx + i___0) + col);
      } else {
#line 295
        *(*(mx + i___0) + col) = *(*(mx + j) + col);
      }
#line 295
      break;
      default: 
#line 296
      *(*(mx + i___0) + col) = (float )((double )(*(*(mx + i___0) + col) + *(*(mx + j) + col)) / 2.0);
#line 296
      break;
      }
#line 290
      col ++;
    }
#line 300
    col = 0;
#line 300
    while (col < Np) {
#line 301
      *(*(mx + col) + i___0) = *(*(mx + i___0) + col);
#line 300
      col ++;
    }
#line 303
    *(coord + (Np - 2)) = (Np + N) - 2;
#line 191
    Np --;
  }
#line 309
  Free2DArray((void **)mx, N);
#line 310
  free((void *)coord);
#line 311
  free((void *)diff);
#line 312
  *ret_tree = tree;
#line 313
  return (1);
}
}
#line 328 "cluster.c"
struct phylo_s *AllocPhylo(int N ) 
{ 
  struct phylo_s *tree ;
  int i___0 ;
  void *tmp ;
  float tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
#line 334
  tmp = malloc((unsigned long )(N - 1) * sizeof(struct phylo_s ));
#line 334
  tree = (struct phylo_s *)tmp;
#line 334
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 335
    return ((struct phylo_s *)((void *)0));
  }
#line 337
  i___0 = 0;
#line 337
  while (i___0 < N - 1) {
#line 339
    (tree + i___0)->diff = (float )0.0;
#line 340
    tmp___0 = (float )0.0;
#line 340
    (tree + i___0)->rblen = tmp___0;
#line 340
    (tree + i___0)->lblen = tmp___0;
#line 341
    tmp___2 = -1;
#line 341
    (tree + i___0)->parent = tmp___2;
#line 341
    tmp___1 = tmp___2;
#line 341
    (tree + i___0)->right = tmp___1;
#line 341
    (tree + i___0)->left = tmp___1;
#line 342
    (tree + i___0)->incnum = 0;
#line 343
    tmp___4 = calloc((size_t )N, sizeof(char ));
#line 343
    tmp___3 = (char *)tmp___4;
#line 343
    (tree + i___0)->is_in = tmp___3;
#line 343
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 344
      return ((struct phylo_s *)((void *)0));
    }
#line 337
    i___0 ++;
  }
#line 346
  return (tree);
}
}
#line 359 "cluster.c"
void FreePhylo(struct phylo_s *tree , int N ) 
{ 
  int idx ;

  {
#line 364
  idx = 0;
#line 364
  while (idx < N - 1) {
#line 365
    free((void *)(tree + idx)->is_in);
#line 364
    idx ++;
  }
#line 366
  free((void *)tree);
#line 367
  return;
}
}
#line 383 "cluster.c"
void MakeDiffMx(char **aseqs , int num , float ***ret_dmx ) 
{ 
  float **dmx ;
  int i___0 ;
  int j ;
  float tmp ;
  float tmp___0 ;

  {
#line 391
  dmx = FMX2Alloc(num, num);
#line 396
  i___0 = 0;
#line 396
  while (i___0 < num) {
#line 397
    j = i___0;
#line 397
    while (j < num) {
#line 398
      tmp___0 = PairwiseIdentity(*(aseqs + i___0), *(aseqs + j));
#line 398
      tmp = (float )(1.0 - (double )tmp___0);
#line 398
      *(*(dmx + j) + i___0) = tmp;
#line 398
      *(*(dmx + i___0) + j) = tmp;
#line 397
      j ++;
    }
#line 396
    i___0 ++;
  }
#line 400
  *ret_dmx = dmx;
#line 401
  return;
}
}
#line 419 "cluster.c"
void MakeIdentityMx(char **aseqs , int num , float ***ret_imx ) 
{ 
  float **imx ;
  int i___0 ;
  int j ;
  float tmp ;

  {
#line 427
  imx = FMX2Alloc(num, num);
#line 431
  i___0 = 0;
#line 431
  while (i___0 < num) {
#line 432
    j = i___0;
#line 432
    while (j < num) {
#line 433
      tmp = PairwiseIdentity(*(aseqs + i___0), *(aseqs + j));
#line 433
      *(*(imx + j) + i___0) = tmp;
#line 433
      *(*(imx + i___0) + j) = tmp;
#line 432
      j ++;
    }
#line 431
    i___0 ++;
  }
#line 435
  *ret_imx = imx;
#line 436
  return;
}
}
#line 456 "cluster.c"
void PrintNewHampshireTree(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) 
{ 
  struct intstack_s *stack ;
  int code ;
  float *blen ;
  int docomma ;
  void *tmp ;
  int tmp___0 ;

  {
#line 464
  tmp = sre_malloc((char *)"cluster.c", 464, sizeof(float ) * (unsigned long )(2 * N - 1));
#line 464
  blen = (float *)tmp;
#line 465
  stack = InitIntStack();
#line 466
  PushIntStack(stack, N);
#line 467
  docomma = 0;
#line 475
  while (1) {
#line 475
    tmp___0 = PopIntStack(stack, & code);
#line 475
    if (! tmp___0) {
#line 475
      break;
    }
#line 477
    if (code < N) {
#line 480
      if (docomma) {
#line 480
        fputs((char const   * __restrict  )",", (FILE * __restrict  )fp);
      }
#line 481
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s:%.5f", (ainfo->sqinfo + code)->name,
              (double )*(blen + code));
#line 482
      docomma = 1;
    } else
#line 485
    if (code < 2 * N) {
#line 488
      if (docomma) {
#line 488
        fputs((char const   * __restrict  )",\n", (FILE * __restrict  )fp);
      }
#line 489
      fputs((char const   * __restrict  )"(", (FILE * __restrict  )fp);
#line 491
      PushIntStack(stack, code + N);
#line 492
      PushIntStack(stack, (tree + (code - N))->right);
#line 493
      PushIntStack(stack, (tree + (code - N))->left);
#line 495
      *(blen + (tree + (code - N))->right) = (tree + (code - N))->rblen;
#line 496
      *(blen + (tree + (code - N))->left) = (tree + (code - N))->lblen;
#line 497
      docomma = 0;
    } else {
#line 503
      if (code == 2 * N) {
#line 503
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )");\n");
      } else {
#line 504
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"):%.5f", (double )*(blen + (code - N)));
      }
#line 505
      docomma = 1;
    }
  }
#line 509
  FreeIntStack(stack);
#line 510
  free((void *)blen);
#line 511
  return;
}
}
#line 519 "cluster.c"
void PrintPhylo(FILE *fp , AINFO *ainfo , struct phylo_s *tree , int N ) 
{ 
  int idx ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 524
  idx = 0;
#line 524
  while (idx < N - 1) {
#line 526
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Interior node %d (code %d)\n",
            idx, idx + N);
#line 527
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tParent: %d (code %d)\n",
            (tree + idx)->parent - N, (tree + idx)->parent);
#line 528
    if ((tree + idx)->left < N) {
#line 528
      tmp = (char const   *)((ainfo->sqinfo + (tree + idx)->left)->name);
    } else {
#line 528
      tmp = "interior";
    }
#line 528
    if ((tree + idx)->left < N) {
#line 528
      tmp___0 = (tree + idx)->left - N;
    } else {
#line 528
      tmp___0 = (tree + idx)->left;
    }
#line 528
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tLeft:   %d (%s) %f\n",
            tmp___0, tmp, (double )(tree + idx)->lblen);
#line 532
    if ((tree + idx)->right < N) {
#line 532
      tmp___1 = (char const   *)((ainfo->sqinfo + (tree + idx)->right)->name);
    } else {
#line 532
      tmp___1 = "interior";
    }
#line 532
    if ((tree + idx)->right < N) {
#line 532
      tmp___2 = (tree + idx)->right - N;
    } else {
#line 532
      tmp___2 = (tree + idx)->right;
    }
#line 532
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tRight:   %d (%s) %f\n",
            tmp___2, tmp___1, (double )(tree + idx)->rblen);
#line 536
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tHeight:  %f\n",
            (double )(tree + idx)->diff);
#line 537
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tIncludes:%d seqs\n",
            (tree + idx)->incnum);
#line 524
    idx ++;
  }
#line 539
  return;
}
}
#line 1 "dayhoff.o"
#pragma merger("0","/tmp/cil-GKRkmk3L.i","")
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 63 "dayhoff.c"
int ParsePAMFile(FILE *fp , int ***ret_pam , float *ret_scale ) 
{ 
  int **pam ;
  char buffer___1[512] ;
  int order[27] ;
  int nsymbols ;
  char *sptr___0 ;
  int idx ;
  int row ;
  int col ;
  float scale ;
  int gotscale ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;
  double tmp___12 ;

  {
#line 74
  gotscale = 0;
#line 76
  scale = (float )0.0;
#line 77
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 77
    squid_errno = 2;
#line 77
    return (0);
  }
#line 83
  while (1) {
#line 84
    tmp = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 84
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 85
      squid_errno = 2;
#line 85
      return (0);
    }
#line 96
    tmp___6 = strstr((char const   *)(buffer___1), "BLOSUM Clustered Scoring Matrix");
#line 96
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 96
      sptr___0 = strchr((char const   *)(buffer___1), '/');
#line 96
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 99
        sptr___0 ++;
#line 100
        tmp___0 = __ctype_b_loc();
#line 100
        if (! ((int const   )*(*tmp___0 + (int )*sptr___0) & 2048)) {
#line 100
          squid_errno = 5;
#line 100
          return (0);
        }
#line 101
        tmp___1 = log(2.0);
#line 101
        tmp___2 = atof((char const   *)sptr___0);
#line 101
        scale = (float )(tmp___1 / tmp___2);
#line 102
        gotscale = 1;
      } else {
#line 96
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 104
      tmp___5 = strstr((char const   *)(buffer___1), "substitution matrix,");
#line 104
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 106
        while (1) {
#line 106
          sptr___0 = strrchr((char const   *)(buffer___1), '=');
#line 106
          if (! ((unsigned long )sptr___0 != (unsigned long )((void *)0))) {
#line 106
            break;
          }
#line 107
          sptr___0 += 2;
#line 108
          tmp___4 = IsReal(sptr___0);
#line 108
          if (tmp___4) {
#line 109
            tmp___3 = atof((char const   *)sptr___0);
#line 109
            scale = (float )tmp___3;
#line 110
            gotscale = 1;
#line 111
            break;
          }
        }
      }
    }
#line 83
    sptr___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 83
    if (! ((unsigned long )sptr___0 == (unsigned long )((void *)0))) {
#line 83
      if (! ((int )*sptr___0 == 35)) {
#line 83
        break;
      }
    }
  }
#line 117
  idx = 0;
#line 118
  while (1) {
#line 119
    order[idx] = (int )*sptr___0 - 65;
#line 120
    if (order[idx] < 0) {
#line 120
      order[idx] = 26;
    } else
#line 120
    if (order[idx] > 25) {
#line 120
      order[idx] = 26;
    }
#line 121
    idx ++;
#line 118
    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 118
    if (! ((unsigned long )sptr___0 != (unsigned long )((void *)0))) {
#line 118
      break;
    }
  }
#line 123
  nsymbols = idx;
#line 130
  tmp___7 = calloc((size_t )27, sizeof(int *));
#line 130
  pam = (int **)tmp___7;
#line 130
  if ((unsigned long )pam == (unsigned long )((void *)0)) {
#line 131
    Die((char *)"calloc failed");
  }
#line 132
  idx = 0;
#line 132
  while (idx < 27) {
#line 133
    tmp___9 = calloc((size_t )27, sizeof(int ));
#line 133
    tmp___8 = (int *)tmp___9;
#line 133
    *(pam + idx) = tmp___8;
#line 133
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 134
      Die((char *)"calloc failed");
    }
#line 132
    idx ++;
  }
#line 138
  row = 0;
#line 138
  while (row < nsymbols) {
#line 140
    tmp___10 = fgets((char * __restrict  )(buffer___1), 512, (FILE * __restrict  )fp);
#line 140
    if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 141
      squid_errno = 2;
#line 141
      return (0);
    }
#line 143
    sptr___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 143
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 144
      squid_errno = 2;
#line 144
      return (0);
    }
#line 145
    col = 0;
#line 145
    while (col < nsymbols) {
#line 147
      if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 147
        squid_errno = 2;
#line 147
        return (0);
      }
#line 151
      if ((int )*sptr___0 == 42) {
#line 152
        col --;
      } else {
#line 151
        tmp___11 = __ctype_b_loc();
#line 151
        if ((int const   )*(*tmp___11 + (int )*sptr___0) & 1024) {
#line 152
          col --;
        } else {
#line 154
          *(*(pam + order[row]) + order[col]) = atoi((char const   *)sptr___0);
        }
      }
#line 156
      sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 145
      col ++;
    }
#line 138
    row ++;
  }
#line 162
  if ((unsigned long )ret_scale != (unsigned long )((void *)0)) {
#line 164
    if (gotscale) {
#line 164
      *ret_scale = scale;
    } else {
#line 167
      Warn((char *)"Failed to parse PAM matrix scale factor. Defaulting to ln(2)/2!");
#line 168
      tmp___12 = log(2.0);
#line 168
      *ret_scale = (float )(tmp___12 / 2.0);
    }
  }
#line 171
  *ret_pam = pam;
#line 172
  return (1);
}
}
#line 1 "eps.o"
#pragma merger("0","/tmp/cil-9Cf6fPLM.i","")
#line 274 "./msa.h"
void EPSWriteSmallMSA(FILE *fp , MSA *msa ) ;
#line 42 "eps.c"
void EPSWriteSmallMSA(FILE *fp , MSA *msa ) 
{ 
  int namewidth ;
  int fontwidth ;
  int hspace ;
  int vspace ;
  char *font ;
  int fontsize ;
  int i___0 ;
  int j ;
  int len ;
  int width ;
  int height ;
  int xpos ;
  int ypos ;
  size_t tmp ;

  {
#line 60
  fontwidth = 8;
#line 61
  hspace = 9;
#line 62
  vspace = 15;
#line 63
  font = sre_strdup((char *)"Courier", -1);
#line 64
  fontsize = 12;
#line 68
  namewidth = 0;
#line 69
  i___0 = 0;
#line 69
  while (i___0 < msa->nseq) {
#line 70
    tmp = strlen((char const   *)*(msa->sqname + i___0));
#line 70
    len = (int )tmp;
#line 70
    if (len > namewidth) {
#line 71
      namewidth = len;
    }
#line 69
    i___0 ++;
  }
#line 72
  namewidth ++;
#line 73
  namewidth *= fontwidth;
#line 77
  if (msa->alen > 50) {
#line 77
    Die((char *)"No EPS fmt if alignment is >50 columns");
  }
#line 78
  width = namewidth + hspace * msa->alen;
#line 79
  if (width > 612) {
#line 79
    Die((char *)"Alignment too wide to write in EPS");
  }
#line 80
  height = vspace * msa->nseq;
#line 81
  if (height > 792) {
#line 81
    Die((char *)"Too many seqs to write in EPS");
  }
#line 85
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%%!PS-Adobe-3.0 EPSF-3.0\n");
#line 86
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%%%%BoundingBox: %d %d %d %d\n",
          0, 0, width, height);
#line 87
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%%%%Pages: 1\n");
#line 88
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%%%%EndComments\n");
#line 92
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"/%s findfont\n",
          font);
#line 93
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d scalefont\n",
          fontsize);
#line 94
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"setfont\n");
#line 95
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"newpath\n");
#line 99
  i___0 = 0;
#line 99
  while (i___0 < msa->nseq) {
#line 101
    ypos = ((msa->nseq - i___0) - 1) * vspace;
#line 103
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d moveto\n",
            0, ypos);
#line 104
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"(%s) show\n", *(msa->sqname + i___0));
#line 106
    xpos = namewidth;
#line 107
    j = 0;
#line 107
    while (j < msa->alen) {
#line 109
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d moveto\n",
              xpos, ypos);
#line 110
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"(%c) show\n",
              (int )*(*(msa->aseq + i___0) + j));
#line 111
      xpos += hspace;
#line 107
      j ++;
    }
#line 99
    i___0 ++;
  }
#line 115
  free((void *)font);
#line 116
  return;
}
}
#line 1 "file.o"
#pragma merger("0","/tmp/cil-JYYM7Y1c.i","")
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 76 "./sqfuncs.h"
char *FileDirname(char *file ) ;
#line 77
char *FileTail(char *file , int noextension ) ;
#line 78
char *FileSameDirectory(char *file1 , char *file2 ) ;
#line 80
char *FileAddSuffix(char *filename , char *sfx ) ;
#line 64 "file.c"
char *FileDirname(char *file ) 
{ 
  char *dirname ;
  char *lastslash ;
  int len ;
  void *tmp ;

  {
#line 71
  lastslash = strrchr((char const   *)file, '/');
#line 72
  if ((unsigned long )lastslash == (unsigned long )((void *)0)) {
#line 72
    len = 0;
  } else {
#line 72
    len = (int )(lastslash - file);
  }
#line 73
  tmp = sre_malloc((char *)"file.c", 73, sizeof(char ) * (unsigned long )(len + 2));
#line 73
  dirname = (char *)tmp;
#line 74
  if (len > 0) {
#line 74
    strncpy((char * __restrict  )dirname, (char const   * __restrict  )file, (size_t )len);
  } else
#line 75
  if ((int )*file != 47) {
#line 75
    *dirname = (char )'.';
#line 75
    len = 1;
  } else {
#line 76
    *dirname = (char )'/';
#line 76
    len = 1;
  }
#line 77
  *(dirname + len) = (char )'\000';
#line 78
  return (dirname);
}
}
#line 97 "file.c"
char *FileTail(char *file , int noextension ) 
{ 
  char *tail ;
  char *lastslash ;
  char *lastdot ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 104
  lastslash = strrchr((char const   *)file, '/');
#line 105
  tmp = strlen((char const   *)file);
#line 105
  tmp___0 = sre_malloc((char *)"file.c", 105, sizeof(char ) * (tmp + 1UL));
#line 105
  tail = (char *)tmp___0;
#line 106
  if ((unsigned long )lastslash == (unsigned long )((void *)0)) {
#line 106
    strcpy((char * __restrict  )tail, (char const   * __restrict  )file);
  } else {
#line 107
    strcpy((char * __restrict  )tail, (char const   * __restrict  )(lastslash + 1));
  }
#line 109
  if (noextension) {
#line 110
    lastdot = strrchr((char const   *)tail, '.');
#line 110
    if ((unsigned long )lastdot != (unsigned long )((void *)0)) {
#line 111
      *lastdot = (char )'\000';
    }
  }
#line 114
  return (tail);
}
}
#line 138 "file.c"
char *FileSameDirectory(char *file1 , char *file2 ) 
{ 
  char *path ;
  char *tail ;
  char *result ;
  int seems_ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 144
  seems_ok = 1;
#line 146
  path = FileDirname(file1);
#line 147
  tail = FileTail(file2, 0);
#line 148
  tmp = strcmp((char const   *)file2, (char const   *)tail);
#line 148
  if (tmp != 0) {
#line 148
    seems_ok = 0;
  }
#line 149
  result = FileConcat(path, tail);
#line 150
  if (! seems_ok) {
#line 150
    tmp___0 = strcmp((char const   *)result, (char const   *)file2);
#line 150
    if (tmp___0 != 0) {
#line 151
      free((void *)result);
#line 151
      result = (char *)((void *)0);
    }
  }
#line 153
  free((void *)path);
#line 154
  free((void *)tail);
#line 155
  return (result);
}
}
#line 165 "file.c"
char *FileConcat(char *dir , char *file ) 
{ 
  char *full ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 170
  tmp = strlen((char const   *)dir);
#line 170
  tmp___0 = strlen((char const   *)file);
#line 170
  tmp___1 = sre_malloc((char *)"file.c", 170, sizeof(char ) * ((tmp + tmp___0) + 2UL));
#line 170
  full = (char *)tmp___1;
#line 171
  if ((int )*file == 47) {
#line 171
    strcpy((char * __restrict  )full, (char const   * __restrict  )file);
  } else {
#line 172
    sprintf((char * __restrict  )full, (char const   * __restrict  )"%s%c%s", dir,
            '/', file);
  }
#line 173
  return (full);
}
}
#line 186 "file.c"
char *FileAddSuffix(char *filename , char *sfx ) 
{ 
  char *new ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 190
  tmp = strlen((char const   *)filename);
#line 190
  tmp___0 = strlen((char const   *)sfx);
#line 190
  tmp___1 = sre_malloc((char *)"file.c", 190, (tmp + tmp___0) + 2UL);
#line 190
  new = (char *)tmp___1;
#line 191
  sprintf((char * __restrict  )new, (char const   * __restrict  )"%s.%s", filename,
          sfx);
#line 192
  return (new);
}
}
#line 229 "file.c"
FILE *EnvFileOpen(char *fname , char *env , char **ret_dir ) 
{ 
  FILE *fp ;
  char *path ;
  char *s___0 ;
  char full[1024] ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 237
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 237
    return ((FILE *)((void *)0));
  }
#line 238
  tmp = getenv((char const   *)env);
#line 238
  path = Strdup(tmp);
#line 238
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 238
    return ((FILE *)((void *)0));
  }
#line 240
  fp = (FILE *)((void *)0);
#line 241
  s___0 = strtok((char * __restrict  )path, (char const   * __restrict  )":");
#line 242
  while ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 244
    tmp___0 = strlen((char const   *)fname);
#line 244
    tmp___1 = strlen((char const   *)s___0);
#line 244
    if (((int )tmp___0 + (int )tmp___1) + 2 > 1024) {
#line 245
      free((void *)path);
#line 245
      return ((FILE *)((void *)0));
    }
#line 246
    sprintf((char * __restrict  )(full), (char const   * __restrict  )"%s%c%s", s___0,
            '/', fname);
#line 247
    fp = fopen((char const   * __restrict  )(full), (char const   * __restrict  )"r");
#line 247
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 247
      break;
    }
#line 248
    s___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )":");
  }
#line 253
  if ((unsigned long )ret_dir != (unsigned long )((void *)0)) {
#line 253
    *ret_dir = Strdup(s___0);
  }
#line 254
  free((void *)path);
#line 256
  return (fp);
}
}
#line 266 "file.c"
int FileExists(char *filename ) 
{ 
  FILE *fp ;

  {
#line 270
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 270
  if (fp) {
#line 270
    fclose(fp);
#line 270
    return (1);
  }
#line 271
  return (0);
}
}
#line 1 "getopt.o"
#pragma merger("0","/tmp/cil-0C00AKb3.i","")
#line 66 "getopt.c"
static int optind___0  =    1;
#line 67 "getopt.c"
static char *optptr  =    (char *)((void *)0);
#line 59 "getopt.c"
int Getopt(int argc , char **argv , struct opt_s *opt , int nopts , char *usage___1 ,
           int *ret_optind , char **ret_optname , char **ret_optarg ) 
{ 
  int i___0 ;
  int arglen ;
  int nmatch ;
  int opti ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 68
  opti = 0;
#line 74
  if (optind___0 >= argc) {
#line 76
    *ret_optind = optind___0;
#line 77
    *ret_optarg = (char *)((void *)0);
#line 78
    *ret_optname = (char *)((void *)0);
#line 79
    return (0);
  } else
#line 74
  if ((int )*(*(argv + optind___0) + 0) != 45) {
#line 76
    *ret_optind = optind___0;
#line 77
    *ret_optarg = (char *)((void *)0);
#line 78
    *ret_optname = (char *)((void *)0);
#line 79
    return (0);
  } else {
#line 74
    tmp = strcmp((char const   *)*(argv + optind___0), "-");
#line 74
    if (tmp == 0) {
#line 76
      *ret_optind = optind___0;
#line 77
      *ret_optarg = (char *)((void *)0);
#line 78
      *ret_optname = (char *)((void *)0);
#line 79
      return (0);
    }
  }
#line 85
  tmp___0 = strcmp((char const   *)*(argv + optind___0), "--");
#line 85
  if (tmp___0 == 0) {
#line 87
    optind___0 ++;
#line 88
    *ret_optind = optind___0;
#line 89
    *ret_optname = (char *)((void *)0);
#line 90
    *ret_optarg = (char *)((void *)0);
#line 91
    return (0);
  }
#line 101
  if ((unsigned long )optptr == (unsigned long )((void *)0)) {
#line 101
    tmp___5 = strncmp((char const   *)*(argv + optind___0), "--", (size_t )2);
#line 101
    if (tmp___5 == 0) {
#line 105
      optptr = strchr((char const   *)*(argv + optind___0), '=');
#line 105
      if ((unsigned long )optptr != (unsigned long )((void *)0)) {
#line 106
        *optptr = (char )'\000';
#line 106
        optptr ++;
      }
#line 108
      tmp___1 = strlen((char const   *)*(argv + optind___0));
#line 108
      arglen = (int )tmp___1;
#line 109
      nmatch = 0;
#line 110
      i___0 = 0;
#line 110
      while (i___0 < nopts) {
#line 111
        if ((opt + i___0)->single == 0) {
#line 111
          tmp___3 = strncmp((char const   *)(opt + i___0)->name, (char const   *)*(argv + optind___0),
                            (size_t )arglen);
#line 111
          if (tmp___3 == 0) {
#line 114
            nmatch ++;
#line 115
            opti = i___0;
#line 116
            tmp___2 = strlen((char const   *)(opt + i___0)->name);
#line 116
            if ((size_t )arglen == tmp___2) {
#line 116
              break;
            }
          }
        }
#line 110
        i___0 ++;
      }
#line 118
      if (nmatch > 1) {
#line 118
        tmp___4 = strlen((char const   *)(opt + i___0)->name);
#line 118
        if ((size_t )arglen != tmp___4) {
#line 119
          Die((char *)"Option \"%s\" is ambiguous; please be more specific.\n%s",
              *(argv + optind___0), usage___1);
        }
      }
#line 121
      if (nmatch == 0) {
#line 122
        Die((char *)"No such option \"%s\".\n%s", *(argv + optind___0), usage___1);
      }
#line 124
      *ret_optname = (opt + opti)->name;
#line 128
      if ((opt + opti)->argtype != 0) {
#line 130
        if ((unsigned long )optptr != (unsigned long )((void *)0)) {
#line 132
          *ret_optarg = optptr;
#line 133
          optptr = (char *)((void *)0);
#line 134
          optind___0 ++;
        } else
#line 136
        if (optind___0 + 1 >= argc) {
#line 137
          Die((char *)"Option %s requires an argument\n%s", (opt + opti)->name, usage___1);
        } else {
#line 140
          *ret_optarg = *(argv + (optind___0 + 1));
#line 141
          optind___0 += 2;
        }
      } else {
#line 146
        if ((unsigned long )optptr != (unsigned long )((void *)0)) {
#line 147
          Die((char *)"Option %s does not take an argument\n%s", (opt + opti)->name,
              usage___1);
        }
#line 148
        *ret_optarg = (char *)((void *)0);
#line 149
        optind___0 ++;
      }
    } else {
#line 101
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 155
    if ((unsigned long )optptr == (unsigned long )((void *)0)) {
#line 156
      optptr = *(argv + optind___0) + 1;
    }
#line 157
    opti = -1;
#line 157
    i___0 = 0;
#line 157
    while (i___0 < nopts) {
#line 158
      if ((opt + i___0)->single == 1) {
#line 158
        if ((int )*optptr == (int )*((opt + i___0)->name + 1)) {
#line 159
          opti = i___0;
#line 159
          break;
        }
      }
#line 157
      i___0 ++;
    }
#line 160
    if (opti == -1) {
#line 161
      Die((char *)"No such option \"%c\".\n%s", (int )*optptr, usage___1);
    }
#line 162
    *ret_optname = (opt + opti)->name;
#line 165
    if ((opt + opti)->argtype != 0) {
#line 167
      if ((int )*(optptr + 1) != 0) {
#line 169
        *ret_optarg = optptr + 1;
#line 170
        optind___0 ++;
      } else
#line 172
      if (optind___0 + 1 < argc) {
#line 174
        *ret_optarg = *(argv + (optind___0 + 1));
#line 175
        optind___0 += 2;
      } else {
#line 177
        Die((char *)"Option %s requires an argument\n%s", (opt + opti)->name, usage___1);
      }
#line 179
      optptr = (char *)((void *)0);
    } else {
#line 183
      *ret_optarg = (char *)((void *)0);
#line 184
      if ((int )*(optptr + 1) != 0) {
#line 185
        optptr ++;
      } else {
#line 188
        optind___0 ++;
#line 189
        optptr = (char *)((void *)0);
      }
    }
  }
#line 197
  if ((opt + opti)->argtype != 0) {
#line 199
    if ((opt + opti)->argtype == 1) {
#line 199
      tmp___8 = IsInt(*ret_optarg);
#line 199
      if (tmp___8) {
#line 199
        goto _L___1;
      } else {
#line 200
        Die((char *)"Option %s requires an integer argument\n%s", (opt + opti)->name,
            usage___1);
      }
    } else
    _L___1: /* CIL Label */ 
#line 202
    if ((opt + opti)->argtype == 2) {
#line 202
      tmp___7 = IsReal(*ret_optarg);
#line 202
      if (tmp___7) {
#line 202
        goto _L___0;
      } else {
#line 203
        Die((char *)"Option %s requires a numerical argument\n%s", (opt + opti)->name,
            usage___1);
      }
    } else
    _L___0: /* CIL Label */ 
#line 205
    if ((opt + opti)->argtype == 3) {
#line 205
      tmp___6 = strlen((char const   *)*ret_optarg);
#line 205
      if (tmp___6 != 1UL) {
#line 206
        Die((char *)"Option %s requires a single-character argument\n%s", (opt + opti)->name,
            usage___1);
      }
    }
  }
#line 211
  *ret_optind = optind___0;
#line 212
  return (1);
}
}
#line 1 "gki.o"
#pragma merger("0","/tmp/cil-XkWVWdLM.i","")
#line 44 "./gki.h"
GKI *GKIInit(void) ;
#line 45
void GKIFree(GKI *hash ) ;
#line 48
int GKIKeyIndex(GKI *hash , char *key ) ;
#line 49
void GKIStatus(GKI *hash ) ;
#line 96 "gki.c"
static int gki_primes[4]  = {      101,      1009,      10007,      100003};
#line 100
static GKI *gki_alloc(int primelevel ) ;
#line 101
static int gki_hashvalue(GKI *hash , char *key ) ;
#line 102
static int gki_upsize(GKI *old ) ;
#line 116 "gki.c"
GKI *GKIInit(void) 
{ 
  GKI *hash ;

  {
#line 120
  hash = gki_alloc(0);
#line 121
  return (hash);
}
}
#line 134 "gki.c"
void GKIFree(GKI *hash ) 
{ 
  struct gki_elem *ptr ;
  int i___0 ;

  {
#line 140
  if ((unsigned long )hash == (unsigned long )((void *)0)) {
#line 140
    return;
  }
#line 142
  i___0 = 0;
#line 142
  while (i___0 < hash->nhash) {
#line 143
    while ((unsigned long )*(hash->table + i___0) != (unsigned long )((void *)0)) {
#line 145
      ptr = (*(hash->table + i___0))->nxt;
#line 147
      if ((unsigned long )(*(hash->table + i___0))->key != (unsigned long )((void *)0)) {
#line 147
        free((void *)(*(hash->table + i___0))->key);
      }
#line 148
      free((void *)*(hash->table + i___0));
#line 149
      *(hash->table + i___0) = ptr;
    }
#line 142
    i___0 ++;
  }
#line 151
  free((void *)hash->table);
#line 152
  free((void *)hash);
#line 153
  return;
}
}
#line 180 "gki.c"
int GKIStoreKey(GKI *hash , char *key ) 
{ 
  int val ;
  struct gki_elem *ptr ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 186
  val = gki_hashvalue(hash, key);
#line 188
  ptr = *(hash->table + val);
#line 189
  tmp = sre_malloc((char *)"gki.c", 189, sizeof(struct gki_elem ));
#line 189
  *(hash->table + val) = (struct gki_elem *)tmp;
#line 190
  tmp___0 = strlen((char const   *)key);
#line 190
  tmp___1 = sre_malloc((char *)"gki.c", 190, sizeof(char ) * (tmp___0 + 1UL));
#line 190
  (*(hash->table + val))->key = (char *)tmp___1;
#line 191
  strcpy((char * __restrict  )(*(hash->table + val))->key, (char const   * __restrict  )key);
#line 193
  (*(hash->table + val))->idx = hash->nkeys;
#line 194
  (*(hash->table + val))->nxt = ptr;
#line 196
  (hash->nkeys) ++;
#line 198
  if (hash->nkeys > 3 * hash->nhash) {
#line 198
    if (hash->primelevel < 3) {
#line 199
      gki_upsize(hash);
    }
  }
#line 201
  return (hash->nkeys - 1);
}
}
#line 218 "gki.c"
int GKIKeyIndex(GKI *hash , char *key ) 
{ 
  struct gki_elem *ptr ;
  int val ;
  int tmp ;

  {
#line 224
  val = gki_hashvalue(hash, key);
#line 225
  ptr = *(hash->table + val);
#line 225
  while ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 226
    tmp = strcmp((char const   *)key, (char const   *)ptr->key);
#line 226
    if (tmp == 0) {
#line 226
      return (ptr->idx);
    }
#line 225
    ptr = ptr->nxt;
  }
#line 227
  return (-1);
}
}
#line 242 "gki.c"
void GKIStatus(GKI *hash ) 
{ 
  struct gki_elem *ptr ;
  int i___0 ;
  int nkeys ;
  int nempty ;
  int maxkeys ;
  int minkeys ;

  {
#line 248
  nempty = 0;
#line 249
  maxkeys = -1;
#line 250
  minkeys = 2147483647;
#line 252
  i___0 = 0;
#line 252
  while (i___0 < hash->nhash) {
#line 254
    nkeys = 0;
#line 255
    ptr = *(hash->table + i___0);
#line 255
    while ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 256
      nkeys ++;
#line 255
      ptr = ptr->nxt;
    }
#line 258
    if (nkeys == 0) {
#line 258
      nempty ++;
    }
#line 259
    if (nkeys > maxkeys) {
#line 259
      maxkeys = nkeys;
    }
#line 260
    if (nkeys < minkeys) {
#line 260
      minkeys = nkeys;
    }
#line 252
    i___0 ++;
  }
#line 263
  printf((char const   * __restrict  )"Total keys:        %d\n", hash->nkeys);
#line 264
  printf((char const   * __restrict  )"Hash table size:   %d\n", hash->nhash);
#line 265
  printf((char const   * __restrict  )"Average occupancy: %.1f\n", (double )((float )hash->nkeys / (float )hash->nhash));
#line 266
  printf((char const   * __restrict  )"Unoccupied slots:  %d\n", nempty);
#line 267
  printf((char const   * __restrict  )"Most in one slot:  %d\n", maxkeys);
#line 268
  printf((char const   * __restrict  )"Least in one slot: %d\n", minkeys);
#line 270
  return;
}
}
#line 286 "gki.c"
static GKI *gki_alloc(int primelevel ) 
{ 
  GKI *hash ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 292
  if (primelevel < 0) {
#line 293
    Die((char *)"bad primelevel in gki_alloc()");
  } else
#line 292
  if (primelevel >= 4) {
#line 293
    Die((char *)"bad primelevel in gki_alloc()");
  }
#line 294
  tmp = sre_malloc((char *)"gki.c", 294, sizeof(GKI ));
#line 294
  hash = (GKI *)tmp;
#line 296
  hash->primelevel = primelevel;
#line 297
  hash->nhash = gki_primes[hash->primelevel];
#line 298
  tmp___0 = sre_malloc((char *)"gki.c", 298, sizeof(struct gki_elem ) * (unsigned long )hash->nhash);
#line 298
  hash->table = (struct gki_elem **)tmp___0;
#line 299
  i___0 = 0;
#line 299
  while (i___0 < hash->nhash) {
#line 300
    *(hash->table + i___0) = (struct gki_elem *)((void *)0);
#line 299
    i___0 ++;
  }
#line 301
  hash->nkeys = 0;
#line 302
  return (hash);
}
}
#line 324 "gki.c"
static int gki_hashvalue(GKI *hash , char *key ) 
{ 
  int val ;

  {
#line 327
  val = 0;
#line 329
  while ((int )*key != 0) {
#line 331
    val = 128 * val + (int )*key;
#line 332
    key ++;
#line 332
    if ((int )*key == 0) {
#line 332
      val %= hash->nhash;
#line 332
      break;
    }
#line 333
    val = (128 * val + (int )*key) % hash->nhash;
#line 329
    key ++;
  }
#line 335
  return (val);
}
}
#line 349 "gki.c"
static int gki_upsize(GKI *old ) 
{ 
  GKI *new ;
  int i___0 ;
  struct gki_elem *optr ;
  struct gki_elem *nptr ;
  int val ;

  {
#line 358
  if (old->primelevel >= 3) {
#line 358
    return (0);
  }
#line 359
  new = gki_alloc(old->primelevel + 1);
#line 366
  i___0 = 0;
#line 366
  while (i___0 < old->nhash) {
#line 368
    optr = *(old->table + i___0);
#line 369
    while ((unsigned long )optr != (unsigned long )((void *)0)) {
#line 371
      val = gki_hashvalue(new, optr->key);
#line 373
      nptr = *(new->table + val);
#line 374
      *(new->table + val) = optr;
#line 375
      optr = optr->nxt;
#line 376
      (*(new->table + val))->nxt = nptr;
    }
#line 366
    i___0 ++;
  }
#line 379
  free((void *)old->table);
#line 385
  old->primelevel = new->primelevel;
#line 386
  old->nhash = new->nhash;
#line 387
  old->table = new->table;
#line 388
  free((void *)new);
#line 389
  return (1);
}
}
#line 1 "gsi.o"
#pragma merger("0","/tmp/cil-6EOKTnX8.i","")
#line 253 "./sqfuncs.h"
sqd_uint16 sre_ntoh16(sqd_uint16 netshort ) ;
#line 254
sqd_uint32 sre_ntoh32(sqd_uint32 netlong ) ;
#line 255
sqd_uint16 sre_hton16(sqd_uint16 hostshort ) ;
#line 256
sqd_uint32 sre_hton32(sqd_uint32 hostlong ) ;
#line 70 "./gsi.h"
GSIFILE *GSIOpen(char *gsifile ) ;
#line 71
int GSIGetRecord(GSIFILE *gsi , char *f1 , sqd_uint16 *f2 , sqd_uint32 *f3 ) ;
#line 72
int GSIGetOffset(GSIFILE *gsi , char *key , char *ret_seqfile , int *ret_format ,
                 long *ret_offset ) ;
#line 74
void GSIClose(GSIFILE *gsi ) ;
#line 75
struct gsiindex_s *GSIAllocIndex(void) ;
#line 76
void GSIFreeIndex(struct gsiindex_s *g ) ;
#line 77
void GSIAddFileToIndex(struct gsiindex_s *g , char *filename , int fmt ) ;
#line 78
void GSIAddKeyToIndex(struct gsiindex_s *g , char *key , int filenum , long offset ) ;
#line 79
void GSISortIndex(struct gsiindex_s *g ) ;
#line 80
void GSIWriteIndex(FILE *fp , struct gsiindex_s *g ) ;
#line 81
void GSIWriteHeader(FILE *fp , int nfiles , long nkeys ) ;
#line 82
int GSIWriteFileRecord(FILE *fp , char *fname , int idx , int fmt ) ;
#line 83
int GSIWriteKeyRecord(FILE *fp , char *key , int fileidx , long offset ) ;
#line 52 "gsi.c"
GSIFILE *GSIOpen(char *gsifile ) 
{ 
  GSIFILE *gsi ;
  char magic[32] ;
  void *tmp ;
  FILE *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 58
  tmp = sre_malloc((char *)"gsi.c", 58, sizeof(GSIFILE ));
#line 58
  gsi = (GSIFILE *)tmp;
#line 59
  tmp___0 = fopen((char const   * __restrict  )gsifile, (char const   * __restrict  )"r");
#line 59
  gsi->gsifp = tmp___0;
#line 59
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 60
    free((void *)gsi);
#line 60
    squid_errno = 4;
#line 60
    return ((GSIFILE *)((void *)0));
  }
#line 62
  tmp___1 = fread((void * __restrict  )(magic), sizeof(char ), (size_t )32, (FILE * __restrict  )gsi->gsifp);
#line 62
  if (! tmp___1) {
#line 63
    free((void *)gsi);
#line 63
    squid_errno = 2;
#line 63
    return ((GSIFILE *)((void *)0));
  }
#line 64
  tmp___2 = strcmp((char const   *)(magic), "GSI");
#line 64
  if (tmp___2 != 0) {
#line 65
    free((void *)gsi);
#line 65
    squid_errno = 5;
#line 65
    return ((GSIFILE *)((void *)0));
  }
#line 67
  tmp___3 = fread((void * __restrict  )(& gsi->nfiles), sizeof(sqd_uint16 ), (size_t )1,
                  (FILE * __restrict  )gsi->gsifp);
#line 67
  if (! tmp___3) {
#line 68
    free((void *)gsi);
#line 68
    squid_errno = 2;
#line 68
    return ((GSIFILE *)((void *)0));
  }
#line 69
  tmp___4 = fread((void * __restrict  )(& gsi->recnum), sizeof(sqd_uint32 ), (size_t )1,
                  (FILE * __restrict  )gsi->gsifp);
#line 69
  if (! tmp___4) {
#line 70
    free((void *)gsi);
#line 70
    squid_errno = 2;
#line 70
    return ((GSIFILE *)((void *)0));
  }
#line 72
  gsi->nfiles = sre_ntoh16(gsi->nfiles);
#line 73
  gsi->recnum = sre_ntoh32(gsi->recnum);
#line 75
  return (gsi);
}
}
#line 92 "gsi.c"
int GSIGetRecord(GSIFILE *gsi , char *f1 , sqd_uint16 *f2 , sqd_uint32 *f3 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 95
  if ((unsigned long )f1 == (unsigned long )((void *)0)) {
#line 95
    fseek(gsi->gsifp, 32L, 1);
  } else {
#line 96
    tmp = fread((void * __restrict  )f1, (size_t )32, (size_t )1, (FILE * __restrict  )gsi->gsifp);
#line 96
    if (! tmp) {
#line 97
      squid_errno = 2;
#line 97
      return (0);
    }
  }
#line 99
  if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 99
    fseek(gsi->gsifp, (long )sizeof(sqd_uint16 ), 1);
  } else {
#line 100
    tmp___0 = fread((void * __restrict  )f2, sizeof(sqd_uint16 ), (size_t )1, (FILE * __restrict  )gsi->gsifp);
#line 100
    if (! tmp___0) {
#line 101
      squid_errno = 2;
#line 101
      return (0);
    }
  }
#line 103
  if ((unsigned long )f3 == (unsigned long )((void *)0)) {
#line 103
    fseek(gsi->gsifp, (long )sizeof(sqd_uint32 ), 1);
  } else {
#line 104
    tmp___1 = fread((void * __restrict  )f3, sizeof(sqd_uint32 ), (size_t )1, (FILE * __restrict  )gsi->gsifp);
#line 104
    if (! tmp___1) {
#line 105
      squid_errno = 2;
#line 105
      return (0);
    }
  }
#line 107
  if ((unsigned long )f2 != (unsigned long )((void *)0)) {
#line 107
    *f2 = sre_ntoh16(*f2);
  }
#line 108
  if ((unsigned long )f3 != (unsigned long )((void *)0)) {
#line 108
    *f3 = sre_ntoh32(*f3);
  }
#line 110
  return (1);
}
}
#line 127 "gsi.c"
int GSIGetOffset(GSIFILE *gsi , char *key , char *ret_seqfile , int *ret_format ,
                 long *ret_offset ) 
{ 
  sqd_uint32 left ;
  sqd_uint32 right ;
  sqd_uint32 mid ;
  int cmp ;
  char name[33] ;
  sqd_uint32 offset ;
  sqd_uint16 filenum ;
  sqd_uint32 fmt ;
  int tmp ;

  {
#line 138
  name[32] = (char )'\000';
#line 140
  left = (sqd_uint32 )((int )gsi->nfiles + 1);
#line 141
  right = (sqd_uint32 )gsi->nfiles + gsi->recnum;
#line 142
  mid = (left + right) / 2U;
#line 143
  fseek(gsi->gsifp, (long )(mid * 38U), 0);
#line 145
  while (1) {
#line 145
    tmp = GSIGetRecord(gsi, name, & filenum, & offset);
#line 145
    if (! tmp) {
#line 145
      break;
    }
#line 147
    cmp = strcmp((char const   *)(name), (char const   *)key);
#line 148
    if (cmp == 0) {
#line 148
      break;
    } else
#line 149
    if (left >= right) {
#line 149
      return (0);
    } else
#line 150
    if (cmp < 0) {
#line 150
      left = mid + 1U;
    } else
#line 151
    if (cmp > 0) {
#line 151
      right = mid - 1U;
    }
#line 152
    mid = (left + right) / 2U;
#line 153
    fseek(gsi->gsifp, (long )(mid * 38U), 0);
  }
#line 158
  fseek(gsi->gsifp, (long )((int )filenum * 38), 0);
#line 159
  GSIGetRecord(gsi, ret_seqfile, (sqd_uint16 *)((void *)0), & fmt);
#line 160
  *ret_format = (int )fmt;
#line 161
  *ret_offset = (long )offset;
#line 163
  return (1);
}
}
#line 170 "gsi.c"
void GSIClose(GSIFILE *gsi ) 
{ 


  {
#line 173
  fclose(gsi->gsifp);
#line 174
  free((void *)gsi);
#line 175
  return;
}
}
#line 195 "gsi.c"
struct gsiindex_s *GSIAllocIndex(void) 
{ 
  struct gsiindex_s *g ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 200
  tmp = sre_malloc((char *)"gsi.c", 200, sizeof(struct gsiindex_s ));
#line 200
  g = (struct gsiindex_s *)tmp;
#line 201
  tmp___0 = sre_malloc((char *)"gsi.c", 201, sizeof(char *) * 10UL);
#line 201
  g->filenames = (char **)tmp___0;
#line 202
  tmp___1 = sre_malloc((char *)"gsi.c", 202, sizeof(int ) * 10UL);
#line 202
  g->fmt = (int *)tmp___1;
#line 203
  tmp___2 = sre_malloc((char *)"gsi.c", 203, sizeof(struct gsikey_s ) * 100UL);
#line 203
  g->elems = (struct gsikey_s *)tmp___2;
#line 204
  g->nfiles = (sqd_uint16 )0;
#line 205
  g->nkeys = 0;
#line 206
  return (g);
}
}
#line 208 "gsi.c"
void GSIFreeIndex(struct gsiindex_s *g ) 
{ 
  int i___0 ;

  {
#line 212
  i___0 = 0;
#line 212
  while (i___0 < (int )g->nfiles) {
#line 212
    free((void *)*(g->filenames + i___0));
#line 212
    i___0 ++;
  }
#line 213
  free((void *)g->filenames);
#line 214
  free((void *)g->fmt);
#line 215
  free((void *)g->elems);
#line 216
  free((void *)g);
#line 217
  return;
}
}
#line 218 "gsi.c"
void GSIAddFileToIndex(struct gsiindex_s *g , char *filename , int fmt ) 
{ 
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 223
  tmp = strlen((char const   *)filename);
#line 223
  len = (int )tmp;
#line 224
  if (len >= 32) {
#line 224
    Die((char *)"File name too long to be indexed.");
  }
#line 225
  *(g->filenames + g->nfiles) = sre_strdup(filename, len);
#line 226
  *(g->fmt + g->nfiles) = fmt;
#line 227
  g->nfiles = (sqd_uint16 )((int )g->nfiles + 1);
#line 228
  if ((int )g->nfiles % 10 == 0) {
#line 229
    tmp___0 = sre_realloc((char *)"gsi.c", 229, (void *)g->filenames, sizeof(char *) * (unsigned long )((int )g->nfiles + 10));
#line 229
    g->filenames = (char **)tmp___0;
#line 230
    tmp___1 = sre_realloc((char *)"gsi.c", 230, (void *)g->fmt, sizeof(int ) * (unsigned long )((int )g->nfiles + 10));
#line 230
    g->fmt = (int *)tmp___1;
  }
#line 232
  return;
}
}
#line 233 "gsi.c"
void GSIAddKeyToIndex(struct gsiindex_s *g , char *key , int filenum , long offset ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 236
  tmp = strlen((char const   *)key);
#line 236
  if (tmp >= 32UL) {
#line 236
    Die((char *)"key too long in GSI index");
  }
#line 237
  if (filenum > 65535) {
#line 237
    Die((char *)"too many files in GSI index");
  }
#line 238
  if (offset > 4294967295L) {
#line 238
    Die((char *)"offset too big in GSI index");
  }
#line 240
  strncpy((char * __restrict  )((g->elems + g->nkeys)->key), (char const   * __restrict  )key,
          (size_t )31);
#line 241
  (g->elems + g->nkeys)->key[31] = (char )'\000';
#line 242
  (g->elems + g->nkeys)->filenum = (sqd_uint16 )filenum;
#line 243
  (g->elems + g->nkeys)->offset = (sqd_uint32 )offset;
#line 244
  (g->nkeys) ++;
#line 246
  if (g->nkeys % 100 == 0) {
#line 247
    tmp___0 = sre_realloc((char *)"gsi.c", 247, (void *)g->elems, sizeof(struct gsikey_s ) * (unsigned long )(g->nkeys + 100));
#line 247
    g->elems = (struct gsikey_s *)tmp___0;
  }
#line 248
  return;
}
}
#line 249 "gsi.c"
static int gsi_keysorter(void const   *k1 , void const   *k2 ) 
{ 
  struct gsikey_s *key1 ;
  struct gsikey_s *key2 ;
  int tmp ;

  {
#line 254
  key1 = (struct gsikey_s *)k1;
#line 255
  key2 = (struct gsikey_s *)k2;
#line 256
  tmp = strcmp((char const   *)(key1->key), (char const   *)(key2->key));
#line 256
  return (tmp);
}
}
#line 258 "gsi.c"
void GSISortIndex(struct gsiindex_s *g ) 
{ 


  {
#line 261
  specqsort((void *)g->elems, g->nkeys, sizeof(struct gsikey_s ), & gsi_keysorter);
#line 262
  return;
}
}
#line 263 "gsi.c"
void GSIWriteIndex(FILE *fp , struct gsiindex_s *g ) 
{ 
  sqd_uint32 i___0 ;

  {
#line 270
  if ((int )g->nfiles > 65535) {
#line 270
    Die((char *)"Too many files in GSI index.");
  }
#line 271
  if ((unsigned int )g->nkeys > 4294967295U) {
#line 271
    Die((char *)"Too many keys in GSI index.");
  }
#line 273
  GSIWriteHeader(fp, (int )g->nfiles, (long )g->nkeys);
#line 274
  i___0 = (sqd_uint32 )0;
#line 274
  while (i___0 < (sqd_uint32 )g->nfiles) {
#line 275
    GSIWriteFileRecord(fp, *(g->filenames + i___0), (int )(i___0 + 1U), *(g->fmt + i___0));
#line 274
    i___0 ++;
  }
#line 276
  i___0 = (sqd_uint32 )0;
#line 276
  while (i___0 < (sqd_uint32 )g->nkeys) {
#line 277
    GSIWriteKeyRecord(fp, (g->elems + i___0)->key, (int )(g->elems + i___0)->filenum,
                      (long )(g->elems + i___0)->offset);
#line 276
    i___0 ++;
  }
#line 278
  return;
}
}
#line 296 "gsi.c"
void GSIWriteHeader(FILE *fp , int nfiles , long nkeys ) 
{ 
  char key[32] ;
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 305
  if (nfiles > 65535) {
#line 305
    Die((char *)"GSI: nfiles out of range");
  }
#line 306
  if (nkeys > 4294967295L) {
#line 306
    Die((char *)"GSI: nkeys out of range");
  }
#line 308
  f1 = (sqd_uint16 )nfiles;
#line 309
  f2 = (sqd_uint32 )nkeys;
#line 310
  f1 = sre_hton16(f1);
#line 311
  f2 = sre_hton32(f2);
#line 312
  strcpy((char * __restrict  )(key), (char const   * __restrict  )"GSI");
#line 314
  tmp = fwrite((void const   * __restrict  )(key), (size_t )1, (size_t )32, (FILE * __restrict  )fp);
#line 314
  if (tmp < 32UL) {
#line 314
    Panic((char *)"gsi.c", 314);
  }
#line 315
  tmp___0 = fwrite((void const   * __restrict  )(& f1), (size_t )2, (size_t )1, (FILE * __restrict  )fp);
#line 315
  if (tmp___0 < 1UL) {
#line 315
    Panic((char *)"gsi.c", 315);
  }
#line 316
  tmp___1 = fwrite((void const   * __restrict  )(& f2), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
#line 316
  if (tmp___1 < 1UL) {
#line 316
    Panic((char *)"gsi.c", 316);
  }
#line 317
  return;
}
}
#line 332 "gsi.c"
int GSIWriteFileRecord(FILE *fp , char *fname , int idx , int fmt ) 
{ 
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 338
  tmp = strlen((char const   *)fname);
#line 338
  if (tmp >= 32UL) {
#line 338
    return (0);
  }
#line 339
  if (idx > 65535) {
#line 339
    Die((char *)"GSI: file index out of range");
  }
#line 340
  if ((unsigned int )fmt > 4294967295U) {
#line 340
    Die((char *)"GSI: format index out of range");
  }
#line 342
  f1 = (sqd_uint16 )idx;
#line 343
  f2 = (sqd_uint32 )fmt;
#line 344
  f1 = sre_hton16(f1);
#line 345
  f2 = sre_hton32(f2);
#line 347
  tmp___0 = fwrite((void const   * __restrict  )fname, (size_t )1, (size_t )32, (FILE * __restrict  )fp);
#line 347
  if (tmp___0 < 32UL) {
#line 347
    Panic((char *)"gsi.c", 347);
  }
#line 348
  tmp___1 = fwrite((void const   * __restrict  )(& f1), (size_t )2, (size_t )1, (FILE * __restrict  )fp);
#line 348
  if (tmp___1 < 1UL) {
#line 348
    Panic((char *)"gsi.c", 348);
  }
#line 349
  tmp___2 = fwrite((void const   * __restrict  )(& f2), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
#line 349
  if (tmp___2 < 1UL) {
#line 349
    Panic((char *)"gsi.c", 349);
  }
#line 350
  return (1);
}
}
#line 367 "gsi.c"
int GSIWriteKeyRecord(FILE *fp , char *key , int fileidx , long offset ) 
{ 
  sqd_uint16 f1 ;
  sqd_uint32 f2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 373
  tmp = strlen((char const   *)key);
#line 373
  if (tmp >= 32UL) {
#line 373
    return (0);
  }
#line 374
  if (fileidx > 65535) {
#line 374
    Die((char *)"GSI: file index out of range");
  }
#line 375
  if (offset > 4294967295L) {
#line 375
    Die((char *)"GSI: offset out of range");
  }
#line 377
  f1 = (sqd_uint16 )fileidx;
#line 378
  f2 = (sqd_uint32 )offset;
#line 379
  f1 = sre_hton16(f1);
#line 380
  f2 = sre_hton32(f2);
#line 382
  tmp___0 = fwrite((void const   * __restrict  )key, (size_t )1, (size_t )32, (FILE * __restrict  )fp);
#line 382
  if (tmp___0 < 32UL) {
#line 382
    Panic((char *)"gsi.c", 382);
  }
#line 383
  tmp___1 = fwrite((void const   * __restrict  )(& f1), (size_t )2, (size_t )1, (FILE * __restrict  )fp);
#line 383
  if (tmp___1 < 1UL) {
#line 383
    Panic((char *)"gsi.c", 383);
  }
#line 384
  tmp___2 = fwrite((void const   * __restrict  )(& f2), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
#line 384
  if (tmp___2 < 1UL) {
#line 384
    Panic((char *)"gsi.c", 384);
  }
#line 385
  return (1);
}
}
#line 1 "hsregex.o"
#pragma merger("0","/tmp/cil-2eMpw6h0.i","")
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 363 "./squid.h"
char *sqd_parse[10]  ;
#line 97 "./sqfuncs.h"
sqd_regexp *sqd_regcomp(char const   *exp___0 ) ;
#line 98
int sqd_regexec(sqd_regexp *prog , char const   *str ) ;
#line 99
void sqd_regsub(sqd_regexp const   *rp , char const   *source , char *dest ) ;
#line 100
void sqd_regerror(char *s___0 ) ;
#line 91 "hsregex.c"
int Strparse(char *rexp , char *s___0 , int ntok ) 
{ 
  sqd_regexp *pat ;
  int code ;
  int len ;
  int i___0 ;
  void *tmp ;

  {
#line 99
  if (ntok >= 10) {
#line 99
    Die((char *)"Strparse(): ntok must be <= %d", 9);
  }
#line 103
  i___0 = 0;
#line 103
  while (i___0 <= ntok) {
#line 104
    if ((unsigned long )sqd_parse[i___0] != (unsigned long )((void *)0)) {
#line 106
      free((void *)sqd_parse[i___0]);
#line 107
      sqd_parse[i___0] = (char *)((void *)0);
    }
#line 103
    i___0 ++;
  }
#line 113
  pat = sqd_regcomp((char const   *)rexp);
#line 113
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
#line 114
    Die((char *)"regexp compilation failed.");
  }
#line 115
  code = sqd_regexec(pat, (char const   *)s___0);
#line 119
  if (code == 1) {
#line 120
    i___0 = 0;
#line 120
    while (i___0 <= ntok) {
#line 121
      if ((unsigned long )pat->startp[i___0] != (unsigned long )((void *)0)) {
#line 121
        if ((unsigned long )pat->endp[i___0] != (unsigned long )((void *)0)) {
#line 123
          len = (int )(pat->endp[i___0] - pat->startp[i___0]);
#line 124
          tmp = sre_malloc((char *)"hsregex.c", 124, sizeof(char ) * (unsigned long )(len + 1));
#line 124
          sqd_parse[i___0] = (char *)tmp;
#line 125
          strncpy((char * __restrict  )sqd_parse[i___0], (char const   * __restrict  )pat->startp[i___0],
                  (size_t )len);
#line 126
          *(sqd_parse[i___0] + len) = (char )'\000';
        }
      }
#line 120
      i___0 ++;
    }
  }
#line 129
  free((void *)pat);
#line 130
  return (code);
}
}
#line 140 "hsregex.c"
void SqdClean(void) 
{ 
  int i___0 ;

  {
#line 147
  i___0 = 0;
#line 147
  while (i___0 <= 9) {
#line 148
    if ((unsigned long )sqd_parse[i___0] != (unsigned long )((void *)0)) {
#line 149
      free((void *)sqd_parse[i___0]);
#line 150
      sqd_parse[i___0] = (char *)((void *)0);
    }
#line 147
    i___0 ++;
  }
#line 152
  return;
}
}
#line 307
static char *reg(struct comp *cp , int paren , int *flagp ) ;
#line 308
static char *regbranch(struct comp *cp , int *flagp ) ;
#line 309
static char *regpiece(struct comp *cp , int *flagp ) ;
#line 310
static char *regatom(struct comp *cp , int *flagp ) ;
#line 311
static char *regnode(struct comp *cp , char op ) ;
#line 312
static char *regnext(char *p ) ;
#line 313
static void regc(struct comp *cp , char b ) ;
#line 314
static void reginsert(struct comp *cp , char op , char *opnd ) ;
#line 315
static void regtail(struct comp *cp , char *p , char *val ) ;
#line 316
static void regoptail(struct comp *cp , char *p , char *val ) ;
#line 333 "hsregex.c"
sqd_regexp *sqd_regcomp(char const   *exp___0 ) 
{ 
  register sqd_regexp *r ;
  register char *scan ;
  int flags ;
  struct comp co ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  register char *longest ;
  register size_t len ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 342
  if ((unsigned long )exp___0 == (unsigned long )((void *)0)) {
#line 343
    sqd_regerror((char *)"NULL argument to sqd_regcomp");
#line 343
    return ((sqd_regexp *)((void *)0));
  }
#line 346
  co.regparse = (char *)exp___0;
#line 347
  co.regnpar = 1;
#line 348
  co.regsize = 0L;
#line 349
  co.regdummy[0] = (char)9;
#line 350
  co.regdummy[2] = (char)0;
#line 350
  co.regdummy[1] = co.regdummy[2];
#line 351
  co.regcode = co.regdummy;
#line 352
  regc(& co, 156);
#line 353
  tmp = reg(& co, 0, & flags);
#line 353
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 354
    return ((sqd_regexp *)((void *)0));
  }
#line 357
  if (co.regsize >= 32767L) {
#line 358
    sqd_regerror((char *)"regexp too big");
#line 358
    return ((sqd_regexp *)((void *)0));
  }
#line 361
  tmp___0 = malloc(sizeof(sqd_regexp ) + (size_t )co.regsize);
#line 361
  r = (sqd_regexp *)tmp___0;
#line 362
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 363
    sqd_regerror((char *)"out of space");
#line 363
    return ((sqd_regexp *)((void *)0));
  }
#line 366
  co.regparse = (char *)exp___0;
#line 367
  co.regnpar = 1;
#line 368
  co.regcode = r->program;
#line 369
  regc(& co, 156);
#line 370
  tmp___1 = reg(& co, 0, & flags);
#line 370
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 371
    return ((sqd_regexp *)((void *)0));
  }
#line 374
  r->regstart = (char )'\000';
#line 375
  r->reganch = (char)0;
#line 376
  r->regmust = (char *)((void *)0);
#line 377
  r->regmlen = 0;
#line 378
  scan = r->program + 1;
#line 379
  tmp___3 = regnext(scan);
#line 379
  if ((int )*tmp___3 == 0) {
#line 380
    scan += 3;
#line 383
    if ((int )*scan == 8) {
#line 384
      r->regstart = *(scan + 3);
    } else
#line 385
    if ((int )*scan == 1) {
#line 386
      r->reganch = (char)1;
    }
#line 396
    if (flags & 4) {
#line 397
      longest = (char *)((void *)0);
#line 398
      len = (size_t )0;
#line 400
      while ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 401
        if ((int )*scan == 8) {
#line 401
          tmp___2 = strlen((char const   *)(scan + 3));
#line 401
          if (tmp___2 >= len) {
#line 402
            longest = scan + 3;
#line 403
            len = strlen((char const   *)(scan + 3));
          }
        }
#line 400
        scan = regnext(scan);
      }
#line 405
      r->regmust = longest;
#line 406
      r->regmlen = (int )len;
    }
  }
#line 410
  return (r);
}
}
#line 422 "hsregex.c"
static char *reg(struct comp *cp , int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
#line 428
  ret = (char *)((void *)0);
#line 431
  parno = 0;
#line 434
  *flagp = 1;
#line 436
  if (paren) {
#line 438
    if (cp->regnpar >= 10) {
#line 439
      sqd_regerror((char *)"too many ()");
#line 439
      return ((char *)((void *)0));
    }
#line 440
    parno = cp->regnpar;
#line 441
    (cp->regnpar) ++;
#line 442
    ret = regnode(cp, 20 + parno);
  }
#line 446
  br = regbranch(cp, & flags);
#line 447
  if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 448
    return ((char *)((void *)0));
  }
#line 449
  if (paren) {
#line 450
    regtail(cp, ret, br);
  } else {
#line 452
    ret = br;
  }
#line 453
  *flagp &= ~ (~ flags & 1);
#line 454
  *flagp |= flags & 4;
#line 455
  while ((int )*(cp->regparse) == 124) {
#line 456
    (cp->regparse) ++;
#line 457
    br = regbranch(cp, & flags);
#line 458
    if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 459
      return ((char *)((void *)0));
    }
#line 460
    regtail(cp, ret, br);
#line 461
    *flagp &= ~ (~ flags & 1);
#line 462
    *flagp |= flags & 4;
  }
#line 466
  if (paren) {
#line 466
    tmp = 30 + parno;
  } else {
#line 466
    tmp = 0;
  }
#line 466
  ender = regnode(cp, tmp);
#line 467
  regtail(cp, ret, ender);
#line 470
  br = ret;
#line 470
  while ((unsigned long )br != (unsigned long )((void *)0)) {
#line 471
    regoptail(cp, br, ender);
#line 470
    br = regnext(br);
  }
#line 474
  if (paren) {
#line 474
    tmp___0 = cp->regparse;
#line 474
    (cp->regparse) ++;
#line 474
    if ((int )*tmp___0 != 41) {
#line 475
      sqd_regerror((char *)"unterminated ()");
#line 475
      return ((char *)((void *)0));
    } else {
#line 474
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 476
  if (! paren) {
#line 476
    if ((int )*(cp->regparse) != 0) {
#line 477
      if ((int )*(cp->regparse) == 41) {
#line 478
        sqd_regerror((char *)"unmatched ()");
#line 478
        return ((char *)((void *)0));
      } else {
#line 480
        sqd_regerror((char *)"internal error: junk on end");
#line 480
        return ((char *)((void *)0));
      }
    }
  }
#line 484
  return (ret);
}
}
#line 492 "hsregex.c"
static char *regbranch(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;
  register int c ;

  {
#line 503
  *flagp = 0;
#line 505
  ret = regnode(cp, 6);
#line 506
  chain = (char *)((void *)0);
#line 507
  while (1) {
#line 507
    c = (int )*(cp->regparse);
#line 507
    if (c != 0) {
#line 507
      if (c != 124) {
#line 507
        if (! (c != 41)) {
#line 507
          break;
        }
      } else {
#line 507
        break;
      }
    } else {
#line 507
      break;
    }
#line 508
    latest = regpiece(cp, & flags);
#line 509
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
#line 510
      return ((char *)((void *)0));
    }
#line 511
    *flagp |= flags & 1;
#line 512
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 513
      *flagp |= flags & 4;
    } else {
#line 515
      regtail(cp, chain, latest);
    }
#line 516
    chain = latest;
  }
#line 518
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 519
    regnode(cp, 9);
  }
#line 521
  return (ret);
}
}
#line 533 "hsregex.c"
static char *regpiece(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 543
  ret = regatom(cp, & flags);
#line 544
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 545
    return ((char *)((void *)0));
  }
#line 547
  op = *(cp->regparse);
#line 548
  if (! ((int )op == 42)) {
#line 548
    if (! ((int )op == 43)) {
#line 548
      if (! ((int )op == 63)) {
#line 549
        *flagp = flags;
#line 550
        return (ret);
      }
    }
  }
#line 553
  if (! (flags & 1)) {
#line 553
    if ((int )op != 63) {
#line 554
      sqd_regerror((char *)"*+ operand could be empty");
#line 554
      return ((char *)((void *)0));
    }
  }
#line 555
  switch ((int )op) {
  case 42: 
#line 556
  *flagp = 4;
#line 556
  break;
  case 43: 
#line 557
  *flagp = 5;
#line 557
  break;
  case 63: 
#line 558
  *flagp = 0;
#line 558
  break;
  }
#line 561
  if ((int )op == 42) {
#line 561
    if (flags & 2) {
#line 562
      reginsert(cp, 10, ret);
    } else {
#line 561
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 563
  if ((int )op == 42) {
#line 565
    reginsert(cp, 6, ret);
#line 566
    tmp = regnode(cp, 7);
#line 566
    regoptail(cp, ret, tmp);
#line 567
    regoptail(cp, ret, ret);
#line 568
    tmp___0 = regnode(cp, 6);
#line 568
    regtail(cp, ret, tmp___0);
#line 569
    tmp___1 = regnode(cp, 9);
#line 569
    regtail(cp, ret, tmp___1);
  } else
#line 570
  if ((int )op == 43) {
#line 570
    if (flags & 2) {
#line 571
      reginsert(cp, 11, ret);
    } else {
#line 570
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 572
  if ((int )op == 43) {
#line 574
    next = regnode(cp, 6);
#line 575
    regtail(cp, ret, next);
#line 576
    tmp___2 = regnode(cp, 7);
#line 576
    regtail(cp, tmp___2, ret);
#line 577
    tmp___3 = regnode(cp, 6);
#line 577
    regtail(cp, next, tmp___3);
#line 578
    tmp___4 = regnode(cp, 9);
#line 578
    regtail(cp, ret, tmp___4);
  } else
#line 579
  if ((int )op == 63) {
#line 581
    reginsert(cp, 6, ret);
#line 582
    tmp___5 = regnode(cp, 6);
#line 582
    regtail(cp, ret, tmp___5);
#line 583
    next = regnode(cp, 9);
#line 584
    regtail(cp, ret, next);
#line 585
    regoptail(cp, ret, next);
  }
#line 587
  (cp->regparse) ++;
#line 588
  if ((int )*(cp->regparse) == 42) {
#line 589
    sqd_regerror((char *)"nested *?+");
#line 589
    return ((char *)((void *)0));
  } else
#line 588
  if ((int )*(cp->regparse) == 43) {
#line 589
    sqd_regerror((char *)"nested *?+");
#line 589
    return ((char *)((void *)0));
  } else
#line 588
  if ((int )*(cp->regparse) == 63) {
#line 589
    sqd_regerror((char *)"nested *?+");
#line 589
    return ((char *)((void *)0));
  }
#line 591
  return (ret);
}
}
#line 602 "hsregex.c"
static char *regatom(struct comp *cp , int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int range ;
  register int rangeend ;
  register int c ;
  char *tmp___0 ;
  char *tmp___1 ;
  register size_t len ;
  register char ender ;
  char *tmp___2 ;

  {
#line 610
  *flagp = 0;
#line 612
  tmp = cp->regparse;
#line 612
  (cp->regparse) ++;
#line 612
  switch ((int )*tmp) {
  case 94: 
#line 614
  ret = regnode(cp, 1);
#line 615
  break;
  case 36: 
#line 617
  ret = regnode(cp, 2);
#line 618
  break;
  case 46: 
#line 620
  ret = regnode(cp, 3);
#line 621
  *flagp |= 3;
#line 622
  break;
  case 91: 
#line 628
  if ((int )*(cp->regparse) == 94) {
#line 629
    ret = regnode(cp, 5);
#line 630
    (cp->regparse) ++;
  } else {
#line 632
    ret = regnode(cp, 4);
  }
#line 633
  c = (int )*(cp->regparse);
#line 633
  if (c == 93) {
#line 634
    regc(cp, c);
#line 635
    (cp->regparse) ++;
  } else
#line 633
  if (c == 45) {
#line 634
    regc(cp, c);
#line 635
    (cp->regparse) ++;
  }
#line 637
  while (1) {
#line 637
    tmp___0 = cp->regparse;
#line 637
    (cp->regparse) ++;
#line 637
    c = (int )*tmp___0;
#line 637
    if (c != 0) {
#line 637
      if (! (c != 93)) {
#line 637
        break;
      }
    } else {
#line 637
      break;
    }
#line 638
    if (c != 45) {
#line 639
      regc(cp, c);
    } else {
#line 640
      c = (int )*(cp->regparse);
#line 640
      if (c == 93) {
#line 641
        regc(cp, '-');
      } else
#line 640
      if (c == 0) {
#line 641
        regc(cp, '-');
      } else {
#line 643
        range = (int )((unsigned char )*(cp->regparse - 2));
#line 644
        rangeend = (int )((unsigned char )c);
#line 645
        if (range > rangeend) {
#line 646
          sqd_regerror((char *)"invalid [] range");
#line 646
          return ((char *)((void *)0));
        }
#line 647
        range ++;
#line 647
        while (range <= rangeend) {
#line 648
          regc(cp, range);
#line 647
          range ++;
        }
#line 649
        (cp->regparse) ++;
      }
    }
  }
#line 652
  regc(cp, '\000');
#line 653
  if (c != 93) {
#line 654
    sqd_regerror((char *)"unmatched []");
#line 654
    return ((char *)((void *)0));
  }
#line 655
  *flagp |= 3;
#line 656
  break;
  case 40: 
#line 659
  ret = reg(cp, 1, & flags);
#line 660
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 661
    return ((char *)((void *)0));
  }
#line 662
  *flagp |= flags & 5;
#line 663
  break;
  case 41: 
  case 124: 
  case 0: 
#line 668
  sqd_regerror((char *)"internal error: \\0|) unexpected");
#line 668
  return ((char *)((void *)0));
#line 669
  break;
  case 42: 
  case 43: 
  case 63: 
#line 673
  sqd_regerror((char *)"?+* follows nothing");
#line 673
  return ((char *)((void *)0));
#line 674
  break;
  case 92: 
#line 676
  if ((int )*(cp->regparse) == 0) {
#line 677
    sqd_regerror((char *)"trailing \\");
#line 677
    return ((char *)((void *)0));
  }
#line 678
  ret = regnode(cp, 8);
#line 679
  tmp___1 = cp->regparse;
#line 679
  (cp->regparse) ++;
#line 679
  regc(cp, (int )*tmp___1);
#line 680
  regc(cp, '\000');
#line 681
  *flagp |= 3;
#line 682
  break;
  default: 
#line 687
  (cp->regparse) --;
#line 688
  len = strcspn((char const   *)cp->regparse, "^$.[()|?+*\\");
#line 689
  if (len == 0UL) {
#line 690
    sqd_regerror((char *)"internal error: strcspn 0");
#line 690
    return ((char *)((void *)0));
  }
#line 691
  ender = *(cp->regparse + len);
#line 692
  if (len > 1UL) {
#line 692
    if ((int )ender == 42) {
#line 693
      len --;
    } else
#line 692
    if ((int )ender == 43) {
#line 693
      len --;
    } else
#line 692
    if ((int )ender == 63) {
#line 693
      len --;
    }
  }
#line 694
  *flagp |= 1;
#line 695
  if (len == 1UL) {
#line 696
    *flagp |= 2;
  }
#line 697
  ret = regnode(cp, 8);
#line 698
  while (len > 0UL) {
#line 699
    tmp___2 = cp->regparse;
#line 699
    (cp->regparse) ++;
#line 699
    regc(cp, (int )*tmp___2);
#line 698
    len --;
  }
#line 700
  regc(cp, '\000');
#line 701
  break;
  }
#line 705
  return (ret);
}
}
#line 711 "hsregex.c"
static char *regnode(struct comp *cp , char op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 716
  ret = cp->regcode;
#line 719
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
#line 720
    cp->regsize += 3L;
#line 721
    return (ret);
  }
#line 724
  ptr = ret;
#line 725
  tmp = ptr;
#line 725
  ptr ++;
#line 725
  *tmp = op;
#line 726
  tmp___0 = ptr;
#line 726
  ptr ++;
#line 726
  *tmp___0 = (char )'\000';
#line 727
  tmp___1 = ptr;
#line 727
  ptr ++;
#line 727
  *tmp___1 = (char )'\000';
#line 728
  cp->regcode = ptr;
#line 730
  return (ret);
}
}
#line 736 "hsregex.c"
static void regc(struct comp *cp , char b ) 
{ 
  char *tmp ;

  {
#line 741
  if ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy)) {
#line 742
    tmp = cp->regcode;
#line 742
    (cp->regcode) ++;
#line 742
    *tmp = b;
  } else {
#line 744
    (cp->regsize) ++;
  }
#line 745
  return;
}
}
#line 752 "hsregex.c"
static void reginsert(struct comp *cp , char op , char *opnd ) 
{ 
  register char *place ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 760
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
#line 761
    cp->regsize += 3L;
#line 762
    return;
  }
#line 765
  memmove((void *)(opnd + 3), (void const   *)opnd, (size_t )(cp->regcode - opnd));
#line 766
  cp->regcode += 3;
#line 768
  place = opnd;
#line 769
  tmp = place;
#line 769
  place ++;
#line 769
  *tmp = op;
#line 770
  tmp___0 = place;
#line 770
  place ++;
#line 770
  *tmp___0 = (char )'\000';
#line 771
  tmp___1 = place;
#line 771
  place ++;
#line 771
  *tmp___1 = (char )'\000';
#line 772
  return;
}
}
#line 777 "hsregex.c"
static void regtail(struct comp *cp , char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
#line 787
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
#line 788
    return;
  }
#line 791
  scan = p;
#line 791
  while (1) {
#line 791
    temp = regnext(scan);
#line 791
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 791
      break;
    }
#line 792
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 791
    scan = temp;
  }
#line 794
  if ((int )*scan == 7) {
#line 794
    offset = (int )(scan - val);
  } else {
#line 794
    offset = (int )(val - scan);
  }
#line 795
  *(scan + 1) = (char )((offset >> 8) & 127);
#line 796
  *(scan + 2) = (char )(offset & 255);
#line 797
  return;
}
}
#line 802 "hsregex.c"
static void regoptail(struct comp *cp , char *p , char *val ) 
{ 


  {
#line 809
  if (! ((unsigned long )cp->regcode != (unsigned long )(cp->regdummy))) {
#line 810
    return;
  } else
#line 809
  if ((int )*p != 6) {
#line 810
    return;
  }
#line 811
  regtail(cp, p + 3, val);
#line 812
  return;
}
}
#line 831
static int regtry(struct exec *ep , sqd_regexp *prog , char *string ) ;
#line 832
static int regmatch(struct exec *ep , char *prog ) ;
#line 833
static size_t regrepeat(struct exec *ep , char *node ) ;
#line 844 "hsregex.c"
int sqd_regexec(sqd_regexp *prog , char const   *str ) 
{ 
  register char *string ;
  register char *s___0 ;
  struct exec ex ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 849
  string = (char *)str;
#line 854
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
#line 855
    sqd_regerror((char *)"NULL argument to sqd_regexec");
#line 856
    return (0);
  } else
#line 854
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 855
    sqd_regerror((char *)"NULL argument to sqd_regexec");
#line 856
    return (0);
  }
#line 860
  if ((int )((unsigned char )prog->program[0]) != 156) {
#line 861
    sqd_regerror((char *)"corrupted regexp");
#line 862
    return (0);
  }
#line 866
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
#line 866
    tmp = strstr((char const   *)string, (char const   *)prog->regmust);
#line 866
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 867
      return (0);
    }
  }
#line 870
  ex.regbol = string;
#line 871
  ex.regstartp = prog->startp;
#line 872
  ex.regendp = prog->endp;
#line 875
  if (prog->reganch) {
#line 876
    tmp___0 = regtry(& ex, prog, string);
#line 876
    return (tmp___0);
  }
#line 879
  if ((int )prog->regstart != 0) {
#line 881
    s___0 = string;
#line 881
    while ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 882
      tmp___1 = regtry(& ex, prog, s___0);
#line 882
      if (tmp___1) {
#line 883
        return (1);
      }
#line 881
      s___0 = strchr((char const   *)(s___0 + 1), (int )prog->regstart);
    }
#line 884
    return (0);
  } else {
#line 887
    s___0 = string;
#line 887
    while (1) {
#line 887
      tmp___2 = regtry(& ex, prog, s___0);
#line 887
      if (tmp___2) {
#line 887
        break;
      }
#line 888
      if ((int )*s___0 == 0) {
#line 889
        return (0);
      }
#line 887
      s___0 ++;
    }
#line 890
    return (1);
  }
}
}
#line 898 "hsregex.c"
static int regtry(struct exec *ep , sqd_regexp *prog , char *string ) 
{ 
  register int i___0 ;
  register char **stp ;
  register char **enp ;
  char **tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
#line 908
  ep->reginput = string;
#line 910
  stp = prog->startp;
#line 911
  enp = prog->endp;
#line 912
  i___0 = 10;
#line 912
  while (i___0 > 0) {
#line 913
    tmp = stp;
#line 913
    stp ++;
#line 913
    *tmp = (char *)((void *)0);
#line 914
    tmp___0 = enp;
#line 914
    enp ++;
#line 914
    *tmp___0 = (char *)((void *)0);
#line 912
    i___0 --;
  }
#line 916
  tmp___1 = regmatch(ep, prog->program + 1);
#line 916
  if (tmp___1) {
#line 917
    prog->startp[0] = string;
#line 918
    prog->endp[0] = ep->reginput;
#line 919
    return (1);
  } else {
#line 921
    return (0);
  }
}
}
#line 934 "hsregex.c"
static int regmatch(struct exec *ep , char *prog ) 
{ 
  register char *scan ;
  char *next ;
  register size_t len ;
  register char *opnd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register int no ;
  register char *input ;
  int tmp___2 ;
  register int no___0 ;
  register char *input___0 ;
  int tmp___3 ;
  register char *save ;
  int tmp___4 ;
  register char nextch ;
  int tmp___5 ;
  register size_t no___1 ;
  register char *save___0 ;
  register size_t min ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 946
  scan = prog;
#line 946
  while ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 951
    next = regnext(scan);
#line 953
    switch ((int )*scan) {
    case 1: 
#line 955
    if ((unsigned long )ep->reginput != (unsigned long )ep->regbol) {
#line 956
      return (0);
    }
#line 957
    break;
    case 2: 
#line 959
    if ((int )*(ep->reginput) != 0) {
#line 960
      return (0);
    }
#line 961
    break;
    case 3: 
#line 963
    if ((int )*(ep->reginput) == 0) {
#line 964
      return (0);
    }
#line 965
    (ep->reginput) ++;
#line 966
    break;
    case 8: 
#line 969
    opnd = scan + 3;
#line 972
    if ((int )*opnd != (int )*(ep->reginput)) {
#line 973
      return (0);
    }
#line 974
    len = strlen((char const   *)opnd);
#line 975
    if (len > 1UL) {
#line 975
      tmp = strncmp((char const   *)opnd, (char const   *)ep->reginput, len);
#line 975
      if (tmp != 0) {
#line 976
        return (0);
      }
    }
#line 977
    ep->reginput += len;
#line 978
    break;
    case 4: 
#line 981
    if ((int )*(ep->reginput) == 0) {
#line 983
      return (0);
    } else {
#line 981
      tmp___0 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
#line 981
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 983
        return (0);
      }
    }
#line 984
    (ep->reginput) ++;
#line 985
    break;
    case 5: 
#line 987
    if ((int )*(ep->reginput) == 0) {
#line 989
      return (0);
    } else {
#line 987
      tmp___1 = strchr((char const   *)(scan + 3), (int )*(ep->reginput));
#line 987
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 989
        return (0);
      }
    }
#line 990
    (ep->reginput) ++;
#line 991
    break;
    case 9: 
#line 993
    break;
    case 7: 
#line 995
    break;
    case 29: 
    case 28: 
    case 27: 
    case 26: 
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    case 21: 
#line 999
    no = (int )*scan - 20;
#line 1000
    input = ep->reginput;
#line 1002
    tmp___2 = regmatch(ep, next);
#line 1002
    if (tmp___2) {
#line 1008
      if ((unsigned long )*(ep->regstartp + no) == (unsigned long )((void *)0)) {
#line 1009
        *(ep->regstartp + no) = input;
      }
#line 1010
      return (1);
    } else {
#line 1012
      return (0);
    }
#line 1013
    break;
    case 39: 
    case 38: 
    case 37: 
    case 36: 
    case 35: 
    case 34: 
    case 33: 
    case 32: 
    case 31: 
#line 1018
    no___0 = (int )*scan - 30;
#line 1019
    input___0 = ep->reginput;
#line 1021
    tmp___3 = regmatch(ep, next);
#line 1021
    if (tmp___3) {
#line 1027
      if ((unsigned long )*(ep->regendp + no___0) == (unsigned long )((void *)0)) {
#line 1028
        *(ep->regendp + no___0) = input___0;
      }
#line 1029
      return (1);
    } else {
#line 1031
      return (0);
    }
#line 1032
    break;
    case 6: 
#line 1035
    save = ep->reginput;
#line 1037
    if ((int )*next != 6) {
#line 1038
      next = scan + 3;
    } else {
#line 1040
      while ((int )*scan == 6) {
#line 1041
        tmp___4 = regmatch(ep, scan + 3);
#line 1041
        if (tmp___4) {
#line 1042
          return (1);
        }
#line 1043
        ep->reginput = save;
#line 1044
        scan = regnext(scan);
      }
#line 1046
      return (0);
    }
#line 1049
    break;
    case 11: 
    case 10: 
#line 1052
    if ((int )*next == 8) {
#line 1052
      tmp___5 = (int )*(next + 3);
    } else {
#line 1052
      tmp___5 = '\000';
    }
#line 1052
    nextch = (char )tmp___5;
#line 1055
    save___0 = ep->reginput;
#line 1056
    if ((int )*scan == 10) {
#line 1056
      tmp___6 = 0;
    } else {
#line 1056
      tmp___6 = 1;
    }
#line 1056
    min = (size_t )tmp___6;
#line 1058
    tmp___7 = regrepeat(ep, scan + 3);
#line 1058
    no___1 = tmp___7 + 1UL;
#line 1058
    while (no___1 > min) {
#line 1059
      ep->reginput = (save___0 + no___1) - 1;
#line 1061
      if ((int )nextch == 0) {
#line 1061
        goto _L;
      } else
#line 1061
      if ((int )*(ep->reginput) == (int )nextch) {
        _L: /* CIL Label */ 
#line 1062
        tmp___8 = regmatch(ep, next);
#line 1062
        if (tmp___8) {
#line 1063
          return (1);
        }
      }
#line 1058
      no___1 --;
    }
#line 1065
    return (0);
#line 1066
    break;
    case 0: 
#line 1069
    return (1);
#line 1070
    break;
    default: 
#line 1072
    sqd_regerror((char *)"regexp corruption");
#line 1073
    return (0);
#line 1074
    break;
    }
#line 946
    scan = next;
  }
#line 1082
  sqd_regerror((char *)"corrupted pointers");
#line 1083
  return (0);
}
}
#line 1089 "hsregex.c"
static size_t regrepeat(struct exec *ep , char *node ) 
{ 
  register size_t count ;
  register char *scan ;
  register char ch ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1098
  switch ((int )*node) {
  case 3: 
#line 1100
  tmp = strlen((char const   *)ep->reginput);
#line 1100
  return (tmp);
#line 1101
  break;
  case 8: 
#line 1103
  ch = *(node + 3);
#line 1104
  count = (size_t )0;
#line 1105
  scan = ep->reginput;
#line 1105
  while ((int )*scan == (int )ch) {
#line 1106
    count ++;
#line 1105
    scan ++;
  }
#line 1107
  return (count);
#line 1108
  break;
  case 4: 
#line 1110
  tmp___0 = strspn((char const   *)ep->reginput, (char const   *)(node + 3));
#line 1110
  return (tmp___0);
#line 1111
  break;
  case 5: 
#line 1113
  tmp___1 = strcspn((char const   *)ep->reginput, (char const   *)(node + 3));
#line 1113
  return (tmp___1);
#line 1114
  break;
  default: 
#line 1116
  sqd_regerror((char *)"internal error: bad call of regrepeat");
#line 1117
  return ((size_t )0);
#line 1118
  break;
  }
#line 1121
  return (0UL);
}
}
#line 1126 "hsregex.c"
static char *regnext(char *p ) 
{ 
  register int offset ;
  char *tmp ;

  {
#line 1130
  offset = (((int )*(p + 1) & 127) << 8) + ((int )*(p + 2) & 255);
#line 1132
  if (offset == 0) {
#line 1133
    return ((char *)((void *)0));
  }
#line 1135
  if ((int )*p == 7) {
#line 1135
    tmp = p - offset;
  } else {
#line 1135
    tmp = p + offset;
  }
#line 1135
  return (tmp);
}
}
#line 1272 "hsregex.c"
void sqd_regsub(sqd_regexp const   *rp , char const   *source , char *dest ) 
{ 
  register sqd_regexp *prog ;
  register char *src ;
  register char *dst ;
  register char c ;
  register int no ;
  register size_t len ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 1278
  prog = (sqd_regexp *)rp;
#line 1279
  src = (char *)source;
#line 1280
  dst = dest;
#line 1285
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
#line 1286
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
#line 1287
    return;
  } else
#line 1285
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 1286
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
#line 1287
    return;
  } else
#line 1285
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 1286
    sqd_regerror((char *)"NULL parameter to sqd_regsub");
#line 1287
    return;
  }
#line 1289
  if ((int )((unsigned char )prog->program[0]) != 156) {
#line 1290
    sqd_regerror((char *)"damaged regexp");
#line 1291
    return;
  }
#line 1294
  while (1) {
#line 1294
    tmp___3 = src;
#line 1294
    src ++;
#line 1294
    c = *tmp___3;
#line 1294
    if (! ((int )c != 0)) {
#line 1294
      break;
    }
#line 1295
    if ((int )c == 38) {
#line 1296
      no = 0;
    } else
#line 1297
    if ((int )c == 92) {
#line 1297
      tmp___0 = __ctype_b_loc();
#line 1297
      if ((int const   )*(*tmp___0 + (int )*src) & 2048) {
#line 1298
        tmp = src;
#line 1298
        src ++;
#line 1298
        no = (int )*tmp - 48;
      } else {
#line 1300
        no = -1;
      }
    } else {
#line 1300
      no = -1;
    }
#line 1302
    if (no < 0) {
#line 1303
      if ((int )c == 92) {
#line 1303
        if ((int )*src == 92) {
#line 1304
          tmp___1 = src;
#line 1304
          src ++;
#line 1304
          c = *tmp___1;
        } else
#line 1303
        if ((int )*src == 38) {
#line 1304
          tmp___1 = src;
#line 1304
          src ++;
#line 1304
          c = *tmp___1;
        }
      }
#line 1305
      tmp___2 = dst;
#line 1305
      dst ++;
#line 1305
      *tmp___2 = c;
    } else
#line 1306
    if ((unsigned long )prog->startp[no] != (unsigned long )((void *)0)) {
#line 1306
      if ((unsigned long )prog->endp[no] != (unsigned long )((void *)0)) {
#line 1306
        if ((unsigned long )prog->endp[no] > (unsigned long )prog->startp[no]) {
#line 1308
          len = (size_t )(prog->endp[no] - prog->startp[no]);
#line 1309
          strncpy((char * __restrict  )dst, (char const   * __restrict  )prog->startp[no],
                  len);
#line 1310
          dst += len;
#line 1311
          if ((int )*(dst - 1) == 0) {
#line 1312
            sqd_regerror((char *)"damaged match string");
#line 1313
            return;
          }
        }
      }
    }
  }
#line 1317
  tmp___4 = dst;
#line 1317
  dst ++;
#line 1317
  *tmp___4 = (char )'\000';
#line 1318
  return;
}
}
#line 1321 "hsregex.c"
void sqd_regerror(char *s___0 ) 
{ 


  {
#line 1325
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"regexp(3): %s\n",
          s___0);
#line 1326
  exit(1);
}
}
#line 1 "iupac.o"
#pragma merger("0","/tmp/cil-Sy1u6eCP.i","")
#line 123 "./squid.h"
struct iupactype iupac[17] ;
#line 127
char *stdcode3[65] ;
#line 128
float dnafq[4] ;
#line 130
char aa_alphabet[21] ;
#line 131
int aa_index[20] ;
#line 25 "iupac.c"
float dnafq[4]  = {      (float )0.25,      (float )0.25,      (float )0.25,      (float )0.25};
#line 33 "iupac.c"
float aafq[20]  = 
#line 33
  {      (float )0.075520,      (float )0.016973,      (float )0.053029,      (float )0.063204, 
        (float )0.040762,      (float )0.068448,      (float )0.022406,      (float )0.057284, 
        (float )0.059398,      (float )0.093399,      (float )0.023569,      (float )0.045293, 
        (float )0.049262,      (float )0.040231,      (float )0.051573,      (float )0.072214, 
        (float )0.057454,      (float )0.065252,      (float )0.012513,      (float )0.031985};
#line 56 "iupac.c"
char aa_alphabet[21]  = 
#line 56
  {      (char )'A',      (char )'C',      (char )'D',      (char )'E', 
        (char )'F',      (char )'G',      (char )'H',      (char )'I', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'P',      (char )'Q',      (char )'R',      (char )'S', 
        (char )'T',      (char )'V',      (char )'W',      (char )'Y', 
        (char )'\000'};
#line 58 "iupac.c"
int aa_index[20]  = 
#line 58
  {      0,      2,      3,      4, 
        5,      6,      7,      8, 
        10,      11,      12,      13, 
        15,      16,      17,      18, 
        19,      21,      22,      24};
#line 63 "iupac.c"
struct iupactype iupac[17]  = 
#line 63
  {      {(char )'A', (char )'T', (char)8, (char)1}, 
        {(char )'C', (char )'G', (char)4, (char)2}, 
        {(char )'G', (char )'C', (char)2, (char)4}, 
        {(char )'T', (char )'A', (char)1, (char)8}, 
        {(char )'U', (char )'A', (char)1, (char)8}, 
        {(char )'N', (char )'N', (char)15, (char)15}, 
        {(char )' ', (char )' ', (char)16, (char)16}, 
        {(char )'R', (char )'Y', (char)10, (char)5}, 
        {(char )'Y', (char )'R', (char)5, (char)10}, 
        {(char )'M', (char )'K', (char)12, (char)3}, 
        {(char )'K', (char )'M', (char)3, (char)12}, 
        {(char )'S', (char )'S', (char)6, (char)6}, 
        {(char )'W', (char )'W', (char)9, (char)9}, 
        {(char )'H', (char )'D', (char)13, (char)11}, 
        {(char )'B', (char )'V', (char)7, (char)14}, 
        {(char )'V', (char )'B', (char)14, (char)7}, 
        {(char )'D', (char )'H', (char)11, (char)13}};
#line 84 "iupac.c"
char *stdcode1[65]  = 
#line 84
  {      (char *)"K",      (char *)"N",      (char *)"K",      (char *)"N", 
        (char *)"T",      (char *)"T",      (char *)"T",      (char *)"T", 
        (char *)"R",      (char *)"S",      (char *)"R",      (char *)"S", 
        (char *)"I",      (char *)"I",      (char *)"M",      (char *)"I", 
        (char *)"Q",      (char *)"H",      (char *)"Q",      (char *)"H", 
        (char *)"P",      (char *)"P",      (char *)"P",      (char *)"P", 
        (char *)"R",      (char *)"R",      (char *)"R",      (char *)"R", 
        (char *)"L",      (char *)"L",      (char *)"L",      (char *)"L", 
        (char *)"E",      (char *)"D",      (char *)"E",      (char *)"D", 
        (char *)"A",      (char *)"A",      (char *)"A",      (char *)"A", 
        (char *)"G",      (char *)"G",      (char *)"G",      (char *)"G", 
        (char *)"V",      (char *)"V",      (char *)"V",      (char *)"V", 
        (char *)"*",      (char *)"Y",      (char *)"*",      (char *)"Y", 
        (char *)"S",      (char *)"S",      (char *)"S",      (char *)"S", 
        (char *)"*",      (char *)"C",      (char *)"W",      (char *)"C", 
        (char *)"L",      (char *)"F",      (char *)"L",      (char *)"F", 
        (char *)"X"};
#line 155 "iupac.c"
char *stdcode3[65]  = 
#line 155
  {      (char *)"Lys",      (char *)"Asn",      (char *)"Lys",      (char *)"Asn", 
        (char *)"Thr",      (char *)"Thr",      (char *)"Thr",      (char *)"Thr", 
        (char *)"Arg",      (char *)"Ser",      (char *)"Arg",      (char *)"Ser", 
        (char *)"Ile",      (char *)"Ile",      (char *)"Met",      (char *)"Ile", 
        (char *)"Gln",      (char *)"His",      (char *)"Gln",      (char *)"His", 
        (char *)"Pro",      (char *)"Pro",      (char *)"Pro",      (char *)"Pro", 
        (char *)"Arg",      (char *)"Arg",      (char *)"Arg",      (char *)"Arg", 
        (char *)"Leu",      (char *)"Leu",      (char *)"Leu",      (char *)"Leu", 
        (char *)"Glu",      (char *)"Asp",      (char *)"Glu",      (char *)"Asp", 
        (char *)"Ala",      (char *)"Ala",      (char *)"Ala",      (char *)"Ala", 
        (char *)"Gly",      (char *)"Gly",      (char *)"Gly",      (char *)"Gly", 
        (char *)"Val",      (char *)"Val",      (char *)"Val",      (char *)"Val", 
        (char *)"***",      (char *)"Tyr",      (char *)"***",      (char *)"Tyr", 
        (char *)"Ser",      (char *)"Ser",      (char *)"Ser",      (char *)"Ser", 
        (char *)"***",      (char *)"Cys",      (char *)"Trp",      (char *)"Cys", 
        (char *)"Leu",      (char *)"Phe",      (char *)"Leu",      (char *)"Trp", 
        (char *)"XXX"};
#line 1 "msa.o"
#pragma merger("0","/tmp/cil-6fHVhvY7.i","")
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 223 "./msa.h"
MSAFILE *MSAFileOpen(char *filename , int format , char *env ) ;
#line 224
MSA *MSAFileRead(MSAFILE *afp ) ;
#line 225
void MSAFileClose(MSAFILE *afp ) ;
#line 227
void MSAFileWrite(FILE *fp , MSA *msa , int outfmt , int do_oneline ) ;
#line 229
int MSAFileRewind(MSAFILE *afp ) ;
#line 230
int MSAFilePositionByKey(MSAFILE *afp , char *key ) ;
#line 231
int MSAFilePositionByIndex(MSAFILE *afp , int idx ) ;
#line 233
int MSAFileFormat(MSAFILE *afp ) ;
#line 239
void MSAAddComment(MSA *msa , char *s___0 ) ;
#line 240
void MSAAddGF(MSA *msa , char *tag , char *value ) ;
#line 241
void MSAAddGS(MSA *msa , char *tag , int sqidx , char *value ) ;
#line 242
void MSAAppendGC(MSA *msa , char *tag , char *value ) ;
#line 244
void MSAAppendGR(MSA *msa , char *tag , int sqidx , char *value ) ;
#line 248
MSA *MSAFromAINFO(char **aseq , AINFO *ainfo ) ;
#line 250
void MSAMingap(MSA *msa ) ;
#line 251
void MSANogap(MSA *msa ) ;
#line 252
void MSAShorterAlignment(MSA *msa , int *useme ) ;
#line 253
void MSASmallerAlignment(MSA *msa , int *useme , MSA **ret_new ) ;
#line 255
char *MSAGetSeqAccession(MSA *msa , int idx ) ;
#line 256
char *MSAGetSeqDescription(MSA *msa , int idx ) ;
#line 257
char *MSAGetSeqSS(MSA *msa , int idx ) ;
#line 258
char *MSAGetSeqSA(MSA *msa , int idx ) ;
#line 260
float MSAAverageSequenceLength(MSA *msa ) ;
#line 278
MSA *ReadMSF(MSAFILE *afp ) ;
#line 279
void WriteMSF(FILE *fp , MSA *msa ) ;
#line 283
MSA *ReadPhylip(MSAFILE *afp ) ;
#line 284
void WritePhylip(FILE *fp , MSA *msa ) ;
#line 288
MSA *ReadSELEX(MSAFILE *afp ) ;
#line 289
void WriteSELEX(FILE *fp , MSA *msa ) ;
#line 294
MSA *ReadStockholm(MSAFILE *afp ) ;
#line 295
void WriteStockholm(FILE *fp , MSA *msa ) ;
#line 296
void WriteStockholmOneBlock(FILE *fp , MSA *msa ) ;
#line 168 "./sqfuncs.h"
int SeqfileFormat(FILE *fp ) ;
#line 182
char *SeqfileFormat2String(int code ) ;
#line 223
void Free3DArray(void ***p , int dim1 , int dim2 ) ;
#line 225
char *sre_fgets(char **buf , int *n , FILE *fp ) ;
#line 62 "msa.c"
MSA *MSAAlloc(int nseq , int alen ) 
{ 
  MSA *msa ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 68
  tmp = sre_malloc((char *)"msa.c", 68, sizeof(MSA ));
#line 68
  msa = (MSA *)tmp;
#line 69
  tmp___0 = sre_malloc((char *)"msa.c", 69, sizeof(char *) * (unsigned long )nseq);
#line 69
  msa->aseq = (char **)tmp___0;
#line 70
  tmp___1 = sre_malloc((char *)"msa.c", 70, sizeof(char *) * (unsigned long )nseq);
#line 70
  msa->sqname = (char **)tmp___1;
#line 71
  tmp___2 = sre_malloc((char *)"msa.c", 71, sizeof(int ) * (unsigned long )nseq);
#line 71
  msa->sqlen = (int *)tmp___2;
#line 72
  tmp___3 = sre_malloc((char *)"msa.c", 72, sizeof(float ) * (unsigned long )nseq);
#line 72
  msa->wgt = (float *)tmp___3;
#line 74
  i___0 = 0;
#line 74
  while (i___0 < nseq) {
#line 76
    *(msa->sqname + i___0) = (char *)((void *)0);
#line 77
    *(msa->sqlen + i___0) = 0;
#line 78
    *(msa->wgt + i___0) = (float )(- 1.0);
#line 80
    if (alen != 0) {
#line 80
      tmp___4 = sre_malloc((char *)"msa.c", 80, sizeof(char ) * (unsigned long )(alen + 1));
#line 80
      *(msa->aseq + i___0) = (char *)tmp___4;
    } else {
#line 81
      *(msa->aseq + i___0) = (char *)((void *)0);
    }
#line 74
    i___0 ++;
  }
#line 84
  msa->alen = alen;
#line 85
  msa->nseq = 0;
#line 86
  msa->nseqalloc = nseq;
#line 87
  msa->nseqlump = nseq;
#line 89
  msa->flags = 0;
#line 90
  msa->type = 0;
#line 91
  msa->name = (char *)((void *)0);
#line 92
  msa->desc = (char *)((void *)0);
#line 93
  msa->acc = (char *)((void *)0);
#line 94
  msa->au = (char *)((void *)0);
#line 95
  msa->ss_cons = (char *)((void *)0);
#line 96
  msa->sa_cons = (char *)((void *)0);
#line 97
  msa->rf = (char *)((void *)0);
#line 98
  msa->sqacc = (char **)((void *)0);
#line 99
  msa->sqdesc = (char **)((void *)0);
#line 100
  msa->ss = (char **)((void *)0);
#line 101
  msa->sslen = (int *)((void *)0);
#line 102
  msa->sa = (char **)((void *)0);
#line 103
  msa->salen = (int *)((void *)0);
#line 104
  msa->index = GKIInit();
#line 105
  msa->lastidx = 0;
#line 107
  i___0 = 0;
#line 107
  while (i___0 < 6) {
#line 108
    msa->cutoff[i___0] = (float )0.;
#line 109
    msa->cutoff_is_set[i___0] = 0;
#line 107
    i___0 ++;
  }
#line 114
  msa->comment = (char **)((void *)0);
#line 115
  msa->ncomment = 0;
#line 116
  msa->alloc_ncomment = 0;
#line 118
  msa->gf_tag = (char **)((void *)0);
#line 119
  msa->gf = (char **)((void *)0);
#line 120
  msa->ngf = 0;
#line 122
  msa->gs_tag = (char **)((void *)0);
#line 123
  msa->gs = (char ***)((void *)0);
#line 124
  msa->gs_idx = (GKI *)((void *)0);
#line 125
  msa->ngs = 0;
#line 127
  msa->gc_tag = (char **)((void *)0);
#line 128
  msa->gc = (char **)((void *)0);
#line 129
  msa->gc_idx = (GKI *)((void *)0);
#line 130
  msa->ngc = 0;
#line 132
  msa->gr_tag = (char **)((void *)0);
#line 133
  msa->gr = (char ***)((void *)0);
#line 134
  msa->gr_idx = (GKI *)((void *)0);
#line 135
  msa->ngr = 0;
#line 139
  return (msa);
}
}
#line 155 "msa.c"
void MSAExpand(MSA *msa ) 
{ 
  int i___0 ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
#line 160
  msa->nseqalloc += msa->nseqlump;
#line 162
  tmp = sre_realloc((char *)"msa.c", 162, (void *)msa->aseq, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 162
  msa->aseq = (char **)tmp;
#line 163
  tmp___0 = sre_realloc((char *)"msa.c", 163, (void *)msa->sqname, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 163
  msa->sqname = (char **)tmp___0;
#line 164
  tmp___1 = sre_realloc((char *)"msa.c", 164, (void *)msa->sqlen, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 164
  msa->sqlen = (int *)tmp___1;
#line 165
  tmp___2 = sre_realloc((char *)"msa.c", 165, (void *)msa->wgt, sizeof(float ) * (unsigned long )msa->nseqalloc);
#line 165
  msa->wgt = (float *)tmp___2;
#line 167
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 168
    tmp___3 = sre_realloc((char *)"msa.c", 168, (void *)msa->ss, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 168
    msa->ss = (char **)tmp___3;
#line 169
    tmp___4 = sre_realloc((char *)"msa.c", 169, (void *)msa->sslen, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 169
    msa->sslen = (int *)tmp___4;
  }
#line 171
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 172
    tmp___5 = sre_realloc((char *)"msa.c", 172, (void *)msa->sa, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 172
    msa->sa = (char **)tmp___5;
#line 173
    tmp___6 = sre_realloc((char *)"msa.c", 173, (void *)msa->salen, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 173
    msa->salen = (int *)tmp___6;
  }
#line 175
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 176
    tmp___7 = sre_realloc((char *)"msa.c", 176, (void *)msa->sqacc, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 176
    msa->sqacc = (char **)tmp___7;
  }
#line 177
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 178
    tmp___8 = sre_realloc((char *)"msa.c", 178, (void *)msa->sqdesc, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 178
    msa->sqdesc = (char **)tmp___8;
  }
#line 180
  i___0 = msa->nseqalloc - msa->nseqlump;
#line 180
  while (i___0 < msa->nseqalloc) {
#line 182
    *(msa->sqname + i___0) = (char *)((void *)0);
#line 183
    *(msa->wgt + i___0) = (float )(- 1.0);
#line 185
    if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 185
      *(msa->sqacc + i___0) = (char *)((void *)0);
    }
#line 186
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 186
      *(msa->sqdesc + i___0) = (char *)((void *)0);
    }
#line 188
    if (msa->alen != 0) {
#line 189
      tmp___9 = sre_realloc((char *)"msa.c", 189, (void *)*(msa->aseq + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
#line 189
      *(msa->aseq + i___0) = (char *)tmp___9;
    } else {
#line 190
      *(msa->aseq + i___0) = (char *)((void *)0);
    }
#line 191
    *(msa->sqlen + i___0) = 0;
#line 193
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 194
      if (msa->alen != 0) {
#line 195
        tmp___10 = sre_realloc((char *)"msa.c", 195, (void *)*(msa->ss + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
#line 195
        *(msa->ss + i___0) = (char *)tmp___10;
      } else {
#line 196
        *(msa->ss + i___0) = (char *)((void *)0);
      }
#line 197
      *(msa->sslen + i___0) = 0;
    }
#line 199
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 200
      if (msa->alen != 0) {
#line 201
        tmp___11 = sre_realloc((char *)"msa.c", 201, (void *)*(msa->ss + i___0), sizeof(char ) * (unsigned long )(msa->alen + 1));
#line 201
        *(msa->sa + i___0) = (char *)tmp___11;
      } else {
#line 203
        *(msa->sa + i___0) = (char *)((void *)0);
      }
#line 204
      *(msa->salen + i___0) = 0;
    }
#line 180
    i___0 ++;
  }
#line 212
  if ((unsigned long )msa->gs != (unsigned long )((void *)0)) {
#line 213
    i___0 = 0;
#line 213
    while (i___0 < msa->ngs) {
#line 215
      if ((unsigned long )*(msa->gs + i___0) != (unsigned long )((void *)0)) {
#line 217
        tmp___12 = sre_realloc((char *)"msa.c", 217, (void *)*(msa->gs + i___0), sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 217
        *(msa->gs + i___0) = (char **)tmp___12;
#line 218
        j = msa->nseqalloc - msa->nseqlump;
#line 218
        while (j < msa->nseqalloc) {
#line 219
          *(*(msa->gs + i___0) + j) = (char *)((void *)0);
#line 218
          j ++;
        }
      }
#line 213
      i___0 ++;
    }
  }
#line 227
  if ((unsigned long )msa->gr != (unsigned long )((void *)0)) {
#line 228
    i___0 = 0;
#line 228
    while (i___0 < msa->ngr) {
#line 230
      if ((unsigned long )*(msa->gr + i___0) != (unsigned long )((void *)0)) {
#line 232
        tmp___13 = sre_realloc((char *)"msa.c", 232, (void *)*(msa->gr + i___0), sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 232
        *(msa->gr + i___0) = (char **)tmp___13;
#line 233
        j = msa->nseqalloc - msa->nseqlump;
#line 233
        while (j < msa->nseqalloc) {
#line 234
          *(*(msa->gr + i___0) + j) = (char *)((void *)0);
#line 233
          j ++;
        }
      }
#line 228
      i___0 ++;
    }
  }
#line 238
  return;
}
}
#line 250 "msa.c"
void MSAFree(MSA *msa ) 
{ 


  {
#line 253
  Free2DArray((void **)msa->aseq, msa->nseq);
#line 254
  Free2DArray((void **)msa->sqname, msa->nseq);
#line 255
  Free2DArray((void **)msa->sqacc, msa->nseq);
#line 256
  Free2DArray((void **)msa->sqdesc, msa->nseq);
#line 257
  Free2DArray((void **)msa->ss, msa->nseq);
#line 258
  Free2DArray((void **)msa->sa, msa->nseq);
#line 260
  if ((unsigned long )msa->sqlen != (unsigned long )((void *)0)) {
#line 260
    free((void *)msa->sqlen);
  }
#line 261
  if ((unsigned long )msa->wgt != (unsigned long )((void *)0)) {
#line 261
    free((void *)msa->wgt);
  }
#line 263
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 263
    free((void *)msa->name);
  }
#line 264
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
#line 264
    free((void *)msa->desc);
  }
#line 265
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
#line 265
    free((void *)msa->acc);
  }
#line 266
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
#line 266
    free((void *)msa->au);
  }
#line 267
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 267
    free((void *)msa->ss_cons);
  }
#line 268
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 268
    free((void *)msa->sa_cons);
  }
#line 269
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 269
    free((void *)msa->rf);
  }
#line 270
  if ((unsigned long )msa->sslen != (unsigned long )((void *)0)) {
#line 270
    free((void *)msa->sslen);
  }
#line 271
  if ((unsigned long )msa->salen != (unsigned long )((void *)0)) {
#line 271
    free((void *)msa->salen);
  }
#line 273
  Free2DArray((void **)msa->comment, msa->ncomment);
#line 274
  Free2DArray((void **)msa->gf_tag, msa->ngf);
#line 275
  Free2DArray((void **)msa->gf, msa->ngf);
#line 276
  Free2DArray((void **)msa->gs_tag, msa->ngs);
#line 277
  Free3DArray((void ***)msa->gs, msa->ngs, msa->nseq);
#line 278
  Free2DArray((void **)msa->gc_tag, msa->ngc);
#line 279
  Free2DArray((void **)msa->gc, msa->ngc);
#line 280
  Free2DArray((void **)msa->gr_tag, msa->ngr);
#line 281
  Free3DArray((void ***)msa->gr, msa->ngr, msa->nseq);
#line 283
  GKIFree(msa->index);
#line 284
  GKIFree(msa->gs_idx);
#line 285
  GKIFree(msa->gc_idx);
#line 286
  GKIFree(msa->gr_idx);
#line 288
  free((void *)msa);
#line 289
  return;
}
}
#line 304 "msa.c"
void MSASetSeqAccession(MSA *msa , int seqidx , char *acc ) 
{ 
  int x ;
  void *tmp ;

  {
#line 309
  if ((unsigned long )msa->sqacc == (unsigned long )((void *)0)) {
#line 310
    tmp = sre_malloc((char *)"msa.c", 310, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 310
    msa->sqacc = (char **)tmp;
#line 311
    x = 0;
#line 311
    while (x < msa->nseqalloc) {
#line 312
      *(msa->sqacc + x) = (char *)((void *)0);
#line 311
      x ++;
    }
  }
#line 314
  *(msa->sqacc + seqidx) = sre_strdup(acc, -1);
#line 315
  return;
}
}
#line 329 "msa.c"
void MSASetSeqDescription(MSA *msa , int seqidx , char *desc ) 
{ 
  int x ;
  void *tmp ;

  {
#line 334
  if ((unsigned long )msa->sqdesc == (unsigned long )((void *)0)) {
#line 335
    tmp = sre_malloc((char *)"msa.c", 335, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 335
    msa->sqdesc = (char **)tmp;
#line 336
    x = 0;
#line 336
    while (x < msa->nseqalloc) {
#line 337
      *(msa->sqdesc + x) = (char *)((void *)0);
#line 336
      x ++;
    }
  }
#line 339
  *(msa->sqdesc + seqidx) = sre_strdup(desc, -1);
#line 340
  return;
}
}
#line 354 "msa.c"
void MSAAddComment(MSA *msa , char *s___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 361
  if ((unsigned long )msa->comment == (unsigned long )((void *)0)) {
#line 362
    tmp = sre_malloc((char *)"msa.c", 362, sizeof(char *) * 10UL);
#line 362
    msa->comment = (char **)tmp;
#line 363
    msa->alloc_ncomment = 10;
  }
#line 365
  if (msa->ncomment == msa->alloc_ncomment) {
#line 366
    msa->alloc_ncomment += 10;
#line 367
    tmp___0 = sre_realloc((char *)"msa.c", 367, (void *)msa->comment, sizeof(char *) * (unsigned long )msa->alloc_ncomment);
#line 367
    msa->comment = (char **)tmp___0;
  }
#line 370
  *(msa->comment + msa->ncomment) = sre_strdup(s___0, -1);
#line 371
  (msa->ncomment) ++;
#line 372
  return;
}
}
#line 387 "msa.c"
void MSAAddGF(MSA *msa , char *tag , char *value ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 394
  if ((unsigned long )msa->gf_tag == (unsigned long )((void *)0)) {
#line 395
    tmp = sre_malloc((char *)"msa.c", 395, sizeof(char *) * 10UL);
#line 395
    msa->gf_tag = (char **)tmp;
#line 396
    tmp___0 = sre_malloc((char *)"msa.c", 396, sizeof(char *) * 10UL);
#line 396
    msa->gf = (char **)tmp___0;
#line 397
    msa->alloc_ngf = 10;
  }
#line 399
  if (msa->ngf == msa->alloc_ngf) {
#line 400
    msa->alloc_ngf += 10;
#line 401
    tmp___1 = sre_realloc((char *)"msa.c", 401, (void *)msa->gf_tag, sizeof(char *) * (unsigned long )msa->alloc_ngf);
#line 401
    msa->gf_tag = (char **)tmp___1;
#line 402
    tmp___2 = sre_realloc((char *)"msa.c", 402, (void *)msa->gf, sizeof(char *) * (unsigned long )msa->alloc_ngf);
#line 402
    msa->gf = (char **)tmp___2;
  }
#line 405
  *(msa->gf_tag + msa->ngf) = sre_strdup(tag, -1);
#line 406
  *(msa->gf + msa->ngf) = sre_strdup(value, -1);
#line 407
  (msa->ngf) ++;
#line 409
  return;
}
}
#line 432 "msa.c"
void MSAAddGS(MSA *msa , char *tag , int sqidx , char *value ) 
{ 
  int tagidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int len ;
  int tmp___5 ;

  {
#line 442
  if ((unsigned long )msa->gs_tag == (unsigned long )((void *)0)) {
#line 444
    msa->gs_idx = GKIInit();
#line 445
    tagidx = GKIStoreKey(msa->gs_idx, tag);
#line 447
    tmp = sre_malloc((char *)"msa.c", 447, sizeof(char *));
#line 447
    msa->gs_tag = (char **)tmp;
#line 448
    tmp___0 = sre_malloc((char *)"msa.c", 448, sizeof(char **));
#line 448
    msa->gs = (char ***)tmp___0;
#line 449
    tmp___1 = sre_malloc((char *)"msa.c", 449, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 449
    *(msa->gs + 0) = (char **)tmp___1;
#line 450
    i___0 = 0;
#line 450
    while (i___0 < msa->nseqalloc) {
#line 451
      *(*(msa->gs + 0) + i___0) = (char *)((void *)0);
#line 450
      i___0 ++;
    }
  } else {
#line 456
    tagidx = GKIKeyIndex(msa->gs_idx, tag);
#line 457
    if (tagidx < 0) {
#line 458
      tagidx = GKIStoreKey(msa->gs_idx, tag);
#line 463
      tmp___2 = sre_realloc((char *)"msa.c", 463, (void *)msa->gs_tag, (unsigned long )(msa->ngs + 1) * sizeof(char *));
#line 463
      msa->gs_tag = (char **)tmp___2;
#line 464
      tmp___3 = sre_realloc((char *)"msa.c", 464, (void *)msa->gs, (unsigned long )(msa->ngs + 1) * sizeof(char **));
#line 464
      msa->gs = (char ***)tmp___3;
#line 465
      tmp___4 = sre_malloc((char *)"msa.c", 465, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 465
      *(msa->gs + msa->ngs) = (char **)tmp___4;
#line 466
      i___0 = 0;
#line 466
      while (i___0 < msa->nseqalloc) {
#line 467
        *(*(msa->gs + msa->ngs) + i___0) = (char *)((void *)0);
#line 466
        i___0 ++;
      }
    }
  }
#line 471
  if (tagidx == msa->ngs) {
#line 472
    *(msa->gs_tag + tagidx) = sre_strdup(tag, -1);
#line 473
    (msa->ngs) ++;
  }
#line 476
  if ((unsigned long )*(*(msa->gs + tagidx) + sqidx) == (unsigned long )((void *)0)) {
#line 477
    *(*(msa->gs + tagidx) + sqidx) = sre_strdup(value, -1);
  } else {
#line 481
    len = sre_strcat(*(msa->gs + tagidx) + sqidx, -1, (char *)"\n", 1);
#line 481
    if (len < 0) {
#line 482
      Die((char *)"failed to sre_strcat()");
    }
#line 483
    tmp___5 = sre_strcat(*(msa->gs + tagidx) + sqidx, len, value, -1);
#line 483
    if (tmp___5 < 0) {
#line 484
      Die((char *)"failed to sre_strcat()");
    }
  }
#line 486
  return;
}
}
#line 506 "msa.c"
void MSAAppendGC(MSA *msa , char *tag , char *value ) 
{ 
  int tagidx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 515
  if ((unsigned long )msa->gc_tag == (unsigned long )((void *)0)) {
#line 517
    tmp = sre_malloc((char *)"msa.c", 517, sizeof(char *));
#line 517
    msa->gc_tag = (char **)tmp;
#line 518
    tmp___0 = sre_malloc((char *)"msa.c", 518, sizeof(char *));
#line 518
    msa->gc = (char **)tmp___0;
#line 519
    msa->gc_idx = GKIInit();
#line 520
    tagidx = GKIStoreKey(msa->gc_idx, tag);
#line 522
    *(msa->gc + 0) = (char *)((void *)0);
  } else {
#line 526
    tagidx = GKIKeyIndex(msa->gc_idx, tag);
#line 527
    if (tagidx < 0) {
#line 528
      tagidx = GKIStoreKey(msa->gc_idx, tag);
#line 533
      tmp___1 = sre_realloc((char *)"msa.c", 533, (void *)msa->gc_tag, (unsigned long )(msa->ngc + 1) * sizeof(char **));
#line 533
      msa->gc_tag = (char **)tmp___1;
#line 534
      tmp___2 = sre_realloc((char *)"msa.c", 534, (void *)msa->gc, (unsigned long )(msa->ngc + 1) * sizeof(char **));
#line 534
      msa->gc = (char **)tmp___2;
#line 535
      *(msa->gc + tagidx) = (char *)((void *)0);
    }
  }
#line 539
  if (tagidx == msa->ngc) {
#line 540
    *(msa->gc_tag + tagidx) = sre_strdup(tag, -1);
#line 541
    (msa->ngc) ++;
  }
#line 543
  sre_strcat(msa->gc + tagidx, -1, value, -1);
#line 544
  return;
}
}
#line 560 "msa.c"
char *MSAGetGC(MSA *msa , char *tag ) 
{ 
  int tagidx ;

  {
#line 565
  if ((unsigned long )msa->gc_idx == (unsigned long )((void *)0)) {
#line 565
    return ((char *)((void *)0));
  }
#line 566
  tagidx = GKIKeyIndex(msa->gc_idx, tag);
#line 566
  if (tagidx < 0) {
#line 566
    return ((char *)((void *)0));
  }
#line 567
  return (*(msa->gc + tagidx));
}
}
#line 589 "msa.c"
void MSAAppendGR(MSA *msa , char *tag , int sqidx , char *value ) 
{ 
  int tagidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 599
  if ((unsigned long )msa->gr_tag == (unsigned long )((void *)0)) {
#line 601
    tmp = sre_malloc((char *)"msa.c", 601, sizeof(char *));
#line 601
    msa->gr_tag = (char **)tmp;
#line 602
    tmp___0 = sre_malloc((char *)"msa.c", 602, sizeof(char **));
#line 602
    msa->gr = (char ***)tmp___0;
#line 603
    tmp___1 = sre_malloc((char *)"msa.c", 603, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 603
    *(msa->gr + 0) = (char **)tmp___1;
#line 604
    i___0 = 0;
#line 604
    while (i___0 < msa->nseqalloc) {
#line 605
      *(*(msa->gr + 0) + i___0) = (char *)((void *)0);
#line 604
      i___0 ++;
    }
#line 606
    msa->gr_idx = GKIInit();
#line 607
    tagidx = GKIStoreKey(msa->gr_idx, tag);
  } else {
#line 613
    tagidx = GKIKeyIndex(msa->gr_idx, tag);
#line 614
    if (tagidx < 0) {
#line 615
      tagidx = GKIStoreKey(msa->gr_idx, tag);
#line 620
      tmp___2 = sre_realloc((char *)"msa.c", 620, (void *)msa->gr_tag, (unsigned long )(msa->ngr + 1) * sizeof(char *));
#line 620
      msa->gr_tag = (char **)tmp___2;
#line 621
      tmp___3 = sre_realloc((char *)"msa.c", 621, (void *)msa->gr, (unsigned long )(msa->ngr + 1) * sizeof(char **));
#line 621
      msa->gr = (char ***)tmp___3;
#line 622
      tmp___4 = sre_malloc((char *)"msa.c", 622, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 622
      *(msa->gr + msa->ngr) = (char **)tmp___4;
#line 623
      i___0 = 0;
#line 623
      while (i___0 < msa->nseqalloc) {
#line 624
        *(*(msa->gr + msa->ngr) + i___0) = (char *)((void *)0);
#line 623
        i___0 ++;
      }
    }
  }
#line 628
  if (tagidx == msa->ngr) {
#line 629
    *(msa->gr_tag + tagidx) = sre_strdup(tag, -1);
#line 630
    (msa->ngr) ++;
  }
#line 632
  sre_strcat(*(msa->gr + tagidx) + sqidx, -1, value, -1);
#line 633
  return;
}
}
#line 661 "msa.c"
void MSAVerifyParse(MSA *msa ) 
{ 
  int idx ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
#line 666
  if (msa->nseq == 0) {
#line 666
    if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 666
      tmp = (char const   *)msa->name;
    } else {
#line 666
      tmp = "";
    }
#line 666
    Die((char *)"Parse error: no sequences were found for alignment %s", tmp);
  }
#line 669
  msa->alen = *(msa->sqlen + 0);
#line 675
  idx = 0;
#line 675
  while (idx < msa->nseq) {
#line 678
    if ((unsigned long )*(msa->aseq + idx) == (unsigned long )((void *)0)) {
#line 679
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 679
        tmp___0 = (char const   *)msa->name;
      } else {
#line 679
        tmp___0 = "";
      }
#line 679
      Die((char *)"Parse error: No sequence for %s in alignment %s", *(msa->sqname + idx),
          tmp___0);
    }
#line 682
    if (msa->flags & 1) {
#line 682
      if ((double )*(msa->wgt + idx) == - 1.0) {
#line 683
        if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 683
          tmp___1 = (char const   *)msa->name;
        } else {
#line 683
          tmp___1 = "";
        }
#line 683
        Die((char *)"Parse error: some weights are set, but %s doesn\'t have one in alignment %s",
            *(msa->sqname + idx), tmp___1);
      }
    }
#line 687
    if (*(msa->sqlen + idx) != msa->alen) {
#line 688
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 688
        tmp___2 = (char const   *)msa->name;
      } else {
#line 688
        tmp___2 = "";
      }
#line 688
      Die((char *)"Parse error: sequence %s: length %d, expected %d in alignment %s",
          *(msa->sqname + idx), *(msa->sqlen + idx), msa->alen, tmp___2);
    }
#line 692
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 692
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
#line 692
        if (*(msa->sslen + idx) != msa->alen) {
#line 693
          if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 693
            tmp___3 = (char const   *)msa->name;
          } else {
#line 693
            tmp___3 = "";
          }
#line 693
          Die((char *)"Parse error: #=GR SS annotation for %s: length %d, expected %d in alignment %s",
              *(msa->sqname + idx), *(msa->sslen + idx), msa->alen, tmp___3);
        }
      }
    }
#line 697
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 697
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
#line 697
        if (*(msa->salen + idx) != msa->alen) {
#line 698
          if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 698
            tmp___4 = (char const   *)msa->name;
          } else {
#line 698
            tmp___4 = "";
          }
#line 698
          Die((char *)"Parse error: #=GR SA annotation for %s: length %d, expected %d in alignment %s",
              *(msa->sqname + idx), *(msa->salen + idx), msa->alen, tmp___4);
        }
      }
    }
#line 675
    idx ++;
  }
#line 704
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 704
    tmp___7 = strlen((char const   *)msa->ss_cons);
#line 704
    if (tmp___7 != (size_t )msa->alen) {
#line 705
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 705
        tmp___5 = (char const   *)msa->name;
      } else {
#line 705
        tmp___5 = "";
      }
#line 705
      tmp___6 = strlen((char const   *)msa->ss_cons);
#line 705
      Die((char *)"Parse error: #=GC SS_cons annotation: length %d, expected %d in alignment %s",
          tmp___6, msa->alen, tmp___5);
    }
  }
#line 710
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 710
    tmp___10 = strlen((char const   *)msa->sa_cons);
#line 710
    if (tmp___10 != (size_t )msa->alen) {
#line 711
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 711
        tmp___8 = (char const   *)msa->name;
      } else {
#line 711
        tmp___8 = "";
      }
#line 711
      tmp___9 = strlen((char const   *)msa->sa_cons);
#line 711
      Die((char *)"Parse error: #=GC SA_cons annotation: length %d, expected %d in alignment %s",
          tmp___9, msa->alen, tmp___8);
    }
  }
#line 716
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 716
    tmp___13 = strlen((char const   *)msa->rf);
#line 716
    if (tmp___13 != (size_t )msa->alen) {
#line 717
      if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 717
        tmp___11 = (char const   *)msa->name;
      } else {
#line 717
        tmp___11 = "";
      }
#line 717
      tmp___12 = strlen((char const   *)msa->rf);
#line 717
      Die((char *)"Parse error: #=GC RF annotation: length %d, expected %d in alignment %s",
          tmp___12, msa->alen, tmp___11);
    }
  }
#line 722
  if (! (msa->flags & 1)) {
#line 723
    FSet(msa->wgt, msa->nseq, (float )1.0);
  }
#line 726
  if ((unsigned long )msa->sqlen != (unsigned long )((void *)0)) {
#line 726
    free((void *)msa->sqlen);
#line 726
    msa->sqlen = (int *)((void *)0);
  }
#line 727
  if ((unsigned long )msa->sslen != (unsigned long )((void *)0)) {
#line 727
    free((void *)msa->sslen);
#line 727
    msa->sslen = (int *)((void *)0);
  }
#line 728
  if ((unsigned long )msa->salen != (unsigned long )((void *)0)) {
#line 728
    free((void *)msa->salen);
#line 728
    msa->salen = (int *)((void *)0);
  }
#line 730
  return;
}
}
#line 755 "msa.c"
MSAFILE *MSAFileOpen(char *filename , int format , char *env ) 
{ 
  MSAFILE *afp ;
  void *tmp ;
  char *ssifile ;
  char *dir ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *full ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  FILE *tmp___5 ;
  FILE *tmp___6 ;
  int tmp___7 ;

  {
#line 760
  tmp = sre_malloc((char *)"msa.c", 760, sizeof(MSAFILE ));
#line 760
  afp = (MSAFILE *)tmp;
#line 761
  tmp___7 = strcmp((char const   *)filename, "-");
#line 761
  if (tmp___7 == 0) {
#line 763
    afp->f = stdin;
#line 764
    afp->do_stdin = 1;
#line 765
    afp->do_gzip = 0;
#line 766
    afp->fname = sre_strdup((char *)"[STDIN]", -1);
#line 767
    afp->ssi = (SSIFILE *)((void *)0);
  } else {
#line 804
    tmp___6 = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 804
    afp->f = tmp___6;
#line 804
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 806
      tmp___0 = strlen((char const   *)filename);
#line 806
      tmp___1 = sre_malloc((char *)"msa.c", 806, sizeof(char ) * (tmp___0 + 5UL));
#line 806
      ssifile = (char *)tmp___1;
#line 807
      sprintf((char * __restrict  )ssifile, (char const   * __restrict  )"%s.ssi",
              filename);
    } else {
#line 809
      tmp___5 = EnvFileOpen(filename, env, & dir);
#line 809
      afp->f = tmp___5;
#line 809
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 812
        full = FileConcat(dir, filename);
#line 813
        tmp___2 = strlen((char const   *)full);
#line 813
        tmp___3 = strlen((char const   *)filename);
#line 813
        tmp___4 = sre_malloc((char *)"msa.c", 813, sizeof(char ) * ((tmp___2 + tmp___3) + 5UL));
#line 813
        ssifile = (char *)tmp___4;
#line 814
        sprintf((char * __restrict  )ssifile, (char const   * __restrict  )"%s.ssi",
                full);
#line 815
        free((void *)dir);
      } else {
#line 817
        return ((MSAFILE *)((void *)0));
      }
    }
#line 819
    afp->do_stdin = 0;
#line 820
    afp->do_gzip = 0;
#line 821
    afp->fname = sre_strdup(filename, -1);
#line 822
    afp->ssi = (SSIFILE *)((void *)0);
#line 827
    SSIOpen(ssifile, & afp->ssi);
#line 828
    free((void *)ssifile);
  }
#line 834
  if (format == 0) {
#line 836
    if (afp->do_stdin == 1) {
#line 837
      Die((char *)"Can\'t autodetect alignment file format from a stdin or gzip pipe");
    } else
#line 836
    if (afp->do_gzip) {
#line 837
      Die((char *)"Can\'t autodetect alignment file format from a stdin or gzip pipe");
    }
#line 838
    format = MSAFileFormat(afp);
#line 839
    if (format == 0) {
#line 840
      Die((char *)"Can\'t determine format of multiple alignment file %s", afp->fname);
    }
  }
#line 843
  afp->format = format;
#line 844
  afp->linenumber = 0;
#line 845
  afp->buf = (char *)((void *)0);
#line 846
  afp->buflen = 0;
#line 848
  return (afp);
}
}
#line 872 "msa.c"
int MSAFileRewind(MSAFILE *afp ) 
{ 


  {
#line 875
  if (afp->do_gzip) {
#line 875
    return (0);
  } else
#line 875
  if (afp->do_stdin) {
#line 875
    return (0);
  }
#line 876
  rewind(afp->f);
#line 877
  return (1);
}
}
#line 879 "msa.c"
int MSAFilePositionByKey(MSAFILE *afp , char *key ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
#line 885
  if ((unsigned long )afp->ssi == (unsigned long )((void *)0)) {
#line 885
    return (0);
  }
#line 886
  tmp = SSIGetOffsetByName(afp->ssi, key, & fh, & offset);
#line 886
  if (tmp != 0) {
#line 886
    return (0);
  }
#line 887
  tmp___0 = SSISetFilePosition(afp->f, & offset);
#line 887
  if (tmp___0 != 0) {
#line 887
    return (0);
  }
#line 888
  return (1);
}
}
#line 890 "msa.c"
int MSAFilePositionByIndex(MSAFILE *afp , int idx ) 
{ 
  int fh ;
  SSIOFFSET offset ;
  int tmp ;
  int tmp___0 ;

  {
#line 896
  if ((unsigned long )afp->ssi == (unsigned long )((void *)0)) {
#line 896
    return (0);
  }
#line 897
  tmp = SSIGetOffsetByNumber(afp->ssi, idx, & fh, & offset);
#line 897
  if (tmp != 0) {
#line 897
    return (0);
  }
#line 898
  tmp___0 = SSISetFilePosition(afp->f, & offset);
#line 898
  if (tmp___0 != 0) {
#line 898
    return (0);
  }
#line 899
  return (1);
}
}
#line 913 "msa.c"
MSA *MSAFileRead(MSAFILE *afp ) 
{ 
  MSA *msa ;

  {
#line 916
  msa = (MSA *)((void *)0);
#line 918
  switch (afp->format) {
  case 101: 
#line 919
  msa = ReadStockholm(afp);
#line 919
  break;
  case 103: 
#line 920
  msa = ReadMSF(afp);
#line 920
  break;
  case 105: 
#line 921
  msa = ReadA2M(afp);
#line 921
  break;
  case 104: 
#line 922
  msa = ReadClustal(afp);
#line 922
  break;
  case 102: 
#line 923
  msa = ReadSELEX(afp);
#line 923
  break;
  case 106: 
#line 924
  msa = ReadPhylip(afp);
#line 924
  break;
  default: 
#line 926
  Die((char *)"MSAFILE corrupted: bad format index");
  }
#line 928
  return (msa);
}
}
#line 940 "msa.c"
void MSAFileClose(MSAFILE *afp ) 
{ 


  {
#line 947
  if (! afp->do_stdin) {
#line 947
    fclose(afp->f);
  }
#line 948
  if ((unsigned long )afp->buf != (unsigned long )((void *)0)) {
#line 948
    free((void *)afp->buf);
  }
#line 949
  if ((unsigned long )afp->ssi != (unsigned long )((void *)0)) {
#line 949
    SSIClose(afp->ssi);
  }
#line 950
  if ((unsigned long )afp->fname != (unsigned long )((void *)0)) {
#line 950
    free((void *)afp->fname);
  }
#line 951
  free((void *)afp);
#line 952
  return;
}
}
#line 954 "msa.c"
char *MSAFileGetLine(MSAFILE *afp ) 
{ 
  char *s___0 ;

  {
#line 958
  s___0 = sre_fgets(& afp->buf, & afp->buflen, afp->f);
#line 958
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 959
    return ((char *)((void *)0));
  }
#line 960
  (afp->linenumber) ++;
#line 961
  return (afp->buf);
}
}
#line 964 "msa.c"
void MSAFileWrite(FILE *fp , MSA *msa , int outfmt , int do_oneline ) 
{ 


  {
#line 967
  switch (outfmt) {
  case 105: 
#line 968
  WriteA2M(fp, msa);
#line 968
  break;
  case 104: 
#line 969
  WriteClustal(fp, msa);
#line 969
  break;
  case 103: 
#line 970
  WriteMSF(fp, msa);
#line 970
  break;
  case 106: 
#line 971
  WritePhylip(fp, msa);
#line 971
  break;
  case 102: 
#line 972
  WriteSELEX(fp, msa);
#line 972
  break;
  case 101: 
#line 974
  if (do_oneline) {
#line 974
    WriteStockholmOneBlock(fp, msa);
  } else {
#line 975
    WriteStockholm(fp, msa);
  }
#line 976
  break;
  default: 
#line 978
  Die((char *)"can\'t write. no such alignment format %d\n", outfmt);
  }
#line 980
  return;
}
}
#line 1000 "msa.c"
int MSAGetSeqidx(MSA *msa , char *name , int guess ) 
{ 
  int seqidx ;
  int tmp ;

  {
#line 1005
  if (guess >= 0) {
#line 1005
    if (guess < msa->nseq) {
#line 1005
      tmp = strcmp((char const   *)name, (char const   *)*(msa->sqname + guess));
#line 1005
      if (tmp == 0) {
#line 1006
        return (guess);
      }
    }
  }
#line 1008
  seqidx = GKIKeyIndex(msa->index, name);
#line 1008
  if (seqidx >= 0) {
#line 1009
    return (seqidx);
  }
#line 1011
  seqidx = GKIStoreKey(msa->index, name);
#line 1012
  if (seqidx >= msa->nseqalloc) {
#line 1012
    MSAExpand(msa);
  }
#line 1014
  *(msa->sqname + seqidx) = sre_strdup(name, -1);
#line 1015
  (msa->nseq) ++;
#line 1016
  return (seqidx);
}
}
#line 1032 "msa.c"
MSA *MSAFromAINFO(char **aseq , AINFO *ainfo ) 
{ 
  MSA *msa ;
  int i___0 ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1038
  msa = MSAAlloc(ainfo->nseq, ainfo->alen);
#line 1039
  i___0 = 0;
#line 1039
  while (i___0 < ainfo->nseq) {
#line 1041
    strcpy((char * __restrict  )*(msa->aseq + i___0), (char const   * __restrict  )*(aseq + i___0));
#line 1042
    *(msa->wgt + i___0) = *(ainfo->wgt + i___0);
#line 1043
    *(msa->sqname + i___0) = sre_strdup((ainfo->sqinfo + i___0)->name, -1);
#line 1044
    *(msa->sqlen + i___0) = msa->alen;
#line 1045
    GKIStoreKey(msa->index, *(msa->sqname + i___0));
#line 1047
    if ((ainfo->sqinfo + i___0)->flags & (1 << 2)) {
#line 1048
      MSASetSeqAccession(msa, i___0, (ainfo->sqinfo + i___0)->acc);
    }
#line 1050
    if ((ainfo->sqinfo + i___0)->flags & (1 << 3)) {
#line 1051
      MSASetSeqDescription(msa, i___0, (ainfo->sqinfo + i___0)->desc);
    }
#line 1053
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
#line 1054
      if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
#line 1055
        tmp = sre_malloc((char *)"msa.c", 1055, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 1055
        msa->ss = (char **)tmp;
#line 1056
        tmp___0 = sre_malloc((char *)"msa.c", 1056, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 1056
        msa->sslen = (int *)tmp___0;
#line 1057
        j = 0;
#line 1057
        while (j < msa->nseqalloc) {
#line 1058
          *(msa->ss + j) = (char *)((void *)0);
#line 1059
          *(msa->sslen + j) = 0;
#line 1057
          j ++;
        }
      }
#line 1062
      MakeAlignedString(*(msa->aseq + i___0), msa->alen, (ainfo->sqinfo + i___0)->ss,
                        msa->ss + i___0);
#line 1063
      *(msa->sslen + i___0) = msa->alen;
    }
#line 1066
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
#line 1067
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
#line 1068
        tmp___1 = sre_malloc((char *)"msa.c", 1068, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 1068
        msa->sa = (char **)tmp___1;
#line 1069
        tmp___2 = sre_malloc((char *)"msa.c", 1069, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 1069
        msa->salen = (int *)tmp___2;
#line 1070
        j = 0;
#line 1070
        while (j < msa->nseqalloc) {
#line 1071
          *(msa->sa + j) = (char *)((void *)0);
#line 1072
          *(msa->salen + j) = 0;
#line 1070
          j ++;
        }
      }
#line 1075
      MakeAlignedString(*(msa->aseq + i___0), msa->alen, (ainfo->sqinfo + i___0)->sa,
                        msa->sa + i___0);
#line 1076
      *(msa->salen + i___0) = msa->alen;
    }
#line 1039
    i___0 ++;
  }
#line 1080
  msa->name = sre_strdup(ainfo->name, -1);
#line 1081
  msa->desc = sre_strdup(ainfo->desc, -1);
#line 1082
  msa->acc = sre_strdup(ainfo->acc, -1);
#line 1083
  msa->au = sre_strdup(ainfo->au, -1);
#line 1084
  msa->ss_cons = sre_strdup(ainfo->cs, -1);
#line 1085
  msa->rf = sre_strdup(ainfo->rf, -1);
#line 1086
  if (ainfo->flags & 1) {
#line 1087
    msa->cutoff[0] = ainfo->tc1;
#line 1087
    msa->cutoff_is_set[0] = 1;
#line 1088
    msa->cutoff[1] = ainfo->tc2;
#line 1088
    msa->cutoff_is_set[1] = 1;
  }
#line 1090
  if (ainfo->flags & (1 << 1)) {
#line 1091
    msa->cutoff[4] = ainfo->nc1;
#line 1091
    msa->cutoff_is_set[4] = 1;
#line 1092
    msa->cutoff[5] = ainfo->nc2;
#line 1092
    msa->cutoff_is_set[5] = 1;
  }
#line 1094
  if (ainfo->flags & (1 << 2)) {
#line 1095
    msa->cutoff[2] = ainfo->ga1;
#line 1095
    msa->cutoff_is_set[2] = 1;
#line 1096
    msa->cutoff[3] = ainfo->ga2;
#line 1096
    msa->cutoff_is_set[3] = 1;
  }
#line 1098
  msa->nseq = ainfo->nseq;
#line 1099
  msa->alen = ainfo->alen;
#line 1100
  return (msa);
}
}
#line 1121 "msa.c"
int MSAFileFormat(MSAFILE *afp ) 
{ 
  int fmt ;
  char *tmp ;

  {
#line 1126
  fmt = SeqfileFormat(afp->f);
#line 1128
  if (fmt == 7) {
#line 1128
    fmt = 105;
  }
#line 1130
  if (fmt != 0) {
#line 1130
    if (! (fmt > 100)) {
#line 1131
      tmp = SeqfileFormat2String(fmt);
#line 1131
      Die((char *)"File %s does not appear to be an alignment file;\nrather, it appears to be an unaligned file in %s format.\nI\'m expecting an alignment file in this context.\n",
          afp->fname, tmp);
    }
  }
#line 1136
  return (fmt);
}
}
#line 1150 "msa.c"
void MSAMingap(MSA *msa ) 
{ 
  int *useme ;
  int apos ;
  int idx ;
  void *tmp ;

  {
#line 1157
  tmp = sre_malloc((char *)"msa.c", 1157, sizeof(int ) * (unsigned long )msa->alen);
#line 1157
  useme = (int *)tmp;
#line 1158
  apos = 0;
#line 1158
  while (apos < msa->alen) {
#line 1160
    idx = 0;
#line 1160
    while (idx < msa->nseq) {
#line 1161
      if (! ((int )*(*(msa->aseq + idx) + apos) == 32)) {
#line 1161
        if (! ((int )*(*(msa->aseq + idx) + apos) == 46)) {
#line 1161
          if (! ((int )*(*(msa->aseq + idx) + apos) == 95)) {
#line 1161
            if (! ((int )*(*(msa->aseq + idx) + apos) == 45)) {
#line 1161
              if (! ((int )*(*(msa->aseq + idx) + apos) == 126)) {
#line 1162
                break;
              }
            }
          }
        }
      }
#line 1160
      idx ++;
    }
#line 1163
    if (idx == msa->nseq) {
#line 1163
      *(useme + apos) = 0;
    } else {
#line 1163
      *(useme + apos) = 1;
    }
#line 1158
    apos ++;
  }
#line 1165
  MSAShorterAlignment(msa, useme);
#line 1166
  free((void *)useme);
#line 1167
  return;
}
}
#line 1182 "msa.c"
void MSANogap(MSA *msa ) 
{ 
  int *useme ;
  int apos ;
  int idx ;
  void *tmp ;

  {
#line 1189
  tmp = sre_malloc((char *)"msa.c", 1189, sizeof(int ) * (unsigned long )msa->alen);
#line 1189
  useme = (int *)tmp;
#line 1190
  apos = 0;
#line 1190
  while (apos < msa->alen) {
#line 1192
    idx = 0;
#line 1192
    while (idx < msa->nseq) {
#line 1193
      if ((int )*(*(msa->aseq + idx) + apos) == 32) {
#line 1194
        break;
      } else
#line 1193
      if ((int )*(*(msa->aseq + idx) + apos) == 46) {
#line 1194
        break;
      } else
#line 1193
      if ((int )*(*(msa->aseq + idx) + apos) == 95) {
#line 1194
        break;
      } else
#line 1193
      if ((int )*(*(msa->aseq + idx) + apos) == 45) {
#line 1194
        break;
      } else
#line 1193
      if ((int )*(*(msa->aseq + idx) + apos) == 126) {
#line 1194
        break;
      }
#line 1192
      idx ++;
    }
#line 1195
    if (idx == msa->nseq) {
#line 1195
      *(useme + apos) = 1;
    } else {
#line 1195
      *(useme + apos) = 0;
    }
#line 1190
    apos ++;
  }
#line 1197
  MSAShorterAlignment(msa, useme);
#line 1198
  free((void *)useme);
#line 1199
  return;
}
}
#line 1218 "msa.c"
void MSAShorterAlignment(MSA *msa , int *useme ) 
{ 
  int apos ;
  int mpos ;
  int idx ;
  int i___0 ;

  {
#line 1229
  apos = 0;
#line 1229
  mpos = 0;
#line 1229
  while (apos < msa->alen) {
#line 1231
    if (*(useme + apos) == 0) {
#line 1231
      goto __Cont;
    }
#line 1234
    if (mpos != apos) {
#line 1236
      idx = 0;
#line 1236
      while (idx < msa->nseq) {
#line 1238
        *(*(msa->aseq + idx) + mpos) = *(*(msa->aseq + idx) + apos);
#line 1239
        if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 1239
          if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
#line 1239
            *(*(msa->ss + idx) + mpos) = *(*(msa->ss + idx) + apos);
          }
        }
#line 1240
        if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 1240
          if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
#line 1240
            *(*(msa->sa + idx) + mpos) = *(*(msa->sa + idx) + apos);
          }
        }
#line 1242
        i___0 = 0;
#line 1242
        while (i___0 < msa->ngr) {
#line 1243
          if ((unsigned long )*(*(msa->gr + i___0) + idx) != (unsigned long )((void *)0)) {
#line 1243
            *(*(*(msa->gr + i___0) + idx) + mpos) = *(*(*(msa->gr + i___0) + idx) + apos);
          }
#line 1242
          i___0 ++;
        }
#line 1236
        idx ++;
      }
#line 1246
      if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 1246
        *(msa->ss_cons + mpos) = *(msa->ss_cons + apos);
      }
#line 1247
      if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 1247
        *(msa->sa_cons + mpos) = *(msa->sa_cons + apos);
      }
#line 1248
      if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 1248
        *(msa->rf + mpos) = *(msa->rf + apos);
      }
#line 1250
      i___0 = 0;
#line 1250
      while (i___0 < msa->ngc) {
#line 1251
        *(*(msa->gc + i___0) + mpos) = *(*(msa->gc + i___0) + apos);
#line 1250
        i___0 ++;
      }
    }
#line 1253
    mpos ++;
    __Cont: /* CIL Label */ 
#line 1229
    apos ++;
  }
#line 1256
  msa->alen = mpos;
#line 1258
  idx = 0;
#line 1258
  while (idx < msa->nseq) {
#line 1260
    *(*(msa->aseq + idx) + mpos) = (char )'\000';
#line 1261
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 1261
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
#line 1261
        *(*(msa->ss + idx) + mpos) = (char )'\000';
      }
    }
#line 1262
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 1262
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
#line 1262
        *(*(msa->sa + idx) + mpos) = (char )'\000';
      }
    }
#line 1264
    i___0 = 0;
#line 1264
    while (i___0 < msa->ngr) {
#line 1265
      if ((unsigned long )*(*(msa->gr + i___0) + idx) != (unsigned long )((void *)0)) {
#line 1265
        *(*(*(msa->gr + i___0) + idx) + mpos) = (char )'\000';
      }
#line 1264
      i___0 ++;
    }
#line 1258
    idx ++;
  }
#line 1268
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 1268
    *(msa->ss_cons + mpos) = (char )'\000';
  }
#line 1269
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 1269
    *(msa->sa_cons + mpos) = (char )'\000';
  }
#line 1270
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 1270
    *(msa->rf + mpos) = (char )'\000';
  }
#line 1272
  i___0 = 0;
#line 1272
  while (i___0 < msa->ngc) {
#line 1273
    *(*(msa->gc + i___0) + mpos) = (char )'\000';
#line 1272
    i___0 ++;
  }
#line 1275
  return;
}
}
#line 1305 "msa.c"
void MSASmallerAlignment(MSA *msa , int *useme , MSA **ret_new ) 
{ 
  MSA *new ;
  int nnew ;
  int oidx ;
  int nidx ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1313
  nnew = 0;
#line 1314
  oidx = 0;
#line 1314
  while (oidx < msa->nseq) {
#line 1315
    if (*(useme + oidx)) {
#line 1315
      nnew ++;
    }
#line 1314
    oidx ++;
  }
#line 1316
  if (nnew == 0) {
#line 1316
    *ret_new = (MSA *)((void *)0);
#line 1316
    return;
  }
#line 1318
  new = MSAAlloc(nnew, 0);
#line 1319
  nidx = 0;
#line 1320
  oidx = 0;
#line 1320
  while (oidx < msa->nseq) {
#line 1321
    if (*(useme + oidx)) {
#line 1323
      *(new->aseq + nidx) = sre_strdup(*(msa->aseq + oidx), msa->alen);
#line 1324
      *(new->sqname + nidx) = sre_strdup(*(msa->sqname + oidx), msa->alen);
#line 1325
      GKIStoreKey(new->index, *(msa->sqname + oidx));
#line 1326
      *(new->wgt + nidx) = *(msa->wgt + oidx);
#line 1327
      if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 1328
        MSASetSeqAccession(new, nidx, *(msa->sqacc + oidx));
      }
#line 1329
      if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 1330
        MSASetSeqDescription(new, nidx, *(msa->sqdesc + oidx));
      }
#line 1331
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 1331
        if ((unsigned long )*(msa->ss + oidx) != (unsigned long )((void *)0)) {
#line 1333
          if ((unsigned long )new->ss == (unsigned long )((void *)0)) {
#line 1333
            tmp = sre_malloc((char *)"msa.c", 1333, sizeof(char *) * (unsigned long )new->nseq);
#line 1333
            new->ss = (char **)tmp;
          }
#line 1334
          *(new->ss + nidx) = sre_strdup(*(msa->ss + oidx), -1);
        }
      }
#line 1336
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 1336
        if ((unsigned long )*(msa->sa + oidx) != (unsigned long )((void *)0)) {
#line 1338
          if ((unsigned long )new->sa == (unsigned long )((void *)0)) {
#line 1338
            tmp___0 = sre_malloc((char *)"msa.c", 1338, sizeof(char *) * (unsigned long )new->nseq);
#line 1338
            new->sa = (char **)tmp___0;
          }
#line 1339
          *(new->sa + nidx) = sre_strdup(*(msa->sa + oidx), -1);
        }
      }
#line 1341
      nidx ++;
    }
#line 1320
    oidx ++;
  }
#line 1344
  new->nseq = nnew;
#line 1345
  new->alen = msa->alen;
#line 1346
  new->flags = msa->flags;
#line 1347
  new->type = msa->type;
#line 1348
  new->name = sre_strdup(msa->name, -1);
#line 1349
  new->desc = sre_strdup(msa->desc, -1);
#line 1350
  new->acc = sre_strdup(msa->acc, -1);
#line 1351
  new->au = sre_strdup(msa->au, -1);
#line 1352
  new->ss_cons = sre_strdup(msa->ss_cons, -1);
#line 1353
  new->sa_cons = sre_strdup(msa->sa_cons, -1);
#line 1354
  new->rf = sre_strdup(msa->rf, -1);
#line 1355
  i___0 = 0;
#line 1355
  while (i___0 < 6) {
#line 1356
    new->cutoff[i___0] = msa->cutoff[i___0];
#line 1357
    new->cutoff_is_set[i___0] = msa->cutoff_is_set[i___0];
#line 1355
    i___0 ++;
  }
#line 1359
  free((void *)new->sqlen);
#line 1361
  MSAMingap(new);
#line 1362
  *ret_new = new;
#line 1363
  return;
}
}
#line 1377 "msa.c"
char *MSAGetSeqAccession(MSA *msa , int idx ) 
{ 


  {
#line 1380
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 1380
    if ((unsigned long )*(msa->sqacc + idx) != (unsigned long )((void *)0)) {
#line 1381
      return (*(msa->sqacc + idx));
    } else {
#line 1383
      return ((char *)((void *)0));
    }
  } else {
#line 1383
    return ((char *)((void *)0));
  }
}
}
#line 1385 "msa.c"
char *MSAGetSeqDescription(MSA *msa , int idx ) 
{ 


  {
#line 1388
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 1388
    if ((unsigned long )*(msa->sqdesc + idx) != (unsigned long )((void *)0)) {
#line 1389
      return (*(msa->sqdesc + idx));
    } else {
#line 1391
      return ((char *)((void *)0));
    }
  } else {
#line 1391
    return ((char *)((void *)0));
  }
}
}
#line 1393 "msa.c"
char *MSAGetSeqSS(MSA *msa , int idx ) 
{ 


  {
#line 1396
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 1396
    if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
#line 1397
      return (*(msa->ss + idx));
    } else {
#line 1399
      return ((char *)((void *)0));
    }
  } else {
#line 1399
    return ((char *)((void *)0));
  }
}
}
#line 1401 "msa.c"
char *MSAGetSeqSA(MSA *msa , int idx ) 
{ 


  {
#line 1404
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 1404
    if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
#line 1405
      return (*(msa->sa + idx));
    } else {
#line 1407
      return ((char *)((void *)0));
    }
  } else {
#line 1407
    return ((char *)((void *)0));
  }
}
}
#line 1427 "msa.c"
float MSAAverageSequenceLength(MSA *msa ) 
{ 
  int i___0 ;
  float avg ;
  int tmp ;

  {
#line 1433
  avg = (float )0.;
#line 1434
  i___0 = 0;
#line 1434
  while (i___0 < msa->nseq) {
#line 1435
    tmp = DealignedLength(*(msa->aseq + i___0));
#line 1435
    avg += (float )tmp;
#line 1434
    i___0 ++;
  }
#line 1437
  if (msa->nseq == 0) {
#line 1437
    return ((float )0.);
  } else {
#line 1438
    return (avg / (float )msa->nseq);
  }
}
}
#line 1 "msf.o"
#pragma merger("0","/tmp/cil-nTSSHZUh.i","")
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 175 "./sqfuncs.h"
int GCGchecksum(char *seq , int len ) ;
#line 176
int GCGMultchecksum(char **seqs , int nseq ) ;
#line 180
int GuessAlignmentSeqtype(char **aseq , int nseq ) ;
#line 231
int IsBlankline(char *s___0 ) ;
#line 81 "msf.c"
MSA *ReadMSF(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int alleged_alen ;
  int alleged_type ;
  int alleged_checksum ;
  char *tok ;
  char *sp ;
  int slen ;
  int sqidx ;
  char *name ;
  char *seq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
#line 96
  tmp = feof(afp->f);
#line 96
  if (tmp) {
#line 96
    return ((MSA *)((void *)0));
  }
#line 97
  s___0 = MSAFileGetLine(afp);
#line 97
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 97
    return ((MSA *)((void *)0));
  }
#line 104
  msa = MSAAlloc(10, 0);
#line 105
  tmp___1 = strncmp((char const   *)s___0, "!!AA_MULTIPLE_ALIGNMENT", (size_t )23);
#line 105
  if (tmp___1 == 0) {
#line 106
    msa->type = 3;
#line 107
    s___0 = MSAFileGetLine(afp);
#line 107
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 107
      return ((MSA *)((void *)0));
    }
  } else {
#line 108
    tmp___0 = strncmp((char const   *)s___0, "!!NA_MULTIPLE_ALIGNMENT", (size_t )23);
#line 108
    if (tmp___0 == 0) {
#line 109
      msa->type = 2;
#line 110
      s___0 = MSAFileGetLine(afp);
#line 110
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 110
        return ((MSA *)((void *)0));
      }
    }
  }
#line 117
  while (1) {
#line 119
    tmp___2 = strstr((char const   *)s___0, "..");
#line 119
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 119
      tmp___3 = strstr((char const   *)s___0, "MSF:");
#line 119
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 119
        tmp___4 = Strparse((char *)"^.+MSF: +([0-9]+) +Type: +([PNX]).+Check: +([0-9]+) +\\.\\.",
                           s___0, 3);
#line 119
        if (tmp___4) {
#line 122
          alleged_alen = atoi((char const   *)sqd_parse[0]);
#line 123
          switch ((int )*(sqd_parse[1])) {
          case 78: 
#line 124
          alleged_type = 2;
#line 124
          break;
          case 80: 
#line 125
          alleged_type = 3;
#line 125
          break;
          case 88: 
#line 126
          alleged_type = 0;
#line 126
          break;
          default: 
#line 127
          alleged_type = 0;
          }
#line 129
          alleged_checksum = atoi((char const   *)sqd_parse[3]);
#line 130
          if (msa->type == 0) {
#line 130
            msa->type = alleged_type;
          }
#line 131
          break;
        }
      }
    }
#line 133
    tmp___5 = IsBlankline(s___0);
#line 133
    if (! tmp___5) {
#line 134
      MSAAddComment(msa, s___0);
    }
#line 117
    s___0 = MSAFileGetLine(afp);
#line 117
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 117
      break;
    }
  }
#line 146
  while (1) {
#line 146
    s___0 = MSAFileGetLine(afp);
#line 146
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 146
      break;
    }
#line 148
    while (1) {
#line 148
      if ((int )*s___0 == 32) {
#line 148
        goto _L;
      } else
#line 148
      if ((int )*s___0 == 9) {
        _L: /* CIL Label */ 
#line 148
        if (! *s___0) {
#line 148
          break;
        }
      } else {
#line 148
        break;
      }
#line 148
      s___0 ++;
    }
#line 150
    if ((int )*s___0 == 10) {
#line 150
      continue;
    } else
#line 151
    if ((int )*s___0 == 33) {
#line 151
      MSAAddComment(msa, s___0);
    } else {
#line 152
      sp = strstr((char const   *)s___0, "Name:");
#line 152
      if ((unsigned long )sp != (unsigned long )((void *)0)) {
#line 155
        sp += 5;
#line 156
        tok = sre_strtok(& sp, (char *)" \t", & slen);
#line 157
        sqidx = GKIStoreKey(msa->index, tok);
#line 158
        if (sqidx >= msa->nseqalloc) {
#line 158
          MSAExpand(msa);
        }
#line 159
        *(msa->sqname + sqidx) = sre_strdup(tok, slen);
#line 160
        (msa->nseq) ++;
#line 162
        sp = strstr((char const   *)sp, "Weight:");
#line 162
        if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 163
          Die((char *)"No Weight: on line %d for %s in name section of MSF file %s\n",
              afp->linenumber, *(msa->sqname + sqidx), afp->fname);
        }
#line 165
        sp += 7;
#line 166
        tok = sre_strtok(& sp, (char *)" \t", & slen);
#line 167
        tmp___6 = atof((char const   *)tok);
#line 167
        *(msa->wgt + sqidx) = (float )tmp___6;
#line 168
        msa->flags |= 1;
      } else {
#line 170
        tmp___7 = strncmp((char const   *)s___0, "//", (size_t )2);
#line 170
        if (tmp___7 == 0) {
#line 171
          break;
        } else {
#line 174
          Die((char *)"Invalid line (probably %d) in name section of MSF file %s:\n%s\n",
              afp->linenumber, afp->fname, s___0);
#line 176
          squid_errno = 5;
#line 177
          return ((MSA *)((void *)0));
        }
      }
    }
  }
#line 187
  while (1) {
#line 187
    s___0 = MSAFileGetLine(afp);
#line 187
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 187
      break;
    }
#line 189
    sp = s___0;
#line 190
    name = sre_strtok(& sp, (char *)" \t", (int *)((void *)0));
#line 190
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 190
      continue;
    }
#line 191
    seq = sre_strtok(& sp, (char *)"\n", & slen);
#line 191
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 191
      continue;
    }
#line 195
    tmp___8 = __ctype_b_loc();
#line 195
    if ((int const   )*(*tmp___8 + (int )*name) & 2048) {
#line 195
      tmp___9 = __ctype_b_loc();
#line 195
      if ((int const   )*(*tmp___9 + (int )*seq) & 2048) {
#line 196
        continue;
      }
    }
#line 200
    sqidx = GKIKeyIndex(msa->index, name);
#line 201
    if (sqidx < 0) {
#line 201
      continue;
    }
#line 203
    *(msa->sqlen + sqidx) = sre_strcat(msa->aseq + sqidx, *(msa->sqlen + sqidx), seq,
                                       slen);
  }
#line 208
  sqidx = 0;
#line 208
  while (sqidx < msa->nseq) {
#line 210
    if ((unsigned long )*(msa->aseq + sqidx) == (unsigned long )((void *)0)) {
#line 211
      Die((char *)"Didn\'t find a sequence for %s in MSF file %s\n", *(msa->sqname + sqidx),
          afp->fname);
    }
#line 213
    sp = *(msa->aseq + sqidx);
#line 213
    s___0 = sp;
#line 213
    while ((int )*s___0 != 0) {
#line 215
      if ((int )*s___0 == 32) {
#line 216
        (*(msa->sqlen + sqidx)) --;
      } else
#line 215
      if ((int )*s___0 == 9) {
#line 216
        (*(msa->sqlen + sqidx)) --;
      } else {
#line 218
        *sp = *s___0;
#line 219
        sp ++;
      }
#line 213
      s___0 ++;
    }
#line 222
    *sp = (char )'\000';
#line 208
    sqidx ++;
  }
#line 225
  MSAVerifyParse(msa);
#line 226
  return (msa);
}
}
#line 244 "msf.c"
void WriteMSF(FILE *fp , MSA *msa ) 
{ 
  time_t now ;
  char date[64] ;
  char **gcg_aseq ;
  char **gcg_sqname ;
  int idx ;
  char *s___0 ;
  int len ;
  int namelen ;
  int pos ;
  char buffer___1[51] ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  struct tm *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 273
  tmp = sre_malloc((char *)"msf.c", 273, sizeof(char *) * (unsigned long )msa->nseq);
#line 273
  gcg_aseq = (char **)tmp;
#line 274
  tmp___0 = sre_malloc((char *)"msf.c", 274, sizeof(char *) * (unsigned long )msa->nseq);
#line 274
  gcg_sqname = (char **)tmp___0;
#line 275
  idx = 0;
#line 275
  while (idx < msa->nseq) {
#line 277
    *(gcg_aseq + idx) = sre_strdup(*(msa->aseq + idx), msa->alen);
#line 278
    *(gcg_sqname + idx) = sre_strdup(*(msa->sqname + idx), -1);
#line 275
    idx ++;
  }
#line 281
  idx = 0;
#line 281
  while (idx < msa->nseq) {
#line 282
    s___0 = *(gcg_sqname + idx);
#line 282
    while ((int )*s___0 != 0) {
#line 283
      tmp___1 = __ctype_b_loc();
#line 283
      if (! ((int const   )*(*tmp___1 + (int )*s___0) & 8)) {
#line 283
        if ((int )*s___0 != 45) {
#line 283
          if ((int )*s___0 != 95) {
#line 284
            *s___0 = (char )'_';
          }
        }
      }
#line 282
      s___0 ++;
    }
#line 281
    idx ++;
  }
#line 286
  idx = 0;
#line 286
  while (idx < msa->nseq) {
#line 288
    s___0 = *(gcg_aseq + idx);
#line 288
    while (1) {
#line 288
      if ((int )*s___0 != 0) {
#line 288
        if (! ((int )*s___0 == 32)) {
#line 288
          if (! ((int )*s___0 == 46)) {
#line 288
            if (! ((int )*s___0 == 95)) {
#line 288
              if (! ((int )*s___0 == 45)) {
#line 288
                if (! ((int )*s___0 == 126)) {
#line 288
                  break;
                }
              }
            }
          }
        }
      } else {
#line 288
        break;
      }
#line 289
      *s___0 = (char )'~';
#line 288
      s___0 ++;
    }
#line 290
    while ((int )*s___0 != 0) {
#line 291
      if ((int )*s___0 == 32) {
#line 291
        *s___0 = (char )'.';
      } else
#line 291
      if ((int )*s___0 == 46) {
#line 291
        *s___0 = (char )'.';
      } else
#line 291
      if ((int )*s___0 == 95) {
#line 291
        *s___0 = (char )'.';
      } else
#line 291
      if ((int )*s___0 == 45) {
#line 291
        *s___0 = (char )'.';
      } else
#line 291
      if ((int )*s___0 == 126) {
#line 291
        *s___0 = (char )'.';
      }
#line 290
      s___0 ++;
    }
#line 292
    pos = msa->alen - 1;
#line 292
    while (1) {
#line 292
      if (pos > 0) {
#line 292
        if (! ((int )*(*(gcg_aseq + idx) + pos) == 32)) {
#line 292
          if (! ((int )*(*(gcg_aseq + idx) + pos) == 46)) {
#line 292
            if (! ((int )*(*(gcg_aseq + idx) + pos) == 95)) {
#line 292
              if (! ((int )*(*(gcg_aseq + idx) + pos) == 45)) {
#line 292
                if (! ((int )*(*(gcg_aseq + idx) + pos) == 126)) {
#line 292
                  break;
                }
              }
            }
          }
        }
      } else {
#line 292
        break;
      }
#line 293
      *(*(gcg_aseq + idx) + pos) = (char )'~';
#line 292
      pos --;
    }
#line 286
    idx ++;
  }
#line 296
  namelen = 0;
#line 297
  idx = 0;
#line 297
  while (idx < msa->nseq) {
#line 298
    tmp___2 = strlen((char const   *)*(msa->sqname + idx));
#line 298
    len = (int )tmp___2;
#line 298
    if (len > namelen) {
#line 299
      namelen = len;
    }
#line 297
    idx ++;
  }
#line 305
  if (msa->type == 0) {
#line 306
    msa->type = GuessAlignmentSeqtype(msa->aseq, msa->nseq);
  }
#line 308
  if (msa->type == 2) {
#line 308
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"!!NA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
#line 309
  if (msa->type == 1) {
#line 309
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"!!NA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
#line 310
  if (msa->type == 3) {
#line 310
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"!!AA_MULTIPLE_ALIGNMENT 1.0\n");
  } else
#line 311
  if (msa->type == 0) {
#line 312
    Die((char *)"WriteMSF(): couldn\'t guess whether that alignment is RNA or protein.\n");
  } else {
#line 314
    Die((char *)"Invalid sequence type %d in WriteMSF()\n", msa->type);
  }
#line 317
  if (msa->ncomment > 0) {
#line 319
    idx = 0;
#line 319
    while (idx < msa->ncomment) {
#line 320
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", *(msa->comment + idx));
#line 319
      idx ++;
    }
#line 321
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 324
  now = time((time_t *)((void *)0));
#line 325
  tmp___3 = localtime((time_t const   *)(& now));
#line 325
  tmp___4 = strftime((char * __restrict  )(date), (size_t )64, (char const   * __restrict  )"%B %d, %Y %H:%M",
                     (struct tm  const  * __restrict  )tmp___3);
#line 325
  if (tmp___4 == 0UL) {
#line 326
    Die((char *)"What time is it on earth? strftime() failed in WriteMSF().\n");
  }
#line 327
  tmp___5 = GCGMultchecksum(gcg_aseq, msa->nseq);
#line 327
  if (msa->type == 2) {
#line 327
    tmp___6 = 'N';
  } else {
#line 327
    tmp___6 = 'P';
  }
#line 327
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 327
    tmp___7 = (char const   *)msa->name;
  } else {
#line 327
    tmp___7 = "squid.msf";
  }
#line 327
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %s  MSF: %d  Type: %c  %s  Check: %d  ..\n",
          tmp___7, msa->alen, tmp___6, date, tmp___5);
#line 333
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 339
  idx = 0;
#line 339
  while (idx < msa->nseq) {
#line 341
    tmp___8 = GCGchecksum(*(gcg_aseq + idx), msa->alen);
#line 341
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" Name: %-*.*s  Len:  %5d  Check: %4d  Weight: %.2f\n",
            namelen, namelen, *(gcg_sqname + idx), msa->alen, tmp___8, (double )*(msa->wgt + idx));
#line 339
    idx ++;
  }
#line 348
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 349
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"//\n");
#line 355
  pos = 0;
#line 355
  while (pos < msa->alen) {
#line 357
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 360
    if (pos + 50 > msa->alen) {
#line 360
      len = msa->alen - pos;
    } else {
#line 360
      len = 50;
    }
#line 361
    if (len > 10) {
#line 362
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s  %-6d%*s%6d\n",
              namelen, "", pos + 1, (len + (len - 1) / 10) - 12, "", pos + len);
    } else {
#line 367
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%*s  %-6d\n",
              namelen, "", pos + 1);
    }
#line 369
    idx = 0;
#line 369
    while (idx < msa->nseq) {
#line 371
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*s ", namelen,
              *(gcg_sqname + idx));
#line 373
      strncpy((char * __restrict  )(buffer___1), (char const   * __restrict  )(*(gcg_aseq + idx) + pos),
              (size_t )50);
#line 374
      buffer___1[50] = (char )'\000';
#line 376
      i___0 = 0;
#line 376
      while (i___0 < len) {
#line 378
        if (! (i___0 % 10)) {
#line 378
          fputc(' ', fp);
        }
#line 379
        fputc((int )buffer___1[i___0], fp);
#line 376
        i___0 ++;
      }
#line 381
      fputc('\n', fp);
#line 369
      idx ++;
    }
#line 355
    pos += 50;
  }
#line 385
  Free2DArray((void **)gcg_aseq, msa->nseq);
#line 386
  Free2DArray((void **)gcg_sqname, msa->nseq);
#line 387
  return;
}
}
#line 1 "phylip.o"
#pragma merger("0","/tmp/cil-BjZ1kyGv.i","")
#line 75 "phylip.c"
MSA *ReadPhylip(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  char *s1 ;
  char *s2 ;
  char name[11] ;
  int nseq ;
  int alen ;
  int idx ;
  int slen ;
  int nblock ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 86
  tmp = feof(afp->f);
#line 86
  if (tmp) {
#line 86
    return ((MSA *)((void *)0));
  }
#line 91
  nseq = 0;
#line 91
  alen = 0;
#line 92
  while (1) {
#line 92
    s___0 = MSAFileGetLine(afp);
#line 92
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 92
      break;
    }
#line 94
    s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 94
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 94
      continue;
    }
#line 95
    s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 95
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 96
      Die((char *)"Failed to parse nseq/alen from first line of PHYLIP file %s\n",
          afp->fname);
    }
#line 97
    tmp___0 = IsInt(s1);
#line 97
    if (tmp___0) {
#line 97
      tmp___1 = IsInt(s2);
#line 97
      if (! tmp___1) {
#line 98
        Die((char *)"nseq and/or alen not an integer in first line of PHYLIP file %s\n",
            afp->fname);
      }
    } else {
#line 98
      Die((char *)"nseq and/or alen not an integer in first line of PHYLIP file %s\n",
          afp->fname);
    }
#line 99
    nseq = atoi((char const   *)s1);
#line 100
    alen = atoi((char const   *)s2);
#line 101
    break;
  }
#line 104
  msa = MSAAlloc(nseq, 0);
#line 105
  idx = 0;
#line 106
  nblock = 0;
#line 107
  while (1) {
#line 107
    s___0 = MSAFileGetLine(afp);
#line 107
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 107
      break;
    }
#line 110
    tmp___2 = __ctype_b_loc();
#line 110
    if ((int const   )*(*tmp___2 + (int )*s___0) & 8192) {
#line 110
      continue;
    }
#line 112
    if (nblock == 0) {
#line 113
      strncpy((char * __restrict  )(name), (char const   * __restrict  )s___0, (size_t )10);
#line 114
      name[10] = (char )'\000';
#line 115
      GKIStoreKey(msa->index, name);
#line 116
      *(msa->sqname + idx) = sre_strdup(name, -1);
#line 117
      s___0 += 10;
    }
#line 120
    s1 = sre_strtok(& s___0, (char *)" \t\n", & slen);
#line 120
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 121
      Die((char *)"Failed to parse sequence at line %d of PHYLIP file %s\n", afp->linenumber,
          afp->fname);
    }
#line 123
    *(msa->sqlen + idx) = sre_strcat(msa->aseq + idx, *(msa->sqlen + idx), s1, slen);
#line 125
    idx ++;
#line 126
    if (idx == nseq) {
#line 126
      idx = 0;
#line 126
      nblock ++;
    }
  }
#line 128
  msa->nseq = nseq;
#line 129
  MSAVerifyParse(msa);
#line 130
  return (msa);
}
}
#line 145 "phylip.c"
void WritePhylip(FILE *fp , MSA *msa ) 
{ 
  int idx ;
  int cpl ;
  char buf[51] ;
  int pos ;

  {
#line 149
  cpl = 50;
#line 155
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %d  %d\n", msa->nseq,
          msa->alen);
#line 163
  pos = 0;
#line 163
  while (pos < msa->alen) {
#line 165
    if (pos > 0) {
#line 165
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 167
    idx = 0;
#line 167
    while (idx < msa->nseq) {
#line 169
      strncpy((char * __restrict  )(buf), (char const   * __restrict  )(*(msa->aseq + idx) + pos),
              (size_t )cpl);
#line 170
      buf[cpl] = (char )'\000';
#line 171
      if (pos > 0) {
#line 171
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", buf);
      } else {
#line 172
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-10.10s%s\n",
                *(msa->sqname + idx), buf);
      }
#line 167
      idx ++;
    }
#line 163
    pos += cpl;
  }
#line 175
  return;
}
}
#line 1 "revcomp.o"
#pragma merger("0","/tmp/cil-QDCYBCHf.i","")
#line 115 "./sqfuncs.h"
char *revcomp(char *comp , char *seq ) ;
#line 141
int StrReverse(char *s1 , char *s2 ) ;
#line 192
int sre_tolower(int c ) ;
#line 34 "revcomp.c"
char *revcomp(char *comp , char *seq ) 
{ 
  char *s___0 ;
  char c ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 40
  if ((unsigned long )comp == (unsigned long )((void *)0)) {
#line 40
    return ((char *)((void *)0));
  }
#line 41
  if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 41
    return ((char *)((void *)0));
  }
#line 43
  StrReverse(comp, seq);
#line 44
  s___0 = comp;
#line 44
  while ((int )*s___0 != 0) {
#line 46
    c = *s___0;
#line 47
    tmp = sre_toupper((int )c);
#line 47
    c = (char )tmp;
#line 48
    switch ((int )c) {
    case 65: 
#line 49
    c = (char )'T';
#line 49
    break;
    case 67: 
#line 50
    c = (char )'G';
#line 50
    break;
    case 71: 
#line 51
    c = (char )'C';
#line 51
    break;
    case 84: 
#line 52
    c = (char )'A';
#line 52
    break;
    case 85: 
#line 53
    c = (char )'A';
#line 53
    break;
    case 82: 
#line 54
    c = (char )'Y';
#line 54
    break;
    case 89: 
#line 55
    c = (char )'R';
#line 55
    break;
    case 77: 
#line 56
    c = (char )'K';
#line 56
    break;
    case 75: 
#line 57
    c = (char )'M';
#line 57
    break;
    case 83: 
#line 58
    c = (char )'S';
#line 58
    break;
    case 87: 
#line 59
    c = (char )'W';
#line 59
    break;
    case 72: 
#line 60
    c = (char )'D';
#line 60
    break;
    case 68: 
#line 61
    c = (char )'H';
#line 61
    break;
    case 66: 
#line 62
    c = (char )'V';
#line 62
    break;
    case 86: 
#line 63
    c = (char )'B';
#line 63
    break;
    default: 
#line 64
    break;
    }
#line 66
    tmp___1 = __ctype_b_loc();
#line 66
    if ((int const   )*(*tmp___1 + (int )*s___0) & 512) {
#line 66
      tmp___0 = sre_tolower((int )c);
#line 66
      c = (char )tmp___0;
    }
#line 67
    *s___0 = c;
#line 44
    s___0 ++;
  }
#line 69
  return (comp);
}
}
#line 1 "rk.o"
#pragma merger("0","/tmp/cil-JCIMF86H.i","")
#line 129 "./sqfuncs.h"
int seqencode(char *codeseq , char *str ) ;
#line 35 "./rk.h"
int rkseq(Hashseq hashprobe , char *sequence ) ;
#line 36
Hashseq rkcomp(char *probe ) ;
#line 33 "rk.c"
Hashseq rkcomp(char *probe ) 
{ 
  Hashseq hashprobe ;
  char coded[sizeof(Hashseq ) * 2UL + 1UL] ;
  int len ;
  int i___0 ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 36
  hashprobe = (Hashseq )0;
#line 41
  tmp = strlen((char const   *)probe);
#line 41
  len = (int )tmp;
#line 41
  if ((unsigned long )len > sizeof(Hashseq ) * 2UL) {
#line 41
    return ((Hashseq )0);
  }
#line 43
  tmp___0 = seqencode(coded, probe);
#line 43
  if (tmp___0 == 0) {
#line 43
    return ((Hashseq )0);
  }
#line 45
  i___0 = 0;
#line 45
  while (i___0 < len) {
#line 47
    hashprobe <<= 4;
#line 48
    hashprobe |= (Hashseq )coded[i___0];
#line 45
    i___0 ++;
  }
#line 51
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
#line 53
    hashprobe <<= 4;
#line 54
    hashprobe |= 15UL;
#line 51
    i___0 ++;
  }
#line 57
  return (hashprobe);
}
}
#line 60 "rk.c"
int rkseq(Hashseq hashprobe , char *sequence ) 
{ 
  long i___0 ;
  long pos ;
  Hashseq target ;

  {
#line 65
  pos = 0L;
#line 66
  target = (Hashseq )0;
#line 69
  i___0 = 0L;
#line 69
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
#line 71
    if ((int )*(sequence + i___0) == 0) {
#line 72
      break;
    }
#line 73
    target <<= 4;
#line 74
    target |= (Hashseq )*(sequence + i___0);
#line 69
    i___0 ++;
  }
#line 77
  while ((int )*(((sequence + pos) + sizeof(Hashseq ) * 2UL) - 1) != 0) {
#line 88
    if ((hashprobe & target) == target) {
#line 89
      return ((int )pos);
    }
#line 90
    target <<= 4;
#line 91
    target |= (Hashseq )*((sequence + pos) + sizeof(Hashseq ) * 2UL);
#line 92
    pos ++;
  }
#line 95
  i___0 = 0L;
#line 95
  while ((unsigned long )i___0 < sizeof(Hashseq ) * 2UL) {
#line 97
    target |= 15UL;
#line 98
    if ((hashprobe & target) == target) {
#line 99
      return ((int )pos);
    }
#line 100
    target <<= 4;
#line 101
    pos ++;
#line 95
    i___0 ++;
  }
#line 104
  return (-1);
}
}
#line 1 "selex.o"
#pragma merger("0","/tmp/cil-0OAQ_Kj_.i","")
#line 290 "./msa.h"
void WriteSELEXOneBlock(FILE *fp , MSA *msa ) ;
#line 120 "./sqfuncs.h"
int DealignAseqs(char **aseqs , int num , char ***ret_rseqs ) ;
#line 121
int IsSELEXFormat(char *filename ) ;
#line 159
int SetSeqinfoString(SQINFO *sqinfo , char *sptr___0 , int flag ) ;
#line 49 "selex.c"
static int copy_alignment_line(char *aseq , int apos , int name_rcol , char *buffer___1 ,
                               int lcol , int rcol , char gapsym ) ;
#line 51
static void actually_write_selex(FILE *fp , MSA *msa , int cpl ) ;
#line 53 "selex.c"
static char commentsyms[3]  = {      (char )'%',      (char )'#',      (char )'\000'};
#line 82 "selex.c"
MSA *ReadSELEX(MSAFILE *afp ) 
{ 
  MSA *msa ;
  FILE *fp ;
  char **aseqs ;
  int num ;
  char buffer___1[4096] ;
  char bufcpy[4096] ;
  struct block_struc *blocks ;
  int blocknum ;
  char *nptr ;
  char *sptr___0 ;
  int currnum ;
  int currblock ;
  int i___0 ;
  int seqidx ;
  int alen ;
  int warn_names ;
  int headnum ;
  int currlen ;
  int count ;
  int have_cs ;
  int have_rf ;
  AINFO base_ainfo ;
  AINFO *ainfo ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  char *tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  double tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  size_t tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  int apos ;
  int rpos ;

  {
#line 88
  num = 0;
#line 91
  blocks = (struct block_struc *)((void *)0);
#line 107
  have_cs = 0;
#line 108
  have_rf = 0;
#line 116
  tmp = feof(afp->f);
#line 116
  if (tmp) {
#line 116
    return ((MSA *)((void *)0));
  }
#line 117
  if (afp->do_gzip) {
#line 118
    Die((char *)"Can\'t read a SELEX format alignment from a pipe, stdin, or gzip\'ed file");
  } else
#line 117
  if (afp->do_stdin) {
#line 118
    Die((char *)"Can\'t read a SELEX format alignment from a pipe, stdin, or gzip\'ed file");
  }
#line 119
  fp = afp->f;
#line 120
  ainfo = & base_ainfo;
#line 128
  InitAinfo(ainfo);
#line 131
  while (1) {
#line 133
    tmp___0 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 133
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 134
      squid_errno = 2;
#line 134
      return ((MSA *)0);
    }
#line 135
    strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 136
    if ((int )buffer___1[0] == 35) {
#line 138
      tmp___2 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
#line 138
      if (tmp___2 == 0) {
#line 138
        have_cs = 1;
      } else {
#line 139
        tmp___1 = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
#line 139
        if (tmp___1 == 0) {
#line 139
          have_rf = 1;
        }
      }
    }
#line 131
    nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 131
    if (! ((unsigned long )nptr == (unsigned long )((void *)0))) {
#line 131
      tmp___3 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 131
      if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 131
        break;
      }
    }
  }
#line 145
  blocknum = 0;
#line 146
  warn_names = 0;
#line 147
  while (1) {
#line 147
    tmp___19 = feof(fp);
#line 147
    if (tmp___19) {
#line 147
      break;
    }
#line 150
    if (blocknum == 0) {
#line 151
      tmp___4 = sre_malloc((char *)"selex.c", 151, sizeof(struct block_struc ));
#line 151
      blocks = (struct block_struc *)tmp___4;
    } else {
#line 153
      tmp___5 = sre_realloc((char *)"selex.c", 153, (void *)blocks, (unsigned long )(blocknum + 1) * sizeof(struct block_struc ));
#line 153
      blocks = (struct block_struc *)tmp___5;
    }
#line 154
    (blocks + blocknum)->lcol = 4097;
#line 155
    (blocks + blocknum)->rcol = -1;
#line 157
    currnum = 0;
#line 158
    while ((unsigned long )nptr != (unsigned long )((void *)0)) {
#line 161
      if (blocknum == 0) {
#line 163
        if (currnum == 0) {
#line 164
          tmp___6 = sre_malloc((char *)"selex.c", 164, sizeof(SQINFO ));
#line 164
          ainfo->sqinfo = (SQINFO *)tmp___6;
        } else {
#line 166
          tmp___7 = sre_realloc((char *)"selex.c", 166, (void *)ainfo->sqinfo, (unsigned long )(currnum + 1) * sizeof(SQINFO ));
#line 166
          ainfo->sqinfo = (SQINFO *)tmp___7;
        }
#line 168
        (ainfo->sqinfo + currnum)->flags = 0;
#line 169
        SetSeqinfoString(ainfo->sqinfo + currnum, nptr, 1);
      } else {
#line 173
        tmp___8 = strcmp((char const   *)((ainfo->sqinfo + currnum)->name), (char const   *)nptr);
#line 173
        if (tmp___8 != 0) {
#line 174
          warn_names = 1;
        }
      }
#line 176
      currnum ++;
#line 179
      sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 179
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 183
        if (sptr___0 - bufcpy < (long )(blocks + blocknum)->lcol) {
#line 184
          (blocks + blocknum)->lcol = (int )(sptr___0 - bufcpy);
        }
#line 186
        tmp___9 = strlen((char const   *)(buffer___1));
#line 186
        sptr___0 = (buffer___1 + tmp___9) - 1;
#line 186
        while (1) {
#line 186
          tmp___10 = strchr(" \t\n", (int )*sptr___0);
#line 186
          if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 186
            break;
          }
#line 186
          sptr___0 --;
        }
#line 190
        if (sptr___0 - buffer___1 > (long )(blocks + blocknum)->rcol) {
#line 191
          (blocks + blocknum)->rcol = (int )(sptr___0 - buffer___1);
        }
      }
#line 195
      while (1) {
#line 197
        tmp___11 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 197
        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 198
          nptr = (char *)((void *)0);
#line 198
          break;
        }
#line 199
        strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 201
        tmp___15 = strncmp((char const   *)(buffer___1), "#=SS", (size_t )4);
#line 201
        if (tmp___15 == 0) {
#line 201
          (ainfo->sqinfo + (currnum - 1))->flags |= 1 << 9;
        } else {
#line 202
          tmp___14 = strncmp((char const   *)(buffer___1), "#=SA", (size_t )4);
#line 202
          if (tmp___14 == 0) {
#line 202
            (ainfo->sqinfo + (currnum - 1))->flags |= 1 << 10;
          } else {
#line 203
            tmp___13 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
#line 203
            if (tmp___13 == 0) {
#line 203
              have_cs = 1;
            } else {
#line 204
              tmp___12 = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
#line 204
              if (tmp___12 == 0) {
#line 204
                have_rf = 1;
              }
            }
          }
        }
#line 206
        nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 206
        if ((unsigned long )nptr == (unsigned long )((void *)0)) {
#line 207
          break;
        }
#line 195
        tmp___16 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 195
        if (! ((unsigned long )tmp___16 != (unsigned long )((void *)0))) {
#line 195
          break;
        }
      }
    }
#line 213
    if (blocknum == 0) {
#line 214
      num = currnum;
    } else
#line 215
    if (currnum != num) {
#line 216
      Die((char *)"Parse error in ReadSELEX()");
    }
#line 217
    blocknum ++;
#line 221
    while (1) {
#line 223
      tmp___17 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 223
      if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
#line 223
        nptr = (char *)((void *)0);
#line 223
        break;
      }
#line 224
      strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 221
      nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 221
      if (! ((unsigned long )nptr == (unsigned long )((void *)0))) {
#line 221
        tmp___18 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 221
        if (! ((unsigned long )tmp___18 != (unsigned long )((void *)0))) {
#line 221
          break;
        }
      }
    }
  }
#line 238
  alen = 0;
#line 239
  currblock = 0;
#line 239
  while (currblock < blocknum) {
#line 240
    alen += ((blocks + currblock)->rcol - (blocks + currblock)->lcol) + 1;
#line 239
    currblock ++;
  }
#line 242
  rewind(fp);
#line 247
  tmp___20 = sre_malloc((char *)"selex.c", 247, (unsigned long )num * sizeof(char *));
#line 247
  aseqs = (char **)tmp___20;
#line 248
  if (have_cs) {
#line 249
    tmp___21 = sre_malloc((char *)"selex.c", 249, (unsigned long )(alen + 1) * sizeof(char ));
#line 249
    ainfo->cs = (char *)tmp___21;
  }
#line 250
  if (have_rf) {
#line 251
    tmp___22 = sre_malloc((char *)"selex.c", 251, (unsigned long )(alen + 1) * sizeof(char ));
#line 251
    ainfo->rf = (char *)tmp___22;
  }
#line 255
  i___0 = 0;
#line 255
  while (i___0 < num) {
#line 257
    tmp___23 = sre_malloc((char *)"selex.c", 257, (unsigned long )(alen + 1) * sizeof(char ));
#line 257
    *(aseqs + i___0) = (char *)tmp___23;
#line 258
    if ((ainfo->sqinfo + i___0)->flags & (1 << 9)) {
#line 259
      tmp___24 = sre_malloc((char *)"selex.c", 259, (unsigned long )(alen + 1) * sizeof(char ));
#line 259
      (ainfo->sqinfo + i___0)->ss = (char *)tmp___24;
    }
#line 260
    if ((ainfo->sqinfo + i___0)->flags & (1 << 10)) {
#line 261
      tmp___25 = sre_malloc((char *)"selex.c", 261, (unsigned long )(alen + 1) * sizeof(char ));
#line 261
      (ainfo->sqinfo + i___0)->sa = (char *)tmp___25;
    }
#line 255
    i___0 ++;
  }
#line 264
  ainfo->alen = alen;
#line 265
  ainfo->nseq = num;
#line 266
  tmp___26 = sre_malloc((char *)"selex.c", 266, sizeof(float ) * (unsigned long )num);
#line 266
  ainfo->wgt = (float *)tmp___26;
#line 267
  FSet(ainfo->wgt, num, (float )1.0);
#line 281
  headnum = 0;
#line 282
  while (1) {
#line 284
    tmp___27 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 284
    if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
#line 285
      Die((char *)"Parse error in ReadSELEX()");
    }
#line 286
    strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 287
    nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 287
    if ((unsigned long )nptr == (unsigned long )((void *)0)) {
#line 287
      goto __Cont;
    }
#line 289
    tmp___47 = strcmp((char const   *)nptr, "#=AU");
#line 289
    if (tmp___47 == 0) {
#line 289
      sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 289
      if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 290
        ainfo->au = Strdup(sptr___0);
      } else {
#line 289
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 291
      tmp___46 = strcmp((char const   *)nptr, "#=ID");
#line 291
      if (tmp___46 == 0) {
#line 291
        sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 291
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 292
          ainfo->name = Strdup(sptr___0);
        } else {
#line 291
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 293
        tmp___45 = strcmp((char const   *)nptr, "#=AC");
#line 293
        if (tmp___45 == 0) {
#line 293
          sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 293
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 294
            ainfo->acc = Strdup(sptr___0);
          } else {
#line 293
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 295
          tmp___44 = strcmp((char const   *)nptr, "#=DE");
#line 295
          if (tmp___44 == 0) {
#line 295
            sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 295
            if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 296
              ainfo->desc = Strdup(sptr___0);
            } else {
#line 295
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 297
            tmp___43 = strcmp((char const   *)nptr, "#=GA");
#line 297
            if (tmp___43 == 0) {
#line 299
              sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 299
              if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 300
                Die((char *)"Parse error in #=GA line in ReadSELEX()");
              }
#line 301
              tmp___28 = atof((char const   *)sptr___0);
#line 301
              ainfo->ga1 = (float )tmp___28;
#line 303
              sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 303
              if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 304
                Die((char *)"Parse error in #=GA line in ReadSELEX()");
              }
#line 305
              tmp___29 = atof((char const   *)sptr___0);
#line 305
              ainfo->ga2 = (float )tmp___29;
#line 307
              ainfo->flags |= 1 << 2;
            } else {
#line 309
              tmp___42 = strcmp((char const   *)nptr, "#=TC");
#line 309
              if (tmp___42 == 0) {
#line 311
                sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 311
                if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 312
                  Die((char *)"Parse error in #=TC line in ReadSELEX()");
                }
#line 313
                tmp___30 = atof((char const   *)sptr___0);
#line 313
                ainfo->tc1 = (float )tmp___30;
#line 315
                sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 315
                if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 316
                  Die((char *)"Parse error in #=TC line in ReadSELEX()");
                }
#line 317
                tmp___31 = atof((char const   *)sptr___0);
#line 317
                ainfo->tc2 = (float )tmp___31;
#line 319
                ainfo->flags |= 1;
              } else {
#line 321
                tmp___41 = strcmp((char const   *)nptr, "#=NC");
#line 321
                if (tmp___41 == 0) {
#line 323
                  sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 323
                  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 324
                    Die((char *)"Parse error in #=NC line in ReadSELEX()");
                  }
#line 325
                  tmp___32 = atof((char const   *)sptr___0);
#line 325
                  ainfo->nc1 = (float )tmp___32;
#line 327
                  sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 327
                  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 328
                    Die((char *)"Parse error in #=NC line in ReadSELEX()");
                  }
#line 329
                  tmp___33 = atof((char const   *)sptr___0);
#line 329
                  ainfo->nc2 = (float )tmp___33;
#line 331
                  ainfo->flags |= 1 << 1;
                } else {
#line 333
                  tmp___40 = strcmp((char const   *)nptr, "#=SQ");
#line 333
                  if (tmp___40 == 0) {
#line 336
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 336
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 337
                      Die((char *)"Parse error in #=SQ line in ReadSELEX()");
                    }
#line 338
                    tmp___34 = strcmp((char const   *)sptr___0, (char const   *)((ainfo->sqinfo + headnum)->name));
#line 338
                    if (tmp___34 != 0) {
#line 338
                      warn_names = 1;
                    }
#line 341
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 341
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 342
                      Die((char *)"Parse error in #=SQ line in ReadSELEX()");
                    }
#line 343
                    tmp___35 = IsReal(sptr___0);
#line 343
                    if (! tmp___35) {
#line 344
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): weight is not a number");
                    }
#line 345
                    tmp___36 = atof((char const   *)sptr___0);
#line 345
                    *(ainfo->wgt + headnum) = (float )tmp___36;
#line 348
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 348
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 349
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
#line 350
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 1);
#line 353
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 353
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 354
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
#line 355
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 2);
#line 358
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )".:");
#line 358
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 359
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
#line 360
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 4);
#line 362
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )".:");
#line 362
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 363
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
#line 364
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 5);
#line 366
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )":\t ");
#line 366
                    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 367
                      Die((char *)"Parse error in #=SQ line in ReadSELEX(): incomplete line");
                    }
#line 368
                    SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 8);
#line 371
                    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 371
                    if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 372
                      SetSeqinfoString(ainfo->sqinfo + headnum, sptr___0, 1 << 3);
                    }
#line 374
                    headnum ++;
                  } else {
#line 376
                    tmp___39 = strcmp((char const   *)nptr, "#=CS");
#line 376
                    if (tmp___39 == 0) {
#line 376
                      break;
                    } else {
#line 377
                      tmp___38 = strcmp((char const   *)nptr, "#=RF");
#line 377
                      if (tmp___38 == 0) {
#line 377
                        break;
                      } else {
#line 378
                        tmp___37 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 378
                        if ((unsigned long )tmp___37 == (unsigned long )((void *)0)) {
#line 378
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
#line 382
  currlen = 0;
#line 383
  currblock = 0;
#line 383
  while (currblock < blocknum) {
#line 386
    seqidx = 0;
#line 387
    while ((unsigned long )nptr != (unsigned long )((void *)0)) {
#line 390
      tmp___62 = strcmp((char const   *)nptr, "#=CS");
#line 390
      if (tmp___62 == 0) {
#line 392
        tmp___48 = strlen((char const   *)nptr);
#line 392
        tmp___49 = copy_alignment_line(ainfo->cs, currlen, (int )(tmp___48 - 1UL),
                                       buffer___1, (blocks + currblock)->lcol, (blocks + currblock)->rcol,
                                       (char )'.');
#line 392
        if (! tmp___49) {
#line 394
          Die((char *)"Parse error in #=CS line in ReadSELEX()");
        }
      } else {
#line 398
        tmp___61 = strcmp((char const   *)nptr, "#=RF");
#line 398
        if (tmp___61 == 0) {
#line 400
          tmp___50 = strlen((char const   *)nptr);
#line 400
          tmp___51 = copy_alignment_line(ainfo->rf, currlen, (int )(tmp___50 - 1UL),
                                         buffer___1, (blocks + currblock)->lcol, (blocks + currblock)->rcol,
                                         (char )'.');
#line 400
          if (! tmp___51) {
#line 402
            Die((char *)"Parse error in #=RF line in ReadSELEX()");
          }
        } else {
#line 405
          tmp___60 = strcmp((char const   *)nptr, "#=SS");
#line 405
          if (tmp___60 == 0) {
#line 407
            tmp___52 = strlen((char const   *)nptr);
#line 407
            tmp___53 = copy_alignment_line((ainfo->sqinfo + (seqidx - 1))->ss, currlen,
                                           (int )(tmp___52 - 1UL), buffer___1, (blocks + currblock)->lcol,
                                           (blocks + currblock)->rcol, (char )'.');
#line 407
            if (! tmp___53) {
#line 410
              Die((char *)"Parse error in #=SS line in ReadSELEX()");
            }
          } else {
#line 414
            tmp___59 = strcmp((char const   *)nptr, "#=SA");
#line 414
            if (tmp___59 == 0) {
#line 416
              tmp___54 = strlen((char const   *)nptr);
#line 416
              tmp___55 = copy_alignment_line((ainfo->sqinfo + (seqidx - 1))->sa, currlen,
                                             (int )(tmp___54 - 1UL), buffer___1, (blocks + currblock)->lcol,
                                             (blocks + currblock)->rcol, (char )'.');
#line 416
              if (! tmp___55) {
#line 419
                Die((char *)"Parse error in #=SA line in ReadSELEX()");
              }
            } else {
#line 422
              tmp___58 = strncmp((char const   *)nptr, "#=", (size_t )2);
#line 422
              if (tmp___58 != 0) {
#line 424
                tmp___56 = strlen((char const   *)nptr);
#line 424
                tmp___57 = copy_alignment_line(*(aseqs + seqidx), currlen, (int )(tmp___56 - 1UL),
                                               buffer___1, (blocks + currblock)->lcol,
                                               (blocks + currblock)->rcol, (char )'.');
#line 424
                if (! tmp___57) {
#line 426
                  Die((char *)"Parse error in alignment line in ReadSELEX()");
                }
#line 427
                seqidx ++;
              }
            }
          }
        }
      }
#line 431
      while (1) {
#line 433
        nptr = (char *)((void *)0);
#line 434
        tmp___63 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 434
        if ((unsigned long )tmp___63 == (unsigned long )((void *)0)) {
#line 434
          break;
        }
#line 435
        strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 436
        nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 436
        if ((unsigned long )nptr == (unsigned long )((void *)0)) {
#line 436
          break;
        }
#line 437
        tmp___64 = strncmp((char const   *)(buffer___1), "#=", (size_t )2);
#line 437
        if (tmp___64 == 0) {
#line 437
          break;
        }
#line 438
        tmp___65 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 438
        if ((unsigned long )tmp___65 == (unsigned long )((void *)0)) {
#line 438
          break;
        }
      }
    }
#line 442
    currlen += ((blocks + currblock)->rcol - (blocks + currblock)->lcol) + 1;
#line 445
    while (1) {
#line 447
      tmp___66 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 447
      if ((unsigned long )tmp___66 == (unsigned long )((void *)0)) {
#line 447
        break;
      }
#line 448
      strcpy((char * __restrict  )(bufcpy), (char const   * __restrict  )(buffer___1));
#line 449
      nptr = strtok((char * __restrict  )(bufcpy), (char const   * __restrict  )" \t\n");
#line 449
      if ((unsigned long )nptr == (unsigned long )((void *)0)) {
#line 449
        goto __Cont___0;
      }
#line 450
      tmp___67 = strncmp((char const   *)(buffer___1), "#=", (size_t )2);
#line 450
      if (tmp___67 == 0) {
#line 450
        break;
      }
#line 451
      tmp___68 = strchr((char const   *)(commentsyms), (int )*nptr);
#line 451
      if ((unsigned long )tmp___68 == (unsigned long )((void *)0)) {
#line 451
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
#line 383
    currblock ++;
  }
#line 459
  seqidx = 0;
#line 459
  while (seqidx < num) {
#line 463
    if ((ainfo->sqinfo + seqidx)->flags & (1 << 9)) {
#line 465
      rpos = 0;
#line 465
      apos = rpos;
#line 465
      while (apos < alen) {
#line 466
        if (! ((int )*(*(aseqs + seqidx) + apos) == 32)) {
#line 466
          if (! ((int )*(*(aseqs + seqidx) + apos) == 46)) {
#line 466
            if (! ((int )*(*(aseqs + seqidx) + apos) == 95)) {
#line 466
              if (! ((int )*(*(aseqs + seqidx) + apos) == 45)) {
#line 466
                if (! ((int )*(*(aseqs + seqidx) + apos) == 126)) {
#line 468
                  *((ainfo->sqinfo + seqidx)->ss + rpos) = *((ainfo->sqinfo + seqidx)->ss + apos);
#line 469
                  rpos ++;
                }
              }
            }
          }
        }
#line 465
        apos ++;
      }
#line 471
      *((ainfo->sqinfo + seqidx)->ss + rpos) = (char )'\000';
    }
#line 474
    if ((ainfo->sqinfo + seqidx)->flags & (1 << 10)) {
#line 476
      rpos = 0;
#line 476
      apos = rpos;
#line 476
      while (apos < alen) {
#line 477
        if (! ((int )*(*(aseqs + seqidx) + apos) == 32)) {
#line 477
          if (! ((int )*(*(aseqs + seqidx) + apos) == 46)) {
#line 477
            if (! ((int )*(*(aseqs + seqidx) + apos) == 95)) {
#line 477
              if (! ((int )*(*(aseqs + seqidx) + apos) == 45)) {
#line 477
                if (! ((int )*(*(aseqs + seqidx) + apos) == 126)) {
#line 479
                  *((ainfo->sqinfo + seqidx)->sa + rpos) = *((ainfo->sqinfo + seqidx)->sa + apos);
#line 480
                  rpos ++;
                }
              }
            }
          }
        }
#line 476
        apos ++;
      }
#line 482
      *((ainfo->sqinfo + seqidx)->sa + rpos) = (char )'\000';
    }
#line 459
    seqidx ++;
  }
#line 487
  if ((unsigned long )ainfo->rf != (unsigned long )((void *)0)) {
#line 487
    *(ainfo->rf + alen) = (char )'\000';
  }
#line 488
  if ((unsigned long )ainfo->cs != (unsigned long )((void *)0)) {
#line 488
    *(ainfo->cs + alen) = (char )'\000';
  }
#line 489
  seqidx = 0;
#line 489
  while (seqidx < num) {
#line 490
    *(*(aseqs + seqidx) + alen) = (char )'\000';
#line 489
    seqidx ++;
  }
#line 493
  seqidx = 0;
#line 493
  while (seqidx < num) {
#line 495
    count = 0;
#line 496
    sptr___0 = *(aseqs + seqidx);
#line 496
    while ((int )*sptr___0 != 0) {
#line 497
      if (! ((int )*sptr___0 == 32)) {
#line 497
        if (! ((int )*sptr___0 == 46)) {
#line 497
          if (! ((int )*sptr___0 == 95)) {
#line 497
            if (! ((int )*sptr___0 == 45)) {
#line 497
              if (! ((int )*sptr___0 == 126)) {
#line 497
                count ++;
              }
            }
          }
        }
      }
#line 496
      sptr___0 ++;
    }
#line 498
    (ainfo->sqinfo + seqidx)->len = count;
#line 499
    (ainfo->sqinfo + seqidx)->flags |= 1 << 6;
#line 493
    seqidx ++;
  }
#line 506
  free((void *)blocks);
#line 507
  if (warn_names) {
#line 508
    Warn((char *)"sequences may be in different orders in blocks of %s?", afp->fname);
  }
#line 512
  msa = MSAFromAINFO(aseqs, ainfo);
#line 513
  MSAVerifyParse(msa);
#line 514
  FreeAlignment(aseqs, ainfo);
#line 515
  return (msa);
}
}
#line 529 "selex.c"
void WriteSELEX(FILE *fp , MSA *msa ) 
{ 


  {
#line 532
  actually_write_selex(fp, msa, 50);
#line 533
  return;
}
}
#line 546 "selex.c"
void WriteSELEXOneBlock(FILE *fp , MSA *msa ) 
{ 


  {
#line 549
  actually_write_selex(fp, msa, msa->alen);
#line 550
  return;
}
}
#line 567 "selex.c"
static void actually_write_selex(FILE *fp , MSA *msa , int cpl ) 
{ 
  int i___0 ;
  int len ;
  int namewidth ;
  char *buf ;
  int currpos ;
  void *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 571
  len = 0;
#line 576
  tmp = malloc(sizeof(char ) * (unsigned long )(cpl + 101));
#line 576
  buf = (char *)tmp;
#line 583
  namewidth = 0;
#line 584
  i___0 = 0;
#line 584
  while (i___0 < msa->nseq) {
#line 585
    tmp___0 = strlen((char const   *)*(msa->sqname + i___0));
#line 585
    len = (int )tmp___0;
#line 585
    if (len > namewidth) {
#line 586
      namewidth = len;
    }
#line 584
    i___0 ++;
  }
#line 587
  if (namewidth < 6) {
#line 587
    namewidth = 6;
  }
#line 591
  i___0 = 0;
#line 591
  while (i___0 < msa->ncomment) {
#line 592
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# %s\n", *(msa->comment + i___0));
#line 591
    i___0 ++;
  }
#line 593
  if (msa->ncomment > 0) {
#line 593
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 597
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 597
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=ID %s\n", msa->name);
  }
#line 598
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
#line 598
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=AC %s\n", msa->acc);
  }
#line 599
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
#line 599
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=DE %s\n", msa->desc);
  }
#line 600
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
#line 600
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=AU %s\n", msa->au);
  }
#line 604
  if (msa->cutoff_is_set[2]) {
#line 604
    if (msa->cutoff_is_set[3]) {
#line 605
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GA %.1f %.1f\n",
              (double )msa->cutoff[2], (double )msa->cutoff[3]);
    } else {
#line 604
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 606
  if (msa->cutoff_is_set[2]) {
#line 607
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GA %.1f\n", (double )msa->cutoff[2]);
  }
#line 608
  if (msa->cutoff_is_set[4]) {
#line 608
    if (msa->cutoff_is_set[5]) {
#line 609
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=NC %.1f %.1f\n",
              (double )msa->cutoff[4], (double )msa->cutoff[5]);
    } else {
#line 608
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 610
  if (msa->cutoff_is_set[4]) {
#line 611
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=NC %.1f\n", (double )msa->cutoff[4]);
  }
#line 612
  if (msa->cutoff_is_set[0]) {
#line 612
    if (msa->cutoff_is_set[1]) {
#line 613
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=TC %.1f %.1f\n",
              (double )msa->cutoff[0], (double )msa->cutoff[1]);
    } else {
#line 612
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 614
  if (msa->cutoff_is_set[0]) {
#line 615
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=TC %.1f\n", (double )msa->cutoff[0]);
  }
#line 619
  i___0 = 0;
#line 619
  while (i___0 < msa->nseq) {
#line 620
    if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 620
      if ((unsigned long )*(msa->sqdesc + i___0) != (unsigned long )((void *)0)) {
#line 620
        tmp___1 = (char const   *)*(msa->sqdesc + i___0);
      } else {
#line 620
        tmp___1 = "-";
      }
    } else {
#line 620
      tmp___1 = "-";
    }
#line 620
    if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 620
      if ((unsigned long )*(msa->sqacc + i___0) != (unsigned long )((void *)0)) {
#line 620
        tmp___2 = (char const   *)*(msa->sqacc + i___0);
      } else {
#line 620
        tmp___2 = "-";
      }
    } else {
#line 620
      tmp___2 = "-";
    }
#line 620
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=SQ %-*.*s %6.4f %s %s %d..%d::%d %s\n",
            namewidth, namewidth, *(msa->sqname + i___0), (double )*(msa->wgt + i___0),
            "-", tmp___2, 0, 0, 0, tmp___1);
#line 619
    i___0 ++;
  }
#line 627
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 631
  currpos = 0;
#line 631
  while (currpos < msa->alen) {
#line 633
    if (currpos > 0) {
#line 633
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 635
    if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 636
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(msa->ss_cons + currpos),
              (size_t )cpl);
#line 637
      *(buf + cpl) = (char )'\000';
#line 638
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s %s\n",
              namewidth, namewidth, "#=CS", buf);
    }
#line 640
    if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 641
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(msa->rf + currpos),
              (size_t )cpl);
#line 642
      *(buf + cpl) = (char )'\000';
#line 643
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s %s\n",
              namewidth, namewidth, "#=RF", buf);
    }
#line 645
    i___0 = 0;
#line 645
    while (i___0 < msa->nseq) {
#line 647
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->aseq + i___0) + currpos),
              (size_t )cpl);
#line 648
      *(buf + cpl) = (char )'\000';
#line 649
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s %s\n",
              namewidth, namewidth, *(msa->sqname + i___0), buf);
#line 651
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 651
        if ((unsigned long )*(msa->ss + i___0) != (unsigned long )((void *)0)) {
#line 652
          strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->ss + i___0) + currpos),
                  (size_t )cpl);
#line 653
          *(buf + cpl) = (char )'\000';
#line 654
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s %s\n",
                  namewidth, namewidth, "#=SS", buf);
        }
      }
#line 656
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 656
        if ((unsigned long )*(msa->sa + i___0) != (unsigned long )((void *)0)) {
#line 657
          strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->sa + i___0) + currpos),
                  (size_t )cpl);
#line 658
          *(buf + cpl) = (char )'\000';
#line 659
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s %s\n",
                  namewidth, namewidth, "#=SA", buf);
        }
      }
#line 645
      i___0 ++;
    }
#line 631
    currpos += cpl;
  }
#line 663
  free((void *)buf);
#line 664
  return;
}
}
#line 677 "selex.c"
static int copy_alignment_line(char *aseq , int apos , int name_rcol , char *buffer___1 ,
                               int lcol , int rcol , char gapsym ) 
{ 
  char *s1 ;
  char *s2 ;
  int i___0 ;

  {
#line 684
  s1 = aseq + apos;
#line 685
  s2 = buffer___1;
#line 686
  i___0 = 0;
#line 686
  while (i___0 < lcol) {
#line 687
    if (*s2) {
#line 687
      s2 ++;
    }
#line 686
    i___0 ++;
  }
#line 689
  i___0 = lcol;
#line 689
  while (i___0 <= rcol) {
#line 691
    if ((int )*s2 == 9) {
#line 692
      Warn((char *)"TAB characters will corrupt a SELEX alignment! Please remove them first.");
#line 693
      return (0);
    }
#line 695
    if (name_rcol >= i___0) {
#line 696
      *s1 = gapsym;
    } else
#line 698
    if ((int )*s2 == 0) {
#line 699
      *s1 = gapsym;
    } else
#line 698
    if ((int )*s2 == 10) {
#line 699
      *s1 = gapsym;
    } else
#line 701
    if ((int )*s2 == 32) {
#line 702
      *s1 = gapsym;
    } else {
#line 705
      *s1 = *s2;
    }
#line 707
    s1 ++;
#line 708
    if (*s2) {
#line 708
      s2 ++;
    }
#line 689
    i___0 ++;
  }
#line 710
  return (1);
}
}
#line 728 "selex.c"
int DealignAseqs(char **aseqs , int num , char ***ret_rseqs ) 
{ 
  char **rseqs ;
  int idx ;
  int depos ;
  int apos ;
  int seqlen ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 738
  tmp = sre_malloc((char *)"selex.c", 738, (unsigned long )num * sizeof(char *));
#line 738
  rseqs = (char **)tmp;
#line 740
  idx = 0;
#line 740
  while (idx < num) {
#line 742
    tmp___0 = strlen((char const   *)*(aseqs + idx));
#line 742
    seqlen = (int )tmp___0;
#line 744
    tmp___1 = sre_malloc((char *)"selex.c", 744, (unsigned long )(seqlen + 1) * sizeof(char ));
#line 744
    *(rseqs + idx) = (char *)tmp___1;
#line 747
    depos = 0;
#line 748
    apos = 0;
#line 748
    while ((int )*(*(aseqs + idx) + apos) != 0) {
#line 749
      if (! ((int )*(*(aseqs + idx) + apos) == 32)) {
#line 749
        if (! ((int )*(*(aseqs + idx) + apos) == 46)) {
#line 749
          if (! ((int )*(*(aseqs + idx) + apos) == 95)) {
#line 749
            if (! ((int )*(*(aseqs + idx) + apos) == 45)) {
#line 749
              if (! ((int )*(*(aseqs + idx) + apos) == 126)) {
#line 751
                *(*(rseqs + idx) + depos) = *(*(aseqs + idx) + apos);
#line 752
                depos ++;
              }
            }
          }
        }
      }
#line 748
      apos ++;
    }
#line 754
    *(*(rseqs + idx) + depos) = (char )'\000';
#line 740
    idx ++;
  }
#line 756
  *ret_rseqs = rseqs;
#line 757
  return (1);
}
}
#line 774 "selex.c"
int IsSELEXFormat(char *filename ) 
{ 
  FILE *fp ;
  char buffer___1[4096] ;
  char *sptr___0 ;
  int linenum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 783
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 783
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 784
    squid_errno = 4;
#line 784
    return (0);
  }
#line 786
  linenum = 0;
#line 787
  while (1) {
#line 787
    if (linenum < 500) {
#line 787
      tmp___12 = fgets((char * __restrict  )(buffer___1), 4096, (FILE * __restrict  )fp);
#line 787
      if (! ((unsigned long )tmp___12 != (unsigned long )((void *)0))) {
#line 787
        break;
      }
    } else {
#line 787
      break;
    }
#line 790
    linenum ++;
#line 792
    tmp___9 = strncmp((char const   *)(buffer___1), "#=AU", (size_t )4);
#line 792
    if (tmp___9 == 0) {
#line 792
      goto DONE;
    } else {
#line 793
      tmp___8 = strncmp((char const   *)(buffer___1), "#=ID", (size_t )4);
#line 793
      if (tmp___8 == 0) {
#line 793
        goto DONE;
      } else {
#line 794
        tmp___7 = strncmp((char const   *)(buffer___1), "#=AC", (size_t )4);
#line 794
        if (tmp___7 == 0) {
#line 794
          goto DONE;
        } else {
#line 795
          tmp___6 = strncmp((char const   *)(buffer___1), "#=DE", (size_t )4);
#line 795
          if (tmp___6 == 0) {
#line 795
            goto DONE;
          } else {
#line 796
            tmp___5 = strncmp((char const   *)(buffer___1), "#=GA", (size_t )4);
#line 796
            if (tmp___5 == 0) {
#line 796
              goto DONE;
            } else {
#line 797
              tmp___4 = strncmp((char const   *)(buffer___1), "#=TC", (size_t )4);
#line 797
              if (tmp___4 == 0) {
#line 797
                goto DONE;
              } else {
#line 798
                tmp___3 = strncmp((char const   *)(buffer___1), "#=NC", (size_t )4);
#line 798
                if (tmp___3 == 0) {
#line 798
                  goto DONE;
                } else {
#line 799
                  tmp___2 = strncmp((char const   *)(buffer___1), "#=SQ", (size_t )4);
#line 799
                  if (tmp___2 == 0) {
#line 799
                    goto DONE;
                  } else {
#line 800
                    tmp___1 = strncmp((char const   *)(buffer___1), "#=SS", (size_t )4);
#line 800
                    if (tmp___1 == 0) {
#line 800
                      goto DONE;
                    } else {
#line 801
                      tmp___0 = strncmp((char const   *)(buffer___1), "#=CS", (size_t )4);
#line 801
                      if (tmp___0 == 0) {
#line 801
                        goto DONE;
                      } else {
#line 802
                        tmp = strncmp((char const   *)(buffer___1), "#=RF", (size_t )4);
#line 802
                        if (tmp == 0) {
#line 802
                          goto DONE;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 805
    tmp___10 = strchr((char const   *)(commentsyms), (int )buffer___1[0]);
#line 805
    if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 805
      continue;
    }
#line 808
    sptr___0 = strtok((char * __restrict  )(buffer___1), (char const   * __restrict  )" \t\n");
#line 808
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 808
      continue;
    }
#line 812
    sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 812
    if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 812
      continue;
    }
#line 814
    tmp___11 = Seqtype(sptr___0);
#line 814
    if (tmp___11 == 0) {
#line 814
      fclose(fp);
#line 814
      return (0);
    }
  }
  DONE: 
#line 818
  fclose(fp);
#line 819
  return (1);
}
}
#line 1 "seqencode.o"
#pragma merger("0","/tmp/cil-FcyLaNq3.i","")
#line 127 "./sqfuncs.h"
int seqcmp(char *s1 , char *s2 , int allow ) ;
#line 128
int seqncmp(char *s1 , char *s2 , int n , int allow ) ;
#line 130
int coded_revcomp(char *comp , char *seq ) ;
#line 131
int seqdecode(char *str , char *codeseq ) ;
#line 132
int seqndecode(char *str , char *codeseq , int n ) ;
#line 27 "seqencode.c"
int seqcmp(char *s1 , char *s2 , int allow ) 
{ 
  int mmat ;
  char *tmp ;

  {
#line 30
  mmat = 0;
#line 32
  while (1) {
#line 32
    if ((int )*s1 != 0) {
#line 32
      if ((int )*s2 != 0) {
#line 32
        if (! (mmat <= allow)) {
#line 32
          break;
        }
      } else {
#line 32
        break;
      }
    } else {
#line 32
      break;
    }
#line 34
    if (! (((int )*s1 & (int )*s2) == (int )*s2)) {
#line 35
      mmat ++;
    }
#line 36
    s1 ++;
#line 37
    s2 ++;
  }
#line 39
  while (1) {
#line 39
    tmp = s1;
#line 39
    s1 ++;
#line 39
    if ((int )*tmp != 0) {
#line 39
      if (! (mmat <= allow)) {
#line 39
        break;
      }
    } else {
#line 39
      break;
    }
#line 40
    mmat ++;
  }
#line 41
  return (mmat);
}
}
#line 46 "seqencode.c"
int seqncmp(char *s1 , char *s2 , int n , int allow ) 
{ 
  int mmat ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 49
  mmat = 0;
#line 51
  while (1) {
#line 51
    if ((int )*s2 != 0) {
#line 51
      tmp = n;
#line 51
      n --;
#line 51
      if (! (tmp != 0)) {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 54
    if (! (((int )*s1 & (int )*s2) == (int )*s2)) {
#line 54
      mmat ++;
#line 54
      if (mmat > allow) {
#line 56
        return (mmat);
      }
    }
#line 57
    s1 ++;
#line 58
    s2 ++;
  }
#line 60
  while (1) {
#line 60
    tmp___0 = n;
#line 60
    n --;
#line 60
    if (tmp___0 != 0) {
#line 60
      tmp___1 = s1;
#line 60
      s1 ++;
#line 60
      if ((int )*tmp___1 != 0) {
#line 60
        if (! (mmat <= allow)) {
#line 60
          break;
        }
      } else {
#line 60
        break;
      }
    } else {
#line 60
      break;
    }
#line 61
    mmat ++;
  }
#line 62
  return (mmat);
}
}
#line 69 "seqencode.c"
int seqencode(char *codeseq , char *str ) 
{ 
  char *ptr ;
  int idx ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 76
  ptr = codeseq;
#line 77
  while ((int )*str != 0) {
#line 79
    tmp___0 = __ctype_b_loc();
#line 79
    if ((int const   )*(*tmp___0 + (int )*str) & 512) {
#line 79
      tmp = toupper((int )*str);
#line 79
      *str = (char )tmp;
    }
#line 80
    idx = 0;
#line 80
    while (1) {
#line 80
      if ((int )*str != (int )iupac[idx].sym) {
#line 80
        if (! (idx <= 17)) {
#line 80
          break;
        }
      } else {
#line 80
        break;
      }
#line 80
      idx ++;
    }
#line 82
    if (idx > 17) {
#line 84
      *ptr = (char)0;
#line 85
      return (0);
    } else {
#line 88
      *ptr = iupac[idx].code;
    }
#line 89
    ptr ++;
#line 90
    str ++;
  }
#line 92
  *ptr = (char)0;
#line 93
  return (1);
}
}
#line 97 "seqencode.c"
int coded_revcomp(char *comp , char *seq ) 
{ 
  long bases ;
  char *bckp ;
  char *fwdp ;
  int idx ;
  long pos ;
  size_t tmp ;

  {
#line 105
  tmp = strlen((char const   *)seq);
#line 105
  bases = (long )tmp;
#line 107
  fwdp = comp;
#line 108
  bckp = (seq + bases) - 1;
#line 109
  pos = 0L;
#line 109
  while (pos < bases) {
#line 111
    idx = 0;
#line 111
    while (1) {
#line 111
      if ((int )*bckp != (int )iupac[idx].code) {
#line 111
        if (! (idx < 17)) {
#line 111
          break;
        }
      } else {
#line 111
        break;
      }
#line 111
      idx ++;
    }
#line 112
    if (idx > 17) {
#line 114
      *fwdp = (char)0;
#line 115
      return (0);
    } else {
#line 118
      *fwdp = iupac[idx].comp;
    }
#line 119
    fwdp ++;
#line 120
    bckp --;
#line 109
    pos ++;
  }
#line 122
  *fwdp = (char)0;
#line 123
  return (1);
}
}
#line 126 "seqencode.c"
int seqdecode(char *str , char *codeseq ) 
{ 
  int idx ;
  int pos ;

  {
#line 132
  pos = 0;
#line 133
  while ((int )*codeseq != 0) {
#line 135
    idx = 0;
#line 135
    while (1) {
#line 135
      if ((int )*codeseq != (int )iupac[idx].code) {
#line 135
        if (! (idx < 17)) {
#line 135
          break;
        }
      } else {
#line 135
        break;
      }
#line 135
      idx ++;
    }
#line 137
    if (idx > 17) {
#line 139
      *(str + pos) = (char )'X';
#line 140
      return (0);
    } else {
#line 143
      *(str + pos) = iupac[idx].sym;
    }
#line 144
    codeseq ++;
#line 145
    pos ++;
  }
#line 147
  *(str + pos) = (char )'\000';
#line 148
  return (1);
}
}
#line 151 "seqencode.c"
int seqndecode(char *str , char *codeseq , int n ) 
{ 
  int idx ;
  int pos ;

  {
#line 158
  pos = 0;
#line 160
  while (1) {
#line 160
    n --;
#line 160
    if (! (n >= 0)) {
#line 160
      break;
    }
#line 162
    idx = 0;
#line 162
    while (1) {
#line 162
      if ((int )*codeseq != (int )iupac[idx].code) {
#line 162
        if (! (idx < 17)) {
#line 162
          break;
        }
      } else {
#line 162
        break;
      }
#line 162
      idx ++;
    }
#line 163
    if (idx > 17) {
#line 165
      *(str + pos) = (char )'X';
#line 166
      return (0);
    } else {
#line 169
      *(str + pos) = iupac[idx].sym;
    }
#line 170
    codeseq ++;
#line 171
    pos ++;
  }
#line 173
  *(str + pos) = (char )'\000';
#line 174
  return (1);
}
}
#line 1 "shuffle.o"
#pragma merger("0","/tmp/cil-39j3v2UR.i","")
#line 137 "./sqfuncs.h"
int StrShuffle(char *s1 , char *s2 ) ;
#line 138
int StrDPShuffle(char *s1 , char *s2 ) ;
#line 139
int StrMarkov0(char *s1 , char *s2 ) ;
#line 140
int StrMarkov1(char *s1 , char *s2 ) ;
#line 142
int StrRegionalShuffle(char *s1 , char *s2 , int w___0 ) ;
#line 143
int AlignmentShuffle(char **ali1 , char **ali2 , int nseq , int alen ) ;
#line 144
int AlignmentBootstrap(char **ali1 , char **ali2 , int nseq , int alen ) ;
#line 145
int QRNAShuffle(char *xs , char *ys , char *x , char *y___0 ) ;
#line 58 "shuffle.c"
int StrShuffle(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  char c ;
  size_t tmp ;
  double tmp___0 ;

  {
#line 65
  if ((unsigned long )s1 != (unsigned long )s2) {
#line 65
    strcpy((char * __restrict  )s1, (char const   * __restrict  )s2);
  }
#line 66
  tmp = strlen((char const   *)s1);
#line 66
  len = (int )tmp;
#line 66
  while (len > 1) {
#line 68
    tmp___0 = sre_random();
#line 68
    pos = (int )(tmp___0 * (double )len);
#line 69
    c = *(s1 + pos);
#line 70
    *(s1 + pos) = *(s1 + (len - 1));
#line 71
    *(s1 + (len - 1)) = c;
#line 66
    len --;
  }
#line 73
  return (1);
}
}
#line 99 "shuffle.c"
int StrDPShuffle(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  int x ;
  int y___0 ;
  char **E ;
  int *nE ;
  int *iE ;
  int n ;
  char sf ;
  char Z[26] ;
  int keep_connecting ;
  int is_eulerian ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 116
  tmp = strlen((char const   *)s2);
#line 116
  len = (int )tmp;
#line 117
  pos = 0;
#line 117
  while (pos < len) {
#line 118
    tmp___0 = __ctype_b_loc();
#line 118
    if (! ((int const   )*(*tmp___0 + (int )*(s2 + pos)) & 1024)) {
#line 118
      return (0);
    }
#line 117
    pos ++;
  }
#line 127
  tmp___1 = sre_malloc((char *)"shuffle.c", 127, sizeof(char *) * 26UL);
#line 127
  E = (char **)tmp___1;
#line 128
  tmp___2 = sre_malloc((char *)"shuffle.c", 128, sizeof(int ) * 26UL);
#line 128
  nE = (int *)tmp___2;
#line 129
  x = 0;
#line 129
  while (x < 26) {
#line 131
    tmp___3 = sre_malloc((char *)"shuffle.c", 131, sizeof(char ) * (unsigned long )(len - 1));
#line 131
    *(E + x) = (char *)tmp___3;
#line 132
    *(nE + x) = 0;
#line 129
    x ++;
  }
#line 135
  tmp___4 = toupper((int )*(s2 + 0));
#line 135
  x = tmp___4 - 65;
#line 136
  pos = 1;
#line 136
  while (pos < len) {
#line 138
    tmp___5 = toupper((int )*(s2 + pos));
#line 138
    y___0 = tmp___5 - 65;
#line 139
    *(*(E + x) + *(nE + x)) = (char )y___0;
#line 140
    (*(nE + x)) ++;
#line 141
    x = y___0;
#line 136
    pos ++;
  }
#line 146
  tmp___6 = toupper((int )*(s2 + (len - 1)));
#line 146
  sf = (char )(tmp___6 - 65);
#line 147
  is_eulerian = 0;
#line 148
  while (! is_eulerian) {
#line 157
    x = 0;
#line 157
    while (x < 26) {
#line 159
      if (*(nE + x) == 0) {
#line 159
        goto __Cont;
      } else
#line 159
      if (x == (int )sf) {
#line 159
        goto __Cont;
      }
#line 161
      tmp___7 = sre_random();
#line 161
      pos = (int )(tmp___7 * (double )*(nE + x));
#line 162
      y___0 = (int )*(*(E + x) + pos);
#line 163
      *(*(E + x) + pos) = *(*(E + x) + (*(nE + x) - 1));
#line 164
      *(*(E + x) + (*(nE + x) - 1)) = (char )y___0;
      __Cont: /* CIL Label */ 
#line 157
      x ++;
    }
#line 176
    x = 0;
#line 176
    while (x < 26) {
#line 176
      Z[x] = (char)0;
#line 176
      x ++;
    }
#line 177
    keep_connecting = 1;
#line 177
    Z[(int )sf] = (char )keep_connecting;
#line 179
    while (keep_connecting) {
#line 180
      keep_connecting = 0;
#line 181
      x = 0;
#line 181
      while (x < 26) {
#line 183
        y___0 = (int )*(*(E + x) + (*(nE + x) - 1));
#line 184
        if ((int )Z[x] == 0) {
#line 184
          if ((int )Z[y___0] == 1) {
#line 186
            Z[x] = (char)1;
#line 187
            keep_connecting = 1;
          }
        }
#line 181
        x ++;
      }
    }
#line 196
    is_eulerian = 1;
#line 197
    x = 0;
#line 197
    while (x < 26) {
#line 199
      if (*(nE + x) == 0) {
#line 199
        goto __Cont___0;
      } else
#line 199
      if (x == (int )sf) {
#line 199
        goto __Cont___0;
      }
#line 200
      if ((int )Z[x] == 0) {
#line 201
        is_eulerian = 0;
#line 202
        break;
      }
      __Cont___0: /* CIL Label */ 
#line 197
      x ++;
    }
  }
#line 224
  x = 0;
#line 224
  while (x < 26) {
#line 225
    n = *(nE + x) - 1;
#line 225
    while (n > 1) {
#line 227
      tmp___8 = sre_random();
#line 227
      pos = (int )(tmp___8 * (double )n);
#line 228
      y___0 = (int )*(*(E + x) + pos);
#line 229
      *(*(E + x) + pos) = *(*(E + x) + (n - 1));
#line 230
      *(*(E + x) + (n - 1)) = (char )y___0;
#line 225
      n --;
    }
#line 224
    x ++;
  }
#line 240
  tmp___9 = sre_malloc((char *)"shuffle.c", 240, sizeof(int ) * 26UL);
#line 240
  iE = (int *)tmp___9;
#line 241
  x = 0;
#line 241
  while (x < 26) {
#line 241
    *(iE + x) = 0;
#line 241
    x ++;
  }
#line 243
  pos = 0;
#line 244
  tmp___10 = toupper((int )*(s2 + 0));
#line 244
  x = tmp___10 - 65;
#line 245
  while (1) {
#line 247
    tmp___11 = pos;
#line 247
    pos ++;
#line 247
    *(s1 + tmp___11) = (char )(65 + x);
#line 249
    y___0 = (int )*(*(E + x) + *(iE + x));
#line 250
    (*(iE + x)) ++;
#line 252
    x = y___0;
#line 254
    if (*(iE + x) == *(nE + x)) {
#line 255
      break;
    }
  }
#line 257
  tmp___12 = pos;
#line 257
  pos ++;
#line 257
  *(s1 + tmp___12) = (char )(65 + (int )sf);
#line 258
  *(s1 + pos) = (char )'\000';
#line 262
  if (x != (int )sf) {
#line 262
    Die((char *)"hey, you didn\'t end on s_f.");
  }
#line 263
  if (pos != len) {
#line 263
    Die((char *)"hey, pos (%d) != len (%d).", pos, len);
  }
#line 267
  Free2DArray((void **)E, 26);
#line 268
  free((void *)nE);
#line 269
  free((void *)iE);
#line 270
  return (1);
}
}
#line 289 "shuffle.c"
int StrMarkov0(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  float p[26] ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 298
  tmp = strlen((char const   *)s2);
#line 298
  len = (int )tmp;
#line 299
  pos = 0;
#line 299
  while (pos < len) {
#line 300
    tmp___0 = __ctype_b_loc();
#line 300
    if (! ((int const   )*(*tmp___0 + (int )*(s2 + pos)) & 1024)) {
#line 300
      return (0);
    }
#line 299
    pos ++;
  }
#line 304
  FSet(p, 26, (float )0.);
#line 305
  pos = 0;
#line 305
  while (pos < len) {
#line 306
    tmp___1 = toupper((int )*(s2 + pos));
#line 306
    p[tmp___1 - 65] = (float )((double )p[tmp___1 - 65] + 1.0);
#line 305
    pos ++;
  }
#line 307
  FNorm(p, 26);
#line 311
  pos = 0;
#line 311
  while (pos < len) {
#line 312
    tmp___2 = FChoose(p, 26);
#line 312
    *(s1 + pos) = (char )(tmp___2 + 65);
#line 311
    pos ++;
  }
#line 313
  *(s1 + pos) = (char )'\000';
#line 315
  return (1);
}
}
#line 334 "shuffle.c"
int StrMarkov1(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  int x ;
  int y___0 ;
  int i___0 ;
  float p[26][26] ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 345
  tmp = strlen((char const   *)s2);
#line 345
  len = (int )tmp;
#line 346
  pos = 0;
#line 346
  while (pos < len) {
#line 347
    tmp___0 = __ctype_b_loc();
#line 347
    if (! ((int const   )*(*tmp___0 + (int )*(s2 + pos)) & 1024)) {
#line 347
      return (0);
    }
#line 346
    pos ++;
  }
#line 351
  x = 0;
#line 351
  while (x < 26) {
#line 351
    FSet(p[x], 26, (float )0.);
#line 351
    x ++;
  }
#line 353
  tmp___1 = toupper((int )*(s2 + 0));
#line 353
  x = tmp___1 - 65;
#line 353
  i___0 = x;
#line 354
  pos = 1;
#line 354
  while (pos < len) {
#line 356
    tmp___2 = toupper((int )*(s2 + pos));
#line 356
    y___0 = tmp___2 - 65;
#line 357
    p[x][y___0] = (float )((double )p[x][y___0] + 1.0);
#line 358
    x = y___0;
#line 354
    pos ++;
  }
#line 360
  x = 0;
#line 360
  while (x < 26) {
#line 361
    FNorm(p[x], 26);
#line 360
    x ++;
  }
#line 365
  x = i___0;
#line 366
  *(s1 + 0) = (char )(x + 65);
#line 367
  pos = 1;
#line 367
  while (pos < len) {
#line 369
    y___0 = FChoose(p[x], 26);
#line 370
    *(s1 + pos) = (char )(y___0 + 65);
#line 371
    x = y___0;
#line 367
    pos ++;
  }
#line 373
  *(s1 + pos) = (char )'\000';
#line 375
  return (1);
}
}
#line 391 "shuffle.c"
int StrReverse(char *s1 , char *s2 ) 
{ 
  int len ;
  int pos ;
  char c ;
  size_t tmp ;

  {
#line 398
  tmp = strlen((char const   *)s2);
#line 398
  len = (int )tmp;
#line 399
  pos = 0;
#line 399
  while (pos < len / 2) {
#line 401
    c = *(s2 + ((len - pos) - 1));
#line 402
    *(s1 + ((len - pos) - 1)) = *(s2 + pos);
#line 403
    *(s1 + pos) = c;
#line 399
    pos ++;
  }
#line 405
  if (len % 2) {
#line 405
    *(s1 + pos) = *(s2 + pos);
  }
#line 406
  *(s1 + len) = (char )'\000';
#line 407
  return (1);
}
}
#line 423 "shuffle.c"
int StrRegionalShuffle(char *s1 , char *s2 , int w___0 ) 
{ 
  int len ;
  char c ;
  int pos ;
  int i___0 ;
  int j ;
  size_t tmp ;
  double tmp___0 ;

  {
#line 431
  if ((unsigned long )s1 != (unsigned long )s2) {
#line 431
    strcpy((char * __restrict  )s1, (char const   * __restrict  )s2);
  }
#line 432
  tmp = strlen((char const   *)s1);
#line 432
  len = (int )tmp;
#line 434
  i___0 = 0;
#line 434
  while (i___0 < len) {
#line 435
    if (len - 1 < (i___0 + w___0) - 1) {
#line 435
      j = len - 1;
    } else {
#line 435
      j = (i___0 + w___0) - 1;
    }
#line 435
    while (j > i___0) {
#line 437
      tmp___0 = sre_random();
#line 437
      pos = i___0 + (int )(tmp___0 * (double )(j - i___0));
#line 438
      c = *(s1 + pos);
#line 439
      *(s1 + pos) = *(s1 + j);
#line 440
      *(s1 + j) = c;
#line 435
      j --;
    }
#line 434
    i___0 += w___0;
  }
#line 442
  return (1);
}
}
#line 462 "shuffle.c"
int AlignmentShuffle(char **ali1 , char **ali2 , int nseq , int alen ) 
{ 
  int i___0 ;
  int pos ;
  char c ;
  double tmp ;

  {
#line 469
  if ((unsigned long )ali1 != (unsigned long )ali2) {
#line 471
    i___0 = 0;
#line 471
    while (i___0 < nseq) {
#line 471
      strcpy((char * __restrict  )*(ali1 + i___0), (char const   * __restrict  )*(ali2 + i___0));
#line 471
      i___0 ++;
    }
  }
#line 474
  i___0 = 0;
#line 474
  while (i___0 < nseq) {
#line 475
    *(*(ali1 + i___0) + alen) = (char )'\000';
#line 474
    i___0 ++;
  }
#line 477
  while (alen > 1) {
#line 479
    tmp = sre_random();
#line 479
    pos = (int )(tmp * (double )alen);
#line 480
    i___0 = 0;
#line 480
    while (i___0 < nseq) {
#line 482
      c = *(*(ali1 + i___0) + pos);
#line 483
      *(*(ali1 + i___0) + pos) = *(*(ali1 + i___0) + (alen - 1));
#line 484
      *(*(ali1 + i___0) + (alen - 1)) = c;
#line 480
      i___0 ++;
    }
#line 477
    alen --;
  }
#line 488
  return (1);
}
}
#line 511 "shuffle.c"
int AlignmentBootstrap(char **ali1 , char **ali2 , int nseq , int alen ) 
{ 
  int pos ;
  int col ;
  int i___0 ;
  double tmp ;

  {
#line 518
  pos = 0;
#line 518
  while (pos < alen) {
#line 520
    tmp = sre_random();
#line 520
    col = (int )(tmp * (double )alen);
#line 521
    i___0 = 0;
#line 521
    while (i___0 < nseq) {
#line 522
      *(*(ali1 + i___0) + pos) = *(*(ali2 + i___0) + col);
#line 521
      i___0 ++;
    }
#line 518
    pos ++;
  }
#line 524
  i___0 = 0;
#line 524
  while (i___0 < nseq) {
#line 525
    *(*(ali1 + i___0) + alen) = (char )'\000';
#line 524
    i___0 ++;
  }
#line 527
  return (1);
}
}
#line 554 "shuffle.c"
int QRNAShuffle(char *xs , char *ys , char *x , char *y___0 ) 
{ 
  int L ;
  int *xycol ;
  int *xcol ;
  int *ycol ;
  int nxy ;
  int nx ;
  int ny ;
  int i___0 ;
  int pos ;
  int c ;
  char xsym ;
  char ysym ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 564
  if ((unsigned long )xs != (unsigned long )x) {
#line 564
    strcpy((char * __restrict  )xs, (char const   * __restrict  )x);
  }
#line 565
  if ((unsigned long )ys != (unsigned long )y___0) {
#line 565
    strcpy((char * __restrict  )ys, (char const   * __restrict  )y___0);
  }
#line 571
  tmp = strlen((char const   *)x);
#line 571
  L = (int )tmp;
#line 572
  tmp___0 = sre_malloc((char *)"shuffle.c", 572, sizeof(int ) * (unsigned long )L);
#line 572
  xycol = (int *)tmp___0;
#line 573
  tmp___1 = sre_malloc((char *)"shuffle.c", 573, sizeof(int ) * (unsigned long )L);
#line 573
  xcol = (int *)tmp___1;
#line 574
  tmp___2 = sre_malloc((char *)"shuffle.c", 574, sizeof(int ) * (unsigned long )L);
#line 574
  ycol = (int *)tmp___2;
#line 575
  ny = 0;
#line 575
  nx = ny;
#line 575
  nxy = nx;
#line 577
  i___0 = 0;
#line 577
  while (i___0 < L) {
#line 579
    if ((int )*(x + i___0) == 32) {
#line 579
      goto _L___2;
    } else
#line 579
    if ((int )*(x + i___0) == 46) {
#line 579
      goto _L___2;
    } else
#line 579
    if ((int )*(x + i___0) == 95) {
#line 579
      goto _L___2;
    } else
#line 579
    if ((int )*(x + i___0) == 45) {
#line 579
      goto _L___2;
    } else
#line 579
    if ((int )*(x + i___0) == 126) {
      _L___2: /* CIL Label */ 
#line 579
      if ((int )*(y___0 + i___0) == 32) {
#line 579
        goto __Cont;
      } else
#line 579
      if ((int )*(y___0 + i___0) == 46) {
#line 579
        goto __Cont;
      } else
#line 579
      if ((int )*(y___0 + i___0) == 95) {
#line 579
        goto __Cont;
      } else
#line 579
      if ((int )*(y___0 + i___0) == 45) {
#line 579
        goto __Cont;
      } else
#line 579
      if ((int )*(y___0 + i___0) == 126) {
#line 579
        goto __Cont;
      } else {
#line 579
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 580
    if ((int )*(x + i___0) == 32) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(x + i___0) == 46) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(x + i___0) == 95) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(x + i___0) == 45) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(x + i___0) == 126) {
      _L___0: /* CIL Label */ 
#line 581
      if ((int )*(x + i___0) == 32) {
#line 581
        *(ycol + ny) = i___0;
#line 581
        ny ++;
      } else
#line 581
      if ((int )*(x + i___0) == 46) {
#line 581
        *(ycol + ny) = i___0;
#line 581
        ny ++;
      } else
#line 581
      if ((int )*(x + i___0) == 95) {
#line 581
        *(ycol + ny) = i___0;
#line 581
        ny ++;
      } else
#line 581
      if ((int )*(x + i___0) == 45) {
#line 581
        *(ycol + ny) = i___0;
#line 581
        ny ++;
      } else
#line 581
      if ((int )*(x + i___0) == 126) {
#line 581
        *(ycol + ny) = i___0;
#line 581
        ny ++;
      } else
#line 582
      if ((int )*(y___0 + i___0) == 32) {
#line 582
        *(xcol + nx) = i___0;
#line 582
        nx ++;
      } else
#line 582
      if ((int )*(y___0 + i___0) == 46) {
#line 582
        *(xcol + nx) = i___0;
#line 582
        nx ++;
      } else
#line 582
      if ((int )*(y___0 + i___0) == 95) {
#line 582
        *(xcol + nx) = i___0;
#line 582
        nx ++;
      } else
#line 582
      if ((int )*(y___0 + i___0) == 45) {
#line 582
        *(xcol + nx) = i___0;
#line 582
        nx ++;
      } else
#line 582
      if ((int )*(y___0 + i___0) == 126) {
#line 582
        *(xcol + nx) = i___0;
#line 582
        nx ++;
      }
    } else
#line 580
    if ((int )*(y___0 + i___0) == 32) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(y___0 + i___0) == 46) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(y___0 + i___0) == 95) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(y___0 + i___0) == 45) {
#line 580
      goto _L___0;
    } else
#line 580
    if ((int )*(y___0 + i___0) == 126) {
#line 580
      goto _L___0;
    } else {
#line 580
      *(xycol + nxy) = i___0;
#line 580
      nxy ++;
    }
    __Cont: /* CIL Label */ 
#line 577
    i___0 ++;
  }
#line 588
  while (nxy > 1) {
#line 589
    tmp___3 = sre_random();
#line 589
    pos = (int )(tmp___3 * (double )nxy);
#line 590
    xsym = *(xs + *(xycol + pos));
#line 590
    ysym = *(ys + *(xycol + pos));
#line 590
    c = *(xycol + pos);
#line 591
    *(xs + *(xycol + pos)) = *(xs + *(xycol + (nxy - 1)));
#line 591
    *(ys + *(xycol + pos)) = *(ys + *(xycol + (nxy - 1)));
#line 591
    *(xycol + pos) = *(xycol + (nxy - 1));
#line 592
    *(xs + *(xycol + (nxy - 1))) = xsym;
#line 592
    *(ys + *(xycol + (nxy - 1))) = ysym;
#line 592
    *(xycol + pos) = *(xycol + (nxy - 1));
#line 588
    nxy --;
  }
#line 594
  while (nx > 1) {
#line 595
    tmp___4 = sre_random();
#line 595
    pos = (int )(tmp___4 * (double )nx);
#line 596
    xsym = *(xs + *(xcol + pos));
#line 596
    ysym = *(ys + *(xcol + pos));
#line 596
    c = *(xcol + pos);
#line 597
    *(xs + *(xcol + pos)) = *(xs + *(xcol + (nx - 1)));
#line 597
    *(ys + *(xcol + pos)) = *(ys + *(xcol + (nx - 1)));
#line 597
    *(xcol + pos) = *(xcol + (nx - 1));
#line 598
    *(xs + *(xcol + (nx - 1))) = xsym;
#line 598
    *(ys + *(xcol + (nx - 1))) = ysym;
#line 598
    *(xcol + (nx - 1)) = c;
#line 594
    nx --;
  }
#line 600
  while (ny > 1) {
#line 601
    tmp___5 = sre_random();
#line 601
    pos = (int )(tmp___5 * (double )ny);
#line 602
    xsym = *(xs + *(ycol + pos));
#line 602
    ysym = *(ys + *(ycol + pos));
#line 602
    c = *(ycol + pos);
#line 603
    *(xs + *(ycol + pos)) = *(xs + *(ycol + (ny - 1)));
#line 603
    *(ys + *(ycol + pos)) = *(ys + *(ycol + (ny - 1)));
#line 603
    *(ycol + pos) = *(ycol + (ny - 1));
#line 604
    *(xs + *(ycol + (ny - 1))) = xsym;
#line 604
    *(ys + *(ycol + (ny - 1))) = ysym;
#line 604
    *(ycol + (ny - 1)) = c;
#line 600
    ny --;
  }
#line 607
  free((void *)xycol);
#line 607
  free((void *)xcol);
#line 607
  free((void *)ycol);
#line 608
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 1 "sqerror.o"
#pragma merger("0","/tmp/cil-8UFILIRJ.i","")
#line 327 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 59 "./squid.h"
int squid_errno  ;
#line 35 "sqerror.c"
void Die(char *format  , ...) 
{ 
  va_list___0 argp ;

  {
#line 40
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nFATAL: ");
#line 41
  __builtin_va_start(argp, format);
#line 42
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, argp);
#line 43
  __builtin_va_end(argp);
#line 44
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 45
  fflush(stderr);
#line 47
  exit(1);
}
}
#line 60 "sqerror.c"
void Warn(char *format  , ...) 
{ 
  va_list___0 argp ;

  {
#line 65
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: ");
#line 66
  __builtin_va_start(argp, format);
#line 67
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format, argp);
#line 68
  __builtin_va_end(argp);
#line 69
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 70
  fflush(stderr);
#line 71
  return;
}
}
#line 87 "sqerror.c"
void Panic(char *file , int line ) 
{ 


  {
#line 90
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nPANIC [%s line %d] ",
          file, line);
#line 91
  perror("Unusual error");
#line 92
  exit(1);
}
}
#line 1 "sqio.o"
#pragma merger("0","/tmp/cil-HgkHWwW8.i","")
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 161 "./sqfuncs.h"
void ToDNA(char *seq ) ;
#line 162
void ToRNA(char *seq ) ;
#line 163
void ToIUPAC(char *seq , int is_aseq ) ;
#line 164
int ReadMultipleRseqs(char *seqfile , int fformat , char ***ret_rseqs , SQINFO **ret_sqinfo ,
                      int *ret_num ) ;
#line 167
SQFILE *SeqfileOpenForIndexing(char *filename , int format , char *env , int ssimode ) ;
#line 169
void SeqfilePosition(SQFILE *sqfp , SSIOFFSET *offset ) ;
#line 170
void SeqfileRewind(SQFILE *sqfp ) ;
#line 174
int GCGBinaryToSequence(char *seq , int len ) ;
#line 177
void WriteSimpleFASTA(FILE *fp , char *seq , char *name , char *desc ) ;
#line 178
int WriteSeq(FILE *outf , int outform , char *seq , SQINFO *sqinfo ) ;
#line 183
SQINFO *MSAToSqinfo(MSA *msa ) ;
#line 218
void s2lower(char *s___0 ) ;
#line 64 "sqio.c"
static void SeqfileGetLine(SQFILE *V ) ;
#line 68 "sqio.c"
static char *aminos  =    (char *)"ABCDEFGHIKLMNPQRSTVWXYZ*";
#line 69 "sqio.c"
static char *primenuc  =    (char *)"ACGTUN";
#line 70 "sqio.c"
static char *protonly  =    (char *)"EFIPQZ";
#line 72
static SQFILE *seqfile_open(char *filename , int format , char *env , int ssimode ) ;
#line 86 "sqio.c"
SQFILE *SeqfileOpen(char *filename , int format , char *env ) 
{ 
  SQFILE *tmp ;

  {
#line 89
  tmp = seqfile_open(filename, format, env, -1);
#line 89
  return (tmp);
}
}
#line 91 "sqio.c"
SQFILE *SeqfileOpenForIndexing(char *filename , int format , char *env , int ssimode ) 
{ 
  SQFILE *tmp ;

  {
#line 94
  tmp = seqfile_open(filename, format, env, ssimode);
#line 94
  return (tmp);
}
}
#line 96 "sqio.c"
static SQFILE *seqfile_open(char *filename , int format , char *env , int ssimode ) 
{ 
  SQFILE *dbfp ;
  void *tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  MSA *tmp___4 ;

  {
#line 101
  tmp = sre_malloc((char *)"sqio.c", 101, sizeof(SQFILE ));
#line 101
  dbfp = (SQFILE *)tmp;
#line 103
  dbfp->ssimode = ssimode;
#line 104
  dbfp->rpl = -1;
#line 105
  dbfp->lastrpl = 0;
#line 106
  dbfp->maxrpl = 0;
#line 107
  dbfp->bpl = -1;
#line 108
  dbfp->lastbpl = 0;
#line 109
  dbfp->maxbpl = 0;
#line 120
  tmp___2 = strcmp((char const   *)filename, "-");
#line 120
  if (tmp___2 == 0) {
#line 122
    dbfp->f = stdin;
#line 123
    dbfp->do_stdin = 1;
#line 124
    dbfp->do_gzip = 0;
#line 125
    dbfp->fname = sre_strdup((char *)"[STDIN]", -1);
  } else {
#line 154
    tmp___0 = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 154
    dbfp->f = tmp___0;
#line 154
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 154
      tmp___1 = EnvFileOpen(filename, env, (char **)((void *)0));
#line 154
      dbfp->f = tmp___1;
#line 154
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 156
        return ((SQFILE *)((void *)0));
      }
    }
#line 158
    dbfp->do_stdin = 0;
#line 159
    dbfp->do_gzip = 0;
#line 160
    dbfp->fname = sre_strdup(filename, -1);
  }
#line 167
  if (format == 0) {
#line 169
    if (dbfp->do_stdin == 1) {
#line 170
      Die((char *)"Can\'t autodetect sequence file format from a stdin or gzip pipe");
    } else
#line 169
    if (dbfp->do_gzip) {
#line 170
      Die((char *)"Can\'t autodetect sequence file format from a stdin or gzip pipe");
    }
#line 171
    format = SeqfileFormat(dbfp->f);
#line 172
    if (format == 0) {
#line 173
      Die((char *)"Can\'t determine format of sequence file %s", dbfp->fname);
    }
  }
#line 179
  dbfp->msa = (MSA *)((void *)0);
#line 180
  dbfp->afp = (MSAFILE *)((void *)0);
#line 181
  dbfp->format = format;
#line 182
  dbfp->linenumber = 0;
#line 183
  dbfp->buf = (char *)((void *)0);
#line 184
  dbfp->buflen = 0;
#line 185
  if (format > 100) {
#line 190
    tmp___3 = sre_malloc((char *)"sqio.c", 190, sizeof(MSAFILE ));
#line 190
    dbfp->afp = (MSAFILE *)tmp___3;
#line 191
    (dbfp->afp)->f = dbfp->f;
#line 192
    (dbfp->afp)->do_stdin = dbfp->do_stdin;
#line 193
    (dbfp->afp)->do_gzip = dbfp->do_gzip;
#line 194
    (dbfp->afp)->fname = dbfp->fname;
#line 195
    (dbfp->afp)->format = dbfp->format;
#line 196
    (dbfp->afp)->linenumber = dbfp->linenumber;
#line 197
    (dbfp->afp)->buf = (char *)((void *)0);
#line 198
    (dbfp->afp)->buflen = 0;
#line 200
    tmp___4 = MSAFileRead(dbfp->afp);
#line 200
    dbfp->msa = tmp___4;
#line 200
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 201
      Die((char *)"Failed to read any alignment data from file %s", dbfp->fname);
    }
#line 204
    (dbfp->msa)->lastidx = 0;
#line 206
    return (dbfp);
  }
#line 211
  SeqfileGetLine(dbfp);
#line 212
  return (dbfp);
}
}
#line 220 "sqio.c"
void SeqfilePosition(SQFILE *sqfp , SSIOFFSET *offset ) 
{ 
  int tmp ;

  {
#line 223
  if (sqfp->do_stdin) {
#line 224
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  } else
#line 223
  if (sqfp->do_gzip) {
#line 224
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  } else
#line 223
  if (sqfp->format > 100) {
#line 224
    Die((char *)"SeqfilePosition() failed: in a nonrewindable data file or stream");
  }
#line 226
  tmp = SSISetFilePosition(sqfp->f, offset);
#line 226
  if (tmp != 0) {
#line 227
    Die((char *)"SSISetFilePosition failed, but that shouldn\'t happen.");
  }
#line 228
  SeqfileGetLine(sqfp);
#line 229
  return;
}
}
#line 241 "sqio.c"
void SeqfileRewind(SQFILE *sqfp ) 
{ 


  {
#line 244
  if (sqfp->do_stdin) {
#line 245
    Die((char *)"SeqfileRewind() failed: in a nonrewindable data file or stream");
  } else
#line 244
  if (sqfp->do_gzip) {
#line 245
    Die((char *)"SeqfileRewind() failed: in a nonrewindable data file or stream");
  }
#line 247
  rewind(sqfp->f);
#line 248
  SeqfileGetLine(sqfp);
#line 249
  return;
}
}
#line 269 "sqio.c"
void SeqfileLineParameters(SQFILE *V , int *ret_bpl , int *ret_rpl ) 
{ 


  {
#line 272
  if (V->rpl > 0) {
#line 272
    if (V->maxrpl == V->rpl) {
#line 272
      if (V->bpl > 0) {
#line 272
        if (V->maxbpl == V->bpl) {
#line 274
          *ret_bpl = V->bpl;
#line 275
          *ret_rpl = V->rpl;
        } else {
#line 277
          *ret_bpl = 0;
#line 278
          *ret_rpl = 0;
        }
      } else {
#line 277
        *ret_bpl = 0;
#line 278
        *ret_rpl = 0;
      }
    } else {
#line 277
      *ret_bpl = 0;
#line 278
      *ret_rpl = 0;
    }
  } else {
#line 277
    *ret_bpl = 0;
#line 278
    *ret_rpl = 0;
  }
#line 280
  return;
}
}
#line 283 "sqio.c"
void SeqfileClose(SQFILE *sqfp ) 
{ 


  {
#line 291
  if ((unsigned long )sqfp->afp != (unsigned long )((void *)0)) {
#line 292
    if ((unsigned long )sqfp->msa != (unsigned long )((void *)0)) {
#line 292
      MSAFree(sqfp->msa);
    }
#line 293
    if ((unsigned long )(sqfp->afp)->buf != (unsigned long )((void *)0)) {
#line 293
      free((void *)(sqfp->afp)->buf);
    }
#line 294
    free((void *)sqfp->afp);
  } else
#line 300
  if (! sqfp->do_stdin) {
#line 300
    fclose(sqfp->f);
  }
#line 301
  if ((unsigned long )sqfp->buf != (unsigned long )((void *)0)) {
#line 301
    free((void *)sqfp->buf);
  }
#line 302
  if ((unsigned long )sqfp->fname != (unsigned long )((void *)0)) {
#line 302
    free((void *)sqfp->fname);
  }
#line 303
  free((void *)sqfp);
#line 304
  return;
}
}
#line 317 "sqio.c"
static void SeqfileGetLine(SQFILE *V ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 320
  if (V->ssimode >= 0) {
#line 321
    tmp = SSIGetFilePosition(V->f, V->ssimode, & V->ssioffset);
#line 321
    if (0 != tmp) {
#line 322
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
#line 323
  tmp___0 = sre_fgets(& V->buf, & V->buflen, V->f);
#line 323
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 324
    *(V->buf) = (char )'\000';
  }
#line 325
  (V->linenumber) ++;
#line 326
  return;
}
}
#line 329 "sqio.c"
void FreeSequence(char *seq , SQINFO *sqinfo ) 
{ 


  {
#line 332
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
#line 332
    free((void *)seq);
  }
#line 333
  if (sqinfo->flags & (1 << 9)) {
#line 333
    free((void *)sqinfo->ss);
  }
#line 334
  if (sqinfo->flags & (1 << 10)) {
#line 334
    free((void *)sqinfo->sa);
  }
#line 335
  return;
}
}
#line 337 "sqio.c"
int SetSeqinfoString(SQINFO *sqinfo , char *sptr___0 , int flag ) 
{ 
  int len ;
  int pos ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 344
  if ((unsigned long )sptr___0 == (unsigned long )((void *)0)) {
#line 344
    return (1);
  }
#line 346
  while ((int )*sptr___0 == 32) {
#line 346
    sptr___0 ++;
  }
#line 347
  tmp = strlen((char const   *)sptr___0);
#line 347
  pos = (int )(tmp - 1UL);
#line 347
  while (pos >= 0) {
#line 348
    tmp___0 = __ctype_b_loc();
#line 348
    if (! ((int const   )*(*tmp___0 + (int )*(sptr___0 + pos)) & 8192)) {
#line 348
      break;
    }
#line 347
    pos --;
  }
#line 349
  *(sptr___0 + (pos + 1)) = (char )'\000';
#line 351
  switch (flag) {
  case 1: 
#line 353
  if ((int )*sptr___0 != 45) {
#line 355
    strncpy((char * __restrict  )(sqinfo->name), (char const   * __restrict  )sptr___0,
            (size_t )63);
#line 356
    sqinfo->name[63] = (char )'\000';
#line 357
    sqinfo->flags |= 1;
  }
#line 359
  break;
  case 1 << 1: 
#line 362
  if ((int )*sptr___0 != 45) {
#line 364
    strncpy((char * __restrict  )(sqinfo->id), (char const   * __restrict  )sptr___0,
            (size_t )63);
#line 365
    sqinfo->id[63] = (char )'\000';
#line 366
    sqinfo->flags |= 1 << 1;
  }
#line 368
  break;
  case 1 << 2: 
#line 371
  if ((int )*sptr___0 != 45) {
#line 373
    strncpy((char * __restrict  )(sqinfo->acc), (char const   * __restrict  )sptr___0,
            (size_t )63);
#line 374
    sqinfo->acc[63] = (char )'\000';
#line 375
    sqinfo->flags |= 1 << 2;
  }
#line 377
  break;
  case 1 << 3: 
#line 380
  if ((int )*sptr___0 != 45) {
#line 382
    if (sqinfo->flags & (1 << 3)) {
#line 384
      tmp___1 = strlen((char const   *)(sqinfo->desc));
#line 384
      len = (int )tmp___1;
#line 385
      if (len < 126) {
#line 387
        strncat((char * __restrict  )(sqinfo->desc), (char const   * __restrict  )" ",
                (size_t )(127 - len));
#line 387
        len ++;
#line 388
        strncat((char * __restrict  )(sqinfo->desc), (char const   * __restrict  )sptr___0,
                (size_t )(127 - len));
      }
    } else {
#line 392
      strncpy((char * __restrict  )(sqinfo->desc), (char const   * __restrict  )sptr___0,
              (size_t )127);
    }
#line 393
    sqinfo->desc[127] = (char )'\000';
#line 394
    sqinfo->flags |= 1 << 3;
  }
#line 396
  break;
  case 1 << 4: 
#line 399
  tmp___2 = IsInt(sptr___0);
#line 399
  if (! tmp___2) {
#line 399
    squid_errno = 5;
#line 399
    return (0);
  }
#line 400
  sqinfo->start = atoi((char const   *)sptr___0);
#line 401
  if (sqinfo->start != 0) {
#line 401
    sqinfo->flags |= 1 << 4;
  }
#line 402
  break;
  case 1 << 5: 
#line 405
  tmp___3 = IsInt(sptr___0);
#line 405
  if (! tmp___3) {
#line 405
    squid_errno = 5;
#line 405
    return (0);
  }
#line 406
  sqinfo->stop = atoi((char const   *)sptr___0);
#line 407
  if (sqinfo->stop != 0) {
#line 407
    sqinfo->flags |= 1 << 5;
  }
#line 408
  break;
  case 1 << 8: 
#line 411
  tmp___4 = IsInt(sptr___0);
#line 411
  if (! tmp___4) {
#line 411
    squid_errno = 5;
#line 411
    return (0);
  }
#line 412
  sqinfo->olen = atoi((char const   *)sptr___0);
#line 413
  if (sqinfo->olen != 0) {
#line 413
    sqinfo->flags |= 1 << 8;
  }
#line 414
  break;
  default: 
#line 417
  Die((char *)"Invalid flag %d to SetSeqinfoString()", flag);
  }
#line 419
  return (1);
}
}
#line 422 "sqio.c"
void SeqinfoCopy(SQINFO *sq1 , SQINFO *sq2 ) 
{ 


  {
#line 425
  sq1->flags = sq2->flags;
#line 426
  if (sq2->flags & 1) {
#line 426
    strcpy((char * __restrict  )(sq1->name), (char const   * __restrict  )(sq2->name));
  }
#line 427
  if (sq2->flags & (1 << 1)) {
#line 427
    strcpy((char * __restrict  )(sq1->id), (char const   * __restrict  )(sq2->id));
  }
#line 428
  if (sq2->flags & (1 << 2)) {
#line 428
    strcpy((char * __restrict  )(sq1->acc), (char const   * __restrict  )(sq2->acc));
  }
#line 429
  if (sq2->flags & (1 << 3)) {
#line 429
    strcpy((char * __restrict  )(sq1->desc), (char const   * __restrict  )(sq2->desc));
  }
#line 430
  if (sq2->flags & (1 << 6)) {
#line 430
    sq1->len = sq2->len;
  }
#line 431
  if (sq2->flags & (1 << 4)) {
#line 431
    sq1->start = sq2->start;
  }
#line 432
  if (sq2->flags & (1 << 5)) {
#line 432
    sq1->stop = sq2->stop;
  }
#line 433
  if (sq2->flags & (1 << 8)) {
#line 433
    sq1->olen = sq2->olen;
  }
#line 434
  if (sq2->flags & (1 << 7)) {
#line 434
    sq1->type = sq2->type;
  }
#line 435
  if (sq2->flags & (1 << 9)) {
#line 435
    sq1->ss = Strdup(sq2->ss);
  }
#line 436
  if (sq2->flags & (1 << 10)) {
#line 436
    sq1->sa = Strdup(sq2->sa);
  }
#line 437
  return;
}
}
#line 444 "sqio.c"
void ToDNA(char *seq ) 
{ 


  {
#line 447
  while ((int )*seq != 0) {
#line 449
    if ((int )*seq == 85) {
#line 449
      *seq = (char )'T';
    } else
#line 450
    if ((int )*seq == 117) {
#line 450
      *seq = (char )'t';
    }
#line 447
    seq ++;
  }
#line 452
  return;
}
}
#line 459 "sqio.c"
void ToRNA(char *seq ) 
{ 


  {
#line 462
  while ((int )*seq != 0) {
#line 464
    if ((int )*seq == 84) {
#line 464
      *seq = (char )'U';
    } else
#line 465
    if ((int )*seq == 116) {
#line 465
      *seq = (char )'u';
    }
#line 462
    seq ++;
  }
#line 467
  return;
}
}
#line 485 "sqio.c"
void ToIUPAC(char *seq , int is_aseq ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 488
  if (is_aseq) {
#line 489
    while ((int )*seq != 0) {
#line 490
      tmp = strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (int )*seq);
#line 490
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 490
        if (! ((int )*seq == 32)) {
#line 490
          if (! ((int )*seq == 46)) {
#line 490
            if (! ((int )*seq == 95)) {
#line 490
              if (! ((int )*seq == 45)) {
#line 490
                if (! ((int )*seq == 126)) {
#line 490
                  *seq = (char )'N';
                }
              }
            }
          }
        }
      }
#line 489
      seq ++;
    }
  } else {
#line 492
    while ((int )*seq != 0) {
#line 493
      tmp___0 = strchr("ACGTUNRYMKSWHBVDacgtunrymkswhbvd", (int )*seq);
#line 493
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 493
        *seq = (char )'N';
      }
#line 492
      seq ++;
    }
  }
#line 495
  return;
}
}
#line 508 "sqio.c"
static void addseq(char *s___0 , struct ReadSeqVars *V ) 
{ 
  char *s0 ;
  char *sq ;
  int rpl ;
  int bpl ;
  int tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 516
  if (V->ssimode == -1) {
#line 522
    if (V->seqlen + V->buflen > V->maxseq) {
#line 523
      if (V->buflen > 500) {
#line 523
        tmp = V->buflen;
      } else {
#line 523
        tmp = 500;
      }
#line 523
      V->maxseq += tmp;
#line 524
      tmp___0 = sre_realloc((char *)"sqio.c", 524, (void *)V->seq, (size_t )(V->maxseq + 1));
#line 524
      V->seq = (char *)tmp___0;
#line 532
      *(V->seq + V->maxseq) = (char)0;
    }
#line 536
    sq = V->seq + V->seqlen;
#line 537
    while ((int )*s___0 != 0) {
#line 538
      tmp___1 = __ctype_b_loc();
#line 538
      if (! ((int const   )*(*tmp___1 + (int )*s___0) & 2048)) {
#line 538
        tmp___2 = __ctype_b_loc();
#line 538
        if (! ((int const   )*(*tmp___2 + (int )*s___0) & 8192)) {
#line 539
          *sq = *s___0;
#line 540
          sq ++;
        }
      }
#line 542
      s___0 ++;
    }
#line 544
    V->seqlen = (int )(sq - V->seq);
  } else {
#line 548
    s0 = s___0;
#line 549
    rpl = 0;
#line 550
    while ((int )*s___0 != 0) {
#line 551
      tmp___3 = __ctype_b_loc();
#line 551
      if (! ((int const   )*(*tmp___3 + (int )*s___0) & 2048)) {
#line 551
        tmp___4 = __ctype_b_loc();
#line 551
        if (! ((int const   )*(*tmp___4 + (int )*s___0) & 8192)) {
#line 552
          rpl ++;
        }
      }
#line 554
      s___0 ++;
    }
#line 556
    V->seqlen += rpl;
#line 557
    bpl = (int )(s___0 - s0);
#line 573
    if (V->rpl != 0) {
#line 574
      if (V->lastrpl > 0) {
#line 575
        if (V->rpl > 0) {
#line 575
          if (V->lastrpl != V->rpl) {
#line 575
            V->rpl = 0;
          } else {
#line 575
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 576
        if (V->rpl == -1) {
#line 576
          V->rpl = V->lastrpl;
        }
      }
#line 578
      V->lastrpl = rpl;
#line 579
      if (rpl > V->maxrpl) {
#line 579
        V->maxrpl = rpl;
      }
    }
#line 581
    if (V->bpl != 0) {
#line 582
      if (V->lastbpl > 0) {
#line 583
        if (V->bpl > 0) {
#line 583
          if (V->lastbpl != V->bpl) {
#line 583
            V->bpl = 0;
          } else {
#line 583
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 584
        if (V->bpl == -1) {
#line 584
          V->bpl = V->lastbpl;
        }
      }
#line 586
      V->lastbpl = bpl;
#line 587
      if (bpl > V->maxbpl) {
#line 587
        V->maxbpl = bpl;
      }
    }
  }
#line 591
  return;
}
}
#line 593 "sqio.c"
static void readLoop(int addfirst , int (*endTest)(char * , int * ) , struct ReadSeqVars *V ) 
{ 
  int addend ;
  int done ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 596
  addend = 0;
#line 597
  done = 0;
#line 599
  V->seqlen = 0;
#line 600
  tmp = 0;
#line 600
  V->lastbpl = tmp;
#line 600
  V->lastrpl = tmp;
#line 601
  if (addfirst) {
#line 602
    if (V->ssimode >= 0) {
#line 602
      V->d_off = V->ssioffset;
    }
#line 603
    addseq(V->buf, V);
  } else
#line 604
  if (V->ssimode >= 0) {
#line 605
    tmp___0 = SSIGetFilePosition(V->f, V->ssimode, & V->d_off);
#line 605
    if (0 != tmp___0) {
#line 606
      Die((char *)"SSIGetFilePosition() failed");
    }
  }
#line 608
  while (1) {
#line 609
    SeqfileGetLine(V);
#line 611
    if ((int )*(V->buf) == 0) {
#line 611
      tmp___1 = feof(V->f);
#line 611
      if (tmp___1) {
#line 612
        done = 1;
      }
    }
#line 613
    tmp___2 = (*endTest)(V->buf, & addend);
#line 613
    done |= tmp___2;
#line 614
    if (addend) {
#line 615
      addseq(V->buf, V);
    } else
#line 614
    if (! done) {
#line 615
      addseq(V->buf, V);
    }
#line 608
    if (! (! done)) {
#line 608
      break;
    }
  }
#line 617
  return;
}
}
#line 620 "sqio.c"
static int endPIR(char *s___0 , int *addend ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 623
  *addend = 0;
#line 624
  tmp = strncmp((char const   *)s___0, "///", (size_t )3);
#line 624
  if (tmp == 0) {
#line 626
    return (1);
  } else {
#line 624
    tmp___0 = strncmp((char const   *)s___0, "ENTRY", (size_t )5);
#line 624
    if (tmp___0 == 0) {
#line 626
      return (1);
    } else {
#line 628
      return (0);
    }
  }
}
}
#line 631 "sqio.c"
static void readPIR(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 636
  while (1) {
#line 636
    tmp = feof(V->f);
#line 636
    if (tmp) {
#line 636
      break;
    } else {
#line 636
      tmp___0 = strncmp((char const   *)V->buf, "ENTRY", (size_t )5);
#line 636
      if (! (tmp___0 != 0)) {
#line 636
        break;
      }
    }
#line 637
    SeqfileGetLine(V);
  }
#line 639
  tmp___1 = feof(V->f);
#line 639
  if (tmp___1) {
#line 639
    return;
  }
#line 640
  if (V->ssimode >= 0) {
#line 640
    V->r_off = V->ssioffset;
  }
#line 642
  sptr___0 = strtok((char * __restrict  )(V->buf + 15), (char const   * __restrict  )"\n\t ");
#line 642
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 644
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
#line 645
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
  }
#line 647
  while (1) {
#line 648
    SeqfileGetLine(V);
#line 649
    tmp___4 = feof(V->f);
#line 649
    if (tmp___4) {
      _L: /* CIL Label */ 
#line 651
      tmp___2 = feof(V->f);
#line 651
      if (! tmp___2) {
#line 651
        tmp___3 = strncmp((char const   *)V->buf, "ACCESSION", (size_t )9);
#line 651
        if (tmp___3 == 0) {
#line 653
          sptr___0 = strtok((char * __restrict  )(V->buf + 15), (char const   * __restrict  )" \t\n");
#line 653
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 654
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
          }
        }
      }
    } else {
#line 649
      tmp___5 = strncmp((char const   *)V->buf, "TITLE", (size_t )5);
#line 649
      if (tmp___5 == 0) {
#line 650
        SetSeqinfoString(V->sqinfo, V->buf + 15, 1 << 3);
      } else {
#line 649
        goto _L;
      }
    }
#line 647
    tmp___6 = feof(V->f);
#line 647
    if (tmp___6) {
#line 647
      break;
    } else {
#line 647
      tmp___7 = strncmp((char const   *)V->buf, "SEQUENCE", (size_t )8);
#line 647
      if (! (tmp___7 != 0)) {
#line 647
        break;
      }
    }
  }
#line 657
  SeqfileGetLine(V);
#line 659
  readLoop(0, & endPIR, V);
#line 663
  (V->sqinfo)->start = 1;
#line 664
  (V->sqinfo)->stop = V->seqlen;
#line 665
  (V->sqinfo)->olen = V->seqlen;
#line 666
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
#line 670
  while (1) {
#line 670
    tmp___8 = feof(V->f);
#line 670
    if (tmp___8) {
#line 670
      break;
    } else {
#line 670
      tmp___9 = strncmp((char const   *)V->buf, "ENTRY", (size_t )5);
#line 670
      if (! (tmp___9 != 0)) {
#line 670
        break;
      }
    }
#line 671
    SeqfileGetLine(V);
  }
#line 673
  return;
}
}
#line 677 "sqio.c"
static int endIG(char *s___0 , int *addend ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 680
  *addend = 1;
#line 681
  tmp = strchr((char const   *)s___0, '1');
#line 681
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 681
    tmp___1 = 1;
  } else {
#line 681
    tmp___0 = strchr((char const   *)s___0, '2');
#line 681
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 681
      tmp___1 = 1;
    } else {
#line 681
      tmp___1 = 0;
    }
  }
#line 681
  return (tmp___1);
}
}
#line 684 "sqio.c"
static void readIG(struct ReadSeqVars *V ) 
{ 
  char *nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 689
  while (1) {
#line 690
    SeqfileGetLine(V);
#line 689
    tmp = feof(V->f);
#line 689
    if (tmp) {
#line 689
      break;
    } else
#line 689
    if ((int )*(V->buf) != 0) {
#line 689
      if ((int )*(V->buf) != 59) {
#line 689
        break;
      }
    }
  }
#line 693
  tmp___0 = feof(V->f);
#line 693
  if (! tmp___0) {
#line 695
    nm = strtok((char * __restrict  )V->buf, (char const   * __restrict  )"\n\t ");
#line 695
    if ((unsigned long )nm != (unsigned long )((void *)0)) {
#line 696
      SetSeqinfoString(V->sqinfo, nm, 1);
    }
#line 698
    readLoop(0, & endIG, V);
  }
#line 701
  while (1) {
#line 701
    tmp___1 = feof(V->f);
#line 701
    if (tmp___1) {
#line 701
      break;
    } else
#line 701
    if ((int )*(V->buf) != 0) {
#line 701
      if ((int )*(V->buf) == 59) {
#line 701
        break;
      }
    }
#line 702
    SeqfileGetLine(V);
  }
#line 703
  return;
}
}
#line 705 "sqio.c"
static int endStrider(char *s___0 , int *addend ) 
{ 
  char *tmp ;

  {
#line 708
  *addend = 0;
#line 709
  tmp = strstr((char const   *)s___0, "//");
#line 709
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 712 "sqio.c"
static void readStrider(struct ReadSeqVars *V ) 
{ 
  char *nm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 717
  while (1) {
#line 717
    tmp___0 = feof(V->f);
#line 717
    if (tmp___0) {
#line 717
      break;
    } else
#line 717
    if (! ((int )*(V->buf) == 59)) {
#line 717
      break;
    }
#line 719
    tmp = strncmp((char const   *)V->buf, "; DNA sequence", (size_t )14);
#line 719
    if (tmp == 0) {
#line 721
      nm = strtok((char * __restrict  )(V->buf + 16), (char const   * __restrict  )",\n\t ");
#line 721
      if ((unsigned long )nm != (unsigned long )((void *)0)) {
#line 722
        SetSeqinfoString(V->sqinfo, nm, 1);
      }
    }
#line 724
    SeqfileGetLine(V);
  }
#line 727
  tmp___1 = feof(V->f);
#line 727
  if (! tmp___1) {
#line 728
    readLoop(1, & endStrider, V);
  }
#line 732
  while (1) {
#line 732
    tmp___2 = feof(V->f);
#line 732
    if (tmp___2) {
#line 732
      break;
    } else
#line 732
    if (! ((int )*(V->buf) != 59)) {
#line 732
      break;
    }
#line 733
    SeqfileGetLine(V);
  }
#line 734
  return;
}
}
#line 737 "sqio.c"
static int endGB(char *s___0 , int *addend ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 740
  *addend = 0;
#line 741
  tmp = strstr((char const   *)s___0, "//");
#line 741
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 741
    tmp___1 = 1;
  } else {
#line 741
    tmp___0 = strstr((char const   *)s___0, "LOCUS");
#line 741
    if ((unsigned long )tmp___0 == (unsigned long )s___0) {
#line 741
      tmp___1 = 1;
    } else {
#line 741
      tmp___1 = 0;
    }
  }
#line 741
  return (tmp___1);
}
}
#line 744 "sqio.c"
static void readGenBank(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int in_definition ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 756
  while (1) {
#line 756
    tmp = strncmp((char const   *)V->buf, "LOCUS", (size_t )5);
#line 756
    if (! (tmp != 0)) {
#line 756
      break;
    }
#line 757
    SeqfileGetLine(V);
  }
#line 759
  if (V->ssimode >= 0) {
#line 759
    V->r_off = V->ssioffset;
  }
#line 761
  sptr___0 = strtok((char * __restrict  )(V->buf + 12), (char const   * __restrict  )"\n\t ");
#line 761
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 762
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
#line 764
  in_definition = 0;
#line 765
  while (1) {
#line 765
    tmp___7 = feof(V->f);
#line 765
    if (tmp___7) {
#line 765
      break;
    }
#line 767
    SeqfileGetLine(V);
#line 768
    tmp___5 = feof(V->f);
#line 768
    if (tmp___5) {
      _L___1: /* CIL Label */ 
#line 774
      tmp___3 = feof(V->f);
#line 774
      if (tmp___3) {
        _L___0: /* CIL Label */ 
#line 780
        tmp___1 = feof(V->f);
#line 780
        if (tmp___1) {
          _L: /* CIL Label */ 
#line 786
          tmp___0 = strncmp((char const   *)V->buf, "ORIGIN", (size_t )6);
#line 786
          if (tmp___0 != 0) {
#line 788
            if (in_definition) {
#line 789
              SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);
            }
          } else {
#line 792
            break;
          }
        } else {
#line 780
          tmp___2 = strstr((char const   *)V->buf, "VERSION");
#line 780
          if ((unsigned long )tmp___2 == (unsigned long )V->buf) {
#line 782
            sptr___0 = strtok((char * __restrict  )(V->buf + 12), (char const   * __restrict  )"\n\t ");
#line 782
            if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 783
              SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
            }
#line 784
            in_definition = 0;
          } else {
#line 780
            goto _L;
          }
        }
      } else {
#line 774
        tmp___4 = strstr((char const   *)V->buf, "ACCESSION");
#line 774
        if ((unsigned long )tmp___4 == (unsigned long )V->buf) {
#line 776
          sptr___0 = strtok((char * __restrict  )(V->buf + 12), (char const   * __restrict  )"\n\t ");
#line 776
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 777
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
          }
#line 778
          in_definition = 0;
        } else {
#line 774
          goto _L___0;
        }
      }
    } else {
#line 768
      tmp___6 = strstr((char const   *)V->buf, "DEFINITION");
#line 768
      if ((unsigned long )tmp___6 == (unsigned long )V->buf) {
#line 770
        sptr___0 = strtok((char * __restrict  )(V->buf + 12), (char const   * __restrict  )"\n");
#line 770
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 771
          SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
        }
#line 772
        in_definition = 1;
      } else {
#line 768
        goto _L___1;
      }
    }
  }
#line 795
  readLoop(0, & endGB, V);
#line 799
  (V->sqinfo)->start = 1;
#line 800
  (V->sqinfo)->stop = V->seqlen;
#line 801
  (V->sqinfo)->olen = V->seqlen;
#line 802
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
#line 805
  while (1) {
#line 805
    tmp___8 = feof(V->f);
#line 805
    if (tmp___8) {
#line 805
      break;
    } else
#line 805
    if ((int )*(V->buf) != 0) {
#line 805
      tmp___9 = strstr((char const   *)V->buf, "LOCUS");
#line 805
      if ((unsigned long )tmp___9 == (unsigned long )V->buf) {
#line 805
        break;
      }
    }
#line 806
    SeqfileGetLine(V);
  }
#line 809
  while (1) {
#line 809
    tmp___10 = feof(V->f);
#line 809
    if (tmp___10) {
#line 809
      break;
    } else {
#line 809
      tmp___11 = strstr((char const   *)V->buf, "LOCUS  ");
#line 809
      if (! ((unsigned long )tmp___11 != (unsigned long )V->buf)) {
#line 809
        break;
      }
    }
#line 810
    SeqfileGetLine(V);
  }
#line 811
  return;
}
}
#line 813 "sqio.c"
static int endGCGdata(char *s___0 , int *addend ) 
{ 


  {
#line 816
  *addend = 0;
#line 817
  return ((int )*s___0 == 62);
}
}
#line 820 "sqio.c"
static void readGCGdata(struct ReadSeqVars *V ) 
{ 
  int binary ;
  int blen ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 823
  binary = 0;
#line 824
  blen = 0;
#line 827
  tmp___0 = Strparse((char *)">>>>([^ ]+) .+2BIT +Len: ([0-9]+)", V->buf, 2);
#line 827
  if (tmp___0) {
#line 829
    binary = 1;
#line 830
    SetSeqinfoString(V->sqinfo, sqd_parse[1], 1);
#line 831
    blen = atoi((char const   *)sqd_parse[2]);
  } else {
#line 833
    tmp = Strparse((char *)">>>>([^ ]+) .+ASCII +Len: [0-9]+", V->buf, 1);
#line 833
    if (tmp) {
#line 834
      SetSeqinfoString(V->sqinfo, sqd_parse[1], 1);
    } else {
#line 836
      Die((char *)"bogus GCGdata format? %s", V->buf);
    }
  }
#line 839
  SeqfileGetLine(V);
#line 840
  SetSeqinfoString(V->sqinfo, V->buf, 1 << 3);
#line 842
  if (binary) {
#line 844
    if (blen >= V->maxseq) {
#line 845
      V->maxseq = blen;
#line 846
      tmp___2 = realloc((void *)V->seq, sizeof(char ) * (unsigned long )(V->maxseq + 4));
#line 846
      tmp___1 = (char *)tmp___2;
#line 846
      V->seq = tmp___1;
#line 846
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 847
        Die((char *)"malloc failed");
      }
    }
#line 850
    tmp___3 = fread((void * __restrict  )V->seq, sizeof(char ), (size_t )((blen + 3) / 4),
                    (FILE * __restrict  )V->f);
#line 850
    if (tmp___3 < (size_t )((blen + 3) / 4)) {
#line 851
      Die((char *)"fread failed");
    }
#line 852
    V->seqlen = blen;
#line 854
    GCGBinaryToSequence(V->seq, blen);
  } else {
#line 856
    readLoop(0, & endGCGdata, V);
  }
#line 858
  while (1) {
#line 858
    tmp___4 = feof(V->f);
#line 858
    if (tmp___4) {
#line 858
      break;
    } else
#line 858
    if ((int )*(V->buf) != 0) {
#line 858
      if ((int )*(V->buf) == 62) {
#line 858
        break;
      }
    }
#line 859
    SeqfileGetLine(V);
  }
#line 860
  return;
}
}
#line 862 "sqio.c"
static int endPearson(char *s___0 , int *addend ) 
{ 


  {
#line 865
  *addend = 0;
#line 866
  return ((int )*s___0 == 62);
}
}
#line 869 "sqio.c"
static void readPearson(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;

  {
#line 874
  if (V->ssimode >= 0) {
#line 874
    V->r_off = V->ssioffset;
  }
#line 876
  if ((int )*(V->buf) != 62) {
#line 877
    Die((char *)"File %s does not appear to be in FASTA format at line %d.\nYou may want to specify the file format on the command line.\nUsually this is done with an option --informat <fmt>.\n",
        V->fname, V->linenumber);
  }
#line 883
  sptr___0 = strtok((char * __restrict  )(V->buf + 1), (char const   * __restrict  )"\n\t ");
#line 883
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 884
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
#line 885
  sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 885
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 886
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
  }
#line 888
  readLoop(0, & endPearson, V);
#line 890
  while (1) {
#line 890
    tmp = feof(V->f);
#line 890
    if (tmp) {
#line 890
      break;
    } else
#line 890
    if ((int )*(V->buf) != 0) {
#line 890
      if ((int )*(V->buf) == 62) {
#line 890
        break;
      }
    }
#line 891
    SeqfileGetLine(V);
  }
#line 893
  return;
}
}
#line 896 "sqio.c"
static int endEMBL(char *s___0 , int *addend ) 
{ 
  int tmp ;

  {
#line 899
  *addend = 0;
#line 908
  tmp = strncmp((char const   *)s___0, "     ", (size_t )5);
#line 908
  return (tmp != 0);
}
}
#line 912 "sqio.c"
static void readEMBL(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 918
  while (1) {
#line 918
    tmp = feof(V->f);
#line 918
    if (tmp) {
#line 918
      break;
    } else {
#line 918
      tmp___0 = strncmp((char const   *)V->buf, "ID  ", (size_t )4);
#line 918
      if (! (tmp___0 != 0)) {
#line 918
        break;
      }
    }
#line 919
    SeqfileGetLine(V);
  }
#line 921
  if (V->ssimode >= 0) {
#line 921
    V->r_off = V->ssioffset;
  }
#line 923
  sptr___0 = strtok((char * __restrict  )(V->buf + 5), (char const   * __restrict  )"\n\t ");
#line 923
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 925
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
#line 926
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 1);
  }
#line 929
  while (1) {
#line 930
    SeqfileGetLine(V);
#line 931
    tmp___3 = feof(V->f);
#line 931
    if (tmp___3) {
      _L: /* CIL Label */ 
#line 936
      tmp___1 = feof(V->f);
#line 936
      if (! tmp___1) {
#line 936
        tmp___2 = strstr((char const   *)V->buf, "DE  ");
#line 936
        if ((unsigned long )tmp___2 == (unsigned long )V->buf) {
#line 938
          sptr___0 = strtok((char * __restrict  )(V->buf + 5), (char const   * __restrict  )"\n");
#line 938
          if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 939
            SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
          }
        }
      }
    } else {
#line 931
      tmp___4 = strstr((char const   *)V->buf, "AC  ");
#line 931
      if ((unsigned long )tmp___4 == (unsigned long )V->buf) {
#line 933
        sptr___0 = strtok((char * __restrict  )(V->buf + 5), (char const   * __restrict  )";  \t\n");
#line 933
        if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 934
          SetSeqinfoString(V->sqinfo, sptr___0, 1 << 2);
        }
      } else {
#line 931
        goto _L;
      }
    }
#line 929
    tmp___5 = feof(V->f);
#line 929
    if (tmp___5) {
#line 929
      break;
    } else {
#line 929
      tmp___6 = strncmp((char const   *)V->buf, "SQ", (size_t )2);
#line 929
      if (! (tmp___6 != 0)) {
#line 929
        break;
      }
    }
  }
#line 943
  readLoop(0, & endEMBL, V);
#line 947
  if (V->ssimode == -1) {
#line 948
    sptr___0 = V->seq;
#line 948
    while ((int )*sptr___0 != 0) {
#line 949
      if ((int )*sptr___0 == 45) {
#line 949
        *sptr___0 = (char )'N';
      }
#line 948
      sptr___0 ++;
    }
  }
#line 953
  (V->sqinfo)->start = 1;
#line 954
  (V->sqinfo)->stop = V->seqlen;
#line 955
  (V->sqinfo)->olen = V->seqlen;
#line 956
  (V->sqinfo)->flags |= ((1 << 4) | (1 << 5)) | (1 << 8);
#line 959
  while (1) {
#line 959
    tmp___7 = feof(V->f);
#line 959
    if (tmp___7) {
#line 959
      break;
    } else {
#line 959
      tmp___8 = strncmp((char const   *)V->buf, "ID  ", (size_t )4);
#line 959
      if (! (tmp___8 != 0)) {
#line 959
        break;
      }
    }
#line 960
    SeqfileGetLine(V);
  }
#line 963
  return;
}
}
#line 966 "sqio.c"
static int endZuker(char *s___0 , int *addend ) 
{ 


  {
#line 969
  *addend = 0;
#line 970
  return ((int )*s___0 == 40);
}
}
#line 973 "sqio.c"
static void readZuker(struct ReadSeqVars *V ) 
{ 
  char *sptr___0 ;
  int tmp ;

  {
#line 978
  SeqfileGetLine(V);
#line 980
  sptr___0 = strtok((char * __restrict  )(V->buf + 6), (char const   * __restrict  )" \t\n");
#line 980
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 981
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
#line 983
  sptr___0 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"\n");
#line 983
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 984
    SetSeqinfoString(V->sqinfo, sptr___0, 1 << 3);
  }
#line 986
  readLoop(0, & endZuker, V);
#line 988
  while (1) {
#line 988
    tmp = feof(V->f);
#line 988
    if (tmp | (((int )*(V->buf) != 0) & ((int )*(V->buf) == 40))) {
#line 988
      break;
    }
#line 989
    SeqfileGetLine(V);
  }
#line 990
  return;
}
}
#line 992 "sqio.c"
static void readUWGCG(struct ReadSeqVars *V ) 
{ 
  char *si ;
  char *sptr___0 ;
  int done ;

  {
#line 999
  V->seqlen = 0;
#line 1003
  si = strstr((char const   *)V->buf, "  Length: ");
#line 1003
  if ((unsigned long )si != (unsigned long )((void *)0)) {
#line 1003
    *si = (char)0;
  } else {
#line 1004
    si = strstr((char const   *)V->buf, "..");
#line 1004
    if ((unsigned long )si != (unsigned long )((void *)0)) {
#line 1004
      *si = (char)0;
    }
  }
#line 1006
  sptr___0 = strtok((char * __restrict  )V->buf, (char const   * __restrict  )"\n\t ");
#line 1006
  if ((unsigned long )sptr___0 != (unsigned long )((void *)0)) {
#line 1007
    SetSeqinfoString(V->sqinfo, sptr___0, 1);
  }
#line 1009
  while (1) {
#line 1010
    done = feof(V->f);
#line 1011
    SeqfileGetLine(V);
#line 1012
    if (! done) {
#line 1012
      addseq(V->buf, V);
    }
#line 1009
    if (! (! done)) {
#line 1009
      break;
    }
  }
#line 1014
  return;
}
}
#line 1042 "sqio.c"
int ReadSeq(SQFILE *V , int format , char **ret_seq , SQINFO *sqinfo ) 
{ 
  int gotuw ;
  MSA *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1047
  squid_errno = 0;
#line 1052
  if (V->format > 100) {
#line 1054
    if ((V->msa)->lastidx >= (V->msa)->nseq) {
#line 1056
      MSAFree(V->msa);
#line 1057
      tmp = MSAFileRead(V->afp);
#line 1057
      V->msa = tmp;
#line 1057
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1058
        return (0);
      }
#line 1059
      (V->msa)->lastidx = 0;
    }
#line 1062
    MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen, *((V->msa)->aseq + (V->msa)->lastidx),
                        & V->seq);
#line 1064
    tmp___0 = strlen((char const   *)V->seq);
#line 1064
    V->seqlen = (int )tmp___0;
#line 1069
    sqinfo->flags = 0;
#line 1070
    if ((unsigned long )*((V->msa)->sqname + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
#line 1071
      SetSeqinfoString(sqinfo, *((V->msa)->sqname + (V->msa)->lastidx), 1);
    }
#line 1072
    if ((unsigned long )(V->msa)->sqacc != (unsigned long )((void *)0)) {
#line 1072
      if ((unsigned long )*((V->msa)->sqacc + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
#line 1073
        SetSeqinfoString(sqinfo, *((V->msa)->sqacc + (V->msa)->lastidx), 1 << 2);
      }
    }
#line 1074
    if ((unsigned long )(V->msa)->sqdesc != (unsigned long )((void *)0)) {
#line 1074
      if ((unsigned long )*((V->msa)->sqdesc + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
#line 1075
        SetSeqinfoString(sqinfo, *((V->msa)->sqdesc + (V->msa)->lastidx), 1 << 3);
      }
    }
#line 1076
    if ((unsigned long )(V->msa)->ss != (unsigned long )((void *)0)) {
#line 1076
      if ((unsigned long )*((V->msa)->ss + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
#line 1077
        MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen,
                            *((V->msa)->ss + (V->msa)->lastidx), & sqinfo->ss);
#line 1079
        sqinfo->flags |= 1 << 9;
      }
    }
#line 1081
    if ((unsigned long )(V->msa)->sa != (unsigned long )((void *)0)) {
#line 1081
      if ((unsigned long )*((V->msa)->sa + (V->msa)->lastidx) != (unsigned long )((void *)0)) {
#line 1082
        MakeDealignedString(*((V->msa)->aseq + (V->msa)->lastidx), (V->msa)->alen,
                            *((V->msa)->sa + (V->msa)->lastidx), & sqinfo->sa);
#line 1084
        sqinfo->flags |= 1 << 10;
      }
    }
#line 1086
    ((V->msa)->lastidx) ++;
  } else {
#line 1089
    tmp___1 = feof(V->f);
#line 1089
    if (tmp___1) {
#line 1089
      return (0);
    }
#line 1091
    if (V->ssimode == -1) {
#line 1092
      tmp___2 = calloc((size_t )501, sizeof(char ));
#line 1092
      V->seq = (char *)tmp___2;
#line 1093
      V->maxseq = 500;
    } else {
#line 1095
      V->seq = (char *)((void *)0);
#line 1096
      V->maxseq = 0;
    }
#line 1098
    V->seqlen = 0;
#line 1099
    V->sqinfo = sqinfo;
#line 1100
    (V->sqinfo)->flags = 0;
#line 1102
    switch (V->format) {
    case 1: 
#line 1103
    readIG(V);
#line 1103
    break;
    case 6: 
#line 1104
    readStrider(V);
#line 1104
    break;
    case 2: 
#line 1105
    readGenBank(V);
#line 1105
    break;
    case 7: 
#line 1106
    readPearson(V);
#line 1106
    break;
    case 4: 
#line 1107
    readEMBL(V);
#line 1107
    break;
    case 8: 
#line 1108
    readZuker(V);
#line 1108
    break;
    case 12: 
#line 1109
    readPIR(V);
#line 1109
    break;
    case 16: 
#line 1110
    readGCGdata(V);
#line 1110
    break;
    case 5: 
#line 1113
    while (1) {
#line 1114
      tmp___3 = strstr((char const   *)V->buf, "..");
#line 1114
      gotuw = (unsigned long )tmp___3 != (unsigned long )((void *)0);
#line 1115
      if (gotuw) {
#line 1115
        readUWGCG(V);
      }
#line 1116
      SeqfileGetLine(V);
#line 1113
      tmp___4 = feof(V->f);
#line 1113
      if (tmp___4) {
#line 1113
        break;
      }
    }
#line 1118
    break;
    default: 
#line 1122
    squid_errno = 5;
#line 1123
    free((void *)V->seq);
#line 1124
    return (0);
    }
#line 1126
    if ((unsigned long )V->seq != (unsigned long )((void *)0)) {
#line 1127
      *(V->seq + V->seqlen) = (char)0;
    }
  }
#line 1132
  sqinfo->len = V->seqlen;
#line 1133
  sqinfo->flags |= 1 << 6;
#line 1134
  *ret_seq = V->seq;
#line 1135
  if (squid_errno == 0) {
#line 1135
    return (1);
  } else {
#line 1135
    return (0);
  }
}
}
#line 1166 "sqio.c"
int SeqfileFormat(FILE *fp ) 
{ 
  char *buf ;
  int len ;
  int fmt ;
  int ndataline ;
  char *bufcpy ;
  char *s___0 ;
  char *s1 ;
  char *s2 ;
  int has_junk ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;

  {
#line 1171
  fmt = 0;
#line 1176
  buf = (char *)((void *)0);
#line 1177
  len = 0;
#line 1178
  ndataline = 0;
#line 1179
  has_junk = 0;
#line 1180
  while (1) {
#line 1180
    tmp___35 = sre_fgets(& buf, & len, fp);
#line 1180
    if (! ((unsigned long )tmp___35 != (unsigned long )((void *)0))) {
#line 1180
      break;
    }
#line 1182
    tmp = IsBlankline(buf);
#line 1182
    if (tmp) {
#line 1182
      continue;
    }
#line 1186
    if (ndataline == 0) {
#line 1188
      tmp___0 = strncmp((char const   *)buf, ">>>>", (size_t )4);
#line 1188
      if (tmp___0 == 0) {
#line 1188
        tmp___1 = strstr((char const   *)buf, "Len: ");
#line 1188
        if (tmp___1) {
#line 1189
          fmt = 16;
#line 1189
          goto DONE;
        }
      }
#line 1191
      if ((int )*(buf + 0) == 62) {
#line 1192
        fmt = 7;
#line 1192
        goto DONE;
      }
#line 1194
      tmp___2 = strncmp((char const   *)buf, "!!AA_SEQUENCE", (size_t )13);
#line 1194
      if (tmp___2 == 0) {
#line 1196
        fmt = 5;
#line 1196
        goto DONE;
      } else {
#line 1194
        tmp___3 = strncmp((char const   *)buf, "!!NA_SEQUENCE", (size_t )13);
#line 1194
        if (tmp___3 == 0) {
#line 1196
          fmt = 5;
#line 1196
          goto DONE;
        }
      }
#line 1198
      tmp___4 = strncmp((char const   *)buf, "# STOCKHOLM 1.", (size_t )14);
#line 1198
      if (tmp___4 == 0) {
#line 1199
        fmt = 101;
#line 1199
        goto DONE;
      }
#line 1201
      tmp___5 = strncmp((char const   *)buf, "CLUSTAL", (size_t )7);
#line 1201
      if (tmp___5 == 0) {
#line 1201
        tmp___6 = strstr((char const   *)buf, "multiple sequence alignment");
#line 1201
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 1203
          fmt = 104;
#line 1203
          goto DONE;
        }
      }
#line 1205
      tmp___7 = strncmp((char const   *)buf, "!!AA_MULTIPLE_ALIGNMENT", (size_t )23);
#line 1205
      if (tmp___7 == 0) {
#line 1207
        fmt = 103;
#line 1207
        goto DONE;
      } else {
#line 1205
        tmp___8 = strncmp((char const   *)buf, "!!NA_MULTIPLE_ALIGNMENT", (size_t )23);
#line 1205
        if (tmp___8 == 0) {
#line 1207
          fmt = 103;
#line 1207
          goto DONE;
        }
      }
#line 1210
      bufcpy = sre_strdup(buf, -1);
#line 1211
      s___0 = bufcpy;
#line 1212
      s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 1212
      if ((unsigned long )s1 != (unsigned long )((void *)0)) {
#line 1212
        s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 1212
        if ((unsigned long )s2 != (unsigned long )((void *)0)) {
#line 1212
          tmp___9 = IsInt(s1);
#line 1212
          if (tmp___9) {
#line 1212
            tmp___10 = IsInt(s2);
#line 1212
            if (tmp___10) {
#line 1216
              free((void *)bufcpy);
#line 1216
              fmt = 106;
#line 1216
              goto DONE;
            }
          }
        }
      }
#line 1217
      free((void *)bufcpy);
    }
#line 1223
    tmp___11 = strncmp((char const   *)buf, "#=AU", (size_t )4);
#line 1223
    if (tmp___11 == 0) {
#line 1234
      fmt = 102;
#line 1234
      goto DONE;
    } else {
#line 1223
      tmp___12 = strncmp((char const   *)buf, "#=ID", (size_t )4);
#line 1223
      if (tmp___12 == 0) {
#line 1234
        fmt = 102;
#line 1234
        goto DONE;
      } else {
#line 1223
        tmp___13 = strncmp((char const   *)buf, "#=AC", (size_t )4);
#line 1223
        if (tmp___13 == 0) {
#line 1234
          fmt = 102;
#line 1234
          goto DONE;
        } else {
#line 1223
          tmp___14 = strncmp((char const   *)buf, "#=DE", (size_t )4);
#line 1223
          if (tmp___14 == 0) {
#line 1234
            fmt = 102;
#line 1234
            goto DONE;
          } else {
#line 1223
            tmp___15 = strncmp((char const   *)buf, "#=GA", (size_t )4);
#line 1223
            if (tmp___15 == 0) {
#line 1234
              fmt = 102;
#line 1234
              goto DONE;
            } else {
#line 1223
              tmp___16 = strncmp((char const   *)buf, "#=TC", (size_t )4);
#line 1223
              if (tmp___16 == 0) {
#line 1234
                fmt = 102;
#line 1234
                goto DONE;
              } else {
#line 1223
                tmp___17 = strncmp((char const   *)buf, "#=NC", (size_t )4);
#line 1223
                if (tmp___17 == 0) {
#line 1234
                  fmt = 102;
#line 1234
                  goto DONE;
                } else {
#line 1223
                  tmp___18 = strncmp((char const   *)buf, "#=SQ", (size_t )4);
#line 1223
                  if (tmp___18 == 0) {
#line 1234
                    fmt = 102;
#line 1234
                    goto DONE;
                  } else {
#line 1223
                    tmp___19 = strncmp((char const   *)buf, "#=SS", (size_t )4);
#line 1223
                    if (tmp___19 == 0) {
#line 1234
                      fmt = 102;
#line 1234
                      goto DONE;
                    } else {
#line 1223
                      tmp___20 = strncmp((char const   *)buf, "#=CS", (size_t )4);
#line 1223
                      if (tmp___20 == 0) {
#line 1234
                        fmt = 102;
#line 1234
                        goto DONE;
                      } else {
#line 1223
                        tmp___21 = strncmp((char const   *)buf, "#=RF", (size_t )4);
#line 1223
                        if (tmp___21 == 0) {
#line 1234
                          fmt = 102;
#line 1234
                          goto DONE;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1236
    tmp___22 = strncmp((char const   *)buf, "///", (size_t )3);
#line 1236
    if (tmp___22 == 0) {
#line 1237
      fmt = 12;
#line 1237
      goto DONE;
    } else {
#line 1236
      tmp___23 = strncmp((char const   *)buf, "ENTRY ", (size_t )6);
#line 1236
      if (tmp___23 == 0) {
#line 1237
        fmt = 12;
#line 1237
        goto DONE;
      }
    }
#line 1240
    tmp___24 = strstr((char const   *)buf, "..");
#line 1240
    if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
#line 1240
      tmp___25 = strstr((char const   *)buf, "MSF:");
#line 1240
      if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
#line 1240
        tmp___26 = strstr((char const   *)buf, "Check:");
#line 1240
        if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
#line 1243
          fmt = 103;
#line 1243
          goto DONE;
        }
      }
    }
#line 1246
    tmp___27 = strstr((char const   *)buf, " Check: ");
#line 1246
    if ((unsigned long )tmp___27 != (unsigned long )((void *)0)) {
#line 1246
      tmp___28 = strstr((char const   *)buf, "..");
#line 1246
      if ((unsigned long )tmp___28 != (unsigned long )((void *)0)) {
#line 1247
        fmt = 5;
#line 1247
        goto DONE;
      }
    }
#line 1249
    tmp___29 = strncmp((char const   *)buf, "LOCUS ", (size_t )6);
#line 1249
    if (tmp___29 == 0) {
#line 1250
      fmt = 2;
#line 1250
      goto DONE;
    } else {
#line 1249
      tmp___30 = strncmp((char const   *)buf, "ORIGIN ", (size_t )6);
#line 1249
      if (tmp___30 == 0) {
#line 1250
        fmt = 2;
#line 1250
        goto DONE;
      }
    }
#line 1252
    tmp___31 = strncmp((char const   *)buf, "ID   ", (size_t )5);
#line 1252
    if (tmp___31 == 0) {
#line 1253
      fmt = 4;
#line 1253
      goto DONE;
    } else {
#line 1252
      tmp___32 = strncmp((char const   *)buf, "SQ   ", (size_t )5);
#line 1252
      if (tmp___32 == 0) {
#line 1253
        fmt = 4;
#line 1253
        goto DONE;
      }
    }
#line 1258
    s___0 = buf;
#line 1259
    s1 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 1259
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 1259
      continue;
    }
#line 1260
    tmp___33 = strchr("#%", (int )*s1);
#line 1260
    if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
#line 1260
      continue;
    }
#line 1265
    s2 = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 1265
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 1266
      has_junk = 1;
    }
#line 1271
    if ((unsigned long )s2 != (unsigned long )((void *)0)) {
#line 1271
      tmp___34 = Seqtype(s2);
#line 1271
      if (tmp___34 == 0) {
#line 1272
        has_junk = 1;
      }
    }
#line 1274
    ndataline ++;
#line 1275
    if (ndataline == 300) {
#line 1275
      break;
    }
  }
#line 1278
  if (ndataline == 0) {
#line 1279
    Die((char *)"Sequence file contains no data");
  }
#line 1285
  if (has_junk == 1) {
#line 1285
    fmt = 0;
  } else {
#line 1286
    fmt = 102;
  }
  DONE: 
#line 1289
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 1289
    free((void *)buf);
  }
#line 1290
  rewind(fp);
#line 1291
  return (fmt);
}
}
#line 1303 "sqio.c"
int GCGBinaryToSequence(char *seq , int len ) 
{ 
  int bpos ;
  int spos ;
  char twobit ;
  int i___0 ;

  {
#line 1311
  bpos = (len - 1) / 4;
#line 1311
  while (bpos >= 0) {
#line 1313
    twobit = *(seq + bpos);
#line 1314
    spos = bpos * 4;
#line 1316
    i___0 = 3;
#line 1316
    while (i___0 >= 0) {
#line 1318
      switch ((int )twobit & 3) {
      case 0: 
#line 1319
      *(seq + (spos + i___0)) = (char )'C';
#line 1319
      break;
      case 1: 
#line 1320
      *(seq + (spos + i___0)) = (char )'T';
#line 1320
      break;
      case 2: 
#line 1321
      *(seq + (spos + i___0)) = (char )'A';
#line 1321
      break;
      case 3: 
#line 1322
      *(seq + (spos + i___0)) = (char )'G';
#line 1322
      break;
      }
#line 1324
      twobit = (char )((int )twobit >> 2);
#line 1316
      i___0 --;
    }
#line 1311
    bpos --;
  }
#line 1327
  *(seq + len) = (char )'\000';
#line 1328
  return (1);
}
}
#line 1346 "sqio.c"
int GCGchecksum(char *seq , int len ) 
{ 
  int i___0 ;
  int chk ;
  int tmp ;

  {
#line 1350
  chk = 0;
#line 1352
  i___0 = 0;
#line 1352
  while (i___0 < len) {
#line 1353
    tmp = sre_toupper((int )*(seq + i___0));
#line 1353
    chk = (chk + (i___0 % 57 + 1) * tmp) % 10000;
#line 1352
    i___0 ++;
  }
#line 1354
  return (chk);
}
}
#line 1372 "sqio.c"
int GCGMultchecksum(char **seqs , int nseq ) 
{ 
  int chk ;
  int idx ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1375
  chk = 0;
#line 1378
  idx = 0;
#line 1378
  while (idx < nseq) {
#line 1379
    tmp = strlen((char const   *)*(seqs + idx));
#line 1379
    tmp___0 = GCGchecksum(*(seqs + idx), (int )tmp);
#line 1379
    chk = (chk + tmp___0) % 10000;
#line 1378
    idx ++;
  }
#line 1380
  return (chk);
}
}
#line 1393 "sqio.c"
int Seqtype(char *seq ) 
{ 
  int saw ;
  char c ;
  int po ;
  int nt ;
  int nu ;
  int na ;
  int aa___0 ;
  int no ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1398
  po = 0;
#line 1399
  nt = 0;
#line 1400
  nu = 0;
#line 1401
  na = 0;
#line 1402
  aa___0 = 0;
#line 1403
  no = 0;
#line 1407
  saw = 0;
#line 1407
  while (1) {
#line 1407
    if ((int )*seq != 0) {
#line 1407
      if (! (saw < 300)) {
#line 1407
        break;
      }
    } else {
#line 1407
      break;
    }
#line 1409
    tmp = sre_toupper((int )*seq);
#line 1409
    c = (char )tmp;
#line 1410
    if (! ((int )c == 32)) {
#line 1410
      if (! ((int )c == 46)) {
#line 1410
        if (! ((int )c == 95)) {
#line 1410
          if (! ((int )c == 45)) {
#line 1410
            if (! ((int )c == 126)) {
#line 1412
              tmp___3 = strchr((char const   *)protonly, (int )c);
#line 1412
              if (tmp___3) {
#line 1412
                po ++;
              } else {
#line 1413
                tmp___2 = strchr((char const   *)primenuc, (int )c);
#line 1413
                if (tmp___2) {
#line 1414
                  na ++;
#line 1415
                  if ((int )c == 84) {
#line 1415
                    nt ++;
                  } else
#line 1416
                  if ((int )c == 85) {
#line 1416
                    nu ++;
                  }
                } else {
#line 1418
                  tmp___1 = strchr((char const   *)aminos, (int )c);
#line 1418
                  if (tmp___1) {
#line 1418
                    aa___0 ++;
                  } else {
#line 1419
                    tmp___0 = __ctype_b_loc();
#line 1419
                    if ((int const   )*(*tmp___0 + (int )c) & 1024) {
#line 1419
                      no ++;
                    }
                  }
                }
              }
#line 1420
              saw ++;
            }
          }
        }
      }
    }
#line 1407
    seq ++;
  }
#line 1424
  if (no > 0) {
#line 1424
    return (0);
  } else
#line 1425
  if (po > 0) {
#line 1425
    return (3);
  } else
#line 1426
  if (na > aa___0) {
#line 1427
    if (nu > nt) {
#line 1427
      return (2);
    } else {
#line 1428
      return (1);
    }
  } else {
#line 1430
    return (3);
  }
}
}
#line 1448 "sqio.c"
int GuessAlignmentSeqtype(char **aseq , int nseq ) 
{ 
  int idx ;
  int nrna ;
  int ndna ;
  int namino ;
  int nother ;
  int tmp ;

  {
#line 1452
  nrna = 0;
#line 1453
  ndna = 0;
#line 1454
  namino = 0;
#line 1455
  nother = 0;
#line 1457
  idx = 0;
#line 1457
  while (idx < nseq) {
#line 1458
    tmp = Seqtype(*(aseq + idx));
#line 1458
    switch (tmp) {
    case 2: 
#line 1459
    nrna ++;
#line 1459
    break;
    case 1: 
#line 1460
    ndna ++;
#line 1460
    break;
    case 3: 
#line 1461
    namino ++;
#line 1461
    break;
    default: 
#line 1462
    nother ++;
    }
#line 1457
    idx ++;
  }
#line 1467
  if (nother) {
#line 1467
    return (0);
  }
#line 1468
  if (namino == nseq) {
#line 1468
    return (3);
  }
#line 1469
  if (ndna == nseq) {
#line 1469
    return (1);
  }
#line 1470
  if (nrna == nseq) {
#line 1470
    return (2);
  }
#line 1474
  if (namino == 0) {
#line 1474
    return (2);
  }
#line 1475
  return (3);
}
}
#line 1494 "sqio.c"
void WriteSimpleFASTA(FILE *fp , char *seq , char *name , char *desc ) 
{ 
  char buf[61] ;
  int len ;
  int pos ;
  size_t tmp ;
  char const   *tmp___0 ;

  {
#line 1501
  tmp = strlen((char const   *)seq);
#line 1501
  len = (int )tmp;
#line 1502
  buf[60] = (char )'\000';
#line 1503
  if ((unsigned long )desc != (unsigned long )((void *)0)) {
#line 1503
    tmp___0 = (char const   *)desc;
  } else {
#line 1503
    tmp___0 = "";
  }
#line 1503
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )">%s %s\n", name,
          tmp___0);
#line 1504
  pos = 0;
#line 1504
  while (pos < len) {
#line 1506
    strncpy((char * __restrict  )(buf), (char const   * __restrict  )(seq + pos),
            (size_t )60);
#line 1507
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", buf);
#line 1504
    pos += 60;
  }
#line 1509
  return;
}
}
#line 1511 "sqio.c"
int WriteSeq(FILE *outf , int outform , char *seq , SQINFO *sqinfo ) 
{ 
  int numline ;
  int lines ;
  int spacer ;
  int width ;
  int tab ;
  int i___0 ;
  int j ;
  int l ;
  int l1 ;
  int ibase ;
  char endstr[10] ;
  char s___0[100] ;
  char ss[100] ;
  int checksum ;
  int seqlen ;
  int which_case ;
  int dostruc ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char tmp___17 ;

  {
#line 1514
  numline = 0;
#line 1515
  lines = 0;
#line 1515
  spacer = 0;
#line 1515
  width = 50;
#line 1515
  tab = 0;
#line 1520
  checksum = 0;
#line 1525
  which_case = 0;
#line 1526
  dostruc = 0;
#line 1527
  if (sqinfo->flags & (1 << 6)) {
#line 1527
    seqlen = sqinfo->len;
  } else {
#line 1527
    tmp = strlen((char const   *)seq);
#line 1527
    seqlen = (int )tmp;
  }
#line 1529
  if (outform > 100) {
#line 1530
    Die((char *)"Tried to write an aligned format with WriteSeq() -- bad, bad.");
  }
#line 1533
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"");
#line 1534
  l1 = 0;
#line 1535
  checksum = GCGchecksum(seq, seqlen);
#line 1537
  switch (outform) {
  case 0: 
#line 1539
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n");
#line 1540
  break;
  case 2: 
#line 1543
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"LOCUS       %s       %d bp\n",
          sqinfo->name, seqlen);
#line 1545
  if (sqinfo->flags & (1 << 2)) {
#line 1545
    tmp___0 = (char const   *)(sqinfo->acc);
  } else {
#line 1545
    tmp___0 = ".";
  }
#line 1545
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ACCESSION   %s\n",
          tmp___0);
#line 1547
  if (sqinfo->flags & (1 << 3)) {
#line 1547
    tmp___1 = (char const   *)(sqinfo->desc);
  } else {
#line 1547
    tmp___1 = ".";
  }
#line 1547
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"DEFINITION  %s\n",
          tmp___1);
#line 1549
  if (sqinfo->flags & (1 << 1)) {
#line 1549
    tmp___2 = (char const   *)(sqinfo->id);
  } else {
#line 1549
    tmp___2 = ".";
  }
#line 1549
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"VERSION     %s\n",
          tmp___2);
#line 1551
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ORIGIN      \n");
#line 1552
  spacer = 11;
#line 1553
  numline = 1;
#line 1554
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n//");
#line 1555
  break;
  case 16: 
#line 1558
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )">>>>%s  9/95  ASCII  Len: %d\n",
          sqinfo->name, seqlen);
#line 1559
  if (sqinfo->flags & (1 << 3)) {
#line 1559
    tmp___3 = (char const   *)(sqinfo->desc);
  } else {
#line 1559
    tmp___3 = "-";
  }
#line 1559
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n", tmp___3);
#line 1560
  break;
  case 12: 
#line 1563
  if (sqinfo->flags & (1 << 1)) {
#line 1563
    tmp___4 = sqinfo->id;
  } else {
#line 1563
    tmp___4 = sqinfo->name;
  }
#line 1563
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ENTRY          %s\n",
          tmp___4);
#line 1565
  if (sqinfo->flags & (1 << 3)) {
#line 1565
    tmp___5 = (char const   *)(sqinfo->desc);
  } else {
#line 1565
    tmp___5 = "-";
  }
#line 1565
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"TITLE          %s\n",
          tmp___5);
#line 1567
  if (sqinfo->flags & (1 << 2)) {
#line 1567
    tmp___6 = (char const   *)(sqinfo->acc);
  } else {
#line 1567
    tmp___6 = "-";
  }
#line 1567
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ACCESSION      %s\n",
          tmp___6);
#line 1569
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SUMMARY                                #Length %d  #Checksum  %d\n",
          sqinfo->len, checksum);
#line 1571
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SEQUENCE\n");
#line 1572
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"                  5        10        15        20        25        30\n");
#line 1573
  spacer = 2;
#line 1574
  numline = 1;
#line 1575
  width = 30;
#line 1576
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n///");
#line 1577
  break;
  case 14: 
#line 1580
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"NAM  %s\n", sqinfo->name);
#line 1581
  if (sqinfo->flags & (((((1 << 1) | (1 << 2)) | (1 << 4)) | (1 << 5)) | (1 << 8))) {
#line 1582
    if (sqinfo->flags & (1 << 8)) {
#line 1582
      tmp___7 = sqinfo->olen;
    } else {
#line 1582
      tmp___7 = 0;
    }
#line 1582
    if (sqinfo->flags & (1 << 5)) {
#line 1582
      tmp___8 = sqinfo->stop;
    } else {
#line 1582
      tmp___8 = 0;
    }
#line 1582
    if (sqinfo->flags & (1 << 4)) {
#line 1582
      tmp___9 = sqinfo->start;
    } else {
#line 1582
      tmp___9 = 0;
    }
#line 1582
    if (sqinfo->flags & (1 << 2)) {
#line 1582
      tmp___10 = (char const   *)(sqinfo->acc);
    } else {
#line 1582
      tmp___10 = "-";
    }
#line 1582
    if (sqinfo->flags & (1 << 1)) {
#line 1582
      tmp___11 = (char const   *)(sqinfo->id);
    } else {
#line 1582
      tmp___11 = "-";
    }
#line 1582
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SRC  %s %s %d..%d::%d\n",
            tmp___11, tmp___10, tmp___9, tmp___8, tmp___7);
  }
#line 1588
  if (sqinfo->flags & (1 << 3)) {
#line 1589
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"DES  %s\n", sqinfo->desc);
  }
#line 1590
  if (sqinfo->flags & (1 << 9)) {
#line 1592
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SEQ  +SS\n");
#line 1593
    dostruc = 1;
  } else {
#line 1596
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SEQ\n");
  }
#line 1597
  numline = 1;
#line 1598
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n++");
#line 1599
  break;
  case 4: 
#line 1602
  if (sqinfo->flags & (1 << 1)) {
#line 1602
    tmp___12 = sqinfo->id;
  } else {
#line 1602
    tmp___12 = sqinfo->name;
  }
#line 1602
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ID   %s\n", tmp___12);
#line 1604
  if (sqinfo->flags & (1 << 2)) {
#line 1604
    tmp___13 = (char const   *)(sqinfo->acc);
  } else {
#line 1604
    tmp___13 = "-";
  }
#line 1604
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"AC   %s\n", tmp___13);
#line 1606
  if (sqinfo->flags & (1 << 3)) {
#line 1606
    tmp___14 = (char const   *)(sqinfo->desc);
  } else {
#line 1606
    tmp___14 = "-";
  }
#line 1606
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"DE   %s\n", tmp___14);
#line 1608
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"SQ             %d BP\n",
          seqlen);
#line 1609
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n//");
#line 1610
  tab = 5;
#line 1611
  spacer = 11;
#line 1612
  break;
  case 5: 
#line 1615
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n", sqinfo->name);
#line 1616
  if (sqinfo->flags & (1 << 2)) {
#line 1617
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"ACCESSION   %s\n",
            sqinfo->acc);
  }
#line 1618
  if (sqinfo->flags & (1 << 3)) {
#line 1619
    fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"DEFINITION  %s\n",
            sqinfo->desc);
  }
#line 1620
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"    %s  Length: %d  (today)  Check: %d  ..\n",
          sqinfo->name, seqlen, checksum);
#line 1622
  spacer = 11;
#line 1623
  numline = 1;
#line 1624
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n");
#line 1625
  break;
  case 6: 
#line 1628
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"; ### from DNA Strider ;-)\n");
#line 1629
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"; DNA sequence  %s, %d bases, %d checksum.\n;\n",
          sqinfo->name, seqlen, checksum);
#line 1631
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"\n//");
#line 1632
  break;
  case 8: 
#line 1638
  which_case = 1;
  case 1: 
#line 1641
  if (sqinfo->flags & (1 << 3)) {
#line 1641
    tmp___15 = (char const   *)(sqinfo->desc);
  } else {
#line 1641
    tmp___15 = "";
  }
#line 1641
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )";%s %s\n", sqinfo->name,
          tmp___15);
#line 1644
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n", sqinfo->name);
#line 1645
  strcpy((char * __restrict  )(endstr), (char const   * __restrict  )"1");
#line 1646
  break;
  case 13: 
#line 1649
  break;
  default: 
#line 1653
  if (sqinfo->flags & (1 << 3)) {
#line 1653
    tmp___16 = (char const   *)(sqinfo->desc);
  } else {
#line 1653
    tmp___16 = "";
  }
#line 1653
  fprintf((FILE * __restrict  )outf, (char const   * __restrict  )">%s %s\n", sqinfo->name,
          tmp___16);
#line 1655
  break;
  }
#line 1658
  if (which_case == 1) {
#line 1658
    s2upper(seq);
  }
#line 1659
  if (which_case == 2) {
#line 1659
    s2lower(seq);
  }
#line 1662
  if (width < 100) {
#line 1662
    width = width;
  } else {
#line 1662
    width = 100;
  }
#line 1663
  i___0 = 0;
#line 1663
  l = 0;
#line 1663
  ibase = 1;
#line 1663
  lines = 0;
#line 1663
  while (i___0 < seqlen) {
#line 1664
    if (l1 < 0) {
#line 1664
      l1 = 0;
    } else
#line 1665
    if (l1 == 0) {
#line 1666
      if (numline) {
#line 1666
        fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%8d ", ibase);
      }
#line 1667
      j = 0;
#line 1667
      while (j < tab) {
#line 1667
        fputc(' ', outf);
#line 1667
        j ++;
      }
    }
#line 1669
    if (spacer != 0) {
#line 1669
      if ((l + 1) % spacer == 1) {
#line 1670
        s___0[l] = (char )' ';
#line 1670
        ss[l] = (char )' ';
#line 1670
        l ++;
      }
    }
#line 1671
    s___0[l] = *(seq + i___0);
#line 1672
    if (sqinfo->flags & (1 << 9)) {
#line 1672
      ss[l] = *(sqinfo->ss + i___0);
    } else {
#line 1672
      ss[l] = (char )'.';
    }
#line 1673
    l ++;
#line 1673
    i___0 ++;
#line 1674
    l1 ++;
#line 1675
    if (l1 == width) {
#line 1675
      goto _L;
    } else
#line 1675
    if (i___0 == seqlen) {
      _L: /* CIL Label */ 
#line 1676
      tmp___17 = (char )'\000';
#line 1676
      ss[l] = tmp___17;
#line 1676
      s___0[l] = tmp___17;
#line 1677
      l = 0;
#line 1677
      l1 = 0;
#line 1678
      if (dostruc) {
#line 1680
        fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n", s___0);
#line 1681
        if (numline) {
#line 1681
          fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"         ");
        }
#line 1682
        j = 0;
#line 1682
        while (j < tab) {
#line 1682
          fputc(' ', outf);
#line 1682
          j ++;
        }
#line 1683
        if (i___0 == seqlen) {
#line 1683
          fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s%s\n",
                  ss, endstr);
        } else {
#line 1684
          fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n",
                  ss);
        }
      } else
#line 1688
      if (i___0 == seqlen) {
#line 1688
        fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s%s\n",
                s___0, endstr);
      } else {
#line 1689
        fprintf((FILE * __restrict  )outf, (char const   * __restrict  )"%s\n", s___0);
      }
#line 1691
      lines ++;
#line 1692
      ibase = i___0 + 1;
    }
  }
#line 1695
  return (lines);
}
}
#line 1716 "sqio.c"
int ReadMultipleRseqs(char *seqfile , int fformat , char ***ret_rseqs , SQINFO **ret_sqinfo ,
                      int *ret_num ) 
{ 
  SQINFO *sqinfo ;
  SQFILE *dbfp ;
  char **rseqs ;
  int numalloced ;
  int num ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1730
  num = 0;
#line 1731
  numalloced = 16;
#line 1732
  tmp = sre_malloc((char *)"sqio.c", 1732, (unsigned long )numalloced * sizeof(char *));
#line 1732
  rseqs = (char **)tmp;
#line 1733
  tmp___0 = sre_malloc((char *)"sqio.c", 1733, (unsigned long )numalloced * sizeof(SQINFO ));
#line 1733
  sqinfo = (SQINFO *)tmp___0;
#line 1734
  dbfp = SeqfileOpen(seqfile, fformat, (char *)((void *)0));
#line 1734
  if ((unsigned long )dbfp == (unsigned long )((void *)0)) {
#line 1734
    return (0);
  }
#line 1736
  while (1) {
#line 1736
    tmp___3 = ReadSeq(dbfp, dbfp->format, rseqs + num, sqinfo + num);
#line 1736
    if (! tmp___3) {
#line 1736
      break;
    }
#line 1738
    num ++;
#line 1739
    if (num == numalloced) {
#line 1741
      numalloced += 16;
#line 1742
      tmp___1 = sre_realloc((char *)"sqio.c", 1742, (void *)rseqs, (unsigned long )numalloced * sizeof(char *));
#line 1742
      rseqs = (char **)tmp___1;
#line 1743
      tmp___2 = sre_realloc((char *)"sqio.c", 1743, (void *)sqinfo, (unsigned long )numalloced * sizeof(SQINFO ));
#line 1743
      sqinfo = (SQINFO *)tmp___2;
    }
  }
#line 1746
  SeqfileClose(dbfp);
#line 1748
  *ret_rseqs = rseqs;
#line 1749
  *ret_sqinfo = sqinfo;
#line 1750
  *ret_num = num;
#line 1751
  return (1);
}
}
#line 1768 "sqio.c"
int String2SeqfileFormat(char *s___0 ) 
{ 
  char *s2 ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1772
  code = 0;
#line 1774
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1774
    return (0);
  }
#line 1775
  s2 = sre_strdup(s___0, -1);
#line 1776
  s2upper(s2);
#line 1778
  tmp___17 = strcmp((char const   *)s2, "FASTA");
#line 1778
  if (tmp___17 == 0) {
#line 1778
    code = 7;
  } else {
#line 1779
    tmp___16 = strcmp((char const   *)s2, "GENBANK");
#line 1779
    if (tmp___16 == 0) {
#line 1779
      code = 2;
    } else {
#line 1780
      tmp___15 = strcmp((char const   *)s2, "EMBL");
#line 1780
      if (tmp___15 == 0) {
#line 1780
        code = 4;
      } else {
#line 1781
        tmp___14 = strcmp((char const   *)s2, "GCG");
#line 1781
        if (tmp___14 == 0) {
#line 1781
          code = 5;
        } else {
#line 1782
          tmp___13 = strcmp((char const   *)s2, "GCGDATA");
#line 1782
          if (tmp___13 == 0) {
#line 1782
            code = 16;
          } else {
#line 1783
            tmp___12 = strcmp((char const   *)s2, "RAW");
#line 1783
            if (tmp___12 == 0) {
#line 1783
              code = 13;
            } else {
#line 1784
              tmp___11 = strcmp((char const   *)s2, "IG");
#line 1784
              if (tmp___11 == 0) {
#line 1784
                code = 1;
              } else {
#line 1785
                tmp___10 = strcmp((char const   *)s2, "STRIDER");
#line 1785
                if (tmp___10 == 0) {
#line 1785
                  code = 6;
                } else {
#line 1786
                  tmp___9 = strcmp((char const   *)s2, "IDRAW");
#line 1786
                  if (tmp___9 == 0) {
#line 1786
                    code = 9;
                  } else {
#line 1787
                    tmp___8 = strcmp((char const   *)s2, "ZUKER");
#line 1787
                    if (tmp___8 == 0) {
#line 1787
                      code = 8;
                    } else {
#line 1788
                      tmp___7 = strcmp((char const   *)s2, "PIR");
#line 1788
                      if (tmp___7 == 0) {
#line 1788
                        code = 12;
                      } else {
#line 1789
                        tmp___6 = strcmp((char const   *)s2, "SQUID");
#line 1789
                        if (tmp___6 == 0) {
#line 1789
                          code = 14;
                        } else {
#line 1790
                          tmp___5 = strcmp((char const   *)s2, "STOCKHOLM");
#line 1790
                          if (tmp___5 == 0) {
#line 1790
                            code = 101;
                          } else {
#line 1791
                            tmp___4 = strcmp((char const   *)s2, "SELEX");
#line 1791
                            if (tmp___4 == 0) {
#line 1791
                              code = 102;
                            } else {
#line 1792
                              tmp___3 = strcmp((char const   *)s2, "MSF");
#line 1792
                              if (tmp___3 == 0) {
#line 1792
                                code = 103;
                              } else {
#line 1793
                                tmp___2 = strcmp((char const   *)s2, "CLUSTAL");
#line 1793
                                if (tmp___2 == 0) {
#line 1793
                                  code = 104;
                                } else {
#line 1794
                                  tmp___1 = strcmp((char const   *)s2, "A2M");
#line 1794
                                  if (tmp___1 == 0) {
#line 1794
                                    code = 105;
                                  } else {
#line 1795
                                    tmp___0 = strcmp((char const   *)s2, "PHYLIP");
#line 1795
                                    if (tmp___0 == 0) {
#line 1795
                                      code = 106;
                                    } else {
#line 1796
                                      tmp = strcmp((char const   *)s2, "EPS");
#line 1796
                                      if (tmp == 0) {
#line 1796
                                        code = 107;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1798
  free((void *)s2);
#line 1799
  return (code);
}
}
#line 1801 "sqio.c"
char *SeqfileFormat2String(int code ) 
{ 


  {
#line 1804
  switch (code) {
  case 0: 
#line 1805
  return ((char *)"unknown");
  case 7: 
#line 1806
  return ((char *)"FASTA");
  case 2: 
#line 1807
  return ((char *)"Genbank");
  case 4: 
#line 1808
  return ((char *)"EMBL");
  case 5: 
#line 1809
  return ((char *)"GCG");
  case 16: 
#line 1810
  return ((char *)"GCG data library");
  case 13: 
#line 1811
  return ((char *)"raw");
  case 1: 
#line 1812
  return ((char *)"Intelligenetics");
  case 6: 
#line 1813
  return ((char *)"MacStrider");
  case 9: 
#line 1814
  return ((char *)"Idraw Postscript");
  case 8: 
#line 1815
  return ((char *)"Zuker");
  case 12: 
#line 1816
  return ((char *)"PIR");
  case 14: 
#line 1817
  return ((char *)"SQUID");
  case 101: 
#line 1818
  return ((char *)"Stockholm");
  case 102: 
#line 1819
  return ((char *)"SELEX");
  case 103: 
#line 1820
  return ((char *)"MSF");
  case 104: 
#line 1821
  return ((char *)"Clustal");
  case 105: 
#line 1822
  return ((char *)"a2m");
  case 106: 
#line 1823
  return ((char *)"Phylip");
  case 107: 
#line 1824
  return ((char *)"EPS");
  default: 
#line 1826
  Die((char *)"Bad code passed to MSAFormat2String()");
  }
#line 1829
  return ((char *)((void *)0));
}
}
#line 1851 "sqio.c"
SQINFO *MSAToSqinfo(MSA *msa ) 
{ 
  int idx ;
  SQINFO *sqinfo ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1857
  tmp = sre_malloc((char *)"sqio.c", 1857, sizeof(SQINFO ) * (unsigned long )msa->nseq);
#line 1857
  sqinfo = (SQINFO *)tmp;
#line 1859
  idx = 0;
#line 1859
  while (idx < msa->nseq) {
#line 1861
    (sqinfo + idx)->flags = 0;
#line 1862
    SetSeqinfoString(sqinfo + idx, *(msa->sqname + idx), 1);
#line 1864
    tmp___0 = MSAGetSeqAccession(msa, idx);
#line 1864
    SetSeqinfoString(sqinfo + idx, tmp___0, 1 << 2);
#line 1866
    tmp___1 = MSAGetSeqDescription(msa, idx);
#line 1866
    SetSeqinfoString(sqinfo + idx, tmp___1, 1 << 3);
#line 1869
    if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 1869
      if ((unsigned long )*(msa->ss + idx) != (unsigned long )((void *)0)) {
#line 1870
        MakeDealignedString(*(msa->aseq + idx), msa->alen, *(msa->ss + idx), & (sqinfo + idx)->ss);
#line 1872
        (sqinfo + idx)->flags |= 1 << 9;
      }
    }
#line 1875
    if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 1875
      if ((unsigned long )*(msa->sa + idx) != (unsigned long )((void *)0)) {
#line 1876
        MakeDealignedString(*(msa->aseq + idx), msa->alen, *(msa->sa + idx), & (sqinfo + idx)->sa);
#line 1878
        (sqinfo + idx)->flags |= 1 << 10;
      }
    }
#line 1881
    (sqinfo + idx)->len = DealignedLength(*(msa->aseq + idx));
#line 1882
    (sqinfo + idx)->flags |= 1 << 6;
#line 1859
    idx ++;
  }
#line 1884
  return (sqinfo);
}
}
#line 1 "squidcore.o"
#pragma merger("0","/tmp/cil-fiULmlqG.i","")
#line 187 "./sqfuncs.h"
void SqdBanner(FILE *fp , char *banner___1 ) ;
#line 45 "squidcore.c"
void SqdBanner(FILE *fp , char *banner___1 ) 
{ 


  {
#line 48
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", banner___1);
#line 49
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SQUID %s (%s)\n",
          "1.9g", "January 2003");
#line 50
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", "Copyright (C) 1992-2003 HHMI/Washington University School of Medicine");
#line 51
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", "Freely distributed under the GNU General Public License (GPL)");
#line 52
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
#line 53
  return;
}
}
#line 1 "sre_ctype.o"
#pragma merger("0","/tmp/cil-vEYtgWnZ.i","")
#line 24 "sre_ctype.c"
int sre_tolower(int c ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 27
  tmp___0 = __ctype_b_loc();
#line 27
  if ((int const   )*(*tmp___0 + c) & 256) {
#line 27
    tmp = tolower(c);
#line 27
    return (tmp);
  } else {
#line 28
    return (c);
  }
}
}
#line 31 "sre_ctype.c"
int sre_toupper(int c ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 34
  tmp___0 = __ctype_b_loc();
#line 34
  if ((int const   )*(*tmp___0 + c) & 512) {
#line 34
    tmp = toupper(c);
#line 34
    return (tmp);
  } else {
#line 35
    return (c);
  }
}
}
#line 1 "sre_math.o"
#pragma merger("0","/tmp/cil-nSCG9g0R.i","")
#line 199 "./sqfuncs.h"
void WeightedLinefit(float *x , float *y___0 , float *var , int N , float *ret_m ,
                     float *ret_b ) ;
#line 203
void FMX2Free(float **mx ) ;
#line 204
double **DMX2Alloc(int rows , int cols ) ;
#line 205
void DMX2Free(double **mx ) ;
#line 206
void FMX2Multiply(float **A , float **B , float **C , int m , int p , int n ) ;
#line 41 "sre_math.c"
int Linefit(float *x , float *y___0 , int N , float *ret_a , float *ret_b , float *ret_r ) 
{ 
  float xavg ;
  float yavg ;
  float sxx ;
  float syy ;
  float sxy ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 50
  yavg = (float )0.0;
#line 50
  xavg = yavg;
#line 51
  i___0 = 0;
#line 51
  while (i___0 < N) {
#line 53
    xavg += *(x + i___0);
#line 54
    yavg += *(y___0 + i___0);
#line 51
    i___0 ++;
  }
#line 56
  xavg /= (float )N;
#line 57
  yavg /= (float )N;
#line 59
  sxy = (float )0.0;
#line 59
  syy = sxy;
#line 59
  sxx = syy;
#line 60
  i___0 = 0;
#line 60
  while (i___0 < N) {
#line 62
    sxx += (*(x + i___0) - xavg) * (*(x + i___0) - xavg);
#line 63
    syy += (*(y___0 + i___0) - yavg) * (*(y___0 + i___0) - xavg);
#line 64
    sxy += (*(x + i___0) - xavg) * (*(y___0 + i___0) - yavg);
#line 60
    i___0 ++;
  }
#line 66
  *ret_b = sxy / sxx;
#line 67
  *ret_a = yavg - xavg * *ret_b;
#line 68
  tmp = sqrt((double )sxx);
#line 68
  tmp___0 = sqrt((double )syy);
#line 68
  *ret_r = (float )((double )sxy / (tmp * tmp___0));
#line 69
  return (1);
}
}
#line 84 "sre_math.c"
void WeightedLinefit(float *x , float *y___0 , float *var , int N , float *ret_m ,
                     float *ret_b ) 
{ 
  int i___0 ;
  double s___0 ;
  double sx ;
  double sy ;
  double sxx ;
  double sxy ;
  double delta ;
  double m ;
  double b ;

  {
#line 94
  sxy = 0.;
#line 94
  sxx = sxy;
#line 94
  sy = sxx;
#line 94
  sx = sy;
#line 94
  s___0 = sx;
#line 95
  i___0 = 0;
#line 95
  while (i___0 < N) {
#line 97
    s___0 += 1. / (double )*(var + i___0);
#line 98
    sx += (double )(*(x + i___0) / *(var + i___0));
#line 99
    sy += (double )(*(y___0 + i___0) / *(var + i___0));
#line 100
    sxx += (double )((*(x + i___0) * *(x + i___0)) / *(var + i___0));
#line 101
    sxy += (double )((*(x + i___0) * *(y___0 + i___0)) / *(var + i___0));
#line 95
    i___0 ++;
  }
#line 104
  delta = s___0 * sxx - sx * sx;
#line 105
  b = (sxx * sy - sx * sxy) / delta;
#line 106
  m = (s___0 * sxy - sx * sy) / delta;
#line 108
  *ret_m = (float )m;
#line 109
  *ret_b = (float )b;
#line 110
  return;
}
}
#line 129 "sre_math.c"
static double cof[11]  = 
#line 129
  {      4.694580336184385e+04,      - 1.560605207784446e+05,      2.065049568014106e+05,      - 1.388934775095388e+05, 
        5.031796415085709e+04,      - 9.601592329182778e+03,      8.785855930895250e+02,      - 3.155153906098611e+01, 
        2.908143421162229e-01,      - 2.319827630494973e-04,      1.251639670050933e-10};
#line 123 "sre_math.c"
double Gammln(double x ) 
{ 
  int i___0 ;
  double xx ;
  double tx ;
  double tmp ;
  double value ;
  double tmp___0 ;

  {
#line 147
  if (x <= 0.0) {
#line 147
    return (999999.);
  }
#line 149
  xx = x - 1.0;
#line 150
  tmp = xx + 11.0;
#line 150
  tx = tmp;
#line 151
  value = 1.0;
#line 152
  i___0 = 10;
#line 152
  while (i___0 >= 0) {
#line 154
    value += cof[i___0] / tmp;
#line 155
    tmp -= 1.0;
#line 152
    i___0 --;
  }
#line 157
  value = log(value);
#line 158
  tx += 0.5;
#line 159
  tmp___0 = log(tx);
#line 159
  value += (0.918938533 + (xx + 0.5) * tmp___0) - tx;
#line 160
  return (value);
}
}
#line 166 "sre_math.c"
float **FMX2Alloc(int rows , int cols ) 
{ 
  float **mx ;
  int r ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 172
  tmp = sre_malloc((char *)"sre_math.c", 172, sizeof(float *) * (unsigned long )rows);
#line 172
  mx = (float **)tmp;
#line 173
  tmp___0 = sre_malloc((char *)"sre_math.c", 173, (sizeof(float ) * (unsigned long )rows) * (unsigned long )cols);
#line 173
  *(mx + 0) = (float *)tmp___0;
#line 174
  r = 1;
#line 174
  while (r < rows) {
#line 175
    *(mx + r) = *(mx + 0) + r * cols;
#line 174
    r ++;
  }
#line 176
  return (mx);
}
}
#line 178 "sre_math.c"
void FMX2Free(float **mx ) 
{ 


  {
#line 181
  free((void *)*(mx + 0));
#line 182
  free((void *)mx);
#line 183
  return;
}
}
#line 184 "sre_math.c"
double **DMX2Alloc(int rows , int cols ) 
{ 
  double **mx ;
  int r ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 190
  tmp = sre_malloc((char *)"sre_math.c", 190, sizeof(double *) * (unsigned long )rows);
#line 190
  mx = (double **)tmp;
#line 191
  tmp___0 = sre_malloc((char *)"sre_math.c", 191, (sizeof(double ) * (unsigned long )rows) * (unsigned long )cols);
#line 191
  *(mx + 0) = (double *)tmp___0;
#line 192
  r = 1;
#line 192
  while (r < rows) {
#line 193
    *(mx + r) = *(mx + 0) + r * cols;
#line 192
    r ++;
  }
#line 194
  return (mx);
}
}
#line 196 "sre_math.c"
void DMX2Free(double **mx ) 
{ 


  {
#line 199
  free((void *)*(mx + 0));
#line 200
  free((void *)mx);
#line 201
  return;
}
}
#line 210 "sre_math.c"
void FMX2Multiply(float **A , float **B , float **C , int m , int p , int n ) 
{ 
  int i___0 ;
  int j ;
  int k ;

  {
#line 215
  i___0 = 0;
#line 215
  while (i___0 < m) {
#line 216
    j = 0;
#line 216
    while (j < n) {
#line 218
      *(*(C + i___0) + j) = (float )0.;
#line 219
      k = 0;
#line 219
      while (k < p) {
#line 220
        *(*(C + i___0) + j) += *(*(A + i___0) + p) * *(*(B + p) + j);
#line 219
        k ++;
      }
#line 216
      j ++;
    }
#line 215
    i___0 ++;
  }
#line 222
  return;
}
}
#line 248 "sre_math.c"
double IncompleteGamma(double a___0 , double x ) 
{ 
  int iter ;
  double oldp ;
  double nu0 ;
  double nu1 ;
  double de0 ;
  double de1 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double p ;
  double val ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 253
  if (a___0 <= 0.) {
#line 253
    Die((char *)"IncompleteGamma(): a must be > 0");
  }
#line 254
  if (x < 0.) {
#line 254
    Die((char *)"IncompleteGamma(): x must be >= 0");
  }
#line 260
  if (x > a___0 + (double )1) {
#line 266
    nu0 = 0.;
#line 267
    de0 = 1.;
#line 268
    nu1 = 1.;
#line 269
    de1 = x;
#line 271
    oldp = nu1;
#line 272
    iter = 1;
#line 272
    while (iter < 100) {
#line 281
      nu0 = nu1 + ((double )iter - a___0) * nu0;
#line 282
      de0 = de1 + ((double )iter - a___0) * de0;
#line 286
      nu1 = x * nu0 + (double )iter * nu1;
#line 287
      de1 = x * de0 + (double )iter * de1;
#line 290
      if (de1 != 0.) {
#line 292
        nu0 /= de1;
#line 293
        de0 /= de1;
#line 294
        nu1 /= de1;
#line 295
        de1 = 1.;
      }
#line 298
      tmp___2 = fabs((nu1 - oldp) / nu1);
#line 298
      if (tmp___2 < 1.e-7) {
#line 299
        tmp = log(x);
#line 299
        tmp___0 = Gammln(a___0);
#line 299
        tmp___1 = exp((a___0 * tmp - x) - tmp___0);
#line 299
        return (nu1 * tmp___1);
      }
#line 301
      oldp = nu1;
#line 272
      iter ++;
    }
#line 303
    Die((char *)"IncompleteGamma(): failed to converge using continued fraction approx");
  } else {
#line 320
    val = 1. / a___0;
#line 320
    p = val;
#line 321
    iter = 1;
#line 321
    while (iter < 10000) {
#line 323
      val *= x / (a___0 + (double )iter);
#line 324
      p += val;
#line 326
      tmp___6 = fabs(val / p);
#line 326
      if (tmp___6 < 1.e-7) {
#line 327
        tmp___3 = log(x);
#line 327
        tmp___4 = Gammln(a___0);
#line 327
        tmp___5 = exp((a___0 * tmp___3 - x) - tmp___4);
#line 327
        return (1. - p * tmp___5);
      }
#line 321
      iter ++;
    }
#line 329
    Die((char *)"IncompleteGamma(): failed to converge using series approx");
  }
#line 332
  return (0.);
}
}
#line 1 "sre_random.o"
#pragma merger("0","/tmp/cil-ASnRVny5.i","")
#line 10 "./sre_random.h"
double sre_random_positive(void) ;
#line 11
double ExponentialRandom(void) ;
#line 13
int DChoose(double *p , int N ) ;
#line 16 "sre_random.c"
static int sre_randseed  =    42;
#line 48 "sre_random.c"
static long rnd1  ;
#line 49 "sre_random.c"
static long rnd2  ;
#line 50 "sre_random.c"
static long rnd  ;
#line 51 "sre_random.c"
static long tbl[64]  ;
#line 45 "sre_random.c"
double sre_random(void) 
{ 
  long x ;
  long y___0 ;
  int i___0 ;
  long a1 ;
  long m1 ;
  long q1 ;
  long r1 ;
  long a2 ;
  long m2 ;
  long q2 ;
  long r2 ;

  {
#line 58
  a1 = 40014L;
#line 59
  m1 = 2147483563L;
#line 60
  q1 = 53668L;
#line 61
  r1 = 12211L;
#line 63
  a2 = 40692L;
#line 64
  m2 = 2147483399L;
#line 65
  q2 = 52774L;
#line 66
  r2 = 3791L;
#line 68
  if (sre_randseed > 0) {
#line 70
    rnd1 = (long )sre_randseed;
#line 71
    rnd2 = (long )sre_randseed;
#line 73
    i___0 = 0;
#line 73
    while (i___0 < 64) {
#line 74
      x = a1 * (rnd1 % q1);
#line 75
      y___0 = r1 * (rnd1 / q1);
#line 76
      rnd1 = x - y___0;
#line 77
      if (rnd1 < 0L) {
#line 77
        rnd1 += m1;
      }
#line 79
      x = a2 * (rnd2 % q2);
#line 80
      y___0 = r2 * (rnd2 / q2);
#line 81
      rnd2 = x - y___0;
#line 82
      if (rnd2 < 0L) {
#line 82
        rnd2 += m2;
      }
#line 84
      tbl[i___0] = rnd1 - rnd2;
#line 85
      if (tbl[i___0] < 0L) {
#line 85
        tbl[i___0] += m1;
      }
#line 73
      i___0 ++;
    }
#line 87
    sre_randseed = 0;
  }
#line 91
  x = a1 * (rnd1 % q1);
#line 92
  y___0 = r1 * (rnd1 / q1);
#line 93
  rnd1 = x - y___0;
#line 94
  if (rnd1 < 0L) {
#line 94
    rnd1 += m1;
  }
#line 96
  x = a2 * (rnd2 % q2);
#line 97
  y___0 = r2 * (rnd2 / q2);
#line 98
  rnd2 = x - y___0;
#line 99
  if (rnd2 < 0L) {
#line 99
    rnd2 += m2;
  }
#line 102
  i___0 = (int )(((double )rnd / (double )m1) * 64.);
#line 103
  rnd = tbl[i___0];
#line 105
  tbl[i___0] = rnd1 - rnd2;
#line 106
  if (tbl[i___0] < 0L) {
#line 106
    tbl[i___0] += m1;
  }
#line 108
  return ((double )rnd / (double )m1);
}
}
#line 116 "sre_random.c"
void sre_srandom(int seed ) 
{ 


  {
#line 119
  if (seed < 0) {
#line 119
    seed = -1 * seed;
  }
#line 120
  if (seed == 0) {
#line 120
    seed = 42;
  }
#line 121
  sre_randseed = seed;
#line 122
  return;
}
}
#line 129 "sre_random.c"
double sre_random_positive(void) 
{ 
  double x ;

  {
#line 133
  while (1) {
#line 133
    x = sre_random();
#line 133
    if (! (x == 0.0)) {
#line 133
      break;
    }
  }
#line 134
  return (x);
}
}
#line 147 "sre_random.c"
double ExponentialRandom(void) 
{ 
  double x ;
  double tmp ;

  {
#line 152
  while (1) {
#line 152
    x = sre_random();
#line 152
    if (! (x == 0.0)) {
#line 152
      break;
    }
  }
#line 153
  tmp = log(x);
#line 153
  return (- tmp);
}
}
#line 175 "sre_random.c"
static double a[32]  = 
#line 175
  {      0.0,      3.917609E-2,      7.841241E-2,      0.11777, 
        0.1573107,      0.1970991,      0.2372021,      0.2776904, 
        0.3186394,      0.36013,      0.4022501,      0.4450965, 
        0.4887764,      0.5334097,      0.5791322,      0.626099, 
        0.6744898,      0.7245144,      0.7764218,      0.8305109, 
        0.8871466,      0.9467818,      1.00999,      1.077516, 
        1.150349,      1.229859,      1.318011,      1.417797, 
        1.534121,      1.67594,      1.862732,      2.153875};
#line 181 "sre_random.c"
static double d[31]  = 
#line 181
  {      0.0,      0.0,      0.0,      0.0, 
        0.0,      0.2636843,      0.2425085,      0.2255674, 
        0.2116342,      0.1999243,      0.1899108,      0.1812252, 
        0.1736014,      0.1668419,      0.1607967,      0.1553497, 
        0.1504094,      0.1459026,      0.14177,      0.1379632, 
        0.1344418,      0.1311722,      0.128126,      0.1252791, 
        0.1226109,      0.1201036,      0.1177417,      0.1155119, 
        0.1134023,      0.1114027,      0.1095039};
#line 187 "sre_random.c"
static double t[31]  = 
#line 187
  {      7.673828E-4,      2.30687E-3,      3.860618E-3,      5.438454E-3, 
        7.0507E-3,      8.708396E-3,      1.042357E-2,      1.220953E-2, 
        1.408125E-2,      1.605579E-2,      1.81529E-2,      2.039573E-2, 
        2.281177E-2,      2.543407E-2,      2.830296E-2,      3.146822E-2, 
        3.499233E-2,      3.895483E-2,      4.345878E-2,      4.864035E-2, 
        5.468334E-2,      6.184222E-2,      7.047983E-2,      8.113195E-2, 
        9.462444E-2,      0.1123001,      0.136498,      0.1716886, 
        0.2276241,      0.330498,      0.5847031};
#line 194 "sre_random.c"
static double h[31]  = 
#line 194
  {      3.920617E-2,      3.932705E-2,      3.951E-2,      3.975703E-2, 
        4.007093E-2,      4.045533E-2,      4.091481E-2,      4.145507E-2, 
        4.208311E-2,      4.280748E-2,      4.363863E-2,      4.458932E-2, 
        4.567523E-2,      4.691571E-2,      4.833487E-2,      4.996298E-2, 
        5.183859E-2,      5.401138E-2,      5.654656E-2,      5.95313E-2, 
        6.308489E-2,      6.737503E-2,      7.264544E-2,      7.926471E-2, 
        8.781922E-2,      9.930398E-2,      0.11556,      0.1404344, 
        0.1836142,      0.2790016,      0.7010474};
#line 201 "sre_random.c"
static long i  ;
#line 202 "sre_random.c"
static double snorm  ;
#line 202 "sre_random.c"
static double u  ;
#line 202 "sre_random.c"
static double s  ;
#line 202 "sre_random.c"
static double ustar  ;
#line 202 "sre_random.c"
static double aa  ;
#line 202 "sre_random.c"
static double w  ;
#line 202 "sre_random.c"
static double y  ;
#line 202 "sre_random.c"
static double tt  ;
#line 172 "sre_random.c"
double Gaussrandom(double mean , double stddev ) 
{ 


  {
#line 204
  u = sre_random();
#line 205
  s = 0.0;
#line 206
  if (u > 0.5) {
#line 206
    s = 1.0;
  }
#line 207
  u += u - s;
#line 208
  u = 32.0 * u;
#line 209
  i = (long )u;
#line 210
  if (i == 32L) {
#line 210
    i = 31L;
  }
#line 211
  if (i == 0L) {
#line 211
    goto S100;
  }
#line 215
  ustar = u - (double )i;
#line 216
  aa = *((a + i) - 1);
  S40: 
#line 218
  if (ustar <= *((t + i) - 1)) {
#line 218
    goto S60;
  }
#line 219
  w = (ustar - *((t + i) - 1)) * *((h + i) - 1);
  S50: 
#line 224
  y = aa + w;
#line 225
  snorm = y;
#line 226
  if (s == 1.0) {
#line 226
    snorm = - y;
  }
#line 227
  return (stddev * snorm + mean);
  S60: 
#line 232
  u = sre_random();
#line 233
  w = u * (*(a + i) - aa);
#line 234
  tt = (0.5 * w + aa) * w;
#line 235
  goto S80;
  S70: 
#line 237
  tt = u;
#line 238
  ustar = sre_random();
  S80: 
#line 240
  if (ustar > tt) {
#line 240
    goto S50;
  }
#line 241
  u = sre_random();
#line 242
  if (ustar >= u) {
#line 242
    goto S70;
  }
#line 243
  ustar = sre_random();
#line 244
  goto S40;
  S100: 
#line 249
  i = 6L;
#line 250
  aa = *(a + 31);
#line 251
  goto S120;
  S110: 
#line 253
  aa += *((d + i) - 1);
#line 254
  i ++;
  S120: 
#line 256
  u += u;
#line 257
  if (u < 1.0) {
#line 257
    goto S110;
  }
#line 258
  u -= 1.0;
  S140: 
#line 260
  w = u * *((d + i) - 1);
#line 261
  tt = (0.5 * w + aa) * w;
#line 262
  goto S160;
  S150: 
#line 264
  tt = u;
  S160: 
#line 266
  ustar = sre_random();
#line 267
  if (ustar > tt) {
#line 267
    goto S50;
  }
#line 268
  u = sre_random();
#line 269
  if (ustar >= u) {
#line 269
    goto S150;
  }
#line 270
  u = sre_random();
#line 271
  goto S140;
}
}
#line 282 "sre_random.c"
int DChoose(double *p , int N ) 
{ 
  double roll ;
  double sum ;
  int i___0 ;
  double tmp ;

  {
#line 289
  roll = sre_random();
#line 290
  sum = 0.0;
#line 291
  i___0 = 0;
#line 291
  while (i___0 < N) {
#line 293
    sum += *(p + i___0);
#line 294
    if (roll < sum) {
#line 294
      return (i___0);
    }
#line 291
    i___0 ++;
  }
#line 296
  tmp = sre_random();
#line 296
  return ((int )(tmp * (double )N));
}
}
#line 298 "sre_random.c"
int FChoose(float *p , int N ) 
{ 
  float roll ;
  float sum ;
  int i___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 305
  tmp = sre_random();
#line 305
  roll = (float )tmp;
#line 306
  sum = (float )0.0;
#line 307
  i___0 = 0;
#line 307
  while (i___0 < N) {
#line 309
    sum += *(p + i___0);
#line 310
    if (roll < sum) {
#line 310
      return (i___0);
    }
#line 307
    i___0 ++;
  }
#line 312
  tmp___0 = sre_random();
#line 312
  return ((int )(tmp___0 * (double )N));
}
}
#line 1 "sre_string.o"
#pragma merger("0","/tmp/cil-lWMs7d56.i","")
#line 216 "./sqfuncs.h"
int Strinsert(char *s1 , char c , int pos ) ;
#line 217
int Strdelete(char *s1 , int pos ) ;
#line 230
char *sre_strncpy(char *s1 , char *s2 , int n ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 35 "sre_string.c"
char *Strdup(char *s___0 ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 39
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 39
    return ((char *)((void *)0));
  }
#line 40
  tmp = strlen((char const   *)s___0);
#line 40
  tmp___0 = malloc(tmp + 1UL);
#line 40
  new = (char *)tmp___0;
#line 40
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 40
    return ((char *)((void *)0));
  }
#line 41
  strcpy((char * __restrict  )new, (char const   * __restrict  )s___0);
#line 42
  return (new);
}
}
#line 50 "sre_string.c"
void StringChop(char *s___0 ) 
{ 
  int i___0 ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 55
  tmp = strlen((char const   *)s___0);
#line 55
  i___0 = (int )(tmp - 1UL);
#line 56
  while (1) {
#line 56
    if (i___0 >= 0) {
#line 56
      tmp___0 = __ctype_b_loc();
#line 56
      if (! ((int const   )*(*tmp___0 + (int )*(s___0 + i___0)) & 8192)) {
#line 56
        break;
      }
    } else {
#line 56
      break;
    }
#line 56
    i___0 --;
  }
#line 57
  *(s___0 + (i___0 + 1)) = (char )'\000';
#line 58
  return;
}
}
#line 60 "sre_string.c"
int Strinsert(char *s1 , char c , int pos ) 
{ 
  char oldc ;
  char *s___0 ;

  {
#line 68
  s___0 = s1 + pos;
#line 68
  while (c) {
#line 71
    oldc = *s___0;
#line 72
    *s___0 = c;
#line 73
    c = oldc;
#line 68
    s___0 ++;
  }
#line 75
  *s___0 = (char )'\000';
#line 77
  return (1);
}
}
#line 81 "sre_string.c"
int Strdelete(char *s1 , int pos ) 
{ 
  char *s___0 ;

  {
#line 87
  s___0 = s1 + pos;
#line 87
  while (*s___0) {
#line 88
    *s___0 = *(s___0 + 1);
#line 87
    s___0 ++;
  }
#line 90
  return (1);
}
}
#line 93 "sre_string.c"
void s2lower(char *s___0 ) 
{ 
  int tmp ;

  {
#line 96
  while ((int )*s___0 != 0) {
#line 97
    tmp = sre_tolower((int )*s___0);
#line 97
    *s___0 = (char )tmp;
#line 96
    s___0 ++;
  }
#line 98
  return;
}
}
#line 100 "sre_string.c"
void s2upper(char *s___0 ) 
{ 
  int tmp ;

  {
#line 103
  while ((int )*s___0 != 0) {
#line 104
    tmp = sre_toupper((int )*s___0);
#line 104
    *s___0 = (char )tmp;
#line 103
    s___0 ++;
  }
#line 105
  return;
}
}
#line 108 "sre_string.c"
void *sre_malloc(char *file , int line , size_t size ) 
{ 
  void *ptr ;

  {
#line 114
  ptr = malloc(size);
#line 114
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 115
    Die((char *)"malloc of %ld bytes failed: file %s line %d", size, file, line);
  }
#line 116
  return (ptr);
}
}
#line 119 "sre_string.c"
void *sre_realloc(char *file , int line , void *p , size_t size ) 
{ 
  void *ptr ;

  {
#line 124
  ptr = realloc(p, size);
#line 124
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 125
    Die((char *)"realloc of %ld bytes failed: file %s line %d", size, file, line);
  }
#line 126
  return (ptr);
}
}
#line 151 "sre_string.c"
void Free2DArray(void **p , int dim1 ) 
{ 
  int i___0 ;

  {
#line 156
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 157
    i___0 = 0;
#line 157
    while (i___0 < dim1) {
#line 158
      if ((unsigned long )*(p + i___0) != (unsigned long )((void *)0)) {
#line 158
        free(*(p + i___0));
      }
#line 157
      i___0 ++;
    }
#line 159
    free((void *)p);
  }
#line 161
  return;
}
}
#line 162 "sre_string.c"
void Free3DArray(void ***p , int dim1 , int dim2 ) 
{ 
  int i___0 ;
  int j ;

  {
#line 167
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 168
    i___0 = 0;
#line 168
    while (i___0 < dim1) {
#line 169
      if ((unsigned long )*(p + i___0) != (unsigned long )((void *)0)) {
#line 170
        j = 0;
#line 170
        while (j < dim2) {
#line 171
          if ((unsigned long )*(*(p + i___0) + j) != (unsigned long )((void *)0)) {
#line 171
            free(*(*(p + i___0) + j));
          }
#line 170
          j ++;
        }
#line 172
        free((void *)*(p + i___0));
      }
#line 168
      i___0 ++;
    }
#line 174
    free((void *)p);
  }
#line 176
  return;
}
}
#line 193 "sre_string.c"
char *RandomSequence(char *alphabet , float *p , int n , int len ) 
{ 
  char *s___0 ;
  int x ;
  void *tmp ;
  int tmp___0 ;

  {
#line 199
  tmp = sre_malloc((char *)"sre_string.c", 199, sizeof(char ) * (unsigned long )(len + 1));
#line 199
  s___0 = (char *)tmp;
#line 200
  x = 0;
#line 200
  while (x < len) {
#line 201
    tmp___0 = FChoose(p, n);
#line 201
    *(s___0 + x) = *(alphabet + tmp___0);
#line 200
    x ++;
  }
#line 202
  *(s___0 + x) = (char )'\000';
#line 203
  return (s___0);
}
}
#line 244 "sre_string.c"
char *sre_fgets(char **buf , int *n , FILE *fp ) 
{ 
  char *s___0 ;
  int len ;
  int pos ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 251
  if (*n == 0) {
#line 253
    tmp = sre_malloc((char *)"sre_string.c", 253, sizeof(char ) * 128UL);
#line 253
    *buf = (char *)tmp;
#line 254
    *n = 128;
  }
#line 260
  tmp___0 = fgets((char * __restrict  )*buf, *n, (FILE * __restrict  )fp);
#line 260
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 260
    return ((char *)((void *)0));
  }
#line 267
  tmp___1 = feof(fp);
#line 267
  if (tmp___1) {
#line 267
    return (*buf);
  }
#line 272
  tmp___2 = strlen((char const   *)*buf);
#line 272
  len = (int )tmp___2;
#line 273
  if ((int )*(*buf + (len - 1)) == 10) {
#line 273
    return (*buf);
  }
#line 280
  pos = *n - 1;
#line 281
  while (1) {
#line 282
    *n += 128;
#line 283
    tmp___3 = sre_realloc((char *)"sre_string.c", 283, (void *)*buf, sizeof(char ) * (unsigned long )*n);
#line 283
    *buf = (char *)tmp___3;
#line 284
    s___0 = *buf + pos;
#line 285
    tmp___4 = fgets((char * __restrict  )s___0, 129, (FILE * __restrict  )fp);
#line 285
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 285
      return (*buf);
    }
#line 286
    tmp___5 = strlen((char const   *)s___0);
#line 286
    len = (int )tmp___5;
#line 287
    if ((int )*(s___0 + (len - 1)) == 10) {
#line 287
      return (*buf);
    }
#line 288
    pos += 128;
  }
}
}
#line 331 "sre_string.c"
int sre_strcat(char **dest , int ldest , char *src , int lsrc ) 
{ 
  int len1 ;
  int len2 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 336
  if (ldest < 0) {
#line 336
    if ((unsigned long )*dest == (unsigned long )((void *)0)) {
#line 336
      len1 = 0;
    } else {
#line 336
      tmp = strlen((char const   *)*dest);
#line 336
      len1 = (int )tmp;
    }
  } else {
#line 337
    len1 = ldest;
  }
#line 339
  if (lsrc < 0) {
#line 339
    if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 339
      len2 = 0;
    } else {
#line 339
      tmp___0 = strlen((char const   *)src);
#line 339
      len2 = (int )tmp___0;
    }
  } else {
#line 340
    len2 = lsrc;
  }
#line 342
  if (len2 == 0) {
#line 342
    return (len1);
  }
#line 344
  if ((unsigned long )*dest == (unsigned long )((void *)0)) {
#line 344
    tmp___1 = sre_malloc((char *)"sre_string.c", 344, sizeof(char ) * (unsigned long )(len2 + 1));
#line 344
    *dest = (char *)tmp___1;
  } else {
#line 345
    tmp___2 = sre_realloc((char *)"sre_string.c", 345, (void *)*dest, sizeof(char ) * (unsigned long )((len1 + len2) + 1));
#line 345
    *dest = (char *)tmp___2;
  }
#line 347
  memcpy((void * __restrict  )(*dest + len1), (void const   * __restrict  )src, (size_t )(len2 + 1));
#line 348
  return (len1 + len2);
}
}
#line 398 "sre_string.c"
char *sre_strtok(char **s___0 , char *delim , int *len ) 
{ 
  char *begin ;
  char *end ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 404
  begin = *s___0;
#line 405
  tmp = strspn((char const   *)begin, (char const   *)delim);
#line 405
  begin += tmp;
#line 406
  if (! *begin) {
#line 406
    return ((char *)((void *)0));
  }
#line 408
  tmp___0 = strcspn((char const   *)begin, (char const   *)delim);
#line 408
  n = (int )tmp___0;
#line 409
  end = begin + n;
#line 410
  if ((int )*end == 0) {
#line 410
    *s___0 = end;
  } else {
#line 412
    *end = (char )'\000';
#line 413
    *s___0 = end + 1;
  }
#line 416
  if ((unsigned long )len != (unsigned long )((void *)0)) {
#line 416
    *len = n;
  }
#line 417
  return (begin);
}
}
#line 435 "sre_string.c"
char *sre_strdup(char *s___0 , int n ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 440
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 440
    return ((char *)((void *)0));
  }
#line 441
  if (n < 0) {
#line 441
    tmp = strlen((char const   *)s___0);
#line 441
    n = (int )tmp;
  }
#line 442
  tmp___0 = sre_malloc((char *)"sre_string.c", 442, sizeof(char ) * (unsigned long )(n + 1));
#line 442
  new = (char *)tmp___0;
#line 443
  strcpy((char * __restrict  )new, (char const   * __restrict  )s___0);
#line 444
  return (new);
}
}
#line 461 "sre_string.c"
char *sre_strncpy(char *s1 , char *s2 , int n ) 
{ 


  {
#line 464
  strncpy((char * __restrict  )s1, (char const   * __restrict  )s2, (size_t )n);
#line 465
  *(s1 + n) = (char )'\000';
#line 466
  return (s1);
}
}
#line 476 "sre_string.c"
int IsBlankline(char *s___0 ) 
{ 
  unsigned short const   **tmp ;

  {
#line 479
  while ((int )*s___0 != 0) {
#line 480
    tmp = __ctype_b_loc();
#line 480
    if (! ((int const   )*(*tmp + (int )*s___0) & 8192)) {
#line 480
      return (0);
    }
#line 479
    s___0 ++;
  }
#line 481
  return (1);
}
}
#line 1 "ssi.o"
#pragma merger("0","/tmp/cil-oWT5J4yM.i","")
#line 689 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 588
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 781
extern int system(char const   *__command ) ;
#line 162 "./ssi.h"
int SSIGetSubseqOffset(SSIFILE *sfp , char *key , int requested_start , int *ret_fh ,
                       SSIOFFSET *record_offset , SSIOFFSET *data_offset , int *ret_actual_start ) ;
#line 166
int SSIFileInfo(SSIFILE *sfp , int fh , char **ret_filename , int *ret_format ) ;
#line 172
SSIINDEX *SSICreateIndex(int mode ) ;
#line 174
int SSIAddFileToIndex(SSIINDEX *g , char *filename , int fmt , int *ret_fh ) ;
#line 175
int SSISetFileForSubseq(SSIINDEX *g , int fh , int bpl , int rpl ) ;
#line 176
int SSIAddPrimaryKeyToIndex(SSIINDEX *g , char *key , int fh , SSIOFFSET *r_off ,
                            SSIOFFSET *d_off , int L ) ;
#line 179
int SSIAddSecondaryKeyToIndex(SSIINDEX *g , char *key , char *pkey ) ;
#line 180
int SSIWriteIndex(char *file , SSIINDEX *g ) ;
#line 181
void SSIFreeIndex(SSIINDEX *g ) ;
#line 185
char *SSIErrorString(int n ) ;
#line 189
void SSIForceExternalSort(SSIINDEX *g ) ;
#line 258 "./sqfuncs.h"
sqd_uint64 sre_ntoh64(sqd_uint64 net_int64 ) ;
#line 259
sqd_uint64 sre_hton64(sqd_uint64 host_int64 ) ;
#line 24 "ssi.c"
static sqd_uint32 v20magic___0  =    4092848561U;
#line 25 "ssi.c"
static sqd_uint32 v20swap___0  =    2984899571U;
#line 27
static int read_i16(FILE *fp , sqd_uint16 *ret_result ) ;
#line 28
static int read_i32(FILE *fp , sqd_uint32 *ret_result ) ;
#line 29
static int read_i64(FILE *fp , sqd_uint64 *ret_result ) ;
#line 30
static int read_offset(FILE *fp , char mode , SSIOFFSET *ret_offset ) ;
#line 31
static int write_i16(FILE *fp , sqd_uint16 n ) ;
#line 32
static int write_i32(FILE *fp , sqd_uint32 n ) ;
#line 33
static int write_i64(FILE *fp , sqd_uint64 n ) ;
#line 34
static int write_offset(FILE *fp , SSIOFFSET *offset ) ;
#line 35
static int binary_search(SSIFILE *sfp , char *key , int klen , SSIOFFSET *base , sqd_uint32 recsize ,
                         sqd_uint32 maxidx ) ;
#line 37
static int indexfile_position(SSIFILE *sfp , SSIOFFSET *base , sqd_uint32 len , sqd_uint32 n ) ;
#line 39
static void clear_ssifile(SSIFILE *sfp ) ;
#line 40
static sqd_uint64 current_index_size(SSIINDEX *g ) ;
#line 41
static int activate_external_sort(SSIINDEX *g ) ;
#line 42
static int load_indexfile(SSIFILE *sfp ) ;
#line 43
static int parse_pkey_info(char *buf , char mode , struct ssipkey_s *pkey ) ;
#line 44
static int parse_skey_info(char *buf , struct ssiskey_s *skey ) ;
#line 59 "ssi.c"
int SSIOpen(char *filename , SSIFILE **ret_sfp ) 
{ 
  SSIFILE *sfp ;
  int status ;
  void *tmp ;
  FILE *tmp___0 ;

  {
#line 62
  sfp = (SSIFILE *)((void *)0);
#line 64
  tmp = malloc(sizeof(SSIFILE ));
#line 64
  sfp = (SSIFILE *)tmp;
#line 64
  if ((unsigned long )sfp == (unsigned long )((void *)0)) {
#line 64
    return (3);
  }
#line 65
  tmp___0 = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 65
  sfp->fp = tmp___0;
#line 65
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 66
    free((void *)sfp);
#line 67
    return (4);
  }
#line 69
  status = load_indexfile(sfp);
#line 70
  *ret_sfp = sfp;
#line 71
  return (status);
}
}
#line 78 "ssi.c"
static int load_indexfile(SSIFILE *sfp ) 
{ 
  sqd_uint32 magic ;
  sqd_uint16 i___0 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char **tmp___13 ;
  void *tmp___14 ;
  sqd_uint32 *tmp___15 ;
  void *tmp___16 ;
  sqd_uint32 *tmp___17 ;
  void *tmp___18 ;
  sqd_uint32 *tmp___19 ;
  void *tmp___20 ;
  sqd_uint32 *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 85
  status = 6;
#line 87
  sfp->filename = (char **)((void *)0);
#line 88
  sfp->fileformat = (sqd_uint32 *)((void *)0);
#line 89
  sfp->fileflags = (sqd_uint32 *)((void *)0);
#line 90
  sfp->bpl = (sqd_uint32 *)((void *)0);
#line 91
  sfp->rpl = (sqd_uint32 *)((void *)0);
#line 92
  sfp->nfiles = (sqd_uint16 )0;
#line 93
  tmp = read_i32(sfp->fp, & magic);
#line 93
  if (! tmp) {
#line 93
    status = 5;
#line 93
    goto FAILURE;
  }
#line 94
  if (magic != v20magic___0) {
#line 94
    if (magic != v20swap___0) {
#line 94
      status = 5;
#line 94
      goto FAILURE;
    }
  }
#line 95
  tmp___0 = read_i32(sfp->fp, & sfp->flags);
#line 95
  if (! tmp___0) {
#line 95
    goto FAILURE;
  }
#line 100
  if (sfp->flags & (unsigned int )(1 << 1)) {
#line 102
    status = 7;
#line 102
    goto FAILURE;
  } else
#line 100
  if (sfp->flags & 1U) {
#line 102
    status = 7;
#line 102
    goto FAILURE;
  }
#line 105
  if (sfp->flags & (unsigned int )(1 << 1)) {
#line 105
    sfp->imode = (char)1;
  } else {
#line 105
    sfp->imode = (char)0;
  }
#line 106
  if (sfp->flags & 1U) {
#line 106
    sfp->smode = (char)1;
  } else {
#line 106
    sfp->smode = (char)0;
  }
#line 108
  tmp___1 = read_i16(sfp->fp, & sfp->nfiles);
#line 108
  if (! tmp___1) {
#line 108
    goto FAILURE;
  }
#line 109
  tmp___2 = read_i32(sfp->fp, & sfp->nprimary);
#line 109
  if (! tmp___2) {
#line 109
    goto FAILURE;
  }
#line 110
  tmp___3 = read_i32(sfp->fp, & sfp->nsecondary);
#line 110
  if (! tmp___3) {
#line 110
    goto FAILURE;
  }
#line 111
  tmp___4 = read_i32(sfp->fp, & sfp->flen);
#line 111
  if (! tmp___4) {
#line 111
    goto FAILURE;
  }
#line 112
  tmp___5 = read_i32(sfp->fp, & sfp->plen);
#line 112
  if (! tmp___5) {
#line 112
    goto FAILURE;
  }
#line 113
  tmp___6 = read_i32(sfp->fp, & sfp->slen);
#line 113
  if (! tmp___6) {
#line 113
    goto FAILURE;
  }
#line 114
  tmp___7 = read_i32(sfp->fp, & sfp->frecsize);
#line 114
  if (! tmp___7) {
#line 114
    goto FAILURE;
  }
#line 115
  tmp___8 = read_i32(sfp->fp, & sfp->precsize);
#line 115
  if (! tmp___8) {
#line 115
    goto FAILURE;
  }
#line 116
  tmp___9 = read_i32(sfp->fp, & sfp->srecsize);
#line 116
  if (! tmp___9) {
#line 116
    goto FAILURE;
  }
#line 118
  tmp___10 = read_offset(sfp->fp, sfp->imode, & sfp->foffset);
#line 118
  if (! tmp___10) {
#line 118
    goto FAILURE;
  }
#line 119
  tmp___11 = read_offset(sfp->fp, sfp->imode, & sfp->poffset);
#line 119
  if (! tmp___11) {
#line 119
    goto FAILURE;
  }
#line 120
  tmp___12 = read_offset(sfp->fp, sfp->imode, & sfp->soffset);
#line 120
  if (! tmp___12) {
#line 120
    goto FAILURE;
  }
#line 128
  if ((int )sfp->nfiles == 0) {
#line 128
    goto FAILURE;
  }
#line 129
  tmp___14 = malloc(sizeof(char *) * (unsigned long )sfp->nfiles);
#line 129
  tmp___13 = (char **)tmp___14;
#line 129
  sfp->filename = tmp___13;
#line 129
  if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 129
    status = 3;
#line 129
    goto FAILURE;
  }
#line 130
  i___0 = (sqd_uint16 )0;
#line 130
  while ((int )i___0 < (int )sfp->nfiles) {
#line 130
    *(sfp->filename + i___0) = (char *)((void *)0);
#line 130
    i___0 = (sqd_uint16 )((int )i___0 + 1);
  }
#line 131
  tmp___16 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
#line 131
  tmp___15 = (sqd_uint32 *)tmp___16;
#line 131
  sfp->fileformat = tmp___15;
#line 131
  if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
#line 131
    status = 3;
#line 131
    goto FAILURE;
  }
#line 132
  tmp___18 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
#line 132
  tmp___17 = (sqd_uint32 *)tmp___18;
#line 132
  sfp->fileflags = tmp___17;
#line 132
  if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
#line 132
    status = 3;
#line 132
    goto FAILURE;
  }
#line 133
  tmp___20 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
#line 133
  tmp___19 = (sqd_uint32 *)tmp___20;
#line 133
  sfp->bpl = tmp___19;
#line 133
  if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
#line 133
    status = 3;
#line 133
    goto FAILURE;
  }
#line 134
  tmp___22 = malloc(sizeof(sqd_uint32 ) * (unsigned long )sfp->nfiles);
#line 134
  tmp___21 = (sqd_uint32 *)tmp___22;
#line 134
  sfp->rpl = tmp___21;
#line 134
  if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
#line 134
    status = 3;
#line 134
    goto FAILURE;
  }
#line 136
  i___0 = (sqd_uint16 )0;
#line 136
  while ((int )i___0 < (int )sfp->nfiles) {
#line 142
    tmp___23 = indexfile_position(sfp, & sfp->foffset, sfp->frecsize, (sqd_uint32 )i___0);
#line 142
    if (tmp___23 != 0) {
#line 142
      goto FAILURE;
    }
#line 143
    tmp___25 = malloc(sizeof(char ) * (unsigned long )sfp->flen);
#line 143
    tmp___24 = (char *)tmp___25;
#line 143
    *(sfp->filename + i___0) = tmp___24;
#line 143
    if ((unsigned long )tmp___24 == (unsigned long )((void *)0)) {
#line 143
      status = 3;
#line 143
      goto FAILURE;
    }
#line 144
    tmp___26 = fread((void * __restrict  )*(sfp->filename + i___0), sizeof(char ),
                     (size_t )sfp->flen, (FILE * __restrict  )sfp->fp);
#line 144
    if (tmp___26 != (size_t )sfp->flen) {
#line 144
      goto FAILURE;
    }
#line 145
    tmp___27 = read_i32(sfp->fp, sfp->fileformat + i___0);
#line 145
    if (! tmp___27) {
#line 145
      goto FAILURE;
    }
#line 146
    tmp___28 = read_i32(sfp->fp, sfp->fileflags + i___0);
#line 146
    if (! tmp___28) {
#line 146
      goto FAILURE;
    }
#line 147
    tmp___29 = read_i32(sfp->fp, sfp->bpl + i___0);
#line 147
    if (! tmp___29) {
#line 147
      goto FAILURE;
    }
#line 148
    tmp___30 = read_i32(sfp->fp, sfp->rpl + i___0);
#line 148
    if (! tmp___30) {
#line 148
      goto FAILURE;
    }
#line 136
    i___0 = (sqd_uint16 )((int )i___0 + 1);
  }
#line 153
  return (0);
  FAILURE: 
#line 158
  SSIClose(sfp);
#line 159
  return (status);
}
}
#line 183 "ssi.c"
int SSIGetOffsetByName(SSIFILE *sfp , char *key , int *ret_fh , SSIOFFSET *ret_offset ) 
{ 
  int status ;
  sqd_uint16 fnum ;
  int tmp ;
  int tmp___0 ;
  char *pkey ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 192
  status = binary_search(sfp, key, (int )sfp->plen, & sfp->poffset, sfp->precsize,
                         sfp->nprimary);
#line 194
  if (status == 0) {
#line 197
    tmp = read_i16(sfp->fp, & fnum);
#line 197
    if (! tmp) {
#line 197
      return (1);
    }
#line 198
    *ret_fh = (int )fnum;
#line 199
    tmp___0 = read_offset(sfp->fp, sfp->smode, ret_offset);
#line 199
    if (! tmp___0) {
#line 199
      return (1);
    }
#line 201
    return (0);
  } else
#line 202
  if (status == 2) {
#line 205
    if (sfp->nsecondary > 0U) {
#line 207
      status = binary_search(sfp, key, (int )sfp->slen, & sfp->soffset, sfp->srecsize,
                             sfp->nsecondary);
#line 209
      if (status != 0) {
#line 209
        return (status);
      }
#line 210
      tmp___1 = malloc(sizeof(char ) * (unsigned long )sfp->plen);
#line 210
      pkey = (char *)tmp___1;
#line 210
      if ((unsigned long )pkey == (unsigned long )((void *)0)) {
#line 210
        return (3);
      }
#line 211
      tmp___2 = fread((void * __restrict  )pkey, sizeof(char ), (size_t )sfp->plen,
                      (FILE * __restrict  )sfp->fp);
#line 211
      if (tmp___2 != (size_t )sfp->plen) {
#line 211
        return (1);
      }
#line 213
      status = SSIGetOffsetByName(sfp, pkey, ret_fh, ret_offset);
#line 214
      free((void *)pkey);
    }
#line 216
    return (status);
  } else {
#line 218
    return (status);
  }
}
}
#line 241 "ssi.c"
int SSIGetOffsetByNumber(SSIFILE *sfp , int n , int *ret_fh , SSIOFFSET *ret_offset ) 
{ 
  sqd_uint16 fnum ;
  char *pkey ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 247
  if ((sqd_uint32 )n >= sfp->nprimary) {
#line 247
    return (2);
  }
#line 248
  tmp = indexfile_position(sfp, & sfp->poffset, sfp->precsize, (sqd_uint32 )n);
#line 248
  if (tmp != 0) {
#line 249
    return (8);
  }
#line 251
  tmp___0 = malloc(sizeof(char ) * (unsigned long )sfp->plen);
#line 251
  pkey = (char *)tmp___0;
#line 251
  if ((unsigned long )pkey == (unsigned long )((void *)0)) {
#line 251
    return (3);
  }
#line 252
  tmp___1 = fread((void * __restrict  )pkey, sizeof(char ), (size_t )sfp->plen, (FILE * __restrict  )sfp->fp);
#line 252
  if (tmp___1 != (size_t )sfp->plen) {
#line 252
    return (1);
  }
#line 253
  tmp___2 = read_i16(sfp->fp, & fnum);
#line 253
  if (! tmp___2) {
#line 253
    return (1);
  }
#line 254
  tmp___3 = read_offset(sfp->fp, sfp->smode, ret_offset);
#line 254
  if (! tmp___3) {
#line 254
    return (1);
  }
#line 255
  *ret_fh = (int )fnum;
#line 256
  free((void *)pkey);
#line 257
  return (0);
}
}
#line 292 "ssi.c"
int SSIGetSubseqOffset(SSIFILE *sfp , char *key , int requested_start , int *ret_fh ,
                       SSIOFFSET *record_offset , SSIOFFSET *data_offset , int *ret_actual_start ) 
{ 
  int status ;
  sqd_uint32 len ;
  int r ;
  int b ;
  int i___0 ;
  int l ;
  int tmp ;
  int tmp___0 ;

  {
#line 304
  status = SSIGetOffsetByName(sfp, key, ret_fh, record_offset);
#line 305
  if (status != 0) {
#line 305
    return (status);
  }
#line 309
  if (! (*(sfp->fileflags + *ret_fh) & 1U)) {
#line 310
    return (10);
  }
#line 314
  tmp = read_offset(sfp->fp, sfp->smode, data_offset);
#line 314
  if (! tmp) {
#line 314
    return (1);
  }
#line 315
  tmp___0 = read_i32(sfp->fp, & len);
#line 315
  if (! tmp___0) {
#line 315
    return (1);
  }
#line 320
  r = (int )*(sfp->rpl + *ret_fh);
#line 321
  b = (int )*(sfp->bpl + *ret_fh);
#line 322
  i___0 = requested_start;
#line 323
  l = (i___0 - 1) / r;
#line 324
  if (r == 0) {
#line 324
    return (10);
  } else
#line 324
  if (b == 0) {
#line 324
    return (10);
  }
#line 325
  if (i___0 < 0) {
#line 325
    return (11);
  } else
#line 325
  if ((sqd_uint32 )i___0 > len) {
#line 325
    return (11);
  }
#line 330
  if (b == r + 1) {
#line 331
    if ((int )sfp->smode == 0) {
#line 332
      data_offset->mode = (char)0;
#line 333
      data_offset->off.i32 = (data_offset->off.i32 + (sqd_uint32 )(l * b)) + (sqd_uint32 )((i___0 - 1) % r);
    } else
#line 334
    if ((int )sfp->smode == 1) {
#line 335
      data_offset->mode = (char)1;
#line 336
      data_offset->off.i64 = (data_offset->off.i64 + (sqd_uint64 )(l * b)) + (sqd_uint64 )((i___0 - 1) % r);
    }
#line 338
    *ret_actual_start = requested_start;
  } else {
#line 343
    if ((int )sfp->smode == 0) {
#line 344
      data_offset->mode = (char)0;
#line 345
      data_offset->off.i32 += (sqd_uint32 )(l * b);
    } else
#line 346
    if ((int )sfp->smode == 1) {
#line 347
      data_offset->mode = (char)1;
#line 348
      data_offset->off.i64 += (sqd_uint64 )(l * b);
    }
#line 351
    *ret_actual_start = 1 + l * r;
  }
#line 353
  return (0);
}
}
#line 378 "ssi.c"
int SSISetFilePosition(FILE *fp , SSIOFFSET *offset ) 
{ 
  int tmp ;

  {
#line 381
  if ((int )offset->mode == 0) {
#line 382
    tmp = fseek(fp, (long )offset->off.i32, 0);
#line 382
    if (tmp != 0) {
#line 382
      return (8);
    }
  } else {
#line 385
    return (7);
  }
#line 395
  return (0);
}
}
#line 417 "ssi.c"
int SSIFileInfo(SSIFILE *sfp , int fh , char **ret_filename , int *ret_format ) 
{ 


  {
#line 420
  if (fh < 0) {
#line 420
    return (12);
  } else
#line 420
  if (fh >= (int )sfp->nfiles) {
#line 420
    return (12);
  }
#line 421
  *ret_filename = *(sfp->filename + fh);
#line 422
  *ret_format = (int )*(sfp->fileformat + fh);
#line 423
  return (0);
}
}
#line 435 "ssi.c"
void SSIClose(SSIFILE *sfp ) 
{ 


  {
#line 438
  if ((unsigned long )sfp != (unsigned long )((void *)0)) {
#line 439
    clear_ssifile(sfp);
#line 440
    if ((unsigned long )sfp->fp != (unsigned long )((void *)0)) {
#line 440
      fclose(sfp->fp);
    }
#line 441
    free((void *)sfp);
  }
#line 443
  return;
}
}
#line 447 "ssi.c"
static void clear_ssifile(SSIFILE *sfp ) 
{ 
  int i___0 ;

  {
#line 452
  if ((unsigned long )sfp->filename != (unsigned long )((void *)0)) {
#line 453
    i___0 = 0;
#line 453
    while (i___0 < (int )sfp->nfiles) {
#line 454
      if ((unsigned long )*(sfp->filename + i___0) != (unsigned long )((void *)0)) {
#line 454
        free((void *)*(sfp->filename + i___0));
      }
#line 453
      i___0 ++;
    }
#line 455
    free((void *)sfp->filename);
  }
#line 457
  if ((unsigned long )sfp->fileformat != (unsigned long )((void *)0)) {
#line 457
    free((void *)sfp->fileformat);
  }
#line 458
  if ((unsigned long )sfp->fileflags != (unsigned long )((void *)0)) {
#line 458
    free((void *)sfp->fileflags);
  }
#line 459
  if ((unsigned long )sfp->bpl != (unsigned long )((void *)0)) {
#line 459
    free((void *)sfp->bpl);
  }
#line 460
  if ((unsigned long )sfp->rpl != (unsigned long )((void *)0)) {
#line 460
    free((void *)sfp->rpl);
  }
#line 461
  return;
}
}
#line 478 "ssi.c"
int SSIRecommendMode(char *file ) 
{ 


  {
#line 482
  return (0);
}
}
#line 514 "ssi.c"
SSIINDEX *SSICreateIndex(int mode ) 
{ 
  SSIINDEX *g ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;
  sqd_uint32 *tmp___2 ;
  void *tmp___3 ;
  sqd_uint32 *tmp___4 ;
  void *tmp___5 ;
  sqd_uint32 *tmp___6 ;
  void *tmp___7 ;
  struct ssipkey_s *tmp___8 ;
  void *tmp___9 ;
  struct ssiskey_s *tmp___10 ;
  void *tmp___11 ;

  {
#line 519
  g = (SSIINDEX *)((void *)0);
#line 520
  tmp = malloc(sizeof(SSIINDEX ));
#line 520
  g = (SSIINDEX *)tmp;
#line 520
  if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 520
    goto FAILURE;
  }
#line 521
  g->smode = mode;
#line 522
  g->imode = 0;
#line 523
  g->external = 0;
#line 524
  g->max_ram = 200;
#line 527
  if (mode == 1) {
#line 528
    Die((char *)"Can\'t create a 64-bit SSI index on this system, sorry;\nI don\'t have 64-bit file offset functions available.\n");
  }
#line 533
  g->filenames = (char **)((void *)0);
#line 534
  g->fileformat = (sqd_uint32 *)((void *)0);
#line 535
  g->bpl = (sqd_uint32 *)((void *)0);
#line 536
  g->rpl = (sqd_uint32 *)((void *)0);
#line 537
  g->flen = (sqd_uint32 )0;
#line 538
  g->nfiles = (sqd_uint16 )0;
#line 540
  g->pkeys = (struct ssipkey_s *)((void *)0);
#line 541
  g->plen = (sqd_uint32 )0;
#line 542
  g->nprimary = (sqd_uint32 )0;
#line 543
  g->ptmpfile = (char *)"tmp.ssi.1";
#line 544
  g->ptmp = (FILE *)((void *)0);
#line 546
  g->skeys = (struct ssiskey_s *)((void *)0);
#line 547
  g->slen = (sqd_uint32 )0;
#line 548
  g->nsecondary = (sqd_uint32 )0;
#line 549
  g->stmpfile = (char *)"tmp.ssi.2";
#line 550
  g->stmp = (FILE *)((void *)0);
#line 555
  tmp___1 = malloc(sizeof(char *) * 10UL);
#line 555
  tmp___0 = (char **)tmp___1;
#line 555
  g->filenames = tmp___0;
#line 555
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 555
    goto FAILURE;
  }
#line 556
  tmp___3 = malloc(sizeof(sqd_uint32 ) * 10UL);
#line 556
  tmp___2 = (sqd_uint32 *)tmp___3;
#line 556
  g->fileformat = tmp___2;
#line 556
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 556
    goto FAILURE;
  }
#line 557
  tmp___5 = malloc(sizeof(sqd_uint32 ) * 10UL);
#line 557
  tmp___4 = (sqd_uint32 *)tmp___5;
#line 557
  g->bpl = tmp___4;
#line 557
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 557
    goto FAILURE;
  }
#line 558
  tmp___7 = malloc(sizeof(sqd_uint32 ) * 10UL);
#line 558
  tmp___6 = (sqd_uint32 *)tmp___7;
#line 558
  g->rpl = tmp___6;
#line 558
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 558
    goto FAILURE;
  }
#line 560
  tmp___9 = malloc(sizeof(struct ssipkey_s ) * 100UL);
#line 560
  tmp___8 = (struct ssipkey_s *)tmp___9;
#line 560
  g->pkeys = tmp___8;
#line 560
  if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 560
    goto FAILURE;
  }
#line 561
  tmp___11 = malloc(sizeof(struct ssipkey_s ) * 100UL);
#line 561
  tmp___10 = (struct ssiskey_s *)tmp___11;
#line 561
  g->skeys = tmp___10;
#line 561
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 561
    goto FAILURE;
  }
#line 563
  return (g);
  FAILURE: 
#line 566
  SSIFreeIndex(g);
#line 567
  return ((SSIINDEX *)((void *)0));
}
}
#line 586 "ssi.c"
int SSIGetFilePosition(FILE *fp , int mode , SSIOFFSET *ret_offset ) 
{ 
  long tmp ;

  {
#line 589
  if (mode == 0) {
#line 591
    ret_offset->mode = (char)0;
#line 592
    tmp = ftell(fp);
#line 592
    ret_offset->off.i32 = (sqd_uint32 )tmp;
#line 593
    if (ret_offset->off.i32 == 4294967295U) {
#line 593
      return (9);
    }
  } else
#line 595
  if (mode != 1) {
#line 595
    abort();
  } else {
#line 597
    ret_offset->mode = (char)1;
#line 599
    return (7);
  }
#line 610
  return (0);
}
}
#line 628 "ssi.c"
int SSIAddFileToIndex(SSIINDEX *g , char *filename , int fmt , int *ret_fh ) 
{ 
  int n ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 633
  if ((int )g->nfiles >= 32767) {
#line 633
    return (13);
  }
#line 635
  tmp = strlen((char const   *)filename);
#line 635
  n = (int )tmp;
#line 636
  if ((sqd_uint32 )(n + 1) > g->flen) {
#line 636
    g->flen = (sqd_uint32 )(n + 1);
  }
#line 638
  *(g->filenames + g->nfiles) = FileTail(filename, 0);
#line 639
  *(g->fileformat + g->nfiles) = (sqd_uint32 )fmt;
#line 640
  *(g->bpl + g->nfiles) = (sqd_uint32 )0;
#line 641
  *(g->rpl + g->nfiles) = (sqd_uint32 )0;
#line 642
  *ret_fh = (int )g->nfiles;
#line 643
  g->nfiles = (sqd_uint16 )((int )g->nfiles + 1);
#line 645
  if ((int )g->nfiles % 10 == 0) {
#line 646
    tmp___0 = realloc((void *)g->filenames, sizeof(char *) * (unsigned long )((int )g->nfiles + 10));
#line 646
    g->filenames = (char **)tmp___0;
#line 647
    if ((unsigned long )g->filenames == (unsigned long )((void *)0)) {
#line 647
      return (3);
    }
#line 648
    tmp___1 = realloc((void *)g->fileformat, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
#line 648
    g->fileformat = (sqd_uint32 *)tmp___1;
#line 649
    if ((unsigned long )g->fileformat == (unsigned long )((void *)0)) {
#line 649
      return (3);
    }
#line 650
    tmp___2 = realloc((void *)g->bpl, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
#line 650
    g->bpl = (sqd_uint32 *)tmp___2;
#line 651
    if ((unsigned long )g->bpl == (unsigned long )((void *)0)) {
#line 651
      return (3);
    }
#line 652
    tmp___3 = realloc((void *)g->rpl, sizeof(sqd_uint32 ) * (unsigned long )((int )g->nfiles + 10));
#line 652
    g->rpl = (sqd_uint32 *)tmp___3;
#line 653
    if ((unsigned long )g->rpl == (unsigned long )((void *)0)) {
#line 653
      return (3);
    }
  }
#line 655
  return (0);
}
}
#line 681 "ssi.c"
int SSISetFileForSubseq(SSIINDEX *g , int fh , int bpl , int rpl ) 
{ 


  {
#line 684
  if (fh < 0) {
#line 684
    return (12);
  } else
#line 684
  if (fh >= (int )g->nfiles) {
#line 684
    return (12);
  }
#line 685
  if (bpl <= 0) {
#line 685
    return (12);
  } else
#line 685
  if (rpl <= 0) {
#line 685
    return (12);
  }
#line 686
  *(g->bpl + fh) = (sqd_uint32 )bpl;
#line 687
  *(g->rpl + fh) = (sqd_uint32 )rpl;
#line 688
  return (0);
}
}
#line 725 "ssi.c"
int SSIAddPrimaryKeyToIndex(SSIINDEX *g , char *key , int fh , SSIOFFSET *r_off ,
                            SSIOFFSET *d_off , int L ) 
{ 
  int n ;
  int tmp ;
  sqd_uint64 tmp___0 ;
  size_t tmp___1 ;
  sqd_uint32 tmp___2 ;
  sqd_uint64 tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
#line 731
  if (fh >= 32767) {
#line 731
    return (13);
  }
#line 732
  if ((long )g->nprimary >= 2147483647L) {
#line 732
    return (14);
  }
#line 733
  if (L > 0) {
#line 733
    if ((unsigned long )d_off == (unsigned long )((void *)0)) {
#line 733
      abort();
    }
  }
#line 738
  if (! g->external) {
#line 738
    tmp___0 = current_index_size(g);
#line 738
    if (tmp___0 >= (sqd_uint64 )g->max_ram) {
#line 739
      tmp = activate_external_sort(g);
#line 739
      if (tmp != 0) {
#line 739
        return (4);
      }
    }
  }
#line 743
  tmp___1 = strlen((char const   *)key);
#line 743
  n = (int )tmp___1;
#line 744
  if ((sqd_uint32 )(n + 1) > g->plen) {
#line 744
    g->plen = (sqd_uint32 )(n + 1);
  }
#line 748
  if (g->external) {
#line 749
    if (g->smode == 0) {
#line 750
      if ((unsigned long )d_off == (unsigned long )((void *)0)) {
#line 750
        tmp___2 = (sqd_uint32 )0;
      } else {
#line 750
        tmp___2 = d_off->off.i32;
      }
#line 750
      fprintf((FILE * __restrict  )g->ptmp, (char const   * __restrict  )"%s\t%d\t%lu\t%lu\t%lu\n",
              key, fh, (unsigned long )r_off->off.i32, (unsigned long )tmp___2, (unsigned long )L);
    } else {
#line 755
      if ((unsigned long )d_off == (unsigned long )((void *)0)) {
#line 755
        tmp___3 = (sqd_uint64 )0;
      } else {
#line 755
        tmp___3 = d_off->off.i64;
      }
#line 755
      fprintf((FILE * __restrict  )g->ptmp, (char const   * __restrict  )"%s\t%d\t%llu\t%llu\t%lu\n",
              key, fh, r_off->off.i64, tmp___3, (unsigned long )L);
    }
#line 760
    (g->nprimary) ++;
#line 761
    return (0);
  }
#line 766
  tmp___4 = sre_strdup(key, n);
#line 766
  (g->pkeys + g->nprimary)->key = tmp___4;
#line 766
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 766
    return (3);
  }
#line 767
  (g->pkeys + g->nprimary)->fnum = (sqd_uint16 )fh;
#line 768
  (g->pkeys + g->nprimary)->r_off = *r_off;
#line 769
  if ((unsigned long )d_off != (unsigned long )((void *)0)) {
#line 769
    if (L > 0) {
#line 770
      (g->pkeys + g->nprimary)->d_off = *d_off;
#line 771
      (g->pkeys + g->nprimary)->len = (sqd_uint32 )L;
    } else {
#line 776
      (g->pkeys + g->nprimary)->d_off = *r_off;
#line 777
      (g->pkeys + g->nprimary)->len = (sqd_uint32 )0;
    }
  } else {
#line 776
    (g->pkeys + g->nprimary)->d_off = *r_off;
#line 777
    (g->pkeys + g->nprimary)->len = (sqd_uint32 )0;
  }
#line 779
  (g->nprimary) ++;
#line 781
  if (g->nprimary % 100U == 0U) {
#line 782
    tmp___5 = realloc((void *)g->pkeys, sizeof(struct ssipkey_s ) * (unsigned long )(g->nprimary + 100U));
#line 782
    g->pkeys = (struct ssipkey_s *)tmp___5;
#line 783
    if ((unsigned long )g->pkeys == (unsigned long )((void *)0)) {
#line 783
      return (3);
    }
  }
#line 785
  return (0);
}
}
#line 802 "ssi.c"
int SSIAddSecondaryKeyToIndex(SSIINDEX *g , char *key , char *pkey ) 
{ 
  int n ;
  int tmp ;
  sqd_uint64 tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
#line 807
  if ((long )g->nsecondary >= 2147483647L) {
#line 807
    return (14);
  }
#line 812
  if (! g->external) {
#line 812
    tmp___0 = current_index_size(g);
#line 812
    if (tmp___0 >= (sqd_uint64 )g->max_ram) {
#line 813
      tmp = activate_external_sort(g);
#line 813
      if (tmp != 0) {
#line 813
        return (4);
      }
    }
  }
#line 817
  tmp___1 = strlen((char const   *)key);
#line 817
  n = (int )tmp___1;
#line 818
  if ((sqd_uint32 )(n + 1) > g->slen) {
#line 818
    g->slen = (sqd_uint32 )(n + 1);
  }
#line 822
  if (g->external) {
#line 823
    fprintf((FILE * __restrict  )g->stmp, (char const   * __restrict  )"%s\t%s\n",
            key, pkey);
#line 824
    (g->nsecondary) ++;
#line 825
    return (0);
  }
#line 830
  tmp___2 = sre_strdup(key, n);
#line 830
  (g->skeys + g->nsecondary)->key = tmp___2;
#line 830
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 830
    return (3);
  }
#line 831
  tmp___3 = sre_strdup(pkey, -1);
#line 831
  (g->skeys + g->nsecondary)->pkey = tmp___3;
#line 831
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 831
    return (3);
  }
#line 832
  (g->nsecondary) ++;
#line 834
  if (g->nsecondary % 100U == 0U) {
#line 835
    tmp___4 = realloc((void *)g->skeys, sizeof(struct ssiskey_s ) * (unsigned long )(g->nsecondary + 100U));
#line 835
    g->skeys = (struct ssiskey_s *)tmp___4;
#line 836
    if ((unsigned long )g->skeys == (unsigned long )((void *)0)) {
#line 836
      return (3);
    }
  }
#line 838
  return (0);
}
}
#line 859 "ssi.c"
static int pkeysort(void const   *k1 , void const   *k2 ) 
{ 
  struct ssipkey_s *key1 ;
  struct ssipkey_s *key2 ;
  int tmp ;

  {
#line 864
  key1 = (struct ssipkey_s *)k1;
#line 865
  key2 = (struct ssipkey_s *)k2;
#line 866
  tmp = strcmp((char const   *)key1->key, (char const   *)key2->key);
#line 866
  return (tmp);
}
}
#line 868 "ssi.c"
static int skeysort(void const   *k1 , void const   *k2 ) 
{ 
  struct ssiskey_s *key1 ;
  struct ssiskey_s *key2 ;
  int tmp ;

  {
#line 873
  key1 = (struct ssiskey_s *)k1;
#line 874
  key2 = (struct ssiskey_s *)k2;
#line 875
  tmp = strcmp((char const   *)key1->key, (char const   *)key2->key);
#line 875
  return (tmp);
}
}
#line 877 "ssi.c"
int SSIWriteIndex(char *file , SSIINDEX *g ) 
{ 
  FILE *fp ;
  int status ;
  int i___0 ;
  sqd_uint32 header_flags ;
  sqd_uint32 file_flags ;
  sqd_uint32 frecsize ;
  sqd_uint32 precsize ;
  sqd_uint32 srecsize ;
  sqd_uint64 foffset ;
  sqd_uint64 poffset ;
  sqd_uint64 soffset ;
  char *s___0 ;
  char *s2 ;
  sqd_uint64 tmp ;
  char cmd[1024] ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  char *buf ;
  int buflen ;
  struct ssipkey_s pkey ;
  char *tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  struct ssiskey_s skey ;
  char *buf___0 ;
  int n ;
  char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;

  {
#line 888
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"wb");
#line 888
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 888
    return (4);
  }
#line 889
  status = 0;
#line 898
  tmp = current_index_size(g);
#line 898
  if (tmp >= 2047ULL) {
#line 899
    g->imode = 1;
#line 901
    Die((char *)"Can\'t switch to 64-bit SSI index mode on this system, sorry;\nI don\'t have 64-bit file offset functions available.\n");
  }
#line 910
  frecsize = 16U + g->flen;
#line 911
  if (g->smode == 1) {
#line 911
    precsize = 22U + g->plen;
  } else {
#line 911
    precsize = 14U + g->plen;
  }
#line 912
  srecsize = g->slen + g->plen;
#line 914
  header_flags = (sqd_uint32 )0;
#line 915
  if (g->smode == 1) {
#line 915
    header_flags |= 1U;
  }
#line 916
  if (g->imode == 1) {
#line 916
    header_flags |= (unsigned int )(1 << 1);
  }
#line 921
  if (header_flags & (unsigned int )(1 << 1)) {
#line 921
    foffset = (sqd_uint64 )66;
  } else {
#line 921
    foffset = (sqd_uint64 )54;
  }
#line 922
  poffset = foffset + (sqd_uint64 )(frecsize * (sqd_uint32 )g->nfiles);
#line 923
  soffset = poffset + (sqd_uint64 )(precsize * g->nprimary);
#line 935
  if (g->external) {
#line 938
    fclose(g->ptmp);
#line 939
    g->ptmp = (FILE *)((void *)0);
#line 940
    sprintf((char * __restrict  )(cmd), (char const   * __restrict  )"env LC_ALL=POSIX sort -o %s %s\n",
            g->ptmpfile, g->ptmpfile);
#line 941
    status = system((char const   *)(cmd));
#line 941
    if (status != 0) {
#line 941
      return (16);
    }
#line 942
    tmp___0 = fopen((char const   * __restrict  )g->ptmpfile, (char const   * __restrict  )"r");
#line 942
    g->ptmp = tmp___0;
#line 942
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 942
      return (16);
    }
#line 944
    fclose(g->stmp);
#line 945
    g->stmp = (FILE *)((void *)0);
#line 946
    sprintf((char * __restrict  )(cmd), (char const   * __restrict  )"env LC_ALL=POSIX sort -o %s %s\n",
            g->stmpfile, g->stmpfile);
#line 947
    status = system((char const   *)(cmd));
#line 947
    if (status != 0) {
#line 947
      return (16);
    }
#line 948
    tmp___1 = fopen((char const   * __restrict  )g->stmpfile, (char const   * __restrict  )"r");
#line 948
    g->stmp = tmp___1;
#line 948
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 948
      return (16);
    }
  } else {
#line 950
    specqsort((void *)g->pkeys, g->nprimary, sizeof(struct ssipkey_s ), & pkeysort);
#line 951
    specqsort((void *)g->skeys, g->nsecondary, sizeof(struct ssiskey_s ), & skeysort);
  }
#line 956
  tmp___2 = write_i32(fp, v20magic___0);
#line 956
  if (! tmp___2) {
#line 956
    return (15);
  }
#line 957
  tmp___3 = write_i32(fp, header_flags);
#line 957
  if (! tmp___3) {
#line 957
    return (15);
  }
#line 958
  tmp___4 = write_i16(fp, g->nfiles);
#line 958
  if (! tmp___4) {
#line 958
    return (15);
  }
#line 959
  tmp___5 = write_i32(fp, g->nprimary);
#line 959
  if (! tmp___5) {
#line 959
    return (15);
  }
#line 960
  tmp___6 = write_i32(fp, g->nsecondary);
#line 960
  if (! tmp___6) {
#line 960
    return (15);
  }
#line 961
  tmp___7 = write_i32(fp, g->flen);
#line 961
  if (! tmp___7) {
#line 961
    return (15);
  }
#line 962
  tmp___8 = write_i32(fp, g->plen);
#line 962
  if (! tmp___8) {
#line 962
    return (15);
  }
#line 963
  tmp___9 = write_i32(fp, g->slen);
#line 963
  if (! tmp___9) {
#line 963
    return (15);
  }
#line 964
  tmp___10 = write_i32(fp, frecsize);
#line 964
  if (! tmp___10) {
#line 964
    return (15);
  }
#line 965
  tmp___11 = write_i32(fp, precsize);
#line 965
  if (! tmp___11) {
#line 965
    return (15);
  }
#line 966
  tmp___12 = write_i32(fp, srecsize);
#line 966
  if (! tmp___12) {
#line 966
    return (15);
  }
#line 967
  if (g->imode == 0) {
#line 968
    tmp___13 = write_i32(fp, (sqd_uint32 )foffset);
#line 968
    if (! tmp___13) {
#line 968
      return (15);
    }
#line 969
    tmp___14 = write_i32(fp, (sqd_uint32 )poffset);
#line 969
    if (! tmp___14) {
#line 969
      return (15);
    }
#line 970
    tmp___15 = write_i32(fp, (sqd_uint32 )soffset);
#line 970
    if (! tmp___15) {
#line 970
      return (15);
    }
  } else {
#line 972
    tmp___16 = write_i64(fp, foffset);
#line 972
    if (! tmp___16) {
#line 972
      return (15);
    }
#line 973
    tmp___17 = write_i64(fp, poffset);
#line 973
    if (! tmp___17) {
#line 973
      return (15);
    }
#line 974
    tmp___18 = write_i64(fp, soffset);
#line 974
    if (! tmp___18) {
#line 974
      return (15);
    }
  }
#line 979
  tmp___19 = malloc(sizeof(char ) * (unsigned long )g->flen);
#line 979
  s___0 = (char *)tmp___19;
#line 979
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 979
    return (3);
  }
#line 980
  i___0 = 0;
#line 980
  while (i___0 < (int )g->nfiles) {
#line 982
    file_flags = (sqd_uint32 )0;
#line 983
    if (*(g->bpl + i___0) > 0U) {
#line 983
      if (*(g->rpl + i___0) > 0U) {
#line 983
        file_flags |= 1U;
      }
    }
#line 985
    strcpy((char * __restrict  )s___0, (char const   * __restrict  )*(g->filenames + i___0));
#line 986
    tmp___20 = fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )g->flen,
                      (FILE * __restrict  )fp);
#line 986
    if (tmp___20 != (size_t )g->flen) {
#line 986
      return (15);
    }
#line 987
    tmp___21 = write_i32(fp, *(g->fileformat + i___0));
#line 987
    if (! tmp___21) {
#line 987
      return (15);
    }
#line 988
    tmp___22 = write_i32(fp, file_flags);
#line 988
    if (! tmp___22) {
#line 988
      return (15);
    }
#line 989
    tmp___23 = write_i32(fp, *(g->bpl + i___0));
#line 989
    if (! tmp___23) {
#line 989
      return (15);
    }
#line 990
    tmp___24 = write_i32(fp, *(g->rpl + i___0));
#line 990
    if (! tmp___24) {
#line 990
      return (15);
    }
#line 980
    i___0 ++;
  }
#line 992
  free((void *)s___0);
#line 996
  tmp___25 = malloc(sizeof(char ) * (unsigned long )g->plen);
#line 996
  s___0 = (char *)tmp___25;
#line 996
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 996
    return (3);
  }
#line 997
  if (g->external) {
#line 998
    buf = (char *)((void *)0);
#line 999
    buflen = 0;
#line 1001
    i___0 = 0;
#line 1001
    while ((sqd_uint32 )i___0 < g->nprimary) {
#line 1003
      tmp___26 = sre_fgets(& buf, & buflen, g->ptmp);
#line 1003
      if ((unsigned long )tmp___26 == (unsigned long )((void *)0)) {
#line 1003
        return (1);
      }
#line 1004
      tmp___27 = parse_pkey_info(buf, (char )g->smode, & pkey);
#line 1004
      if (tmp___27 != 0) {
#line 1004
        return (6);
      }
#line 1005
      strcpy((char * __restrict  )s___0, (char const   * __restrict  )pkey.key);
#line 1006
      tmp___28 = fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )g->plen,
                        (FILE * __restrict  )fp);
#line 1006
      if (tmp___28 != (size_t )g->plen) {
#line 1006
        return (15);
      }
#line 1007
      tmp___29 = write_i16(fp, pkey.fnum);
#line 1007
      if (! tmp___29) {
#line 1007
        return (15);
      }
#line 1008
      tmp___30 = write_offset(fp, & pkey.r_off);
#line 1008
      if (! tmp___30) {
#line 1008
        return (15);
      }
#line 1009
      tmp___31 = write_offset(fp, & pkey.d_off);
#line 1009
      if (! tmp___31) {
#line 1009
        return (15);
      }
#line 1010
      tmp___32 = write_i32(fp, pkey.len);
#line 1010
      if (! tmp___32) {
#line 1010
        return (15);
      }
#line 1001
      i___0 ++;
    }
#line 1012
    free((void *)buf);
  } else {
#line 1014
    i___0 = 0;
#line 1014
    while ((sqd_uint32 )i___0 < g->nprimary) {
#line 1016
      strcpy((char * __restrict  )s___0, (char const   * __restrict  )(g->pkeys + i___0)->key);
#line 1017
      tmp___33 = fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )g->plen,
                        (FILE * __restrict  )fp);
#line 1017
      if (tmp___33 != (size_t )g->plen) {
#line 1017
        return (15);
      }
#line 1018
      tmp___34 = write_i16(fp, (g->pkeys + i___0)->fnum);
#line 1018
      if (! tmp___34) {
#line 1018
        return (15);
      }
#line 1019
      tmp___35 = write_offset(fp, & (g->pkeys + i___0)->r_off);
#line 1019
      if (! tmp___35) {
#line 1019
        return (15);
      }
#line 1020
      tmp___36 = write_offset(fp, & (g->pkeys + i___0)->d_off);
#line 1020
      if (! tmp___36) {
#line 1020
        return (15);
      }
#line 1021
      tmp___37 = write_i32(fp, (g->pkeys + i___0)->len);
#line 1021
      if (! tmp___37) {
#line 1021
        return (15);
      }
#line 1014
      i___0 ++;
    }
  }
#line 1027
  if (g->nsecondary > 0U) {
#line 1028
    tmp___38 = malloc(sizeof(char ) * (unsigned long )g->slen);
#line 1028
    s2 = (char *)tmp___38;
#line 1028
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 1028
      return (3);
    }
#line 1030
    if (g->external) {
#line 1032
      buf___0 = (char *)((void *)0);
#line 1033
      n = 0;
#line 1035
      i___0 = 0;
#line 1035
      while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1037
        tmp___39 = sre_fgets(& buf___0, & n, g->stmp);
#line 1037
        if ((unsigned long )tmp___39 == (unsigned long )((void *)0)) {
#line 1037
          return (1);
        }
#line 1038
        tmp___40 = parse_skey_info(buf___0, & skey);
#line 1038
        if (tmp___40 != 0) {
#line 1038
          return (6);
        }
#line 1039
        strcpy((char * __restrict  )s2, (char const   * __restrict  )skey.key);
#line 1040
        strcpy((char * __restrict  )s___0, (char const   * __restrict  )skey.pkey);
#line 1041
        tmp___41 = fwrite((void const   * __restrict  )s2, sizeof(char ), (size_t )g->slen,
                          (FILE * __restrict  )fp);
#line 1041
        if (tmp___41 != (size_t )g->slen) {
#line 1041
          return (15);
        }
#line 1042
        tmp___42 = fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )g->plen,
                          (FILE * __restrict  )fp);
#line 1042
        if (tmp___42 != (size_t )g->plen) {
#line 1042
          return (15);
        }
#line 1035
        i___0 ++;
      }
#line 1044
      free((void *)buf___0);
    } else {
#line 1046
      i___0 = 0;
#line 1046
      while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1048
        strcpy((char * __restrict  )s2, (char const   * __restrict  )(g->skeys + i___0)->key);
#line 1049
        strcpy((char * __restrict  )s___0, (char const   * __restrict  )(g->skeys + i___0)->pkey);
#line 1050
        tmp___43 = fwrite((void const   * __restrict  )s2, sizeof(char ), (size_t )g->slen,
                          (FILE * __restrict  )fp);
#line 1050
        if (tmp___43 != (size_t )g->slen) {
#line 1050
          return (15);
        }
#line 1051
        tmp___44 = fwrite((void const   * __restrict  )s___0, sizeof(char ), (size_t )g->plen,
                          (FILE * __restrict  )fp);
#line 1051
        if (tmp___44 != (size_t )g->plen) {
#line 1051
          return (15);
        }
#line 1046
        i___0 ++;
      }
    }
#line 1054
    free((void *)s2);
  }
#line 1057
  free((void *)s___0);
#line 1058
  fclose(fp);
#line 1059
  return (status);
}
}
#line 1072 "ssi.c"
void SSIFreeIndex(SSIINDEX *g ) 
{ 
  int i___0 ;

  {
#line 1076
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 1078
    if (g->external == 0) {
#line 1079
      i___0 = 0;
#line 1079
      while ((sqd_uint32 )i___0 < g->nprimary) {
#line 1079
        free((void *)(g->pkeys + i___0)->key);
#line 1079
        i___0 ++;
      }
#line 1080
      i___0 = 0;
#line 1080
      while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1080
        free((void *)(g->skeys + i___0)->key);
#line 1080
        i___0 ++;
      }
#line 1081
      i___0 = 0;
#line 1081
      while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1081
        free((void *)(g->skeys + i___0)->pkey);
#line 1081
        i___0 ++;
      }
#line 1082
      if ((unsigned long )g->pkeys != (unsigned long )((void *)0)) {
#line 1082
        free((void *)g->pkeys);
      }
#line 1083
      if ((unsigned long )g->skeys != (unsigned long )((void *)0)) {
#line 1083
        free((void *)g->skeys);
      }
    } else {
#line 1085
      if ((unsigned long )g->ptmp != (unsigned long )((void *)0)) {
#line 1085
        fclose(g->ptmp);
      }
#line 1086
      if ((unsigned long )g->stmp != (unsigned long )((void *)0)) {
#line 1086
        fclose(g->stmp);
      }
#line 1088
      remove((char const   *)g->ptmpfile);
#line 1089
      remove((char const   *)g->stmpfile);
    }
#line 1092
    i___0 = 0;
#line 1092
    while (i___0 < (int )g->nfiles) {
#line 1092
      free((void *)*(g->filenames + i___0));
#line 1092
      i___0 ++;
    }
#line 1093
    if ((unsigned long )g->filenames != (unsigned long )((void *)0)) {
#line 1093
      free((void *)g->filenames);
    }
#line 1094
    if ((unsigned long )g->fileformat != (unsigned long )((void *)0)) {
#line 1094
      free((void *)g->fileformat);
    }
#line 1095
    if ((unsigned long )g->bpl != (unsigned long )((void *)0)) {
#line 1095
      free((void *)g->bpl);
    }
#line 1096
    if ((unsigned long )g->rpl != (unsigned long )((void *)0)) {
#line 1096
      free((void *)g->rpl);
    }
#line 1097
    free((void *)g);
  }
#line 1099
  return;
}
}
#line 1113 "ssi.c"
char *SSIErrorString(int n ) 
{ 


  {
#line 1116
  switch (n) {
  case 0: 
#line 1117
  return ((char *)"ok (no error)");
  case 1: 
#line 1118
  return ((char *)"no data, fread() failed");
  case 2: 
#line 1119
  return ((char *)"no such key");
  case 3: 
#line 1120
  return ((char *)"out of memory, malloc() failed");
  case 4: 
#line 1121
  return ((char *)"file not found, fopen() failed");
  case 5: 
#line 1122
  return ((char *)"not a SSI file? (bad magic)");
  case 6: 
#line 1123
  return ((char *)"corrupt format? unexpected data");
  case 7: 
#line 1124
  return ((char *)"no large file support for this system");
  case 8: 
#line 1125
  return ((char *)"failed to reposition on disk");
  case 9: 
#line 1126
  return ((char *)"failed to get file position on disk");
  case 10: 
#line 1127
  return ((char *)"no fast subseq support for this seqfile");
  case 11: 
#line 1128
  return ((char *)"subseq start is out of range");
  case 12: 
#line 1129
  return ((char *)"an argument is out of range");
  case 13: 
#line 1130
  return ((char *)"number of files exceeds limit");
  case 14: 
#line 1131
  return ((char *)"number of keys exceeds limit");
  case 15: 
#line 1132
  return ((char *)"an fwrite() failed");
  case 16: 
#line 1133
  return ((char *)"some problem with external sorting");
  default: 
#line 1134
  return ((char *)"unrecognized code");
  }
}
}
#line 1139 "ssi.c"
static int read_i16(FILE *fp , sqd_uint16 *ret_result ) 
{ 
  sqd_uint16 result ;
  size_t tmp ;

  {
#line 1143
  tmp = fread((void * __restrict  )(& result), sizeof(sqd_uint16 ), (size_t )1, (FILE * __restrict  )fp);
#line 1143
  if (tmp != 1UL) {
#line 1143
    return (0);
  }
#line 1144
  *ret_result = sre_ntoh16(result);
#line 1145
  return (1);
}
}
#line 1147 "ssi.c"
static int write_i16(FILE *fp , sqd_uint16 n ) 
{ 
  size_t tmp ;

  {
#line 1150
  n = sre_hton16(n);
#line 1151
  tmp = fwrite((void const   * __restrict  )(& n), sizeof(sqd_uint16 ), (size_t )1,
               (FILE * __restrict  )fp);
#line 1151
  if (tmp != 1UL) {
#line 1151
    return (0);
  }
#line 1152
  return (1);
}
}
#line 1154 "ssi.c"
static int read_i32(FILE *fp , sqd_uint32 *ret_result ) 
{ 
  sqd_uint32 result ;
  size_t tmp ;

  {
#line 1158
  tmp = fread((void * __restrict  )(& result), sizeof(sqd_uint32 ), (size_t )1, (FILE * __restrict  )fp);
#line 1158
  if (tmp != 1UL) {
#line 1158
    return (0);
  }
#line 1159
  *ret_result = sre_ntoh32(result);
#line 1160
  return (1);
}
}
#line 1162 "ssi.c"
static int write_i32(FILE *fp , sqd_uint32 n ) 
{ 
  size_t tmp ;

  {
#line 1165
  n = sre_hton32(n);
#line 1166
  tmp = fwrite((void const   * __restrict  )(& n), sizeof(sqd_uint32 ), (size_t )1,
               (FILE * __restrict  )fp);
#line 1166
  if (tmp != 1UL) {
#line 1166
    return (0);
  }
#line 1167
  return (1);
}
}
#line 1169 "ssi.c"
static int read_i64(FILE *fp , sqd_uint64 *ret_result ) 
{ 
  sqd_uint64 result ;
  size_t tmp ;

  {
#line 1173
  tmp = fread((void * __restrict  )(& result), sizeof(sqd_uint64 ), (size_t )1, (FILE * __restrict  )fp);
#line 1173
  if (tmp != 1UL) {
#line 1173
    return (0);
  }
#line 1174
  *ret_result = sre_ntoh64(result);
#line 1175
  return (1);
}
}
#line 1177 "ssi.c"
static int write_i64(FILE *fp , sqd_uint64 n ) 
{ 
  size_t tmp ;

  {
#line 1180
  n = sre_hton64(n);
#line 1181
  tmp = fwrite((void const   * __restrict  )(& n), sizeof(sqd_uint64 ), (size_t )1,
               (FILE * __restrict  )fp);
#line 1181
  if (tmp != 1UL) {
#line 1181
    return (0);
  }
#line 1182
  return (1);
}
}
#line 1184 "ssi.c"
static int read_offset(FILE *fp , char mode , SSIOFFSET *ret_offset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1187
  if ((int )mode == 0) {
#line 1188
    ret_offset->mode = (char)0;
#line 1189
    tmp = read_i32(fp, & ret_offset->off.i32);
#line 1189
    if (! tmp) {
#line 1189
      return (0);
    }
  } else
#line 1190
  if ((int )mode == 1) {
#line 1191
    ret_offset->mode = (char)1;
#line 1192
    tmp___0 = read_i64(fp, & ret_offset->off.i64);
#line 1192
    if (! tmp___0) {
#line 1192
      return (0);
    }
  } else {
#line 1193
    return (0);
  }
#line 1195
  return (1);
}
}
#line 1197 "ssi.c"
static int write_offset(FILE *fp , SSIOFFSET *offset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1200
  if ((int )offset->mode == 0) {
#line 1200
    tmp = write_i32(fp, offset->off.i32);
#line 1200
    return (tmp);
  } else
#line 1201
  if ((int )offset->mode == 1) {
#line 1201
    tmp___0 = write_i64(fp, offset->off.i64);
#line 1201
    return (tmp___0);
  } else {
#line 1202
    abort();
  }
#line 1204
  return (1);
}
}
#line 1207 "ssi.c"
static int parse_pkey_info(char *buf , char mode , struct ssipkey_s *pkey ) 
{ 
  char *s___0 ;
  char *tok ;
  int n ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 1213
  s___0 = buf;
#line 1214
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1214
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1214
    return (6);
  }
#line 1215
  pkey->key = tok;
#line 1216
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1216
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1216
    return (6);
  }
#line 1217
  tmp = atoi((char const   *)tok);
#line 1217
  pkey->fnum = (sqd_uint16 )tmp;
#line 1219
  if ((int )mode == 0) {
#line 1220
    tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1220
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1220
      return (6);
    }
#line 1221
    pkey->r_off.mode = mode;
#line 1222
    tmp___0 = strtoul((char const   * __restrict  )tok, (char ** __restrict  )((void *)0),
                      10);
#line 1222
    pkey->r_off.off.i32 = (sqd_uint32 )tmp___0;
#line 1223
    tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1223
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1223
      return (6);
    }
#line 1224
    pkey->d_off.mode = mode;
#line 1225
    tmp___1 = strtoul((char const   * __restrict  )tok, (char ** __restrict  )((void *)0),
                      10);
#line 1225
    pkey->d_off.off.i32 = (sqd_uint32 )tmp___1;
  } else {
#line 1238
    return (7);
  }
#line 1241
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1241
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1241
    return (6);
  }
#line 1242
  tmp___2 = strtoul((char const   * __restrict  )tok, (char ** __restrict  )((void *)0),
                    10);
#line 1242
  pkey->len = (sqd_uint32 )tmp___2;
#line 1244
  return (0);
}
}
#line 1246 "ssi.c"
static int parse_skey_info(char *buf , struct ssiskey_s *skey ) 
{ 
  char *s___0 ;
  char *tok ;
  int n ;

  {
#line 1252
  s___0 = buf;
#line 1253
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1253
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1253
    return (6);
  }
#line 1254
  skey->key = tok;
#line 1255
  tok = sre_strtok(& s___0, (char *)"\t\n", & n);
#line 1255
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 1255
    return (6);
  }
#line 1256
  skey->pkey = tok;
#line 1257
  return (0);
}
}
#line 1282 "ssi.c"
static int binary_search(SSIFILE *sfp , char *key , int klen , SSIOFFSET *base , sqd_uint32 recsize ,
                         sqd_uint32 maxidx ) 
{ 
  char *name ;
  sqd_uint32 left ;
  sqd_uint32 right ;
  sqd_uint32 mid ;
  int cmp ;
  int status ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 1291
  if (maxidx == 0U) {
#line 1291
    return (2);
  }
#line 1292
  tmp = malloc(sizeof(char ) * (unsigned long )klen);
#line 1292
  name = (char *)tmp;
#line 1292
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1292
    return (3);
  }
#line 1293
  left = (sqd_uint32 )0;
#line 1294
  right = maxidx - 1U;
#line 1295
  while (1) {
#line 1296
    mid = (left + right) / 2U;
#line 1298
    status = indexfile_position(sfp, base, recsize, mid);
#line 1298
    if (status != 0) {
#line 1299
      free((void *)name);
#line 1299
      return (status);
    }
#line 1300
    tmp___0 = fread((void * __restrict  )name, sizeof(char ), (size_t )klen, (FILE * __restrict  )sfp->fp);
#line 1300
    if (tmp___0 != (size_t )klen) {
#line 1301
      free((void *)name);
#line 1301
      return (1);
    }
#line 1302
    cmp = strcmp((char const   *)name, (char const   *)key);
#line 1303
    if (cmp == 0) {
#line 1303
      break;
    } else
#line 1304
    if (left >= right) {
#line 1305
      free((void *)name);
#line 1305
      return (2);
    } else
#line 1306
    if (cmp < 0) {
#line 1306
      left = mid + 1U;
    } else
#line 1307
    if (cmp > 0) {
#line 1308
      if (mid == 0U) {
#line 1308
        free((void *)name);
#line 1308
        return (2);
      } else {
#line 1309
        right = mid - 1U;
      }
    }
  }
#line 1312
  free((void *)name);
#line 1313
  return (0);
}
}
#line 1331 "ssi.c"
static int indexfile_position(SSIFILE *sfp , SSIOFFSET *base , sqd_uint32 len , sqd_uint32 n ) 
{ 
  SSIOFFSET pos ;
  int status ;

  {
#line 1337
  if ((int )base->mode == 0) {
#line 1338
    pos.mode = (char)0;
#line 1339
    pos.off.i32 = base->off.i32 + n * len;
  } else
#line 1340
  if ((int )base->mode == 1) {
#line 1341
    pos.mode = (char)1;
#line 1342
    pos.off.i64 = base->off.i64 + (sqd_uint64 )(n * len);
  } else {
#line 1343
    return (0);
  }
#line 1344
  status = SSISetFilePosition(sfp->fp, & pos);
#line 1344
  if (status != 0) {
#line 1344
    return (status);
  }
#line 1345
  return (0);
}
}
#line 1354 "ssi.c"
static sqd_uint64 current_index_size(SSIINDEX *g ) 
{ 
  sqd_uint64 frecsize ;
  sqd_uint64 precsize ;
  sqd_uint64 srecsize ;
  sqd_uint64 total ;

  {
#line 1363
  frecsize = (sqd_uint64 )(16U + g->flen);
#line 1364
  if (g->smode == 1) {
#line 1364
    precsize = (sqd_uint64 )(22U + g->plen);
  } else {
#line 1364
    precsize = (sqd_uint64 )(14U + g->plen);
  }
#line 1365
  srecsize = (sqd_uint64 )(g->plen + g->slen);
#line 1366
  total = (((66ULL + frecsize * (sqd_uint64 )g->nfiles) + precsize * (sqd_uint64 )g->nprimary) + srecsize * (sqd_uint64 )g->nsecondary) / 1048576ULL;
#line 1371
  return (total);
}
}
#line 1383 "ssi.c"
static int activate_external_sort(SSIINDEX *g ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  FILE *tmp___1 ;
  FILE *tmp___2 ;

  {
#line 1388
  if (g->external) {
#line 1388
    return (0);
  }
#line 1389
  tmp = FileExists(g->ptmpfile);
#line 1389
  if (tmp) {
#line 1389
    return (1);
  }
#line 1390
  tmp___0 = FileExists(g->stmpfile);
#line 1390
  if (tmp___0) {
#line 1390
    return (1);
  }
#line 1391
  tmp___1 = fopen((char const   * __restrict  )g->ptmpfile, (char const   * __restrict  )"w");
#line 1391
  g->ptmp = tmp___1;
#line 1391
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 1391
    return (1);
  }
#line 1392
  tmp___2 = fopen((char const   * __restrict  )g->stmpfile, (char const   * __restrict  )"w");
#line 1392
  g->stmp = tmp___2;
#line 1392
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 1392
    return (1);
  }
#line 1397
  i___0 = 0;
#line 1397
  while ((sqd_uint32 )i___0 < g->nprimary) {
#line 1398
    if (g->smode == 0) {
#line 1399
      fprintf((FILE * __restrict  )g->ptmp, (char const   * __restrict  )"%s\t%u\t%lu\t%lu\t%lu\n",
              (g->pkeys + i___0)->key, (unsigned int )(g->pkeys + i___0)->fnum, (unsigned long )(g->pkeys + i___0)->r_off.off.i32,
              (unsigned long )(g->pkeys + i___0)->d_off.off.i32, (unsigned long )(g->pkeys + i___0)->len);
    } else {
#line 1405
      fprintf((FILE * __restrict  )g->ptmp, (char const   * __restrict  )"%s\t%u\t%llu\t%llu\t%lu\n",
              (g->pkeys + i___0)->key, (unsigned int )(g->pkeys + i___0)->fnum, (g->pkeys + i___0)->r_off.off.i64,
              (g->pkeys + i___0)->d_off.off.i64, (unsigned long )(g->pkeys + i___0)->len);
    }
#line 1397
    i___0 ++;
  }
#line 1412
  i___0 = 0;
#line 1412
  while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1413
    fprintf((FILE * __restrict  )g->stmp, (char const   * __restrict  )"%s\t%s\n",
            (g->skeys + i___0)->key, (g->skeys + i___0)->pkey);
#line 1412
    i___0 ++;
  }
#line 1417
  i___0 = 0;
#line 1417
  while ((sqd_uint32 )i___0 < g->nprimary) {
#line 1417
    free((void *)(g->pkeys + i___0)->key);
#line 1417
    i___0 ++;
  }
#line 1418
  i___0 = 0;
#line 1418
  while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1418
    free((void *)(g->skeys + i___0)->key);
#line 1418
    i___0 ++;
  }
#line 1419
  i___0 = 0;
#line 1419
  while ((sqd_uint32 )i___0 < g->nsecondary) {
#line 1419
    free((void *)(g->skeys + i___0)->pkey);
#line 1419
    i___0 ++;
  }
#line 1420
  if ((unsigned long )g->pkeys != (unsigned long )((void *)0)) {
#line 1420
    free((void *)g->pkeys);
  }
#line 1421
  if ((unsigned long )g->skeys != (unsigned long )((void *)0)) {
#line 1421
    free((void *)g->skeys);
  }
#line 1422
  g->pkeys = (struct ssipkey_s *)((void *)0);
#line 1423
  g->skeys = (struct ssiskey_s *)((void *)0);
#line 1427
  g->external = 1;
#line 1428
  return (0);
}
}
#line 1435 "ssi.c"
void SSIForceExternalSort(SSIINDEX *g ) 
{ 
  int tmp ;

  {
#line 1438
  tmp = activate_external_sort(g);
#line 1438
  if (tmp != 0) {
#line 1439
    Die((char *)"failed to turn external sorting on.");
  }
#line 1440
  return;
}
}
#line 1 "stack.o"
#pragma merger("0","/tmp/cil-xDT4wXwy.i","")
#line 238 "./sqfuncs.h"
void ReverseIntStack(struct intstack_s *stack ) ;
#line 36 "stack.c"
struct intstack_s *InitIntStack(void) 
{ 
  struct intstack_s *stack ;
  void *tmp ;

  {
#line 41
  tmp = malloc(sizeof(struct intstack_s ));
#line 41
  stack = (struct intstack_s *)tmp;
#line 41
  if ((unsigned long )stack == (unsigned long )((void *)0)) {
#line 42
    Die((char *)"Memory allocation failure at %s line %d", "stack.c", 42);
  }
#line 43
  stack->nxt = (struct intstack_s *)((void *)0);
#line 44
  return (stack);
}
}
#line 46 "stack.c"
void PushIntStack(struct intstack_s *stack , int data ) 
{ 
  struct intstack_s *new ;
  void *tmp ;

  {
#line 51
  tmp = malloc(sizeof(struct intstack_s ));
#line 51
  new = (struct intstack_s *)tmp;
#line 51
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 52
    Die((char *)"Memory allocation failure at %s line %d", "stack.c", 52);
  }
#line 53
  new->data = data;
#line 55
  new->nxt = stack->nxt;
#line 56
  stack->nxt = new;
#line 57
  return;
}
}
#line 59 "stack.c"
int PopIntStack(struct intstack_s *stack , int *ret_data ) 
{ 
  struct intstack_s *old ;

  {
#line 64
  if ((unsigned long )stack->nxt == (unsigned long )((void *)0)) {
#line 64
    return (0);
  }
#line 66
  old = stack->nxt;
#line 67
  stack->nxt = old->nxt;
#line 69
  *ret_data = old->data;
#line 70
  free((void *)old);
#line 71
  return (1);
}
}
#line 74 "stack.c"
void ReverseIntStack(struct intstack_s *stack ) 
{ 
  struct intstack_s *old ;
  struct intstack_s *new ;

  {
#line 80
  old = stack->nxt;
#line 81
  stack->nxt = (struct intstack_s *)((void *)0);
#line 82
  while ((unsigned long )old != (unsigned long )((void *)0)) {
#line 84
    new = old;
#line 85
    old = old->nxt;
#line 86
    new->nxt = stack->nxt;
#line 87
    stack->nxt = new;
  }
#line 89
  return;
}
}
#line 91 "stack.c"
int FreeIntStack(struct intstack_s *stack ) 
{ 
  int data ;
  int count ;
  int tmp ;

  {
#line 95
  count = 0;
#line 97
  while (1) {
#line 97
    tmp = PopIntStack(stack, & data);
#line 97
    if (! tmp) {
#line 97
      break;
    }
#line 98
    count ++;
  }
#line 99
  free((void *)stack);
#line 100
  return (count);
}
}
#line 1 "stockholm.o"
#pragma merger("0","/tmp/cil-rpP2iLxj.i","")
#line 37 "stockholm.c"
static int parse_gf(MSA *msa , char *buf ) ;
#line 38
static int parse_gs(MSA *msa , char *buf ) ;
#line 39
static int parse_gc(MSA *msa , char *buf ) ;
#line 40
static int parse_gr(MSA *msa , char *buf ) ;
#line 41
static int parse_comment(MSA *msa , char *buf ) ;
#line 42
static int parse_sequence(MSA *msa , char *buf ) ;
#line 43
static void actually_write_stockholm(FILE *fp , MSA *msa , int cpl ) ;
#line 93 "stockholm.c"
MSA *ReadStockholm(MSAFILE *afp ) 
{ 
  MSA *msa ;
  char *s___0 ;
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 100
  tmp = feof(afp->f);
#line 100
  if (tmp) {
#line 100
    return ((MSA *)((void *)0));
  }
#line 104
  msa = MSAAlloc(10, 0);
#line 111
  while (1) {
#line 112
    s___0 = MSAFileGetLine(afp);
#line 112
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 113
      MSAFree(msa);
#line 114
      return ((MSA *)((void *)0));
    }
#line 111
    tmp___0 = IsBlankline(s___0);
#line 111
    if (! tmp___0) {
#line 111
      break;
    }
  }
#line 118
  tmp___1 = strncmp((char const   *)s___0, "# STOCKHOLM 1.", (size_t )14);
#line 118
  if (tmp___1 != 0) {
#line 119
    Die((char *)"File %s doesn\'t appear to be in Stockholm format.\nAssuming there isn\'t some other problem with your file (it is an\nalignment file, right?), please either:\n  a) use the Babelfish format autotranslator option (-B, usually);\n  b) specify the file\'s format with the --informat option; or\n  a) reformat the alignment to Stockholm format.\n",
        afp->fname);
  }
#line 130
  while (1) {
#line 130
    s___0 = MSAFileGetLine(afp);
#line 130
    if (! ((unsigned long )s___0 != (unsigned long )((void *)0))) {
#line 130
      break;
    }
#line 132
    while (1) {
#line 132
      if (! ((int )*s___0 == 32)) {
#line 132
        if (! ((int )*s___0 == 9)) {
#line 132
          break;
        }
      }
#line 132
      s___0 ++;
    }
#line 134
    if ((int )*s___0 == 35) {
#line 135
      tmp___5 = strncmp((char const   *)s___0, "#=GF", (size_t )4);
#line 135
      if (tmp___5 == 0) {
#line 135
        status = parse_gf(msa, s___0);
      } else {
#line 136
        tmp___4 = strncmp((char const   *)s___0, "#=GS", (size_t )4);
#line 136
        if (tmp___4 == 0) {
#line 136
          status = parse_gs(msa, s___0);
        } else {
#line 137
          tmp___3 = strncmp((char const   *)s___0, "#=GC", (size_t )4);
#line 137
          if (tmp___3 == 0) {
#line 137
            status = parse_gc(msa, s___0);
          } else {
#line 138
            tmp___2 = strncmp((char const   *)s___0, "#=GR", (size_t )4);
#line 138
            if (tmp___2 == 0) {
#line 138
              status = parse_gr(msa, s___0);
            } else {
#line 139
              status = parse_comment(msa, s___0);
            }
          }
        }
      }
    } else {
#line 141
      tmp___6 = strncmp((char const   *)s___0, "//", (size_t )2);
#line 141
      if (tmp___6 == 0) {
#line 141
        break;
      } else
#line 142
      if ((int )*s___0 == 10) {
#line 142
        continue;
      } else {
#line 143
        status = parse_sequence(msa, s___0);
      }
    }
#line 145
    if (status == 0) {
#line 146
      if ((unsigned long )msa->name == (unsigned long )((void *)0)) {
#line 146
        tmp___7 = "";
      } else {
#line 146
        tmp___7 = (char const   *)msa->name;
      }
#line 146
      Die((char *)"Stockholm format parse error: line %d of file %s while reading alignment %s",
          afp->linenumber, afp->fname, tmp___7);
    }
  }
#line 150
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 150
    if (msa->nseq != 0) {
#line 151
      if ((unsigned long )msa->name == (unsigned long )((void *)0)) {
#line 151
        tmp___8 = "";
      } else {
#line 151
        tmp___8 = (char const   *)msa->name;
      }
#line 151
      Die((char *)"Didn\'t find // at end of alignment %s", tmp___8);
    }
  }
#line 153
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 153
    if (msa->nseq == 0) {
#line 155
      MSAFree(msa);
#line 156
      return ((MSA *)((void *)0));
    }
  }
#line 159
  MSAVerifyParse(msa);
#line 160
  return (msa);
}
}
#line 176 "stockholm.c"
void WriteStockholm(FILE *fp , MSA *msa ) 
{ 


  {
#line 179
  actually_write_stockholm(fp, msa, 50);
#line 180
  return;
}
}
#line 194 "stockholm.c"
void WriteStockholmOneBlock(FILE *fp , MSA *msa ) 
{ 


  {
#line 197
  actually_write_stockholm(fp, msa, msa->alen);
#line 198
  return;
}
}
#line 215 "stockholm.c"
static void actually_write_stockholm(FILE *fp , MSA *msa , int cpl ) 
{ 
  int i___0 ;
  int j ;
  int len ;
  int namewidth ;
  int typewidth ;
  int markupwidth ;
  char *buf ;
  int currpos ;
  char *s___0 ;
  char *tok ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 219
  len = 0;
#line 221
  typewidth = 0;
#line 222
  markupwidth = 0;
#line 231
  namewidth = 0;
#line 232
  i___0 = 0;
#line 232
  while (i___0 < msa->nseq) {
#line 233
    tmp = strlen((char const   *)*(msa->sqname + i___0));
#line 233
    len = (int )tmp;
#line 233
    if (len > namewidth) {
#line 234
      namewidth = len;
    }
#line 232
    i___0 ++;
  }
#line 240
  if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 240
    markupwidth = 4;
#line 240
    typewidth = 2;
  }
#line 241
  if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 241
    markupwidth = 4;
#line 241
    typewidth = 2;
  }
#line 242
  i___0 = 0;
#line 242
  while (i___0 < msa->ngr) {
#line 243
    tmp___0 = strlen((char const   *)*(msa->gr_tag + i___0));
#line 243
    len = (int )tmp___0;
#line 243
    if (len > typewidth) {
#line 243
      typewidth = len;
    }
#line 242
    i___0 ++;
  }
#line 245
  if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 245
    markupwidth = 4;
#line 245
    if (typewidth < 2) {
#line 245
      typewidth = 2;
    }
  }
#line 246
  if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 246
    markupwidth = 4;
#line 246
    if (typewidth < 7) {
#line 246
      typewidth = 7;
    }
  }
#line 247
  if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 247
    markupwidth = 4;
#line 247
    if (typewidth < 7) {
#line 247
      typewidth = 7;
    }
  }
#line 248
  i___0 = 0;
#line 248
  while (i___0 < msa->ngc) {
#line 249
    tmp___1 = strlen((char const   *)*(msa->gc_tag + i___0));
#line 249
    len = (int )tmp___1;
#line 249
    if (len > typewidth) {
#line 249
      typewidth = len;
    }
#line 248
    i___0 ++;
  }
#line 251
  tmp___2 = sre_malloc((char *)"stockholm.c", 251, sizeof(char ) * (unsigned long )((((cpl + namewidth) + typewidth) + markupwidth) + 61));
#line 251
  buf = (char *)tmp___2;
#line 255
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# STOCKHOLM 1.0\n");
#line 259
  i___0 = 0;
#line 259
  while (i___0 < msa->ncomment) {
#line 260
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# %s\n", *(msa->comment + i___0));
#line 259
    i___0 ++;
  }
#line 261
  if (msa->ncomment > 0) {
#line 261
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 265
  if ((unsigned long )msa->name != (unsigned long )((void *)0)) {
#line 265
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF ID    %s\n",
            msa->name);
  }
#line 266
  if ((unsigned long )msa->acc != (unsigned long )((void *)0)) {
#line 266
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF AC    %s\n",
            msa->acc);
  }
#line 267
  if ((unsigned long )msa->desc != (unsigned long )((void *)0)) {
#line 267
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF DE    %s\n",
            msa->desc);
  }
#line 268
  if ((unsigned long )msa->au != (unsigned long )((void *)0)) {
#line 268
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF AU    %s\n",
            msa->au);
  }
#line 272
  if (msa->cutoff_is_set[2]) {
#line 272
    if (msa->cutoff_is_set[3]) {
#line 273
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF GA    %.1f %.1f\n",
              (double )msa->cutoff[2], (double )msa->cutoff[3]);
    } else {
#line 272
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 274
  if (msa->cutoff_is_set[2]) {
#line 275
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF GA    %.1f\n",
            (double )msa->cutoff[2]);
  }
#line 276
  if (msa->cutoff_is_set[4]) {
#line 276
    if (msa->cutoff_is_set[5]) {
#line 277
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF NC    %.1f %.1f\n",
              (double )msa->cutoff[4], (double )msa->cutoff[5]);
    } else {
#line 276
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 278
  if (msa->cutoff_is_set[4]) {
#line 279
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF NC    %.1f\n",
            (double )msa->cutoff[4]);
  }
#line 280
  if (msa->cutoff_is_set[0]) {
#line 280
    if (msa->cutoff_is_set[1]) {
#line 281
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF TC    %.1f %.1f\n",
              (double )msa->cutoff[0], (double )msa->cutoff[1]);
    } else {
#line 280
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 282
  if (msa->cutoff_is_set[0]) {
#line 283
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF TC    %.1f\n",
            (double )msa->cutoff[0]);
  }
#line 285
  i___0 = 0;
#line 285
  while (i___0 < msa->ngf) {
#line 286
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GF %-5s %s\n",
            *(msa->gf_tag + i___0), *(msa->gf + i___0));
#line 285
    i___0 ++;
  }
#line 287
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 292
  if (msa->flags & 1) {
#line 294
    i___0 = 0;
#line 294
    while (i___0 < msa->nseq) {
#line 295
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GS %-*.*s WT    %.2f\n",
              namewidth, namewidth, *(msa->sqname + i___0), (double )*(msa->wgt + i___0));
#line 294
      i___0 ++;
    }
#line 296
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 298
  if ((unsigned long )msa->sqacc != (unsigned long )((void *)0)) {
#line 300
    i___0 = 0;
#line 300
    while (i___0 < msa->nseq) {
#line 301
      if ((unsigned long )*(msa->sqacc + i___0) != (unsigned long )((void *)0)) {
#line 302
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GS %-*.*s AC    %s\n",
                namewidth, namewidth, *(msa->sqname + i___0), *(msa->sqacc + i___0));
      }
#line 300
      i___0 ++;
    }
#line 303
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 305
  if ((unsigned long )msa->sqdesc != (unsigned long )((void *)0)) {
#line 307
    i___0 = 0;
#line 307
    while (i___0 < msa->nseq) {
#line 308
      if ((unsigned long )*(msa->sqdesc + i___0) != (unsigned long )((void *)0)) {
#line 309
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GS %*.*s DE    %s\n",
                namewidth, namewidth, *(msa->sqname + i___0), *(msa->sqdesc + i___0));
      }
#line 307
      i___0 ++;
    }
#line 310
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 312
  i___0 = 0;
#line 312
  while (i___0 < msa->ngs) {
#line 321
    j = 0;
#line 321
    while (j < msa->nseq) {
#line 322
      if ((unsigned long )*(*(msa->gs + i___0) + j) != (unsigned long )((void *)0)) {
#line 324
        s___0 = *(*(msa->gs + i___0) + j);
#line 325
        while (1) {
#line 325
          tok = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
#line 325
          if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 325
            break;
          }
#line 326
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GS %*.*s %5s %s\n",
                  namewidth, namewidth, *(msa->sqname + j), *(msa->gs_tag + i___0),
                  tok);
        }
      }
#line 321
      j ++;
    }
#line 329
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 312
    i___0 ++;
  }
#line 335
  currpos = 0;
#line 335
  while (currpos < msa->alen) {
#line 337
    if (currpos > 0) {
#line 337
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 338
    i___0 = 0;
#line 338
    while (i___0 < msa->nseq) {
#line 340
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->aseq + i___0) + currpos),
              (size_t )cpl);
#line 341
      *(buf + cpl) = (char )'\000';
#line 342
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-*.*s  %s\n",
              (namewidth + typewidth) + markupwidth, (namewidth + typewidth) + markupwidth,
              *(msa->sqname + i___0), buf);
#line 345
      if ((unsigned long )msa->ss != (unsigned long )((void *)0)) {
#line 345
        if ((unsigned long )*(msa->ss + i___0) != (unsigned long )((void *)0)) {
#line 346
          strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->ss + i___0) + currpos),
                  (size_t )cpl);
#line 347
          *(buf + cpl) = (char )'\000';
#line 348
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GR %-*.*s SS     %s\n",
                  namewidth, namewidth, *(msa->sqname + i___0), buf);
        }
      }
#line 350
      if ((unsigned long )msa->sa != (unsigned long )((void *)0)) {
#line 350
        if ((unsigned long )*(msa->sa + i___0) != (unsigned long )((void *)0)) {
#line 351
          strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->sa + i___0) + currpos),
                  (size_t )cpl);
#line 352
          *(buf + cpl) = (char )'\000';
#line 353
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GR %-*.*s SA     %s\n",
                  namewidth, namewidth, *(msa->sqname + i___0), buf);
        }
      }
#line 355
      j = 0;
#line 355
      while (j < msa->ngr) {
#line 356
        if ((unsigned long )*(*(msa->gr + j) + i___0) != (unsigned long )((void *)0)) {
#line 357
          strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(*(msa->gr + j) + i___0) + currpos),
                  (size_t )cpl);
#line 358
          *(buf + cpl) = (char )'\000';
#line 359
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GR %-*.*s %5s  %s\n",
                  namewidth, namewidth, *(msa->sqname + i___0), *(msa->gr_tag + j),
                  buf);
        }
#line 355
        j ++;
      }
#line 338
      i___0 ++;
    }
#line 363
    if ((unsigned long )msa->ss_cons != (unsigned long )((void *)0)) {
#line 364
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(msa->ss_cons + currpos),
              (size_t )cpl);
#line 365
      *(buf + cpl) = (char )'\000';
#line 366
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GC %-*.*s %s\n",
              namewidth + typewidth, namewidth + typewidth, "SS_cons", buf);
    }
#line 369
    if ((unsigned long )msa->sa_cons != (unsigned long )((void *)0)) {
#line 370
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(msa->sa_cons + currpos),
              (size_t )cpl);
#line 371
      *(buf + cpl) = (char )'\000';
#line 372
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GC %-*.*s %s\n",
              namewidth + typewidth, namewidth + typewidth, "SA_cons", buf);
    }
#line 375
    if ((unsigned long )msa->rf != (unsigned long )((void *)0)) {
#line 376
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(msa->rf + currpos),
              (size_t )cpl);
#line 377
      *(buf + cpl) = (char )'\000';
#line 378
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GC %-*.*s %s\n",
              namewidth + typewidth, namewidth + typewidth, "RF", buf);
    }
#line 380
    j = 0;
#line 380
    while (j < msa->ngc) {
#line 381
      strncpy((char * __restrict  )buf, (char const   * __restrict  )(*(msa->gc + j) + currpos),
              (size_t )cpl);
#line 382
      *(buf + cpl) = (char )'\000';
#line 383
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#=GC %-*.*s %s\n",
              namewidth + typewidth, namewidth + typewidth, *(msa->gc_tag + j), buf);
#line 380
      j ++;
    }
#line 335
    currpos += cpl;
  }
#line 387
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"//\n");
#line 388
  free((void *)buf);
#line 389
  return;
}
}
#line 398 "stockholm.c"
static int parse_gf(MSA *msa , char *buf ) 
{ 
  char *gf ;
  char *featurename ;
  char *text ;
  char *s___0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 406
  s___0 = buf;
#line 407
  gf = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 407
  if ((unsigned long )gf == (unsigned long )((void *)0)) {
#line 407
    return (0);
  }
#line 408
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 408
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
#line 408
    return (0);
  }
#line 409
  text = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
#line 409
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 409
    return (0);
  }
#line 410
  while (1) {
#line 410
    if (*text) {
#line 410
      if (! ((int )*text == 32)) {
#line 410
        if (! ((int )*text == 9)) {
#line 410
          break;
        }
      }
    } else {
#line 410
      break;
    }
#line 410
    text ++;
  }
#line 412
  tmp___11 = strcmp((char const   *)featurename, "ID");
#line 412
  if (tmp___11 == 0) {
#line 413
    msa->name = sre_strdup(text, -1);
  } else {
#line 414
    tmp___10 = strcmp((char const   *)featurename, "AC");
#line 414
    if (tmp___10 == 0) {
#line 415
      msa->acc = sre_strdup(text, -1);
    } else {
#line 416
      tmp___9 = strcmp((char const   *)featurename, "DE");
#line 416
      if (tmp___9 == 0) {
#line 417
        msa->desc = sre_strdup(text, -1);
      } else {
#line 418
        tmp___8 = strcmp((char const   *)featurename, "AU");
#line 418
        if (tmp___8 == 0) {
#line 419
          msa->au = sre_strdup(text, -1);
        } else {
#line 420
          tmp___7 = strcmp((char const   *)featurename, "GA");
#line 420
          if (tmp___7 == 0) {
#line 422
            s___0 = text;
#line 423
            text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 423
            if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 423
              return (0);
            }
#line 424
            tmp = atof((char const   *)text);
#line 424
            msa->cutoff[2] = (float )tmp;
#line 425
            msa->cutoff_is_set[2] = 1;
#line 426
            text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 426
            if ((unsigned long )text != (unsigned long )((void *)0)) {
#line 427
              tmp___0 = atof((char const   *)text);
#line 427
              msa->cutoff[3] = (float )tmp___0;
#line 428
              msa->cutoff_is_set[3] = 1;
            }
          } else {
#line 431
            tmp___6 = strcmp((char const   *)featurename, "NC");
#line 431
            if (tmp___6 == 0) {
#line 433
              s___0 = text;
#line 434
              text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 434
              if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 434
                return (0);
              }
#line 435
              tmp___1 = atof((char const   *)text);
#line 435
              msa->cutoff[4] = (float )tmp___1;
#line 436
              msa->cutoff_is_set[4] = 1;
#line 437
              text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 437
              if ((unsigned long )text != (unsigned long )((void *)0)) {
#line 438
                tmp___2 = atof((char const   *)text);
#line 438
                msa->cutoff[5] = (float )tmp___2;
#line 439
                msa->cutoff_is_set[5] = 1;
              }
            } else {
#line 442
              tmp___5 = strcmp((char const   *)featurename, "TC");
#line 442
              if (tmp___5 == 0) {
#line 444
                s___0 = text;
#line 445
                text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 445
                if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 445
                  return (0);
                }
#line 446
                tmp___3 = atof((char const   *)text);
#line 446
                msa->cutoff[0] = (float )tmp___3;
#line 447
                msa->cutoff_is_set[0] = 1;
#line 448
                text = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 448
                if ((unsigned long )text != (unsigned long )((void *)0)) {
#line 449
                  tmp___4 = atof((char const   *)text);
#line 449
                  msa->cutoff[1] = (float )tmp___4;
#line 450
                  msa->cutoff_is_set[1] = 1;
                }
              } else {
#line 454
                MSAAddGF(msa, featurename, text);
              }
            }
          }
        }
      }
    }
  }
#line 456
  return (1);
}
}
#line 463 "stockholm.c"
static int parse_gs(MSA *msa , char *buf ) 
{ 
  char *gs ;
  char *seqname ;
  char *featurename ;
  char *text ;
  int seqidx ;
  char *s___0 ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 473
  s___0 = buf;
#line 474
  gs = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 474
  if ((unsigned long )gs == (unsigned long )((void *)0)) {
#line 474
    return (0);
  }
#line 475
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 475
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
#line 475
    return (0);
  }
#line 476
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 476
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
#line 476
    return (0);
  }
#line 477
  text = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
#line 477
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 477
    return (0);
  }
#line 478
  while (1) {
#line 478
    if (*text) {
#line 478
      if (! ((int )*text == 32)) {
#line 478
        if (! ((int )*text == 9)) {
#line 478
          break;
        }
      }
    } else {
#line 478
      break;
    }
#line 478
    text ++;
  }
#line 482
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
#line 483
  msa->lastidx = seqidx;
#line 485
  tmp___2 = strcmp((char const   *)featurename, "WT");
#line 485
  if (tmp___2 == 0) {
#line 487
    tmp = atof((char const   *)text);
#line 487
    *(msa->wgt + seqidx) = (float )tmp;
#line 488
    msa->flags |= 1;
  } else {
#line 491
    tmp___1 = strcmp((char const   *)featurename, "AC");
#line 491
    if (tmp___1 == 0) {
#line 492
      MSASetSeqAccession(msa, seqidx, text);
    } else {
#line 494
      tmp___0 = strcmp((char const   *)featurename, "DE");
#line 494
      if (tmp___0 == 0) {
#line 495
        MSASetSeqDescription(msa, seqidx, text);
      } else {
#line 498
        MSAAddGS(msa, featurename, seqidx, text);
      }
    }
  }
#line 500
  return (1);
}
}
#line 506 "stockholm.c"
static int parse_gc(MSA *msa , char *buf ) 
{ 
  char *gc ;
  char *featurename ;
  char *text ;
  char *s___0 ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 515
  s___0 = buf;
#line 516
  gc = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 516
  if ((unsigned long )gc == (unsigned long )((void *)0)) {
#line 516
    return (0);
  }
#line 517
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 517
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
#line 517
    return (0);
  }
#line 518
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
#line 518
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 518
    return (0);
  }
#line 520
  tmp___1 = strcmp((char const   *)featurename, "SS_cons");
#line 520
  if (tmp___1 == 0) {
#line 521
    sre_strcat(& msa->ss_cons, -1, text, len);
  } else {
#line 522
    tmp___0 = strcmp((char const   *)featurename, "SA_cons");
#line 522
    if (tmp___0 == 0) {
#line 523
      sre_strcat(& msa->sa_cons, -1, text, len);
    } else {
#line 524
      tmp = strcmp((char const   *)featurename, "RF");
#line 524
      if (tmp == 0) {
#line 525
        sre_strcat(& msa->rf, -1, text, len);
      } else {
#line 527
        MSAAppendGC(msa, featurename, text);
      }
    }
  }
#line 529
  return (1);
}
}
#line 535 "stockholm.c"
static int parse_gr(MSA *msa , char *buf ) 
{ 
  char *gr ;
  char *seqname ;
  char *featurename ;
  char *text ;
  int seqidx ;
  int len ;
  int j ;
  char *s___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 547
  s___0 = buf;
#line 548
  gr = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 548
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
#line 548
    return (0);
  }
#line 549
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 549
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
#line 549
    return (0);
  }
#line 550
  featurename = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 550
  if ((unsigned long )featurename == (unsigned long )((void *)0)) {
#line 550
    return (0);
  }
#line 551
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
#line 551
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 551
    return (0);
  }
#line 554
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx);
#line 555
  msa->lastidx = seqidx;
#line 557
  tmp___4 = strcmp((char const   *)featurename, "SS");
#line 557
  if (tmp___4 == 0) {
#line 559
    if ((unsigned long )msa->ss == (unsigned long )((void *)0)) {
#line 561
      tmp = sre_malloc((char *)"stockholm.c", 561, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 561
      msa->ss = (char **)tmp;
#line 562
      tmp___0 = sre_malloc((char *)"stockholm.c", 562, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 562
      msa->sslen = (int *)tmp___0;
#line 563
      j = 0;
#line 563
      while (j < msa->nseqalloc) {
#line 565
        *(msa->ss + j) = (char *)((void *)0);
#line 566
        *(msa->sslen + j) = 0;
#line 563
        j ++;
      }
    }
#line 569
    *(msa->sslen + seqidx) = sre_strcat(msa->ss + seqidx, *(msa->sslen + seqidx),
                                        text, len);
  } else {
#line 571
    tmp___3 = strcmp((char const   *)featurename, "SA");
#line 571
    if (tmp___3 == 0) {
#line 573
      if ((unsigned long )msa->sa == (unsigned long )((void *)0)) {
#line 575
        tmp___1 = sre_malloc((char *)"stockholm.c", 575, sizeof(char *) * (unsigned long )msa->nseqalloc);
#line 575
        msa->sa = (char **)tmp___1;
#line 576
        tmp___2 = sre_malloc((char *)"stockholm.c", 576, sizeof(int ) * (unsigned long )msa->nseqalloc);
#line 576
        msa->salen = (int *)tmp___2;
#line 577
        j = 0;
#line 577
        while (j < msa->nseqalloc) {
#line 579
          *(msa->sa + j) = (char *)((void *)0);
#line 580
          *(msa->salen + j) = 0;
#line 577
          j ++;
        }
      }
#line 583
      *(msa->salen + seqidx) = sre_strcat(msa->sa + seqidx, *(msa->salen + seqidx),
                                          text, len);
    } else {
#line 586
      MSAAppendGR(msa, featurename, seqidx, text);
    }
  }
#line 588
  return (1);
}
}
#line 594 "stockholm.c"
static int parse_comment(MSA *msa , char *buf ) 
{ 
  char *s___0 ;
  char *comment ;

  {
#line 600
  s___0 = buf + 1;
#line 601
  if ((int )*s___0 == 10) {
#line 601
    *s___0 = (char )'\000';
#line 601
    comment = s___0;
  } else {
#line 602
    comment = sre_strtok(& s___0, (char *)"\n", (int *)((void *)0));
#line 602
    if ((unsigned long )comment == (unsigned long )((void *)0)) {
#line 602
      return (0);
    }
  }
#line 604
  MSAAddComment(msa, comment);
#line 605
  return (1);
}
}
#line 608 "stockholm.c"
static int parse_sequence(MSA *msa , char *buf ) 
{ 
  char *s___0 ;
  char *seqname ;
  char *text ;
  int seqidx ;
  int len ;

  {
#line 617
  s___0 = buf;
#line 618
  seqname = sre_strtok(& s___0, (char *)" \t\n", (int *)((void *)0));
#line 618
  if ((unsigned long )seqname == (unsigned long )((void *)0)) {
#line 618
    return (0);
  }
#line 619
  text = sre_strtok(& s___0, (char *)" \t\n", & len);
#line 619
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 619
    return (0);
  }
#line 622
  seqidx = MSAGetSeqidx(msa, seqname, msa->lastidx + 1);
#line 623
  msa->lastidx = seqidx;
#line 625
  *(msa->sqlen + seqidx) = sre_strcat(msa->aseq + seqidx, *(msa->sqlen + seqidx),
                                      text, len);
#line 626
  return (1);
}
}
#line 1 "translate.o"
#pragma merger("0","/tmp/cil-CMAFujR1.i","")
#line 244 "./sqfuncs.h"
char *Translate(char *seq , char **code ) ;
#line 47 "translate.c"
char *Translate(char *seq , char **code ) 
{ 
  int codon ;
  char *aaseq ;
  char *aaptr ;
  int i___0 ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 55
  if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 56
    squid_errno = 2;
#line 56
    return ((char *)((void *)0));
  }
#line 57
  tmp = strlen((char const   *)seq);
#line 57
  tmp___0 = calloc(tmp + 1UL, sizeof(char ));
#line 57
  aaseq = (char *)tmp___0;
#line 57
  if ((unsigned long )aaseq == (unsigned long )((void *)0)) {
#line 58
    Die((char *)"calloc failed");
  }
#line 60
  aaptr = aaseq;
#line 61
  while (1) {
#line 61
    if ((int )*seq != 0) {
#line 61
      if ((int )*(seq + 1) != 0) {
#line 61
        if (! ((int )*(seq + 2) != 0)) {
#line 61
          break;
        }
      } else {
#line 61
        break;
      }
    } else {
#line 61
      break;
    }
#line 65
    codon = 0;
#line 66
    i___0 = 0;
#line 66
    while (i___0 < 3) {
#line 68
      codon *= 4;
#line 69
      switch ((int )*(seq + i___0)) {
      case 97: 
      case 65: 
#line 70
      break;
      case 99: 
      case 67: 
#line 71
      codon ++;
#line 71
      break;
      case 103: 
      case 71: 
#line 72
      codon += 2;
#line 72
      break;
      case 116: 
      case 84: 
#line 73
      codon += 3;
#line 73
      break;
      case 117: 
      case 85: 
#line 74
      codon += 3;
#line 74
      break;
      default: 
#line 75
      codon = 64;
#line 75
      break;
      }
#line 77
      if (codon == 64) {
#line 77
        break;
      }
#line 66
      i___0 ++;
    }
#line 80
    strcpy((char * __restrict  )aaptr, (char const   * __restrict  )*(code + codon));
#line 81
    tmp___1 = strlen((char const   *)*(code + codon));
#line 81
    aaptr += tmp___1;
#line 61
    seq += 3;
  }
#line 83
  return (aaseq);
}
}
#line 1 "types.o"
#pragma merger("0","/tmp/cil-xhHnfLE6.i","")
#line 251 "./sqfuncs.h"
void Byteswap(char *swap , int nbytes ) ;
#line 30 "types.c"
int IsInt(char *s___0 ) 
{ 
  int hex ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 33
  hex = 0;
#line 35
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 35
    squid_errno = 6;
#line 35
    return (0);
  }
#line 38
  while (1) {
#line 38
    tmp = __ctype_b_loc();
#line 38
    if (! ((int const   )*(*tmp + (int )*s___0) & 8192)) {
#line 38
      break;
    }
#line 38
    s___0 ++;
  }
#line 40
  if ((int )*s___0 == 45) {
#line 40
    s___0 ++;
  } else
#line 40
  if ((int )*s___0 == 43) {
#line 40
    s___0 ++;
  }
#line 42
  tmp___1 = strncmp((char const   *)s___0, "0x", (size_t )2);
#line 42
  if (tmp___1 == 0) {
#line 42
    tmp___2 = strlen((char const   *)s___0);
#line 42
    if ((int )tmp___2 > 2) {
#line 45
      s___0 += 2;
#line 46
      hex = 1;
    } else {
#line 42
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 42
    tmp___3 = strncmp((char const   *)s___0, "0X", (size_t )2);
#line 42
    if (tmp___3 == 0) {
#line 42
      tmp___4 = strlen((char const   *)s___0);
#line 42
      if ((int )tmp___4 > 2) {
#line 45
        s___0 += 2;
#line 46
        hex = 1;
      } else {
#line 42
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 48
    if ((int )*s___0 == 48) {
#line 48
      tmp___0 = strlen((char const   *)s___0);
#line 48
      if ((int )tmp___0 > 1) {
#line 49
        s___0 ++;
      }
    }
  }
#line 51
  if (! hex) {
#line 52
    while ((int )*s___0 != 0) {
#line 54
      tmp___5 = __ctype_b_loc();
#line 54
      if (! ((int const   )*(*tmp___5 + (int )*s___0) & 2048)) {
#line 54
        return (0);
      }
#line 55
      s___0 ++;
    }
  } else {
#line 58
    while ((int )*s___0 != 0) {
#line 60
      tmp___6 = __ctype_b_loc();
#line 60
      if (! ((int const   )*(*tmp___6 + (int )*s___0) & 4096)) {
#line 60
        return (0);
      }
#line 61
      s___0 ++;
    }
  }
#line 64
  return (1);
}
}
#line 73 "types.c"
int IsReal(char *s___0 ) 
{ 
  int gotdecimal ;
  int gotexp ;
  int gotreal ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 76
  gotdecimal = 0;
#line 77
  gotexp = 0;
#line 78
  gotreal = 0;
#line 80
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 80
    return (0);
  }
#line 82
  while (1) {
#line 82
    tmp = __ctype_b_loc();
#line 82
    if (! ((int const   )*(*tmp + (int )*s___0) & 8192)) {
#line 82
      break;
    }
#line 82
    s___0 ++;
  }
#line 83
  if ((int )*s___0 == 45) {
#line 83
    s___0 ++;
  } else
#line 83
  if ((int )*s___0 == 43) {
#line 83
    s___0 ++;
  }
#line 89
  while ((int )*s___0 != 0) {
#line 91
    tmp___1 = __ctype_b_loc();
#line 91
    if ((int const   )*(*tmp___1 + (int )*s___0) & 2048) {
#line 92
      gotreal ++;
    } else
#line 93
    if ((int )*s___0 == 46) {
#line 95
      if (gotdecimal) {
#line 95
        return (0);
      }
#line 96
      if (gotexp) {
#line 96
        return (0);
      } else {
#line 97
        gotdecimal ++;
      }
    } else
#line 99
    if ((int )*s___0 == 101) {
#line 99
      goto _L;
    } else
#line 99
    if ((int )*s___0 == 69) {
      _L: /* CIL Label */ 
#line 101
      if (gotexp) {
#line 101
        return (0);
      } else {
#line 102
        gotexp ++;
      }
    } else {
#line 104
      tmp___0 = __ctype_b_loc();
#line 104
      if ((int const   )*(*tmp___0 + (int )*s___0) & 8192) {
#line 105
        break;
      }
    }
#line 107
    s___0 ++;
  }
#line 110
  while (1) {
#line 110
    tmp___2 = __ctype_b_loc();
#line 110
    if (! ((int const   )*(*tmp___2 + (int )*s___0) & 8192)) {
#line 110
      break;
    }
#line 110
    s___0 ++;
  }
#line 111
  if ((int )*s___0 == 0) {
#line 111
    if (gotreal) {
#line 111
      return (1);
    } else {
#line 112
      return (0);
    }
  } else {
#line 112
    return (0);
  }
}
}
#line 132 "types.c"
void Byteswap(char *swap , int nbytes ) 
{ 
  int x ;
  char byte ;

  {
#line 138
  x = 0;
#line 138
  while (x < nbytes / 2) {
#line 140
    byte = *(swap + ((nbytes - x) - 1));
#line 141
    *(swap + ((nbytes - x) - 1)) = *(swap + x);
#line 142
    *(swap + x) = byte;
#line 138
    x ++;
  }
#line 144
  return;
}
}
#line 165 "types.c"
sqd_uint16 sre_ntoh16(sqd_uint16 netshort ) 
{ 


  {
#line 169
  return (netshort);
}
}
#line 175 "types.c"
sqd_uint32 sre_ntoh32(sqd_uint32 netlong ) 
{ 


  {
#line 179
  return (netlong);
}
}
#line 185 "types.c"
sqd_uint16 sre_hton16(sqd_uint16 hostshort ) 
{ 


  {
#line 189
  return (hostshort);
}
}
#line 195 "types.c"
sqd_uint32 sre_hton32(sqd_uint32 hostlong ) 
{ 


  {
#line 199
  return (hostlong);
}
}
#line 207 "types.c"
sqd_uint64 sre_ntoh64(sqd_uint64 net_int64 ) 
{ 


  {
#line 211
  return (net_int64);
}
}
#line 217 "types.c"
sqd_uint64 sre_hton64(sqd_uint64 host_int64 ) 
{ 


  {
#line 221
  return (host_int64);
}
}
#line 1 "vectorops.o"
#pragma merger("0","/tmp/cil-YtFTVyc5.i","")
#line 8 "./vectorops.h"
void DSet(double *vec , int n , double value ) ;
#line 10
void DScale(double *vec , int n , double scale ) ;
#line 12
double DSum(double *vec , int n ) ;
#line 14
void DAdd(double *vec1 , double *vec2 , int n ) ;
#line 16
void DCopy(double *vec1 , double *vec2 , int n ) ;
#line 18
double DDot(double *vec1 , double *vec2 , int n ) ;
#line 20
double DMax(double *vec , int n ) ;
#line 21
float FMax(float *vec , int n ) ;
#line 22
double DMin(double *vec , int n ) ;
#line 23
float FMin(float *vec , int n ) ;
#line 24
int DArgMax(double *vec , int n ) ;
#line 26
int DArgMin(double *vec , int n ) ;
#line 27
int FArgMin(float *vec , int n ) ;
#line 28
void DNorm(double *vec , int n ) ;
#line 30
void DLog(double *vec , int n ) ;
#line 31
void FLog(float *vec , int n ) ;
#line 32
void DExp(double *vec , int n ) ;
#line 33
void FExp(float *vec , int n ) ;
#line 34
double DLogSum(double *vec , int n ) ;
#line 35
float FLogSum(float *vec , int n ) ;
#line 31 "vectorops.c"
void DSet(double *vec , int n , double value ) 
{ 
  int x ;

  {
#line 35
  x = 0;
#line 35
  while (x < n) {
#line 35
    *(vec + x) = value;
#line 35
    x ++;
  }
#line 36
  return;
}
}
#line 38 "vectorops.c"
void FSet(float *vec , int n , float value ) 
{ 
  int x ;

  {
#line 42
  x = 0;
#line 42
  while (x < n) {
#line 42
    *(vec + x) = value;
#line 42
    x ++;
  }
#line 43
  return;
}
}
#line 45 "vectorops.c"
void DScale(double *vec , int n , double scale ) 
{ 
  int x ;

  {
#line 49
  x = 0;
#line 49
  while (x < n) {
#line 49
    *(vec + x) *= scale;
#line 49
    x ++;
  }
#line 50
  return;
}
}
#line 52 "vectorops.c"
void FScale(float *vec , int n , float scale ) 
{ 
  int x ;

  {
#line 56
  x = 0;
#line 56
  while (x < n) {
#line 56
    *(vec + x) *= scale;
#line 56
    x ++;
  }
#line 57
  return;
}
}
#line 59 "vectorops.c"
double DSum(double *vec , int n ) 
{ 
  double sum ;
  int x ;

  {
#line 62
  sum = 0.;
#line 64
  x = 0;
#line 64
  while (x < n) {
#line 64
    sum += *(vec + x);
#line 64
    x ++;
  }
#line 65
  return (sum);
}
}
#line 68 "vectorops.c"
float FSum(float *vec , int n ) 
{ 
  float sum ;
  int x ;

  {
#line 71
  sum = (float )0.;
#line 73
  x = 0;
#line 73
  while (x < n) {
#line 73
    sum += *(vec + x);
#line 73
    x ++;
  }
#line 74
  return (sum);
}
}
#line 77 "vectorops.c"
void DAdd(double *vec1 , double *vec2 , int n ) 
{ 
  int x ;

  {
#line 81
  x = 0;
#line 81
  while (x < n) {
#line 81
    *(vec1 + x) += *(vec2 + x);
#line 81
    x ++;
  }
#line 82
  return;
}
}
#line 84 "vectorops.c"
void FAdd(float *vec1 , float *vec2 , int n ) 
{ 
  int x ;

  {
#line 88
  x = 0;
#line 88
  while (x < n) {
#line 88
    *(vec1 + x) += *(vec2 + x);
#line 88
    x ++;
  }
#line 89
  return;
}
}
#line 91 "vectorops.c"
void DCopy(double *vec1 , double *vec2 , int n ) 
{ 
  int x ;

  {
#line 95
  x = 0;
#line 95
  while (x < n) {
#line 95
    *(vec1 + x) = *(vec2 + x);
#line 95
    x ++;
  }
#line 96
  return;
}
}
#line 98 "vectorops.c"
void FCopy(float *vec1 , float *vec2 , int n ) 
{ 
  int x ;

  {
#line 102
  x = 0;
#line 102
  while (x < n) {
#line 102
    *(vec1 + x) = *(vec2 + x);
#line 102
    x ++;
  }
#line 103
  return;
}
}
#line 105 "vectorops.c"
double DDot(double *vec1 , double *vec2 , int n ) 
{ 
  double result ;
  int x ;

  {
#line 108
  result = 0.;
#line 110
  x = 0;
#line 110
  while (x < n) {
#line 110
    result += *(vec1 + x) * *(vec2 + x);
#line 110
    x ++;
  }
#line 111
  return (result);
}
}
#line 114 "vectorops.c"
float FDot(float *vec1 , float *vec2 , int n ) 
{ 
  float result ;
  int x ;

  {
#line 117
  result = (float )0.;
#line 119
  x = 0;
#line 119
  while (x < n) {
#line 119
    result += *(vec1 + x) * *(vec2 + x);
#line 119
    x ++;
  }
#line 120
  return (result);
}
}
#line 123 "vectorops.c"
double DMax(double *vec , int n ) 
{ 
  int i___0 ;
  double best ;

  {
#line 129
  best = *(vec + 0);
#line 130
  i___0 = 1;
#line 130
  while (i___0 < n) {
#line 131
    if (*(vec + i___0) > best) {
#line 131
      best = *(vec + i___0);
    }
#line 130
    i___0 ++;
  }
#line 132
  return (best);
}
}
#line 135 "vectorops.c"
float FMax(float *vec , int n ) 
{ 
  int i___0 ;
  float best ;

  {
#line 141
  best = *(vec + 0);
#line 142
  i___0 = 1;
#line 142
  while (i___0 < n) {
#line 143
    if (*(vec + i___0) > best) {
#line 143
      best = *(vec + i___0);
    }
#line 142
    i___0 ++;
  }
#line 144
  return (best);
}
}
#line 147 "vectorops.c"
double DMin(double *vec , int n ) 
{ 
  int i___0 ;
  double best ;

  {
#line 153
  best = *(vec + 0);
#line 154
  i___0 = 1;
#line 154
  while (i___0 < n) {
#line 155
    if (*(vec + i___0) < best) {
#line 155
      best = *(vec + i___0);
    }
#line 154
    i___0 ++;
  }
#line 156
  return (best);
}
}
#line 159 "vectorops.c"
float FMin(float *vec , int n ) 
{ 
  int i___0 ;
  float best ;

  {
#line 165
  best = *(vec + 0);
#line 166
  i___0 = 1;
#line 166
  while (i___0 < n) {
#line 167
    if (*(vec + i___0) < best) {
#line 167
      best = *(vec + i___0);
    }
#line 166
    i___0 ++;
  }
#line 168
  return (best);
}
}
#line 171 "vectorops.c"
int DArgMax(double *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
#line 175
  best = 0;
#line 177
  i___0 = 1;
#line 177
  while (i___0 < n) {
#line 178
    if (*(vec + i___0) > *(vec + best)) {
#line 178
      best = i___0;
    }
#line 177
    i___0 ++;
  }
#line 179
  return (best);
}
}
#line 182 "vectorops.c"
int FArgMax(float *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
#line 186
  best = 0;
#line 188
  i___0 = 1;
#line 188
  while (i___0 < n) {
#line 189
    if (*(vec + i___0) > *(vec + best)) {
#line 189
      best = i___0;
    }
#line 188
    i___0 ++;
  }
#line 190
  return (best);
}
}
#line 193 "vectorops.c"
int DArgMin(double *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
#line 197
  best = 0;
#line 198
  i___0 = 1;
#line 198
  while (i___0 < n) {
#line 199
    if (*(vec + i___0) < *(vec + best)) {
#line 199
      best = i___0;
    }
#line 198
    i___0 ++;
  }
#line 200
  return (best);
}
}
#line 203 "vectorops.c"
int FArgMin(float *vec , int n ) 
{ 
  int i___0 ;
  int best ;

  {
#line 207
  best = 0;
#line 209
  i___0 = 1;
#line 209
  while (i___0 < n) {
#line 210
    if (*(vec + i___0) < *(vec + best)) {
#line 210
      best = i___0;
    }
#line 209
    i___0 ++;
  }
#line 211
  return (best);
}
}
#line 214 "vectorops.c"
void DNorm(double *vec , int n ) 
{ 
  int x ;
  double sum ;

  {
#line 220
  sum = DSum(vec, n);
#line 221
  if (sum != 0.0) {
#line 221
    x = 0;
#line 221
    while (x < n) {
#line 221
      *(vec + x) /= sum;
#line 221
      x ++;
    }
  } else {
#line 222
    x = 0;
#line 222
    while (x < n) {
#line 222
      *(vec + x) = 1. / (double )n;
#line 222
      x ++;
    }
  }
#line 223
  return;
}
}
#line 225 "vectorops.c"
void FNorm(float *vec , int n ) 
{ 
  int x ;
  float sum ;

  {
#line 231
  sum = FSum(vec, n);
#line 232
  if ((double )sum != 0.0) {
#line 232
    x = 0;
#line 232
    while (x < n) {
#line 232
      *(vec + x) /= sum;
#line 232
      x ++;
    }
  } else {
#line 233
    x = 0;
#line 233
    while (x < n) {
#line 233
      *(vec + x) = (float )(1. / (double )((float )n));
#line 233
      x ++;
    }
  }
#line 234
  return;
}
}
#line 236 "vectorops.c"
void DLog(double *vec , int n ) 
{ 
  int x ;

  {
#line 240
  x = 0;
#line 240
  while (x < n) {
#line 241
    if (*(vec + x) > 0.) {
#line 241
      *(vec + x) = log(*(vec + x));
    } else {
#line 242
      *(vec + x) = - 1.7976931348623157e+308;
    }
#line 240
    x ++;
  }
#line 243
  return;
}
}
#line 245 "vectorops.c"
void FLog(float *vec , int n ) 
{ 
  int x ;
  double tmp ;

  {
#line 249
  x = 0;
#line 249
  while (x < n) {
#line 250
    if ((double )*(vec + x) > 0.) {
#line 250
      tmp = log((double )*(vec + x));
#line 250
      *(vec + x) = (float )tmp;
    } else {
#line 251
      *(vec + x) = - 3.40282347e+38F;
    }
#line 249
    x ++;
  }
#line 252
  return;
}
}
#line 254 "vectorops.c"
void DExp(double *vec , int n ) 
{ 
  int x ;

  {
#line 258
  x = 0;
#line 258
  while (x < n) {
#line 258
    *(vec + x) = exp(*(vec + x));
#line 258
    x ++;
  }
#line 259
  return;
}
}
#line 261 "vectorops.c"
void FExp(float *vec , int n ) 
{ 
  int x ;
  double tmp ;

  {
#line 265
  x = 0;
#line 265
  while (x < n) {
#line 265
    tmp = exp((double )*(vec + x));
#line 265
    *(vec + x) = (float )tmp;
#line 265
    x ++;
  }
#line 266
  return;
}
}
#line 268 "vectorops.c"
double DLogSum(double *vec , int n ) 
{ 
  int x ;
  double max ;
  double sum ;
  double tmp ;
  double tmp___0 ;

  {
#line 274
  max = DMax(vec, n);
#line 275
  sum = 0.0;
#line 276
  x = 0;
#line 276
  while (x < n) {
#line 277
    if (*(vec + x) > max - 50.) {
#line 278
      tmp = exp(*(vec + x) - max);
#line 278
      sum += tmp;
    }
#line 276
    x ++;
  }
#line 279
  tmp___0 = log(sum);
#line 279
  sum = tmp___0 + max;
#line 280
  return (sum);
}
}
#line 283 "vectorops.c"
float FLogSum(float *vec , int n ) 
{ 
  int x ;
  float max ;
  float sum ;
  double tmp ;
  double tmp___0 ;

  {
#line 289
  max = FMax(vec, n);
#line 290
  sum = (float )0.0;
#line 291
  x = 0;
#line 291
  while (x < n) {
#line 292
    if ((double )*(vec + x) > (double )max - 50.) {
#line 293
      tmp = exp((double )(*(vec + x) - max));
#line 293
      sum = (float )((double )sum + tmp);
    }
#line 291
    x ++;
  }
#line 294
  tmp___0 = log((double )sum);
#line 294
  sum = (float )(tmp___0 + (double )max);
#line 295
  return (sum);
}
}
#line 1 "weight.o"
#pragma merger("0","/tmp/cil-r0cgX3lw.i","")
#line 264 "./sqfuncs.h"
void GSCWeights(char **aseq , int nseq , int alen , float *wgt ) ;
#line 265
void VoronoiWeights(char **aseq , int nseq , int alen , float *wgt ) ;
#line 266
void BlosumWeights(char **aseqs , int nseq , int alen , float maxid , float *wgt ) ;
#line 267
void PositionBasedWeights(char **aseq , int nseq , int alen , float *wgt ) ;
#line 268
void FilterAlignment(MSA *msa , float cutoff , MSA **ret_new ) ;
#line 269
void SampleAlignment(MSA *msa , int sample , MSA **ret_new ) ;
#line 270
void SingleLinkCluster(char **aseq , int nseq , int alen , float maxid , int **ret_c ,
                       int *ret_nc ) ;
#line 25 "weight.c"
static void upweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt , int node ) ;
#line 26
static void downweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt ,
                       float *fwt , int node ) ;
#line 28
static float simple_distance(char *s1 , char *s2 ) ;
#line 29
static int simple_diffmx(char **aseqs , int num , float ***ret_dmx ) ;
#line 45 "weight.c"
void GSCWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  float **dmx ;
  struct phylo_s *tree ;
  float *lwt ;
  float *rwt ;
  float *fwt ;
  int i___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  float tmp___3 ;

  {
#line 56
  if (nseq == 1) {
#line 56
    *(wgt + 0) = (float )1.0;
#line 56
    return;
  }
#line 62
  MakeDiffMx(aseq, nseq, & dmx);
#line 63
  tmp = Cluster(dmx, nseq, (enum clust_strategy )2, & tree);
#line 63
  if (! tmp) {
#line 63
    Die((char *)"Cluster() failed");
  }
#line 67
  tmp___0 = sre_malloc((char *)"weight.c", 67, sizeof(float ) * (unsigned long )(2 * nseq - 1));
#line 67
  lwt = (float *)tmp___0;
#line 68
  tmp___1 = sre_malloc((char *)"weight.c", 68, sizeof(float ) * (unsigned long )(2 * nseq - 1));
#line 68
  rwt = (float *)tmp___1;
#line 69
  tmp___2 = sre_malloc((char *)"weight.c", 69, sizeof(float ) * (unsigned long )(2 * nseq - 1));
#line 69
  fwt = (float *)tmp___2;
#line 76
  i___0 = 0;
#line 76
  while (i___0 < nseq) {
#line 77
    tmp___3 = (float )0.0;
#line 77
    *(rwt + i___0) = tmp___3;
#line 77
    *(lwt + i___0) = tmp___3;
#line 76
    i___0 ++;
  }
#line 80
  upweight(tree, nseq, lwt, rwt, nseq);
#line 84
  *(fwt + nseq) = (float )nseq;
#line 85
  downweight(tree, nseq, lwt, rwt, fwt, nseq);
#line 87
  i___0 = 0;
#line 87
  while (i___0 < nseq) {
#line 88
    *(wgt + i___0) = *(fwt + i___0);
#line 87
    i___0 ++;
  }
#line 90
  FMX2Free(dmx);
#line 91
  FreePhylo(tree, nseq);
#line 92
  free((void *)lwt);
#line 92
  free((void *)rwt);
#line 92
  free((void *)fwt);
#line 93
  return;
}
}
#line 95 "weight.c"
static void upweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt , int node ) 
{ 
  int ld ;
  int rd ;

  {
#line 100
  ld = (tree + (node - nseq))->left;
#line 101
  if (ld >= nseq) {
#line 101
    upweight(tree, nseq, lwt, rwt, ld);
  }
#line 102
  rd = (tree + (node - nseq))->right;
#line 103
  if (rd >= nseq) {
#line 103
    upweight(tree, nseq, lwt, rwt, rd);
  }
#line 104
  *(lwt + node) = (*(lwt + ld) + *(rwt + ld)) + (tree + (node - nseq))->lblen;
#line 105
  *(rwt + node) = (*(lwt + rd) + *(rwt + rd)) + (tree + (node - nseq))->rblen;
#line 106
  return;
}
}
#line 109 "weight.c"
static void downweight(struct phylo_s *tree , int nseq , float *lwt , float *rwt ,
                       float *fwt , int node ) 
{ 
  int ld ;
  int rd ;
  float lnum ;
  float rnum ;

  {
#line 115
  ld = (tree + (node - nseq))->left;
#line 116
  rd = (tree + (node - nseq))->right;
#line 117
  if ((double )(*(lwt + node) + *(rwt + node)) > 0.0) {
#line 119
    *(fwt + ld) = *(fwt + node) * (*(lwt + node) / (*(lwt + node) + *(rwt + node)));
#line 120
    *(fwt + rd) = *(fwt + node) * (*(rwt + node) / (*(lwt + node) + *(rwt + node)));
  } else {
#line 124
    if (ld >= nseq) {
#line 124
      lnum = (float )(tree + (ld - nseq))->incnum;
    } else {
#line 124
      lnum = (float )1.0;
    }
#line 125
    if (rd >= nseq) {
#line 125
      rnum = (float )(tree + (rd - nseq))->incnum;
    } else {
#line 125
      rnum = (float )1.0;
    }
#line 126
    *(fwt + ld) = (*(fwt + node) * lnum) / (lnum + rnum);
#line 127
    *(fwt + rd) = (*(fwt + node) * rnum) / (lnum + rnum);
  }
#line 130
  if (ld >= nseq) {
#line 130
    downweight(tree, nseq, lwt, rwt, fwt, ld);
  }
#line 131
  if (rd >= nseq) {
#line 131
    downweight(tree, nseq, lwt, rwt, fwt, rd);
  }
#line 132
  return;
}
}
#line 153 "weight.c"
void VoronoiWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  float **dmx ;
  float *halfmin ;
  char **psym ;
  int *nsym ;
  int symseen[27] ;
  char *randseq ;
  int acol ;
  int idx ;
  int symidx ;
  int i___0 ;
  float min ;
  float dist ;
  float challenge ;
  float champion ;
  int itscale ;
  int iteration ;
  int best ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
#line 175
  if (nseq == 1) {
#line 175
    *(wgt + 0) = (float )1.0;
#line 175
    return;
  }
#line 177
  itscale = 50;
#line 182
  tmp = simple_diffmx(aseq, nseq, & dmx);
#line 182
  if (! tmp) {
#line 183
    Die((char *)"simple_diffmx() failed");
  }
#line 184
  tmp___0 = sre_malloc((char *)"weight.c", 184, sizeof(float ) * (unsigned long )nseq);
#line 184
  halfmin = (float *)tmp___0;
#line 185
  idx = 0;
#line 185
  while (idx < nseq) {
#line 187
    min = (float )1.0;
#line 187
    i___0 = 0;
#line 187
    while (i___0 < nseq) {
#line 189
      if (i___0 == idx) {
#line 189
        goto __Cont;
      }
#line 190
      if (*(*(dmx + idx) + i___0) < min) {
#line 190
        min = *(*(dmx + idx) + i___0);
      }
      __Cont: /* CIL Label */ 
#line 187
      i___0 ++;
    }
#line 192
    *(halfmin + idx) = (float )((double )min / 2.0);
#line 185
    idx ++;
  }
#line 194
  Free2DArray((void **)dmx, nseq);
#line 198
  tmp___1 = sre_malloc((char *)"weight.c", 198, (unsigned long )alen * sizeof(char *));
#line 198
  psym = (char **)tmp___1;
#line 199
  tmp___2 = sre_malloc((char *)"weight.c", 199, (unsigned long )alen * sizeof(int ));
#line 199
  nsym = (int *)tmp___2;
#line 200
  acol = 0;
#line 200
  while (acol < alen) {
#line 201
    tmp___3 = sre_malloc((char *)"weight.c", 201, 27UL * sizeof(char ));
#line 201
    *(psym + acol) = (char *)tmp___3;
#line 200
    acol ++;
  }
#line 204
  acol = 0;
#line 204
  while (acol < alen) {
#line 206
    memset((void *)(symseen), 0, sizeof(int ) * 27UL);
#line 207
    idx = 0;
#line 207
    while (idx < nseq) {
#line 208
      if ((int )*(*(aseq + idx) + acol) == 32) {
#line 218
        symseen[26] = 1;
      } else
#line 208
      if ((int )*(*(aseq + idx) + acol) == 46) {
#line 218
        symseen[26] = 1;
      } else
#line 208
      if ((int )*(*(aseq + idx) + acol) == 95) {
#line 218
        symseen[26] = 1;
      } else
#line 208
      if ((int )*(*(aseq + idx) + acol) == 45) {
#line 218
        symseen[26] = 1;
      } else
#line 208
      if ((int )*(*(aseq + idx) + acol) == 126) {
#line 218
        symseen[26] = 1;
      } else {
#line 210
        tmp___4 = __ctype_b_loc();
#line 210
        if ((int const   )*(*tmp___4 + (int )*(*(aseq + idx) + acol)) & 256) {
#line 211
          symidx = (int )*(*(aseq + idx) + acol) - 65;
        } else {
#line 213
          symidx = (int )*(*(aseq + idx) + acol) - 97;
        }
#line 214
        if (symidx >= 0) {
#line 214
          if (symidx < 26) {
#line 215
            symseen[symidx] = 1;
          }
        }
      }
#line 207
      idx ++;
    }
#line 220
    *(nsym + acol) = 0;
#line 220
    i___0 = 0;
#line 220
    while (i___0 < 26) {
#line 221
      if (symseen[i___0]) {
#line 223
        *(*(psym + acol) + *(nsym + acol)) = (char )(65 + i___0);
#line 224
        (*(nsym + acol)) ++;
      }
#line 220
      i___0 ++;
    }
#line 226
    if (symseen[26]) {
#line 226
      *(*(psym + acol) + *(nsym + acol)) = (char )' ';
#line 226
      (*(nsym + acol)) ++;
    }
#line 204
    acol ++;
  }
#line 268
  tmp___5 = sre_malloc((char *)"weight.c", 268, (unsigned long )(alen + 1) * sizeof(char ));
#line 268
  randseq = (char *)tmp___5;
#line 270
  best = (int )42.;
#line 271
  FSet(wgt, nseq, (float )0.0);
#line 272
  iteration = 0;
#line 272
  while (iteration < itscale * nseq) {
#line 274
    acol = 0;
#line 274
    while (acol < alen) {
#line 275
      if (*(nsym + acol) == 0) {
#line 275
        *(randseq + acol) = (char )' ';
      } else {
#line 275
        tmp___6 = sre_random();
#line 275
        *(randseq + acol) = *(*(psym + acol) + (int )(tmp___6 * (double )*(nsym + acol)));
      }
#line 274
      acol ++;
    }
#line 276
    *(randseq + acol) = (char )'\000';
#line 278
    tmp___7 = sre_random();
#line 278
    champion = (float )tmp___7;
#line 279
    min = (float )1.0;
#line 279
    idx = 0;
#line 279
    while (idx < nseq) {
#line 281
      dist = simple_distance(*(aseq + idx), randseq);
#line 282
      if (dist < *(halfmin + idx)) {
#line 284
        best = idx;
#line 285
        break;
      }
#line 287
      if (dist < min) {
#line 288
        tmp___8 = sre_random();
#line 288
        champion = (float )tmp___8;
#line 288
        best = idx;
#line 288
        min = dist;
      } else
#line 289
      if (dist == min) {
#line 291
        tmp___9 = sre_random();
#line 291
        challenge = (float )tmp___9;
#line 292
        if (challenge > champion) {
#line 293
          champion = challenge;
#line 293
          best = idx;
#line 293
          min = dist;
        }
      }
#line 279
      idx ++;
    }
#line 296
    *(wgt + best) = (float )((double )*(wgt + best) + 1.0);
#line 272
    iteration ++;
  }
#line 299
  idx = 0;
#line 299
  while (idx < nseq) {
#line 300
    *(wgt + idx) /= (float )itscale;
#line 299
    idx ++;
  }
#line 302
  free((void *)randseq);
#line 303
  free((void *)nsym);
#line 304
  free((void *)halfmin);
#line 305
  Free2DArray((void **)psym, alen);
#line 306
  return;
}
}
#line 315 "weight.c"
static float simple_distance(char *s1 , char *s2 ) 
{ 
  int diff ;
  int valid ;
  double tmp ;

  {
#line 318
  diff = 0;
#line 319
  valid = 0;
#line 321
  while ((int )*s1 != 0) {
#line 323
    if ((int )*s1 == 32) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s1 == 46) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s1 == 95) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s1 == 45) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s1 == 126) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s2 == 32) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s2 == 46) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s2 == 95) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s2 == 45) {
#line 323
      goto __Cont;
    } else
#line 323
    if ((int )*s2 == 126) {
#line 323
      goto __Cont;
    }
#line 324
    if ((int )*s1 != (int )*s2) {
#line 324
      diff ++;
    }
#line 325
    valid ++;
    __Cont: /* CIL Label */ 
#line 321
    s1 ++;
#line 321
    s2 ++;
  }
#line 327
  if (valid > 0) {
#line 327
    tmp = (double )((float )diff / (float )valid);
  } else {
#line 327
    tmp = 0.0;
  }
#line 327
  return ((float )tmp);
}
}
#line 342 "weight.c"
static int simple_diffmx(char **aseqs , int num , float ***ret_dmx ) 
{ 
  float **dmx ;
  int i___0 ;
  int j ;
  void *tmp ;
  float *tmp___0 ;
  void *tmp___1 ;
  float tmp___2 ;

  {
#line 352
  tmp = malloc(sizeof(float *) * (unsigned long )num);
#line 352
  dmx = (float **)tmp;
#line 352
  if ((unsigned long )dmx == (unsigned long )((void *)0)) {
#line 353
    Die((char *)"malloc failed");
  }
#line 354
  i___0 = 0;
#line 354
  while (i___0 < num) {
#line 355
    tmp___1 = malloc(sizeof(float ) * (unsigned long )num);
#line 355
    tmp___0 = (float *)tmp___1;
#line 355
    *(dmx + i___0) = tmp___0;
#line 355
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 356
      Die((char *)"malloc failed");
    }
#line 354
    i___0 ++;
  }
#line 360
  i___0 = 0;
#line 360
  while (i___0 < num) {
#line 361
    j = i___0;
#line 361
    while (j < num) {
#line 362
      tmp___2 = simple_distance(*(aseqs + i___0), *(aseqs + j));
#line 362
      *(*(dmx + j) + i___0) = tmp___2;
#line 362
      *(*(dmx + i___0) + j) = tmp___2;
#line 361
      j ++;
    }
#line 360
    i___0 ++;
  }
#line 366
  *ret_dmx = dmx;
#line 367
  return (1);
}
}
#line 393 "weight.c"
void BlosumWeights(char **aseqs , int nseq , int alen , float maxid , float *wgt ) 
{ 
  int *c ;
  int nc ;
  int *nmem ;
  int i___0 ;
  void *tmp ;

  {
#line 400
  SingleLinkCluster(aseqs, nseq, alen, maxid, & c, & nc);
#line 402
  FSet(wgt, nseq, (float )1.0);
#line 403
  tmp = sre_malloc((char *)"weight.c", 403, sizeof(int ) * (unsigned long )nc);
#line 403
  nmem = (int *)tmp;
#line 405
  i___0 = 0;
#line 405
  while (i___0 < nc) {
#line 405
    *(nmem + i___0) = 0;
#line 405
    i___0 ++;
  }
#line 406
  i___0 = 0;
#line 406
  while (i___0 < nseq) {
#line 406
    (*(nmem + *(c + i___0))) ++;
#line 406
    i___0 ++;
  }
#line 407
  i___0 = 0;
#line 407
  while (i___0 < nseq) {
#line 407
    *(wgt + i___0) = (float )(1. / (double )((float )*(nmem + *(c + i___0))));
#line 407
    i___0 ++;
  }
#line 409
  free((void *)nmem);
#line 410
  free((void *)c);
#line 411
  return;
}
}
#line 462 "weight.c"
void PositionBasedWeights(char **aseq , int nseq , int alen , float *wgt ) 
{ 
  int rescount[26] ;
  int nres ;
  int idx ;
  int pos ;
  int x ;
  float norm ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  float tmp___4 ;

  {
#line 471
  FSet(wgt, nseq, (float )0.0);
#line 472
  pos = 0;
#line 472
  while (pos < alen) {
#line 474
    x = 0;
#line 474
    while (x < 26) {
#line 474
      rescount[x] = 0;
#line 474
      x ++;
    }
#line 475
    idx = 0;
#line 475
    while (idx < nseq) {
#line 476
      tmp___0 = __ctype_b_loc();
#line 476
      if ((int const   )*(*tmp___0 + (int )*(*(aseq + idx) + pos)) & 1024) {
#line 477
        tmp = toupper((int )*(*(aseq + idx) + pos));
#line 477
        (rescount[tmp - 65]) ++;
      }
#line 475
      idx ++;
    }
#line 479
    nres = 0;
#line 480
    x = 0;
#line 480
    while (x < 26) {
#line 481
      if (rescount[x] > 0) {
#line 481
        nres ++;
      }
#line 480
      x ++;
    }
#line 483
    idx = 0;
#line 483
    while (idx < nseq) {
#line 484
      tmp___2 = __ctype_b_loc();
#line 484
      if ((int const   )*(*tmp___2 + (int )*(*(aseq + idx) + pos)) & 1024) {
#line 485
        tmp___1 = toupper((int )*(*(aseq + idx) + pos));
#line 485
        *(wgt + idx) = (float )((double )*(wgt + idx) + 1. / (double )((float )(nres * rescount[tmp___1 - 65])));
      }
#line 483
      idx ++;
    }
#line 472
    pos ++;
  }
#line 488
  idx = 0;
#line 488
  while (idx < nseq) {
#line 489
    tmp___3 = DealignedLength(*(aseq + idx));
#line 489
    *(wgt + idx) /= (float )tmp___3;
#line 488
    idx ++;
  }
#line 490
  tmp___4 = FSum(wgt, nseq);
#line 490
  norm = (float )nseq / tmp___4;
#line 491
  FScale(wgt, nseq, norm);
#line 492
  return;
}
}
#line 520 "weight.c"
void FilterAlignment(MSA *msa , float cutoff , MSA **ret_new ) 
{ 
  int nnew ;
  int *list ;
  int *useme ;
  float ident ;
  int i___0 ;
  int j ;
  int remove___0 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 532
  tmp = sre_malloc((char *)"weight.c", 532, sizeof(int ) * (unsigned long )msa->nseq);
#line 532
  list = (int *)tmp;
#line 533
  tmp___0 = sre_malloc((char *)"weight.c", 533, sizeof(int ) * (unsigned long )msa->nseq);
#line 533
  useme = (int *)tmp___0;
#line 534
  i___0 = 0;
#line 534
  while (i___0 < msa->nseq) {
#line 534
    *(useme + i___0) = 0;
#line 534
    i___0 ++;
  }
#line 536
  nnew = 0;
#line 537
  i___0 = 0;
#line 537
  while (i___0 < msa->nseq) {
#line 539
    remove___0 = 0;
#line 540
    j = 0;
#line 540
    while (j < nnew) {
#line 542
      ident = PairwiseIdentity(*(msa->aseq + i___0), *(msa->aseq + *(list + j)));
#line 543
      if (ident > cutoff) {
#line 545
        remove___0 = 1;
#line 546
        printf((char const   * __restrict  )"removing %12s -- fractional identity %.2f to %s\n",
               *(msa->sqname + i___0), (double )ident, *(msa->sqname + *(list + j)));
#line 549
        break;
      }
#line 540
      j ++;
    }
#line 552
    if (remove___0 == 0) {
#line 553
      tmp___1 = nnew;
#line 553
      nnew ++;
#line 553
      *(list + tmp___1) = i___0;
#line 554
      *(useme + i___0) = 1;
    }
#line 537
    i___0 ++;
  }
#line 558
  MSASmallerAlignment(msa, useme, ret_new);
#line 559
  free((void *)list);
#line 560
  free((void *)useme);
#line 561
  return;
}
}
#line 586 "weight.c"
void SampleAlignment(MSA *msa , int sample , MSA **ret_new ) 
{ 
  int *list ;
  int *useme ;
  int i___0 ;
  int idx ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 596
  tmp = sre_malloc((char *)"weight.c", 596, sizeof(int ) * (unsigned long )msa->nseq);
#line 596
  list = (int *)tmp;
#line 597
  tmp___0 = sre_malloc((char *)"weight.c", 597, sizeof(int ) * (unsigned long )msa->nseq);
#line 597
  useme = (int *)tmp___0;
#line 598
  i___0 = 0;
#line 598
  while (i___0 < msa->nseq) {
#line 600
    *(list + i___0) = i___0;
#line 601
    *(useme + i___0) = 0;
#line 598
    i___0 ++;
  }
#line 606
  if (sample >= msa->nseq) {
#line 606
    sample = msa->nseq;
  }
#line 609
  len = msa->nseq;
#line 609
  i___0 = 0;
#line 609
  while (i___0 < sample) {
#line 611
    tmp___1 = sre_random();
#line 611
    idx = (int )(tmp___1 * (double )len);
#line 612
    printf((char const   * __restrict  )"chose %d: %s\n", *(list + idx), *(msa->sqname + *(list + idx)));
#line 613
    *(useme + *(list + idx)) = 1;
#line 614
    len --;
#line 614
    *(list + idx) = *(list + len);
#line 609
    i___0 ++;
  }
#line 617
  MSASmallerAlignment(msa, useme, ret_new);
#line 618
  free((void *)list);
#line 619
  free((void *)useme);
#line 620
  return;
}
}
#line 703 "weight.c"
void SingleLinkCluster(char **aseq , int nseq , int alen , float maxid , int **ret_c ,
                       int *ret_nc ) 
{ 
  int *a___0 ;
  int na ;
  int *b ;
  int nb ;
  int *c ;
  int nc ;
  int v ;
  int w___0 ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  float tmp___2 ;

  {
#line 716
  tmp = sre_malloc((char *)"weight.c", 716, sizeof(int ) * (unsigned long )nseq);
#line 716
  a___0 = (int *)tmp;
#line 717
  tmp___0 = sre_malloc((char *)"weight.c", 717, sizeof(int ) * (unsigned long )nseq);
#line 717
  b = (int *)tmp___0;
#line 718
  tmp___1 = sre_malloc((char *)"weight.c", 718, sizeof(int ) * (unsigned long )nseq);
#line 718
  c = (int *)tmp___1;
#line 719
  i___0 = 0;
#line 719
  while (i___0 < nseq) {
#line 719
    *(a___0 + i___0) = i___0;
#line 719
    i___0 ++;
  }
#line 720
  na = nseq;
#line 721
  nb = 0;
#line 722
  nc = 0;
#line 726
  while (na > 0) {
#line 728
    v = *(a___0 + (na - 1));
#line 728
    na --;
#line 729
    *(b + nb) = v;
#line 729
    nb ++;
#line 730
    while (nb > 0) {
#line 732
      v = *(b + (nb - 1));
#line 732
      nb --;
#line 733
      *(c + v) = nc;
#line 734
      i___0 = na - 1;
#line 734
      while (i___0 >= 0) {
#line 735
        tmp___2 = simple_distance(*(aseq + v), *(aseq + *(a___0 + i___0)));
#line 735
        if ((double )tmp___2 <= 1. - (double )maxid) {
#line 737
          w___0 = *(a___0 + i___0);
#line 737
          *(a___0 + i___0) = *(a___0 + (na - 1));
#line 737
          na --;
#line 738
          *(b + nb) = w___0;
#line 738
          nb ++;
        }
#line 734
        i___0 --;
      }
    }
#line 741
    nc ++;
  }
#line 746
  free((void *)a___0);
#line 747
  free((void *)b);
#line 748
  *ret_c = c;
#line 749
  *ret_nc = nc;
#line 750
  return;
}
}

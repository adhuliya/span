/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 46 "/home/codeman/.itsoflife/mydata/local/packages-live/llvm-clang9.0.0/build/lib/clang/9.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 68 "./defines.h"
typedef long flow_t;
#line 69 "./defines.h"
typedef long cost_t;
#line 99
struct node;
#line 100 "./defines.h"
typedef struct node *node_p;
#line 102
struct arc;
#line 103 "./defines.h"
typedef struct arc *arc_p;
#line 107 "./defines.h"
struct node {
   cost_t potential ;
   int orientation ;
   node_p child ;
   node_p pred ;
   node_p sibling ;
   node_p sibling_prev ;
   arc_p basic_arc ;
   arc_p firstout ;
   arc_p firstin ;
   arc_p arc_tmp ;
   flow_t flow ;
   long depth ;
   int number ;
   int time ;
};
#line 126 "./defines.h"
struct arc {
   cost_t cost ;
   node_p tail ;
   node_p head ;
   int ident ;
   arc_p nextout ;
   arc_p nextin ;
   flow_t flow ;
   cost_t org_cost ;
};
#line 138 "./defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long max_residual_new_m ;
   long max_new_m ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_p nodes ;
   node_p stop_nodes ;
   arc_p arcs ;
   arc_p stop_arcs ;
   arc_p dummy_arcs ;
   arc_p stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 138 "./defines.h"
typedef struct network network_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 99 "./defines.h"
typedef struct node node_t;
#line 102 "./defines.h"
typedef struct arc arc_t;
#line 51 "pbeampp.c"
struct basket {
   arc_t *a ;
   cost_t cost ;
   cost_t abs_cost ;
};
#line 51 "pbeampp.c"
typedef struct basket BASKET;
#line 1 "mcf.o"
#pragma merger("0","/tmp/cil-DCdZYd4U.i","")
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 32 "./mcfutil.h"
double flow_cost(network_t *net___0 ) ;
#line 36
long getfree(network_t *net___0 ) ;
#line 32 "./readmin.h"
long read_min(network_t *net___0 ) ;
#line 30 "./output.h"
long write_circulations(char *outfile , network_t *net___0 ) ;
#line 30 "./pstart.h"
long primal_start_artificial(network_t *net___0 ) ;
#line 35 "./psimplex.h"
long primal_net_simplex(network_t *net___0 ) ;
#line 30 "./implicit.h"
long price_out_impl(network_t *net___0 ) ;
#line 31
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) ;
#line 28 "mcf.c"
network_t net  ;
#line 35 "mcf.c"
long global_opt(void) 
{ 
  long new_arcs ;
  long residual_nb_it ;
  double tmp ;

  {
#line 44
  new_arcs = -1L;
#line 45
  if (net.n_trips <= 15000L) {
#line 45
    residual_nb_it = 5L;
  } else {
#line 45
    residual_nb_it = 5L;
  }
#line 48
  while (new_arcs) {
#line 51
    printf((char const   * __restrict  )"active arcs                : %ld\n", net.m);
#line 54
    primal_net_simplex(& net);
#line 58
    printf((char const   * __restrict  )"simplex iterations         : %ld\n", net.iterations);
#line 59
    tmp = flow_cost(& net);
#line 59
    printf((char const   * __restrict  )"objective value            : %0.0f\n", tmp);
#line 67
    if (! residual_nb_it) {
#line 68
      break;
    }
#line 71
    if (net.m_impl) {
#line 73
      new_arcs = suspend_impl(& net, (cost_t )-1, 0L);
#line 76
      if (new_arcs) {
#line 77
        printf((char const   * __restrict  )"erased arcs                : %ld\n",
               new_arcs);
      }
    }
#line 82
    new_arcs = price_out_impl(& net);
#line 85
    if (new_arcs) {
#line 86
      printf((char const   * __restrict  )"new implicit arcs          : %ld\n", new_arcs);
    }
#line 89
    if (new_arcs < 0L) {
#line 92
      printf((char const   * __restrict  )"not enough memory, exit(-1)\n");
#line 95
      exit(-1);
    }
#line 103
    residual_nb_it --;
  }
#line 106
  printf((char const   * __restrict  )"checksum                   : %ld\n", net.checksum);
#line 108
  return (0L);
}
}
#line 117 "mcf.c"
int main(int argc , char **argv ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 124
  if (argc < 2) {
#line 125
    return (-1);
  }
#line 128
  printf((char const   * __restrict  )"\nMCF SPEC CPU2006 version 1.10\n");
#line 129
  printf((char const   * __restrict  )"Copyright (c) 1998-2000 Zuse Institut Berlin (ZIB)\n");
#line 130
  printf((char const   * __restrict  )"Copyright (c) 2000-2002 Andreas Loebel & ZIB\n");
#line 131
  printf((char const   * __restrict  )"Copyright (c) 2003-2005 Andreas Loebel\n");
#line 132
  printf((char const   * __restrict  )"\n");
#line 136
  memset((void *)(& net), 0, sizeof(network_t ));
#line 137
  net.bigM = (long )1.0e7;
#line 139
  strcpy((char * __restrict  )(net.inputfile), (char const   * __restrict  )*(argv + 1));
#line 141
  tmp = read_min(& net);
#line 141
  if (tmp) {
#line 143
    printf((char const   * __restrict  )"read error, exit\n");
#line 144
    getfree(& net);
#line 145
    return (-1);
  }
#line 150
  printf((char const   * __restrict  )"nodes                      : %ld\n", net.n_trips);
#line 154
  primal_start_artificial(& net);
#line 155
  global_opt();
#line 159
  printf((char const   * __restrict  )"done\n");
#line 164
  tmp___0 = write_circulations((char *)"mcf.out", & net);
#line 164
  if (tmp___0) {
#line 166
    getfree(& net);
#line 167
    return (-1);
  }
#line 171
  getfree(& net);
#line 172
  return (0);
}
}
#line 1 "mcfutil.o"
#pragma merger("0","/tmp/cil-CO_zC0fZ.i","")
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 30 "./mcfutil.h"
void refresh_neighbour_lists(network_t *net___0 ) ;
#line 31
long refresh_potential(network_t *net___0 ) ;
#line 33
double flow_org_cost(network_t *net___0 ) ;
#line 34
long primal_feasible(network_t *net___0 ) ;
#line 35
long dual_feasible(network_t *net___0 ) ;
#line 28 "mcfutil.c"
void refresh_neighbour_lists(network_t *net___0 ) 
{ 
  node_t *node ;
  arc_t *arc ;
  void *stop ;

  {
#line 39
  node = net___0->nodes;
#line 40
  stop = (void *)net___0->stop_nodes;
#line 40
  while ((unsigned long )node < (unsigned long )((node_t *)stop)) {
#line 42
    node->firstin = (arc_t *)((void *)0);
#line 43
    node->firstout = (arc_t *)((void *)0);
#line 40
    node ++;
  }
#line 46
  arc = net___0->arcs;
#line 47
  stop = (void *)net___0->stop_arcs;
#line 47
  while ((unsigned long )arc < (unsigned long )((arc_t *)stop)) {
#line 49
    arc->nextout = (arc->tail)->firstout;
#line 50
    (arc->tail)->firstout = arc;
#line 51
    arc->nextin = (arc->head)->firstin;
#line 52
    (arc->head)->firstin = arc;
#line 47
    arc ++;
  }
#line 55
  return;
}
}
#line 68 "mcfutil.c"
long refresh_potential(network_t *net___0 ) 
{ 
  node_t *node ;
  node_t *tmp ;
  node_t *root ;
  long checksum ;

  {
#line 75
  root = net___0->nodes;
#line 76
  checksum = 0L;
#line 79
  root->potential = -100000000L;
#line 80
  node = root->child;
#line 80
  tmp = node;
#line 81
  while ((unsigned long )node != (unsigned long )root) {
#line 83
    while (node) {
#line 85
      if (node->orientation == 1) {
#line 86
        node->potential = (node->basic_arc)->cost + (node->pred)->potential;
      } else {
#line 89
        node->potential = (node->pred)->potential - (node->basic_arc)->cost;
#line 90
        checksum ++;
      }
#line 93
      tmp = node;
#line 94
      node = node->child;
    }
#line 97
    node = tmp;
#line 99
    while (node->pred) {
#line 101
      tmp = node->sibling;
#line 102
      if (tmp) {
#line 104
        node = tmp;
#line 105
        break;
      } else {
#line 108
        node = node->pred;
      }
    }
  }
#line 112
  return (checksum);
}
}
#line 122 "mcfutil.c"
double flow_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 132
  fleet = 0L;
#line 133
  operational_cost = (cost_t )0;
#line 136
  stop = (void *)net___0->stop_arcs;
#line 137
  arc = net___0->arcs;
#line 137
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 139
    if (arc->ident == 2) {
#line 140
      arc->flow = (flow_t )1;
    } else {
#line 142
      arc->flow = (flow_t )0;
    }
#line 137
    arc ++;
  }
#line 145
  stop = (void *)net___0->stop_nodes;
#line 146
  node = net___0->nodes;
#line 146
  node ++;
#line 146
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
#line 147
    (node->basic_arc)->flow = node->flow;
#line 146
    node ++;
  }
#line 149
  stop = (void *)net___0->stop_arcs;
#line 150
  arc = net___0->arcs;
#line 150
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 152
    if (arc->flow) {
#line 154
      if ((arc->tail)->number < 0) {
#line 154
        if (! ((arc->head)->number > 0)) {
#line 154
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 156
      if (! (arc->tail)->number) {
#line 158
        operational_cost += arc->cost - net___0->bigM;
#line 159
        fleet ++;
      } else {
#line 162
        operational_cost += arc->cost;
      }
    }
#line 150
    arc ++;
  }
#line 168
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
#line 181 "mcfutil.c"
double flow_org_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 191
  fleet = 0L;
#line 192
  operational_cost = (cost_t )0;
#line 195
  stop = (void *)net___0->stop_arcs;
#line 196
  arc = net___0->arcs;
#line 196
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 198
    if (arc->ident == 2) {
#line 199
      arc->flow = (flow_t )1;
    } else {
#line 201
      arc->flow = (flow_t )0;
    }
#line 196
    arc ++;
  }
#line 204
  stop = (void *)net___0->stop_nodes;
#line 205
  node = net___0->nodes;
#line 205
  node ++;
#line 205
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
#line 206
    (node->basic_arc)->flow = node->flow;
#line 205
    node ++;
  }
#line 208
  stop = (void *)net___0->stop_arcs;
#line 209
  arc = net___0->arcs;
#line 209
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 211
    if (arc->flow) {
#line 213
      if ((arc->tail)->number < 0) {
#line 213
        if (! ((arc->head)->number > 0)) {
#line 213
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 215
      if (! (arc->tail)->number) {
#line 217
        operational_cost += arc->org_cost - net___0->bigM;
#line 218
        fleet ++;
      } else {
#line 221
        operational_cost += arc->org_cost;
      }
    }
#line 209
    arc ++;
  }
#line 226
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
#line 239 "mcfutil.c"
long primal_feasible(network_t *net___0 ) 
{ 
  void *stop ;
  node_t *node ;
  arc_t *dummy ;
  arc_t *stop_dummy ;
  arc_t *arc ;
  flow_t flow ;
  flow_t tmp ;

  {
#line 247
  dummy = net___0->dummy_arcs;
#line 248
  stop_dummy = net___0->stop_dummy;
#line 253
  node = net___0->nodes;
#line 254
  stop = (void *)net___0->stop_nodes;
#line 256
  node ++;
#line 256
  while ((unsigned long )node < (unsigned long )((node_t *)stop)) {
#line 258
    arc = node->basic_arc;
#line 259
    flow = node->flow;
#line 260
    if ((unsigned long )arc >= (unsigned long )dummy) {
#line 260
      if ((unsigned long )arc < (unsigned long )stop_dummy) {
#line 262
        if (flow >= 0L) {
#line 262
          tmp = flow;
        } else {
#line 262
          tmp = - flow;
        }
#line 262
        if (tmp > net___0->feas_tol) {
#line 264
          printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 265
          printf((char const   * __restrict  )"artificial arc with nonzero flow, node %d (%ld)\n",
                 node->number, flow);
        }
      } else {
#line 260
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 271
    if (flow < - net___0->feas_tol) {
#line 274
      printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 275
      printf((char const   * __restrict  )"basis primal infeasible (%ld)\n", flow);
#line 276
      net___0->feasible = 0L;
#line 277
      return (1L);
    } else
#line 271
    if (flow - 1L > net___0->feas_tol) {
#line 274
      printf((char const   * __restrict  )"PRIMAL NETWORK SIMPLEX: ");
#line 275
      printf((char const   * __restrict  )"basis primal infeasible (%ld)\n", flow);
#line 276
      net___0->feasible = 0L;
#line 277
      return (1L);
    }
#line 256
    node ++;
  }
#line 282
  net___0->feasible = 1L;
#line 284
  return (0L);
}
}
#line 297 "mcfutil.c"
long dual_feasible(network_t *net___0 ) 
{ 
  arc_t *arc ;
  arc_t *stop ;
  cost_t red_cost ;

  {
#line 304
  stop = net___0->stop_arcs;
#line 309
  arc = net___0->arcs;
#line 309
  while ((unsigned long )arc < (unsigned long )stop) {
#line 311
    red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 313
    switch (arc->ident) {
    case 1: 
    case 0: 
#line 329
    if (red_cost < - net___0->feas_tol) {
#line 334
      goto DUAL_INFEAS;
    }
#line 337
    break;
    case 2: 
#line 339
    if (red_cost > net___0->feas_tol) {
#line 344
      goto DUAL_INFEAS;
    }
#line 347
    break;
    default: 
#line 350
    break;
    }
#line 309
    arc ++;
  }
#line 354
  return (0L);
  DUAL_INFEAS: 
#line 357
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DUAL NETWORK SIMPLEX: ");
#line 358
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"basis dual infeasible\n");
#line 359
  return (1L);
}
}
#line 369 "mcfutil.c"
long getfree(network_t *net___0 ) 
{ 
  node_p tmp ;
  arc_p tmp___0 ;
  arc_p tmp___1 ;

  {
#line 377
  if (net___0->nodes) {
#line 377
    free((void *)net___0->nodes);
  }
#line 378
  if (net___0->arcs) {
#line 378
    free((void *)net___0->arcs);
  }
#line 379
  if (net___0->dummy_arcs) {
#line 379
    free((void *)net___0->dummy_arcs);
  }
#line 380
  tmp = (node_p )((void *)0);
#line 380
  net___0->stop_nodes = tmp;
#line 380
  net___0->nodes = tmp;
#line 381
  tmp___0 = (arc_p )((void *)0);
#line 381
  net___0->stop_arcs = tmp___0;
#line 381
  net___0->arcs = tmp___0;
#line 382
  tmp___1 = (arc_p )((void *)0);
#line 382
  net___0->stop_dummy = tmp___1;
#line 382
  net___0->dummy_arcs = tmp___1;
#line 384
  return (0L);
}
}
#line 1 "readmin.o"
#pragma merger("0","/tmp/cil-ZbwAJrS9.i","")
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 385
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 29 "readmin.c"
long read_min(network_t *net___0 ) 
{ 
  FILE *in ;
  char instring[201] ;
  long t ;
  long h ;
  long c ;
  long i ;
  arc_t *arc ;
  node_t *node ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  cost_t tmp___4 ;
  cost_t tmp___5 ;
  cost_t tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 35
  in = (FILE *)((void *)0);
#line 43
  in = fopen((char const   * __restrict  )(net___0->inputfile), (char const   * __restrict  )"r");
#line 43
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 44
    return (-1L);
  }
#line 46
  fgets((char * __restrict  )(instring), 200, (FILE * __restrict  )in);
#line 47
  tmp = sscanf((char const   * __restrict  )(instring), (char const   * __restrict  )"%ld %ld",
               & t, & h);
#line 47
  if (tmp != 2) {
#line 48
    return (-1L);
  }
#line 51
  net___0->n_trips = t;
#line 52
  net___0->m_org = h;
#line 53
  net___0->n = (t + t) + 1L;
#line 54
  net___0->m = ((t + t) + t) + h;
#line 56
  if (net___0->n_trips <= 15000L) {
#line 58
    net___0->max_m = net___0->m;
#line 59
    net___0->max_new_m = 3000000L;
  } else {
#line 67
    net___0->max_m = 27328512L;
#line 71
    net___0->max_new_m = 28900000L;
  }
#line 74
  net___0->max_residual_new_m = net___0->max_m - net___0->m;
#line 80
//AD  tmp___0 = calloc((size_t )(net___0->n + 1L), sizeof(node_t ));
#line 80
//AD  net___0->nodes = (node_t *)tmp___0;
      net___0->nodes = (node_t *)calloc((size_t )(net___0->n + 1L), sizeof(node_t )); //AD
#line 81
//AD  tmp___1 = calloc((size_t )net___0->n, sizeof(arc_t ));
#line 81
//AD  net___0->dummy_arcs = (arc_t *)tmp___1;
      net___0->dummy_arcs = (arc_t *)calloc((size_t )net___0->n, sizeof(arc_t )); //AD
#line 82
//AD  tmp___2 = calloc((size_t )net___0->max_m, sizeof(arc_t ));
#line 82
//AD  net___0->arcs = (arc_t *)tmp___2;
      net___0->arcs = (arc_t *)calloc((size_t )net___0->max_m, sizeof(arc_t )); //AD
#line 84
  if (net___0->nodes) {
#line 84
    if (net___0->arcs) {
#line 84
      if (! net___0->dummy_arcs) {
#line 86
        printf((char const   * __restrict  )"read_min(): not enough memory\n");
#line 87
        getfree(net___0);
#line 88
        return (-1L);
      }
    } else {
#line 86
      printf((char const   * __restrict  )"read_min(): not enough memory\n");
#line 87
      getfree(net___0);
#line 88
      return (-1L);
    }
  } else {
#line 86
    printf((char const   * __restrict  )"read_min(): not enough memory\n");
#line 87
    getfree(net___0);
#line 88
    return (-1L);
  }
#line 108
  net___0->stop_nodes = (net___0->nodes + net___0->n) + 1;
#line 109
  net___0->stop_arcs = net___0->arcs + net___0->m;
#line 110
  net___0->stop_dummy = net___0->dummy_arcs + net___0->n;
#line 113
  node = net___0->nodes;
#line 114
  arc = net___0->arcs;
#line 116
  i = 1L;
#line 116
  while (i <= net___0->n_trips) {
#line 118
    fgets((char * __restrict  )(instring), 200, (FILE * __restrict  )in);
#line 120
    tmp___3 = sscanf((char const   * __restrict  )(instring), (char const   * __restrict  )"%ld %ld",
                     & t, & h);
#line 120
    if (tmp___3 != 2) {
#line 121
      return (-1L);
    } else
#line 120
    if (t > h) {
#line 121
      return (-1L);
    }
#line 123
    (node + i)->number = (int )(- i);
#line 124
    (node + i)->flow = (flow_t )-1;
#line 126
    (node + (i + net___0->n_trips))->number = (int )i;
#line 127
    (node + (i + net___0->n_trips))->flow = (flow_t )1;
#line 129
    (node + i)->time = (int )t;
#line 130
    (node + (i + net___0->n_trips))->time = (int )h;
#line 132
    arc->tail = node + net___0->n;
#line 133
    arc->head = node + i;
#line 134
    tmp___4 = net___0->bigM + 15L;
#line 134
    arc->cost = tmp___4;
#line 134
    arc->org_cost = tmp___4;
#line 135
    arc->nextout = (arc->tail)->firstout;
#line 136
    (arc->tail)->firstout = arc;
#line 137
    arc->nextin = (arc->head)->firstin;
#line 138
    (arc->head)->firstin = arc;
#line 139
    arc ++;
#line 141
    arc->tail = node + (i + net___0->n_trips);
#line 142
    arc->head = node + net___0->n;
#line 143
    tmp___5 = (cost_t )15;
#line 143
    arc->cost = tmp___5;
#line 143
    arc->org_cost = tmp___5;
#line 144
    arc->nextout = (arc->tail)->firstout;
#line 145
    (arc->tail)->firstout = arc;
#line 146
    arc->nextin = (arc->head)->firstin;
#line 147
    (arc->head)->firstin = arc;
#line 148
    arc ++;
#line 150
    arc->tail = node + i;
#line 151
    arc->head = node + (i + net___0->n_trips);
#line 152
    if (net___0->bigM > (long )1.0e7) {
#line 152
      tmp___7 = net___0->bigM;
    } else {
#line 152
      tmp___7 = (long )1.0e7;
    }
#line 152
    tmp___6 = 2L * tmp___7;
#line 152
    arc->cost = tmp___6;
#line 152
    arc->org_cost = tmp___6;
#line 153
    arc->nextout = (arc->tail)->firstout;
#line 154
    (arc->tail)->firstout = arc;
#line 155
    arc->nextin = (arc->head)->firstin;
#line 156
    (arc->head)->firstin = arc;
#line 157
    arc ++;
#line 116
    i ++;
  }
#line 161
  if (i != net___0->n_trips + 1L) {
#line 162
    return (-1L);
  }
#line 165
  i = 0L;
#line 165
  while (i < net___0->m_org) {
#line 167
    fgets((char * __restrict  )(instring), 200, (FILE * __restrict  )in);
#line 169
    tmp___8 = sscanf((char const   * __restrict  )(instring), (char const   * __restrict  )"%ld %ld %ld",
                     & t, & h, & c);
#line 169
    if (tmp___8 != 3) {
#line 170
      return (-1L);
    }
#line 172
    arc->tail = node + (t + net___0->n_trips);
#line 173
    arc->head = node + h;
#line 174
    arc->org_cost = c;
#line 175
    arc->cost = c;
#line 176
    arc->nextout = (arc->tail)->firstout;
#line 177
    (arc->tail)->firstout = arc;
#line 178
    arc->nextin = (arc->head)->firstin;
#line 179
    (arc->head)->firstin = arc;
#line 165
    i ++;
#line 165
    arc ++;
  }
#line 183
  if ((unsigned long )net___0->stop_arcs != (unsigned long )arc) {
#line 185
    net___0->stop_arcs = arc;
#line 186
    arc = net___0->arcs;
#line 187
    net___0->m = 0L;
#line 187
    while ((unsigned long )arc < (unsigned long )net___0->stop_arcs) {
#line 188
      (net___0->m) ++;
#line 187
      arc ++;
    }
#line 189
    net___0->m_org = net___0->m;
  }
#line 192
  fclose(in);
#line 195
  net___0->clustfile[0] = (char)0;
#line 197
  i = 1L;
#line 197
  while (i <= net___0->n_trips) {
#line 199
    if (net___0->bigM > (long )1.0e7) {
#line 199
      tmp___9 = net___0->bigM;
    } else {
#line 199
      tmp___9 = (long )1.0e7;
    }
#line 199
    (net___0->arcs + (3L * i - 1L))->cost = -2L * tmp___9;
#line 201
    if (net___0->bigM > (long )1.0e7) {
#line 201
      tmp___10 = net___0->bigM;
    } else {
#line 201
      tmp___10 = (long )1.0e7;
    }
#line 201
    (net___0->arcs + (3L * i - 1L))->org_cost = -2L * tmp___10;
#line 197
    i ++;
  }
#line 206
  return (0L);
}
}
#line 1 "implicit.o"
#pragma merger("0","/tmp/cil-Wh175cng.i","")
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 28 "implicit.c"
long resize_prob(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  node_t *stop ;
  node_t *root ;
  size_t off ;
  void *tmp ;

  {
#line 42
  net___0->max_m += net___0->max_new_m;
#line 43
  net___0->max_residual_new_m += net___0->max_new_m;
#line 55
  tmp = realloc((void *)net___0->arcs, (unsigned long )net___0->max_m * sizeof(arc_t ));
#line 55
  arc = (arc_t *)tmp;
#line 56
  if (! arc) {
#line 58
    printf((char const   * __restrict  )"network %s: not enough memory\n", net___0->inputfile);
#line 59
    fflush(stdout);
#line 60
    return (-1L);
  }
#line 63
  off = (size_t )arc - (size_t )net___0->arcs;
#line 65
  net___0->arcs = arc;
#line 66
  net___0->stop_arcs = arc + net___0->m;
#line 68
  node = net___0->nodes;
#line 68
  root = node;
#line 69
  node ++;
#line 69
  stop = (node_t *)((void *)net___0->stop_nodes);
#line 69
  while ((unsigned long )node < (unsigned long )stop) {
#line 70
    if ((unsigned long )node->pred != (unsigned long )root) {
#line 71
      node->basic_arc = (arc_t *)((size_t )node->basic_arc + off);
    }
#line 69
    node ++;
  }
#line 73
  return (0L);
}
}
#line 83 "implicit.c"
void insert_new_arc(arc_t *new , long newpos , node_t *tail , node_t *head , cost_t cost ,
                    cost_t red_cost ) 
{ 
  long pos ;

  {
#line 97
  (new + newpos)->tail = tail;
#line 98
  (new + newpos)->head = head;
#line 99
  (new + newpos)->org_cost = cost;
#line 100
  (new + newpos)->cost = cost;
#line 101
  (new + newpos)->flow = red_cost;
#line 103
  pos = newpos + 1L;
#line 104
  while (1) {
#line 104
    if (pos - 1L) {
#line 104
      if (! (red_cost > (new + (pos / 2L - 1L))->flow)) {
#line 104
        break;
      }
    } else {
#line 104
      break;
    }
#line 106
    (new + (pos - 1L))->tail = (new + (pos / 2L - 1L))->tail;
#line 107
    (new + (pos - 1L))->head = (new + (pos / 2L - 1L))->head;
#line 108
    (new + (pos - 1L))->cost = (new + (pos / 2L - 1L))->cost;
#line 109
    (new + (pos - 1L))->org_cost = (new + (pos / 2L - 1L))->cost;
#line 110
    (new + (pos - 1L))->flow = (new + (pos / 2L - 1L))->flow;
#line 112
    pos /= 2L;
#line 113
    (new + (pos - 1L))->tail = tail;
#line 114
    (new + (pos - 1L))->head = head;
#line 115
    (new + (pos - 1L))->cost = cost;
#line 116
    (new + (pos - 1L))->org_cost = cost;
#line 117
    (new + (pos - 1L))->flow = red_cost;
  }
#line 120
  return;
}
}
#line 129 "implicit.c"
void replace_weaker_arc(network_t *net___0 , arc_t *new , node_t *tail , node_t *head ,
                        cost_t cost , cost_t red_cost ) 
{ 
  long pos ;
  long cmp ;

  {
#line 144
  (new + 0)->tail = tail;
#line 145
  (new + 0)->head = head;
#line 146
  (new + 0)->org_cost = cost;
#line 147
  (new + 0)->cost = cost;
#line 148
  (new + 0)->flow = red_cost;
#line 150
  pos = 1L;
#line 151
  if ((new + 1)->flow > (new + 2)->flow) {
#line 151
    cmp = 2L;
  } else {
#line 151
    cmp = 3L;
  }
#line 152
  while (1) {
#line 152
    if (cmp <= net___0->max_residual_new_m) {
#line 152
      if (! (red_cost < (new + (cmp - 1L))->flow)) {
#line 152
        break;
      }
    } else {
#line 152
      break;
    }
#line 154
    (new + (pos - 1L))->tail = (new + (cmp - 1L))->tail;
#line 155
    (new + (pos - 1L))->head = (new + (cmp - 1L))->head;
#line 156
    (new + (pos - 1L))->cost = (new + (cmp - 1L))->cost;
#line 157
    (new + (pos - 1L))->org_cost = (new + (cmp - 1L))->cost;
#line 158
    (new + (pos - 1L))->flow = (new + (cmp - 1L))->flow;
#line 160
    (new + (cmp - 1L))->tail = tail;
#line 161
    (new + (cmp - 1L))->head = head;
#line 162
    (new + (cmp - 1L))->cost = cost;
#line 163
    (new + (cmp - 1L))->org_cost = cost;
#line 164
    (new + (cmp - 1L))->flow = red_cost;
#line 165
    pos = cmp;
#line 166
    cmp *= 2L;
#line 167
    if (cmp + 1L <= net___0->max_residual_new_m) {
#line 168
      if ((new + (cmp - 1L))->flow < (new + cmp)->flow) {
#line 169
        cmp ++;
      }
    }
  }
#line 172
  return;
}
}
#line 194 "implicit.c"
long price_out_impl(network_t *net___0 ) 
{ 
  long i ;
  long trips ;
  long new_arcs ;
  long resized ;
  long latest ;
  long min_impl_duration ;
  register cost_t bigM ;
  register cost_t head_potential ;
  register cost_t arc_cost ;
  register cost_t red_cost ;
  register cost_t bigM_minus_min_impl_duration ;
  register arc_t *arcout ;
  register arc_t *arcin ;
  register arc_t *arcnew ;
  register arc_t *stop ;
  register arc_t *first_of_sparse_list ;
  register node_t *tail ;
  register node_t *head ;
  long tmp ;

  {
#line 202
  new_arcs = 0L;
#line 203
  resized = 0L;
#line 205
  min_impl_duration = 15L;
#line 207
  bigM = net___0->bigM;
#line 209
  arc_cost = (cost_t )30;
#line 223
  bigM_minus_min_impl_duration = bigM - min_impl_duration;
#line 227
  if (net___0->n_trips <= 15000L) {
#line 229
    if (net___0->m + net___0->max_new_m > net___0->max_m) {
#line 229
      if ((net___0->n_trips * net___0->n_trips) / 2L + net___0->m > net___0->max_m) {
#line 234
        resized = 1L;
#line 235
        tmp = resize_prob(net___0);
#line 235
        if (tmp) {
#line 236
          return (-1L);
        }
#line 238
        refresh_neighbour_lists(net___0);
      }
    }
  }
#line 259
  arcnew = net___0->stop_arcs;
#line 260
  trips = net___0->n_trips;
#line 262
  arcout = net___0->arcs;
#line 263
  i = 0L;
#line 263
  while (1) {
#line 263
    if (i < trips) {
#line 263
      if (! ((arcout + 1)->ident == -1)) {
#line 263
        break;
      }
    } else {
#line 263
      break;
    }
#line 263
    i ++;
#line 263
    arcout += 3;
  }
#line 264
  first_of_sparse_list = (arc_t *)((void *)0);
#line 265
  while (i < trips) {
#line 267
    if ((arcout + 1)->ident != -1) {
#line 269
      (((arcout->head)->firstout)->head)->arc_tmp = first_of_sparse_list;
#line 270
      first_of_sparse_list = arcout + 1;
    }
#line 273
    if (arcout->ident == -1) {
#line 274
      goto __Cont;
    }
#line 276
    head = arcout->head;
#line 277
    latest = ((cost_t )head->time - arcout->org_cost) + bigM_minus_min_impl_duration;
#line 280
    head_potential = head->potential;
#line 282
    arcin = (first_of_sparse_list->tail)->arc_tmp;
#line 283
    while (arcin) {
#line 285
      tail = arcin->tail;
#line 287
      if ((cost_t )tail->time + arcin->org_cost > latest) {
#line 289
        arcin = tail->arc_tmp;
#line 290
        continue;
      }
#line 293
      red_cost = (arc_cost - tail->potential) + head->potential;
#line 295
      if (red_cost < 0L) {
#line 297
        if (new_arcs < net___0->max_residual_new_m) {
#line 299
          insert_new_arc(arcnew, new_arcs, tail, head, arc_cost, red_cost);
#line 301
          new_arcs ++;
        } else
#line 303
        if ((arcnew + 0)->flow > red_cost) {
#line 304
          replace_weaker_arc(net___0, arcnew, tail, head, arc_cost, red_cost);
        }
      }
#line 308
      arcin = tail->arc_tmp;
    }
    __Cont: /* CIL Label */ 
#line 265
    i ++;
#line 265
    arcout += 3;
  }
#line 312
  if (new_arcs) {
#line 314
    arcnew = net___0->stop_arcs;
#line 315
    net___0->stop_arcs += new_arcs;
#line 316
    stop = (arc_t *)((void *)net___0->stop_arcs);
#line 317
    if (resized) {
#line 319
      while ((unsigned long )arcnew != (unsigned long )stop) {
#line 321
        arcnew->flow = (flow_t )0;
#line 322
        arcnew->ident = 1;
#line 319
        arcnew ++;
      }
    } else {
#line 327
      while ((unsigned long )arcnew != (unsigned long )stop) {
#line 329
        arcnew->flow = (flow_t )0;
#line 330
        arcnew->ident = 1;
#line 331
        arcnew->nextout = (arcnew->tail)->firstout;
#line 332
        (arcnew->tail)->firstout = arcnew;
#line 333
        arcnew->nextin = (arcnew->head)->firstin;
#line 334
        (arcnew->head)->firstin = arcnew;
#line 327
        arcnew ++;
      }
    }
#line 338
    net___0->m += new_arcs;
#line 339
    net___0->m_impl += new_arcs;
#line 340
    net___0->max_residual_new_m -= new_arcs;
  }
#line 350
  return (new_arcs);
}
}
#line 359 "implicit.c"
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) 
{ 
  long susp ;
  cost_t red_cost ;
  arc_t *new_arc ;
  arc_t *arc ;
  void *stop ;

  {
#line 375
  if (all) {
#line 376
    susp = net___0->m_impl;
  } else {
#line 379
    stop = (void *)net___0->stop_arcs;
#line 380
    new_arc = net___0->arcs + (net___0->m - net___0->m_impl);
#line 381
    susp = 0L;
#line 381
    arc = new_arc;
#line 381
    while ((unsigned long )arc < (unsigned long )((arc_t *)stop)) {
#line 383
      if (arc->ident == 1) {
#line 384
        red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
      } else {
#line 388
        red_cost = (cost_t )-2;
#line 390
        if (arc->ident == 0) {
#line 392
          if ((unsigned long )(arc->tail)->basic_arc == (unsigned long )arc) {
#line 393
            (arc->tail)->basic_arc = new_arc;
          } else {
#line 395
            (arc->head)->basic_arc = new_arc;
          }
        }
      }
#line 399
      if (red_cost > threshold) {
#line 400
        susp ++;
      } else {
#line 403
        *new_arc = *arc;
#line 404
        new_arc ++;
      }
#line 381
      arc ++;
    }
  }
#line 415
  if (susp) {
#line 417
    net___0->m -= susp;
#line 418
    net___0->m_impl -= susp;
#line 419
    net___0->stop_arcs -= susp;
#line 420
    net___0->max_residual_new_m += susp;
#line 422
    refresh_neighbour_lists(net___0);
  }
#line 425
  return (susp);
}
}
#line 1 "pstart.o"
#pragma merger("0","/tmp/cil-fv74erp7.i","")
#line 29 "pstart.c"
long primal_start_artificial(network_t *net___0 ) 
{ 
  node_t *node ;
  node_t *root ;
  arc_t *arc ;
  void *stop ;

  {
#line 40
  node = net___0->nodes;
#line 40
  root = node;
#line 40
  node ++;
#line 41
  root->basic_arc = (arc_p )((void *)0);
#line 42
  root->pred = (node_p )((void *)0);
#line 43
  root->child = node;
#line 44
  root->sibling = (node_p )((void *)0);
#line 45
  root->sibling_prev = (node_p )((void *)0);
#line 46
  root->depth = net___0->n + 1L;
#line 47
  root->orientation = 0;
#line 48
  root->potential = -100000000L;
#line 49
  root->flow = (flow_t )0;
#line 51
  stop = (void *)net___0->stop_arcs;
#line 52
  arc = net___0->arcs;
#line 52
  while ((unsigned long )arc != (unsigned long )((arc_t *)stop)) {
#line 53
    if (arc->ident != -1) {
#line 54
      arc->ident = 1;
    }
#line 52
    arc ++;
  }
#line 56
  arc = net___0->dummy_arcs;
#line 57
  stop = (void *)net___0->stop_nodes;
#line 57
  while ((unsigned long )node != (unsigned long )((node_t *)stop)) {
#line 59
    node->basic_arc = arc;
#line 60
    node->pred = root;
#line 61
    node->child = (node_p )((void *)0);
#line 62
    node->sibling = node + 1;
#line 63
    node->sibling_prev = node - 1;
#line 64
    node->depth = 1L;
#line 66
    arc->cost = 100000000L;
#line 67
    arc->ident = 0;
#line 69
    node->orientation = 1;
#line 70
    node->potential = (cost_t )0;
#line 71
    arc->tail = node;
#line 72
    arc->head = root;
#line 73
    node->flow = (flow_t )0;
#line 57
    arc ++;
#line 57
    node ++;
  }
#line 76
  node --;
#line 76
  root ++;
#line 77
  node->sibling = (node_p )((void *)0);
#line 78
  root->sibling_prev = (node_p )((void *)0);
#line 80
  return (0L);
}
}
#line 1 "output.o"
#pragma merger("0","/tmp/cil-rgzV0hm8.i","")
#line 30 "output.c"
long write_circulations(char *outfile , network_t *net___0 ) 
{ 
  FILE *out ;
  arc_t *block ;
  arc_t *arc ;
  arc_t *arc2 ;
  arc_t *first_impl ;

  {
#line 40
  out = (FILE *)((void *)0);
#line 44
  first_impl = net___0->stop_arcs - net___0->m_impl;
#line 46
  out = fopen((char const   * __restrict  )outfile, (char const   * __restrict  )"w");
#line 46
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 47
    return (-1L);
  }
#line 49
  refresh_neighbour_lists(net___0);
#line 51
  block = (net___0->nodes + net___0->n)->firstout;
#line 51
  while (block) {
#line 53
    if (block->flow) {
#line 55
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"()\n");
#line 57
      arc = block;
#line 58
      while (arc) {
#line 60
        if ((unsigned long )arc >= (unsigned long )first_impl) {
#line 61
          fprintf((FILE * __restrict  )out, (char const   * __restrict  )"***\n");
        }
#line 63
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%d\n", - (arc->head)->number);
#line 64
        arc2 = (arc->head + net___0->n_trips)->firstout;
#line 65
        while (arc2) {
#line 66
          if (arc2->flow) {
#line 67
            break;
          }
#line 65
          arc2 = arc2->nextout;
        }
#line 68
        if (! arc2) {
#line 70
          fclose(out);
#line 71
          return (-1L);
        }
#line 74
        if ((arc2->head)->number) {
#line 75
          arc = arc2;
        } else {
#line 77
          arc = (arc_t *)((void *)0);
        }
      }
    }
#line 51
    block = block->nextout;
  }
#line 84
  fclose(out);
#line 86
  return (0L);
}
}
#line 1 "treeup.o"
#pragma merger("0","/tmp/cil-ouyOeD9T.i","")
#line 30 "./treeup.h"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) ;
#line 29 "treeup.c"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) 
{ 
  arc_t *basic_arc_temp ;
  arc_t *new_basic_arc ;
  node_t *father ;
  node_t *temp ;
  node_t *new_pred ;
  long orientation_temp ;
  long depth_temp ;
  long depth_iminus ;
  long new_depth ;
  flow_t flow_temp ;
  cost_t tmp ;

  {
#line 71
  if ((unsigned long )bea->tail == (unsigned long )jplus) {
#line 71
    if (sigma < 0L) {
#line 71
      goto _L;
    } else {
#line 71
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 71
  if ((unsigned long )bea->tail == (unsigned long )iplus) {
#line 71
    if (sigma > 0L) {
      _L: /* CIL Label */ 
#line 73
      if (sigma >= 0L) {
#line 73
        sigma = sigma;
      } else {
#line 73
        sigma = - sigma;
      }
    } else {
#line 71
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 75
    if (sigma >= 0L) {
#line 75
      tmp = sigma;
    } else {
#line 75
      tmp = - sigma;
    }
#line 75
    sigma = - tmp;
  }
#line 77
  father = iminus;
#line 78
  father->potential += sigma;
  RECURSION: 
#line 80
  temp = father->child;
#line 81
  if (temp) {
    ITERATION: 
#line 84
    temp->potential += sigma;
#line 85
    father = temp;
#line 86
    goto RECURSION;
  }
  TEST: 
#line 89
  if ((unsigned long )father == (unsigned long )iminus) {
#line 90
    goto CONTINUE;
  }
#line 91
  temp = father->sibling;
#line 92
  if (temp) {
#line 93
    goto ITERATION;
  }
#line 94
  father = father->pred;
#line 95
  goto TEST;
  CONTINUE: 
#line 101
  temp = iplus;
#line 102
  father = temp->pred;
#line 103
  depth_iminus = iminus->depth;
#line 103
  new_depth = depth_iminus;
#line 104
  new_pred = jplus;
#line 105
  new_basic_arc = bea;
#line 106
  while ((unsigned long )temp != (unsigned long )jminus) {
#line 108
    if (temp->sibling) {
#line 109
      (temp->sibling)->sibling_prev = temp->sibling_prev;
    }
#line 110
    if (temp->sibling_prev) {
#line 111
      (temp->sibling_prev)->sibling = temp->sibling;
    } else {
#line 112
      father->child = temp->sibling;
    }
#line 115
    temp->pred = new_pred;
#line 116
    temp->sibling = new_pred->child;
#line 117
    if (temp->sibling) {
#line 118
      (temp->sibling)->sibling_prev = temp;
    }
#line 119
    new_pred->child = temp;
#line 120
    temp->sibling_prev = (node_p )0;
#line 122
    orientation_temp = (long )(! temp->orientation);
#line 123
    if (orientation_temp == cycle_ori) {
#line 124
      flow_temp = temp->flow + delta;
    } else {
#line 126
      flow_temp = temp->flow - delta;
    }
#line 127
    basic_arc_temp = temp->basic_arc;
#line 128
    depth_temp = temp->depth;
#line 130
    temp->orientation = (int )new_orientation;
#line 131
    temp->flow = new_flow;
#line 132
    temp->basic_arc = new_basic_arc;
#line 133
    temp->depth = new_depth;
#line 135
    new_pred = temp;
#line 136
    new_orientation = orientation_temp;
#line 137
    new_flow = flow_temp;
#line 138
    new_basic_arc = basic_arc_temp;
#line 139
    new_depth = depth_iminus - depth_temp;
#line 140
    temp = father;
#line 141
    father = temp->pred;
  }
#line 144
  if (delta > feas_tol) {
#line 146
    temp = jminus;
#line 146
    while ((unsigned long )temp != (unsigned long )w) {
#line 148
      temp->depth -= depth_iminus;
#line 149
      if ((long )temp->orientation != cycle_ori) {
#line 150
        temp->flow += delta;
      } else {
#line 152
        temp->flow -= delta;
      }
#line 146
      temp = temp->pred;
    }
#line 154
    temp = jplus;
#line 154
    while ((unsigned long )temp != (unsigned long )w) {
#line 156
      temp->depth += depth_iminus;
#line 157
      if ((long )temp->orientation == cycle_ori) {
#line 158
        temp->flow += delta;
      } else {
#line 160
        temp->flow -= delta;
      }
#line 154
      temp = temp->pred;
    }
  } else {
#line 165
    temp = jminus;
#line 165
    while ((unsigned long )temp != (unsigned long )w) {
#line 166
      temp->depth -= depth_iminus;
#line 165
      temp = temp->pred;
    }
#line 167
    temp = jplus;
#line 167
    while ((unsigned long )temp != (unsigned long )w) {
#line 168
      temp->depth += depth_iminus;
#line 167
      temp = temp->pred;
    }
  }
#line 171
  return;
}
}
#line 1 "pbla.o"
#pragma merger("0","/tmp/cil-9LyYf1xu.i","")
#line 30 "./pbla.h"
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) ;
#line 41 "pbla.c"
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) 
{ 
  node_t *iminus ;

  {
#line 56
  iminus = (node_t *)((void *)0);
#line 59
  while ((unsigned long )iplus != (unsigned long )jplus) {
#line 61
    if (iplus->depth < jplus->depth) {
#line 63
      if (iplus->orientation) {
#line 64
        if (*delta > iplus->flow) {
#line 64
          iminus = iplus;
#line 64
          *delta = iplus->flow;
#line 64
          *xchange = 0L;
        }
      } else
#line 65
      if ((iplus->pred)->pred) {
#line 66
        if (*delta > 1L - iplus->flow) {
#line 66
          iminus = iplus;
#line 66
          *delta = 1L - iplus->flow;
#line 66
          *xchange = 0L;
        }
      }
#line 67
      iplus = iplus->pred;
    } else {
#line 71
      if (! jplus->orientation) {
#line 72
        if (*delta >= jplus->flow) {
#line 72
          iminus = jplus;
#line 72
          *delta = jplus->flow;
#line 72
          *xchange = 1L;
        }
      } else
#line 73
      if ((jplus->pred)->pred) {
#line 74
        if (*delta >= 1L - jplus->flow) {
#line 74
          iminus = jplus;
#line 74
          *delta = 1L - jplus->flow;
#line 74
          *xchange = 1L;
        }
      }
#line 75
      jplus = jplus->pred;
    }
  }
#line 79
  *w = iplus;
#line 81
  return (iminus);
}
}
#line 1 "pflowup.o"
#pragma merger("0","/tmp/cil-Uu0HxPu1.i","")
#line 30 "./pflowup.h"
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) ;
#line 29 "pflowup.c"
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) 
{ 


  {
#line 40
  while ((unsigned long )iplus != (unsigned long )w) {
#line 42
    if (iplus->orientation) {
#line 43
      iplus->flow = (flow_t )0;
    } else {
#line 45
      iplus->flow = (flow_t )1;
    }
#line 40
    iplus = iplus->pred;
  }
#line 48
  while ((unsigned long )jplus != (unsigned long )w) {
#line 50
    if (jplus->orientation) {
#line 51
      jplus->flow = (flow_t )1;
    } else {
#line 53
      jplus->flow = (flow_t )0;
    }
#line 48
    jplus = jplus->pred;
  }
#line 55
  return;
}
}
#line 1 "psimplex.o"
#pragma merger("0","/tmp/cil-jawl7fZ4.i","")
#line 30 "./pbeampp.h"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) ;
#line 30 "psimplex.c"
long primal_net_simplex(network_t *net___0 ) 
{ 
  flow_t delta ;
  flow_t new_flow ;
  long opt ;
  long xchange ;
  long new_orientation ;
  node_t *iplus ;
  node_t *jplus ;
  node_t *iminus ;
  node_t *jminus ;
  node_t *w ;
  arc_t *bea ;
  arc_t *bla ;
  arc_t *arcs ;
  arc_t *stop_arcs ;
  node_t *temp ;
  long m ;
  long new_set ;
  cost_t red_cost_of_bea ;
  long *iterations ;
  long *bound_exchanges ;
  long *checksum ;
  long tmp ;
  long tmp___0 ;

  {
#line 38
  opt = 0L;
#line 48
  arcs = net___0->arcs;
#line 49
  stop_arcs = net___0->stop_arcs;
#line 51
  m = net___0->m;
#line 54
  iterations = & net___0->iterations;
#line 55
  bound_exchanges = & net___0->bound_exchanges;
#line 56
  checksum = & net___0->checksum;
#line 59
  while (! opt) {
#line 61
    bea = primal_bea_mpp(m, arcs, stop_arcs, & red_cost_of_bea);
#line 61
    if (bea) {
#line 63
      (*iterations) ++;
#line 71
      if (red_cost_of_bea > 0L) {
#line 73
        iplus = bea->head;
#line 74
        jplus = bea->tail;
      } else {
#line 78
        iplus = bea->tail;
#line 79
        jplus = bea->head;
      }
#line 82
      delta = (flow_t )1;
#line 83
      iminus = primal_iminus(& delta, & xchange, iplus, jplus, & w);
#line 86
      if (! iminus) {
#line 88
        (*bound_exchanges) ++;
#line 90
        if (bea->ident == 2) {
#line 91
          bea->ident = 1;
        } else {
#line 93
          bea->ident = 2;
        }
#line 95
        if (delta) {
#line 96
          primal_update_flow(iplus, jplus, w);
        }
      } else {
#line 100
        if (xchange) {
#line 102
          temp = jplus;
#line 103
          jplus = iplus;
#line 104
          iplus = temp;
        }
#line 107
        jminus = iminus->pred;
#line 109
        bla = iminus->basic_arc;
#line 111
        if (xchange != (long )iminus->orientation) {
#line 112
          new_set = 1L;
        } else {
#line 114
          new_set = 2L;
        }
#line 116
        if (red_cost_of_bea > 0L) {
#line 117
          new_flow = 1L - delta;
        } else {
#line 119
          new_flow = delta;
        }
#line 121
        if ((unsigned long )bea->tail == (unsigned long )iplus) {
#line 122
          new_orientation = 1L;
        } else {
#line 124
          new_orientation = 0L;
        }
#line 126
        update_tree((long )(! xchange), new_orientation, delta, new_flow, iplus, jplus,
                    iminus, jminus, w, bea, red_cost_of_bea, net___0->feas_tol);
#line 131
        bea->ident = 0;
#line 132
        bla->ident = (int )new_set;
#line 134
        if (! ((*iterations - 1L) % 200L)) {
#line 136
          tmp = refresh_potential(net___0);
#line 136
          *checksum += tmp;
        }
      }
    } else {
#line 148
      opt = 1L;
    }
  }
#line 152
  tmp___0 = refresh_potential(net___0);
#line 152
  *checksum += tmp___0;
#line 153
  primal_feasible(net___0);
#line 154
  dual_feasible(net___0);
#line 156
  return (0L);
}
}
#line 1 "pbeampp.o"
#pragma merger("0","/tmp/cil-_F0x47tx.i","")
#line 34 "pbeampp.c"
int bea_is_dual_infeasible(arc_t *arc , cost_t red_cost ) 
{ 
  int tmp ;

  {
#line 41
  if (red_cost < 0L) {
#line 41
    if (arc->ident == 1) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if (red_cost > 0L) {
#line 41
    if (arc->ident == 2) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return (tmp);
}
}
#line 58 "pbeampp.c"
static long basket_size  ;
#line 59 "pbeampp.c"
static BASKET basket[351]  ;
#line 60 "pbeampp.c"
static BASKET *perm[351]  ;
#line 65 "pbeampp.c"
void sort_basket(long min , long max ) 
{ 
  long l ;
  long r ;
  cost_t cut ;
  BASKET *xchange ;

  {
#line 75
  l = min;
#line 75
  r = max;
#line 77
  cut = (perm[(l + r) / 2L])->abs_cost;
#line 79
  while (1) {
#line 81
    while ((perm[l])->abs_cost > cut) {
#line 82
      l ++;
    }
#line 83
    while (cut > (perm[r])->abs_cost) {
#line 84
      r --;
    }
#line 86
    if (l < r) {
#line 88
      xchange = perm[l];
#line 89
      perm[l] = perm[r];
#line 90
      perm[r] = xchange;
    }
#line 92
    if (l <= r) {
#line 94
      l ++;
#line 94
      r --;
    }
#line 79
    if (! (l <= r)) {
#line 79
      break;
    }
  }
#line 100
  if (min < r) {
#line 101
    sort_basket(min, r);
  }
#line 102
  if (l < max) {
#line 102
    if (l <= 50L) {
#line 103
      sort_basket(l, max);
    }
  }
#line 104
  return;
}
}
#line 111 "pbeampp.c"
static long nr_group  ;
#line 112 "pbeampp.c"
static long group_pos  ;
#line 115 "pbeampp.c"
static long initialize  =    1L;
#line 119 "pbeampp.c"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) 
{ 
  long i ;
  long next ;
  long old_group_pos ;
  arc_t *arc ;
  cost_t red_cost ;
  int tmp ;

  {
#line 133
  if (initialize) {
#line 135
    i = 1L;
#line 135
    while (i < 351L) {
#line 136
      perm[i] = & basket[i];
#line 135
      i ++;
    }
#line 137
    nr_group = (m - 1L) / 300L + 1L;
#line 138
    group_pos = 0L;
#line 139
    basket_size = 0L;
#line 140
    initialize = 0L;
  } else {
#line 144
    i = 2L;
#line 144
    next = 0L;
#line 144
    while (1) {
#line 144
      if (i <= 50L) {
#line 144
        if (! (i <= basket_size)) {
#line 144
          break;
        }
      } else {
#line 144
        break;
      }
#line 146
      arc = (perm[i])->a;
#line 147
      red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 148
      if (red_cost < 0L) {
#line 148
        if (arc->ident == 1) {
#line 148
          goto _L;
        } else {
#line 148
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 148
      if (red_cost > 0L) {
#line 148
        if (arc->ident == 2) {
          _L: /* CIL Label */ 
#line 151
          next ++;
#line 152
          (perm[next])->a = arc;
#line 153
          (perm[next])->cost = red_cost;
#line 154
          if (red_cost >= 0L) {
#line 154
            (perm[next])->abs_cost = red_cost;
          } else {
#line 154
            (perm[next])->abs_cost = - red_cost;
          }
        }
      }
#line 144
      i ++;
    }
#line 157
    basket_size = next;
  }
#line 160
  old_group_pos = group_pos;
  NEXT: 
#line 164
  arc = arcs + group_pos;
#line 165
  while ((unsigned long )arc < (unsigned long )stop_arcs) {
#line 167
    if (arc->ident > 0) {
#line 170
      red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
#line 171
      tmp = bea_is_dual_infeasible(arc, red_cost);
#line 171
      if (tmp) {
#line 173
        basket_size ++;
#line 174
        (perm[basket_size])->a = arc;
#line 175
        (perm[basket_size])->cost = red_cost;
#line 176
        if (red_cost >= 0L) {
#line 176
          (perm[basket_size])->abs_cost = red_cost;
        } else {
#line 176
          (perm[basket_size])->abs_cost = - red_cost;
        }
      }
    }
#line 165
    arc += nr_group;
  }
#line 182
  group_pos ++;
#line 182
  if (group_pos == nr_group) {
#line 183
    group_pos = 0L;
  }
#line 185
  if (basket_size < 50L) {
#line 185
    if (group_pos != old_group_pos) {
#line 186
      goto NEXT;
    }
  }
#line 188
  if (basket_size == 0L) {
#line 190
    initialize = 1L;
#line 191
    *red_cost_of_bea = (cost_t )0;
#line 192
    return ((arc_t *)((void *)0));
  }
#line 195
  sort_basket(1L, basket_size);
#line 197
  *red_cost_of_bea = (perm[1])->cost;
#line 198
  return ((perm[1])->a);
}
}
